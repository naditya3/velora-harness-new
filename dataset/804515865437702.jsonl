{"instance_id": "804515865437702", "repo": "righttyper/righttyper", "base_commit": "1d85184427dbb1f7b3e5488e6e25c75284e9bacd", "problem_statement": "sys.monitoring `PY_YIELD` leaks internal `async_generator_wrapped_value` object:\\n### Bug description:\\n\\nRather than the actual value, `sys.monitoring`'s `PY_YIELD` event passes in to the callback the internal `async_generator_wrapped_value`.\\nI imagine this is a bug... it's inconsistent with what it does for non-async generators.\\n\\n```python\\nimport sys\\nimport types\\nimport typing\\nimport asyncio\\n\\nasync def gen():\\n    yield 42\\n\\nasync def main():\\n    async for _ in gen():\\n        pass\\n\\ndef handle_yield(code: types.CodeType, offset: int, value: object) -> typing.Any:\\n    if code.co_filename == __file__:\\n        print(f\"yield name={code.co_qualname} {type(value)=}\")\\n\\nsysmon = sys.monitoring\\nsysmon.use_tool_id(4, \"r\")\\nsysmon.register_callback(4, sysmon.events.PY_YIELD, handle_yield)\\nsysmon.set_events(4, sysmon.events.PY_YIELD)\\n\\nasyncio.run(main())\\n```\\n\\nThis prints out:\\n```\\nyield name=gen type(value)=<class 'async_generator_wrapped_value'>\\n```\\n\\n### CPython versions tested on:\\n\\n3.12, 3.13, 3.14\\n\\n### Operating systems tested on:\\n\\nmacOS", "FAIL_TO_PASS": ["tests/test_integration.py::test_discovered_generator", "tests/test_integration.py::test_generator", "tests/test_integration.py::test_discovered_genexpr", "tests/test_integration.py::test_discovered_genexpr_two_in_same_line", "tests/test_integration.py::test_generator_with_return", "tests/test_integration.py::test_discovered_function_annotated[True]", "tests/test_integration.py::test_coroutine"], "PASS_TO_PASS": ["tests/test_integration.py::test_type_from_annotation_none_return", "tests/test_transformer.py::test_generics_arg_already_annotated[True]", "tests/test_integration.py::test_self_inherited_method_called_indirectly", "tests/test_integration.py::test_self_inherited_method_returns_non_self", "tests/test_integration.py::test_mocked_function", "tests/test_integration.py::test_zero_SystemExit[True-True]", "tests/test_integration.py::test_custom_collection_sample_error[tuple-tuple]", "tests/test_integration.py::test_arg_parsing", "tests/test_transformer.py::test_transform_deletes_type_hint_comments_in_parameters", "tests/test_integration.py::test_self_inherited_classmethod", "tests/test_integration.py::test_class_name_imported", "tests/test_integration.py::test_class_name_in_test", "tests/test_integration.py::test_discovered_function_type_in_return", "tests/test_integration.py::test_function_type_in_annotation", "tests/test_integration.py::test_zero_SystemExit[False-False]", "tests/test_integration.py::test_custom_collection_sample_error[ItemsView-ItemsView[Never,", "tests/test_typing.py::test_get_value_type_coro", "tests/test_transformer.py::test_types_in_annotation", "tests/test_typing.py::test_typeinfo_from_set", "tests/test_typing.py::test_sample_process_generator_union", "tests/test_integration.py::test_generic_simple", "tests/test_integration.py::test_custom_collection_len_error[list-MyContainer[Never]]", "tests/test_transformer.py::test_generics_inline_simple", "tests/test_typeinfo.py::test_generalize_shared_variability", "tests/test_integration.py::test_none_arg", "tests/test_typeinfo.py::test_generalize_uniform_single_type_with_generic", "tests/test_typing.py::test_type_from_annotations", "tests/test_transformer.py::test_generics_existing_generics", "tests/test_integration.py::test_function_type_future_annotations", "tests/test_integration.py::test_self_yield_generator", "tests/test_typeinfo.py::test_generalize_generic_within_args", "tests/test_integration.py::test_custom_collection_len_error[set-MyContainer[Never]]", "tests/test_integration.py::test_class_properties", "tests/test_typing.py::test_get_value_type_dict_with_non_collection_items", "tests/test_integration.py::test_self_wrapped_method", "tests/test_integration.py::test_union_superclass[False]", "tests/test_transformer.py::test_if_type_checking_insertion", "tests/test_stubs.py::test_stubs_empty_class", "tests/test_integration.py::test_discovered_function_type_in_args", "tests/test_integration.py::test_call_with_none_default", "tests/test_transformer.py::test_generics_ret_already_annotated[False]", "tests/test_integration.py::test_nonzero_SystemExit[True-True]", "tests/test_typeinfo.py::test_generalize_single_sample", "tests/test_typing.py::test_sample_process_simple", "tests/test_typeinfo.py::test_generalize_generic_among_options", "tests/test_typeinfo.py::test_generalize_empty", "tests/test_transformer.py::test_transform_deletes_type_hint_comments_in_header", "tests/test_typing.py::test_sample_process_iterator_union", "tests/test_integration.py::test_posonly_and_kwonly", "tests/test_integration.py::test_custom_collection_sample_error[ValuesView-ValuesView[Never]]", "tests/test_integration.py::test_default_class_method", "tests/test_transformer.py::test_transform_deletes_type_hint_comments_for_retval", "tests/test_integration.py::test_class_method_imported", "tests/test_integration.py::test_custom_collection_sample_error[set-MyContainer[Never]]", "tests/test_integration.py::test_numpy_ndarray_dtype_name", "tests/test_typeinfo.py::test_generalize_varied_length_samples", "tests/test_integration.py::test_union_superclass[True]", "tests/test_transformer.py::test_used_names", "tests/test_transformer.py::test_transform_unknown_type_with_import_annotations", "tests/test_typeinfo.py::test_generalize_mixed_with_constant_types", "tests/test_integration.py::test_custom_collection_len_error[tuple-tuple]", "tests/test_transformer.py::test_transform_function", "tests/test_integration.py::test_nonzero_SystemExit[False-False]", "tests/test_typing.py::test_get_value_type_custom_collection", "tests/test_stubs.py::test_stubs_context_handler", "tests/test_transformer.py::test_inserts_imports_after_docstring_and_space", "tests/test_integration.py::test_class_method", "tests/test_transformer.py::test_uses_imported_domains", "tests/test_typing.py::test_typeinfo", "tests/test_transformer.py::test_generics_inline_nested", "tests/test_integration.py::test_function_lookup_for_defaults", "tests/test_transformer.py::test_imports_subdomain_if_needed", "tests/test_issues.py::test_issue_22", "tests/test_transformer.py::test_transform_unknown_type_as_string", "tests/test_integration.py::test_varargs_empty", "tests/test_typeinfo.py::test_generalize_jaxtyping_single_sample", "tests/test_integration.py::test_default_inner_function", "tests/test_typing.py::test_merged_types_generics_superclass", "tests/test_integration.py::test_self_bound_method", "tests/test_transformer.py::test_generics_arg_already_annotated[False]", "tests/test_integration.py::test_custom_collection_len_error[ItemsView-ItemsView[Never,", "tests/test_typing.py::test_get_value_type", "tests/test_stubs.py::test_stubs_conditional", "tests/test_typing.py::test_sample_process_iterator", "tests/test_typing.py::test_merged_types_generics", "tests/test_integration.py::test_default_arg", "tests/test_integration.py::test_custom_collection_len_error[ValuesView-ValuesView[Never]]", "tests/test_typing.py::test_sample_process_generator", "tests/test_transformer.py::test_builtin_name_conflicts_even_module_name", "tests/test_integration.py::test_internal_numpy_type", "tests/test_integration.py::test_self_within_other_types", "tests/test_transformer.py::test_class_names_dont_affect_body_of_methods", "tests/test_transformer.py::test_import_conflicts_with_import", "tests/test_transformer.py::test_nonglobal_assignments_are_ignored", "tests/test_typing.py::test_get_value_type_dtype", "tests/test_typing.py::test_non_array_with_dtype", "tests/test_typeinfo.py::test_generalize_first_same_then_different", "tests/test_stubs.py::test_stubs", "tests/test_transformer.py::test_uses_imported_aliases", "tests/test_integration.py::test_iterable", "tests/test_integration.py::test_module_list_not_lost_with_multiprocessing", "tests/test_transformer.py::test_import_conflicts_alias_for_module", "tests/test_integration.py::test_self_classmethod", "tests/test_integration.py::test_custom_collection_len_error[dict-MyContainer[Never,", "tests/test_integration.py::test_rich_is_messed_up", "tests/test_integration.py::test_inner_function", "tests/test_transformer.py::test_builtin_name_conflicts", "tests/test_transformer.py::test_transform_method", "tests/test_tool.py::test_reset_monitoring_after_init", "tests/test_integration.py::test_type_from_generic_alias_annotation", "tests/test_typeinfo.py::test_generalize_generic_with_string", "tests/test_transformer.py::test_import_conflicts_with_definitions", "tests/test_typeinfo.py::test_is_typevar", "tests/test_integration.py::test_self_simple", "tests/test_stubs.py::test_stubs_all_variable", "tests/test_integration.py::test_zero_SystemExit[True-False]", "tests/test_integration.py::test_generate_stubs", "tests/test_transformer.py::test_existing_typing_imports", "tests/test_integration.py::test_custom_collection_sample_error[list-MyContainer[Never]]", "tests/test_integration.py::test_nonzero_SystemExit[True-False]", "tests/test_typing.py::test_merged_types_superclass", "tests/test_integration.py::test_nonzero_SystemExit[False-True]", "tests/test_typeinfo.py::test_generalize_generic", "tests/test_transformer.py::test_transform_local_function", "tests/test_transformer.py::test_generics_already_annotated_no_overlap", "tests/test_integration.py::test_local_class_name", "tests/test_integration.py::test_return_private_class", "tests/test_integration.py::test_numpy_type_name", "tests/test_transformer.py::test_generics_ret_already_annotated[True]", "tests/test_integration.py::test_generic_and_defaults", "tests/test_transformer.py::test_import_conflicts_with_with", "tests/test_integration.py::test_kwargs_empty", "tests/test_integration.py::test_generic_typevar_location", "tests/test_typeinfo.py::test_generalize_uniform_single_type", "tests/test_integration.py::test_annotation_with_numpy_dtype_name", "tests/test_stubs.py::test_stubs_no_any", "tests/test_transformer.py::test_inner_function", "tests/test_integration.py::test_discovered_function_type_in_yield", "tests/test_transformer.py::test_generics_inline_multiple", "tests/test_typing.py::test_get_value_type_namedtuple_in_class", "tests/test_integration.py::test_varargs", "tests/test_integration.py::test_module_type", "tests/test_transformer.py::test_transform_adds_typing_import_for_typing_names", "tests/test_integration.py::test_class_properties_inner_functions", "tests/test_integration.py::test_type_from_main", "tests/test_typeinfo.py::test_generalize_jaxtyping_dimensions", "tests/test_transformer.py::test_relative_import", "tests/test_integration.py::test_self_subtyping_reversed", "tests/test_integration.py::test_builtins", "tests/test_integration.py::test_zero_SystemExit[False-True]", "tests/test_integration.py::test_class_properties_no_setter", "tests/test_typing.py::test_merged_types_generics_str_not_merged", "tests/test_typeinfo.py::test_generalize_all_distinct_types", "tests/test_typeinfo.py::test_generalize_generic_not_generalizable", "tests/test_typing.py::test_merged_types", "tests/test_integration.py::test_generic_yield", "tests/test_integration.py::test_generic_yield_generator", "tests/test_transformer.py::test_generics_defined_simple", "tests/test_integration.py::test_custom_collection_sample_error[dict-MyContainer[Never,", "tests/test_transformer.py::test_override_annotations", "tests/test_transformer.py::test_nonglobal_imported_modules_are_ignored", "tests/test_typing.py::test_merged_types_superclass_bare_type", "tests/test_integration.py::test_no_return", "tests/test_integration.py::test_custom_collection_len_error[KeysView-KeysView[Never]]", "tests/test_integration.py::test_self", "tests/test_integration.py::test_sampling_overlaps", "tests/test_integration.py::test_kwargs", "tests/test_integration.py::test_generic_name_conflict", "tests/test_integration.py::test_function_type", "tests/test_integration.py::test_self_inherited_method", "tests/test_integration.py::test_custom_collection_sample_error[KeysView-KeysView[Never]]", "tests/test_tool.py::test_reset_monitoring_before_init", "tests/test_stubs.py::test_stubs_try", "tests/test_transformer.py::test_transform_locally_defined_types", "tests/test_stubs.py::test_stubs_assign_tuple", "tests/test_transformer.py::test_import_conflicts_with_assignments", "tests/test_integration.py::test_self_subtyping"], "language": "python", "test_command": "source /saved/ENV || source /saved/*/ENV && pytest --no-header -rA --tb=no -p no:cacheprovider --continue-on-collection-errors", "test_output_parser": "python/parse_log_pytest_v3", "image_storage_uri": "vmvm-registry.fbinfra.net/repomate_image_activ_pytest/righttyper_righttyper:1d85184427dbb1f7b3e5488e6e25c75284e9bacd", "patch": "[\"diff --git a/righttyper/righttyper.py b/righttyper/righttyper.py\\nindex c82f063..8df0ba1 100644\\n--- a/righttyper/righttyper.py\\n+++ b/righttyper/righttyper.py\\n@@ -2,7 +2,6 @@\\n import importlib.metadata\\n import importlib.util\\n import inspect\\n-import itertools\\n import logging\\n import os\\n import runpy\\n@@ -29,6 +28,8 @@\\n     SignatureChanges\\n )\\n from righttyper.righttyper_runtime import (\\n+    find_function,\\n+    unwrap,\\n     get_value_type,\\n     get_type_name,\\n     should_skip_function,\\n@@ -47,6 +48,8 @@\\n     FuncAnnotation,\\n     FunctionName,\\n     TypeInfo,\\n+    NoneTypeInfo,\\n+    AnyTypeInfo,\\n     Sample,\\n )\\n from righttyper.typeinfo import (\\n@@ -211,14 +214,18 @@ class T(TypeInfo.Transformer):\\n             \\\"\\\"\\\"Updates Callable type declarations based on observations.\\\"\\\"\\\"\\n             def visit(vself, node: TypeInfo) -> TypeInfo:\\n                 # if 'args' is there, the function is already annotated\\n-                # FIXME make overriding dependent upon ignore_annotations\\n-                if node.func and not node.args and node.func in self.samples:\\n+                if node.func and (options.ignore_annotations or not node.args) and node.func in self.samples:\\n                     if (ann := mk_annotation(node.func)):\\n-                        # TODO: fix callable arguments being strings\\n-                        return TypeInfo('typing', 'Callable', args=(\\n-                            f\\\"[{\\\", \\\".join(map(lambda a: str(a[1]), ann.args[int(node.is_bound):]))}]\\\",\\n-                            ann.retval\\n-                        ))\\n+                        if node.name == 'Callable':\\n+                            # TODO: fix callable arguments being strings\\n+                            return TypeInfo('typing', 'Callable', args=(\\n+                                f\\\"[{\\\", \\\".join(map(lambda a: str(a[1]), ann.args[int(node.is_bound):]))}]\\\",\\n+                                ann.retval\\n+                            ))\\n+                        elif node.name in ('Generator', 'AsyncGenerator'):\\n+                            return ann.retval\\n+                        elif node.name == 'Coroutine':\\n+                            return node.replace(args=(NoneTypeInfo, AnyTypeInfo, ann.retval))\\n \\n                 return super().visit(node)\\n \\n@@ -382,60 +389,6 @@ def process_yield_or_return(\\n     return sys.monitoring.DISABLE if (options.sampling and found) else None\\n \\n \\n-def unwrap(method: FunctionType|classmethod|None) -> FunctionType|None:\\n-    \\\"\\\"\\\"Follows a chain of `__wrapped__` attributes to find the original function.\\\"\\\"\\\"\\n-\\n-    visited = set()         # there shouldn't be a loop, but just in case...\\n-    while hasattr(method, \\\"__wrapped__\\\"):\\n-        if method in visited:\\n-            return None\\n-        visited.add(method)\\n-\\n-        method = getattr(method, \\\"__wrapped__\\\")\\n-\\n-    return method\\n-\\n-\\n-def find_function(\\n-    caller_frame: FrameType,\\n-    code: CodeType\\n-) -> abc.Callable|None:\\n-    \\\"\\\"\\\"Attempts to map back from a code object to the function that uses it.\\\"\\\"\\\"\\n-\\n-    visited = set()\\n-\\n-    def find_in_class(class_obj: object) -> abc.Callable|None:\\n-        if class_obj in visited:\\n-            return None\\n-        visited.add(class_obj)\\n-\\n-        for obj in class_obj.__dict__.values():\\n-            if isinstance(obj, (FunctionType, classmethod)):\\n-                if (obj := unwrap(obj)) and getattr(obj, \\\"__code__\\\", None) is code:\\n-                    return obj\\n-\\n-            elif inspect.isclass(obj):\\n-                if (f := find_in_class(obj)):\\n-                    return f\\n-\\n-        return None\\n-\\n-    dicts: abc.Iterable[Any] = caller_frame.f_globals.values()\\n-    if caller_frame.f_back:\\n-        dicts = itertools.chain(caller_frame.f_back.f_locals.values(), dicts)\\n-\\n-    for obj in dicts:\\n-        if isinstance(obj, FunctionType):\\n-            if (obj := unwrap(obj)) and getattr(obj, \\\"__code__\\\", None) is code:\\n-                return obj\\n-\\n-        elif inspect.isclass(obj):\\n-            if (f := find_in_class(obj)):\\n-                return f\\n-\\n-    return None\\n-\\n-\\n def process_function_arguments(\\n     t: FuncInfo,\\n     frame_id: int,\\n\",\"diff --git a/righttyper/righttyper_runtime.py b/righttyper/righttyper_runtime.py\\nindex 1bd393d..68bb11e 100644\\n--- a/righttyper/righttyper_runtime.py\\n+++ b/righttyper/righttyper_runtime.py\\n@@ -5,8 +5,18 @@\\n \\n import collections.abc as abc\\n from functools import cache\\n-from itertools import islice\\n-from types import CodeType, FrameType, NoneType, FunctionType, MethodType, GenericAlias\\n+import itertools\\n+from types import (\\n+    CodeType,\\n+    FrameType,\\n+    NoneType,\\n+    FunctionType,\\n+    MethodType,\\n+    GeneratorType,\\n+    AsyncGeneratorType,\\n+    CoroutineType,\\n+    GenericAlias\\n+)\\n from typing import Any, cast, TypeAlias\\n from pathlib import Path\\n \\n@@ -17,7 +27,8 @@\\n     FuncInfo,\\n     T,\\n     TypeInfo,\\n-    NoneTypeInfo\\n+    NoneTypeInfo,\\n+    AnyTypeInfo\\n )\\n from righttyper.righttyper_utils import skip_this_file, get_main_module_fqn\\n \\n@@ -28,10 +39,10 @@ def sample_from_collection(value: abc.Collection[T]|abc.Iterator[T], depth = 0)\\n \\n     if isinstance(value, abc.Collection):\\n         n = random.randint(0, min(MAX_ELEMENTS, len(value) - 1))\\n-        return next(islice(value, n, n + 1))\\n+        return next(itertools.islice(value, n, n + 1))\\n \\n     n = random.randint(1, MAX_ELEMENTS)\\n-    return list(islice(value, n))[-1]\\n+    return list(itertools.islice(value, n))[-1]\\n \\n \\n JX_DTYPES = None\\n@@ -256,7 +267,7 @@ def get_type_name(obj: type, depth: int = 0) -> TypeInfo:\\n             return TypeInfo(\\\"typing\\\", \\\"Iterator\\\", args=(TypeInfo(\\\"\\\", \\\"int\\\", type_obj=int),))\\n         # TODO match other ABC from collections.abc based on interface\\n         elif issubclass(obj, abc.Iterator):\\n-            return TypeInfo(\\\"typing\\\", \\\"Iterator\\\", args=(TypeInfo(\\\"typing\\\", \\\"Any\\\"),))\\n+            return TypeInfo(\\\"typing\\\", \\\"Iterator\\\", args=(AnyTypeInfo,))\\n         else:\\n             # fall back to its name, just so we can tell where it came from.\\n             return TypeInfo.from_type(obj)\\n@@ -299,6 +310,60 @@ def _is_instance(obj: object, types: tuple[type, ...]) -> type|None:\\n     return None\\n \\n \\n+def unwrap(method: FunctionType|classmethod|None) -> FunctionType|None:\\n+    \\\"\\\"\\\"Follows a chain of `__wrapped__` attributes to find the original function.\\\"\\\"\\\"\\n+\\n+    visited = set()         # there shouldn't be a loop, but just in case...\\n+    while hasattr(method, \\\"__wrapped__\\\"):\\n+        if method in visited:\\n+            return None\\n+        visited.add(method)\\n+\\n+        method = getattr(method, \\\"__wrapped__\\\")\\n+\\n+    return method\\n+\\n+\\n+def find_function(\\n+    caller_frame: FrameType,\\n+    code: CodeType\\n+) -> abc.Callable|None:\\n+    \\\"\\\"\\\"Attempts to map back from a code object to the function that uses it.\\\"\\\"\\\"\\n+\\n+    visited = set()\\n+\\n+    def find_in_class(class_obj: object) -> abc.Callable|None:\\n+        if class_obj in visited:\\n+            return None\\n+        visited.add(class_obj)\\n+\\n+        for obj in class_obj.__dict__.values():\\n+            if isinstance(obj, (FunctionType, classmethod)):\\n+                if (obj := unwrap(obj)) and getattr(obj, \\\"__code__\\\", None) is code:\\n+                    return obj\\n+\\n+            elif inspect.isclass(obj):\\n+                if (f := find_in_class(obj)):\\n+                    return f\\n+\\n+        return None\\n+\\n+    dicts: abc.Iterable[Any] = caller_frame.f_globals.values()\\n+    if caller_frame.f_back:\\n+        dicts = itertools.chain(caller_frame.f_back.f_locals.values(), dicts)\\n+\\n+    for obj in dicts:\\n+        if isinstance(obj, FunctionType):\\n+            if (obj := unwrap(obj)) and getattr(obj, \\\"__code__\\\", None) is code:\\n+                return obj\\n+\\n+        elif inspect.isclass(obj):\\n+            if (f := find_in_class(obj)):\\n+                return f\\n+\\n+    return None\\n+\\n+\\n def get_value_type(value: Any, /, use_jaxtyping: bool = False, depth: int = 0) -> TypeInfo:\\n     \\\"\\\"\\\"\\n     get_value_type takes a value (an instance) as input and returns a string representing its type.\\n@@ -317,6 +382,28 @@ def get_value_type(value: Any, /, use_jaxtyping: bool = False, depth: int = 0) -\\n     t: type|None\\n     args: tuple[TypeInfo, ...]\\n \\n+\\n+    def type_for_generator(\\n+        obj: GeneratorType|AsyncGeneratorType|CoroutineType,\\n+        frame: FrameType|None,\\n+        code: CodeType,\\n+        name: str\\n+    ) -> TypeInfo:\\n+        # FIXME We can't yet retrieve types from annotations because all Callable\\n+        # arguments returned by type_from_annotations are strings\\n+        #if (f := find_function(frame, code)):\\n+        #    ann = type_from_annotations(f)\\n+        #    (now use ann_type.args[-1], the return value)\\n+\\n+        return TypeInfo(\\\"typing\\\", name,\\n+            func=FuncInfo(\\n+                Filename(code.co_filename),\\n+                code.co_firstlineno,\\n+                FunctionName(obj.__qualname__)\\n+            )\\n+        )\\n+\\n+\\n     if isinstance(value, dict):\\n         t = type(value)\\n         args = (TypeInfo(\\\"typing\\\", \\\"Never\\\"), TypeInfo(\\\"typing\\\", \\\"Never\\\"))\\n@@ -369,15 +456,12 @@ def get_value_type(value: Any, /, use_jaxtyping: bool = False, depth: int = 0) -\\n             return TypeInfo(\\\"\\\", \\\"tuple\\\", args=args)\\n     elif isinstance(value, (FunctionType, MethodType)):\\n         return type_from_annotations(value)\\n-    elif isinstance(value, abc.Generator):\\n-        any = TypeInfo(\\\"typing\\\", \\\"Any\\\")\\n-        return TypeInfo(\\\"typing\\\", \\\"Generator\\\", args=(any, any, any))  # FIXME needs yield / send / return types\\n-    elif isinstance(value, abc.AsyncGenerator):\\n-        any = TypeInfo(\\\"typing\\\", \\\"Any\\\")\\n-        return TypeInfo(\\\"typing\\\", \\\"AsyncGenerator\\\", args=(any, any))  # FIXME needs yield / send types\\n-    elif isinstance(value, abc.Coroutine):\\n-        any = TypeInfo(\\\"typing\\\", \\\"Any\\\")\\n-        return TypeInfo(\\\"typing\\\", \\\"Coroutine\\\", args=(any, any, any))  # FIXME needs yield / send / return types\\n+    elif isinstance(value, GeneratorType):\\n+        return type_for_generator(value, value.gi_frame, value.gi_code, \\\"Generator\\\")\\n+    elif isinstance(value, AsyncGeneratorType):\\n+        return type_for_generator(value, value.ag_frame, value.ag_code, \\\"AsyncGenerator\\\")\\n+    elif isinstance(value, CoroutineType):\\n+        return type_for_generator(value, value.cr_frame, value.cr_code, \\\"Coroutine\\\")\\n     elif isinstance(value, type) and value is not type:\\n         return TypeInfo(\\\"\\\", \\\"type\\\", args=(get_type_name(value, depth+1),))\\n \\n@@ -392,7 +476,7 @@ def get_value_type(value: Any, /, use_jaxtyping: bool = False, depth: int = 0) -\\n \\n     if (t := type(value)).__module__ == 'numpy' and t.__qualname__ == 'ndarray':\\n         return TypeInfo(\\\"numpy\\\", \\\"ndarray\\\", args=(\\n-            TypeInfo(\\\"typing\\\", \\\"Any\\\"),\\n+            AnyTypeInfo,\\n             get_type_name(type(value.dtype), depth+1)\\n         ))\\n \\n\",\"diff --git a/righttyper/righttyper_types.py b/righttyper/righttyper_types.py\\nindex d849c6a..f97c6d0 100644\\n--- a/righttyper/righttyper_types.py\\n+++ b/righttyper/righttyper_types.py\\n@@ -122,8 +122,8 @@ def visit(self, node: \\\"TypeInfo\\\") -> \\\"TypeInfo\\\":\\n             return node\\n \\n \\n-# FIXME make Singleton using __new__\\n-NoneTypeInfo = TypeInfo(\\\"\\\", \\\"None\\\", type_obj=types.NoneType)\\n+NoneTypeInfo = TypeInfo(\\\"\\\", \\\"None\\\", type_obj=types.NoneType)    # FIXME make Singleton using __new__\\n+AnyTypeInfo = TypeInfo(\\\"typing\\\", \\\"Any\\\")\\n \\n \\n @dataclass\\n@@ -142,27 +142,22 @@ class Sample:\\n \\n     def process(self) -> tuple[TypeInfo, ...]:\\n         retval = self.returns\\n-        if len(self.yields):\\n-            y = TypeInfo.from_set(self.yields)\\n-            is_async = False\\n-\\n-            # FIXME capture send type and switch to Generator/AsyncGenerator if any sent\\n-\\n-            if len(self.yields) == 1:\\n-                y = next(iter(self.yields))\\n-                if str(y) == \\\"builtins.async_generator_wrapped_value\\\":\\n-                    y = TypeInfo(\\\"typing\\\", \\\"Any\\\")  # FIXME how to unwrap the value without waiting on it?\\n-                    is_async = True\\n-\\n-            if self.returns is NoneTypeInfo:\\n-                # Note that we are unable to differentiate between an implicit \\\"None\\\"\\n-                # return and an explicit \\\"return None\\\".\\n-                # FIXME return value doesn't matter for AsyncIterator\\n-                iter_type = \\\"AsyncIterator\\\" if is_async else \\\"Iterator\\\"\\n-                retval = TypeInfo(\\\"typing\\\", iter_type, (y,))\\n-\\n+        if self.yields:\\n+            if any(str(t) == \\\"builtins.async_generator_wrapped_value\\\" for t in self.yields):\\n+                # FIXME how to unwrap the y without waiting on it?\\n+                # FIXME need send type\\n+                y = s = AnyTypeInfo\\n+                retval = TypeInfo(\\\"typing\\\", \\\"AsyncGenerator\\\", (y, s))\\n             else:\\n-                retval = TypeInfo(\\\"typing\\\", \\\"Generator\\\", (y, TypeInfo(\\\"typing\\\", \\\"Any\\\"), self.returns))\\n+                y = TypeInfo.from_set(self.yields)\\n+\\n+                if self.returns is NoneTypeInfo:\\n+                    # Note that we are unable to differentiate between an implicit \\\"None\\\"\\n+                    # return and an explicit \\\"return None\\\".\\n+                    retval = TypeInfo(\\\"typing\\\", \\\"Iterator\\\", (y,))\\n+                else:\\n+                    s = AnyTypeInfo # FIXME need send type\\n+                    retval = TypeInfo(\\\"typing\\\", \\\"Generator\\\", (y, s, self.returns))\\n \\n         type_data = (*self.args, retval)\\n \\n\",\"diff --git a/.gitignore b/.gitignore\\nindex 4779cf5..3536cef 100644\\n--- a/.gitignore\\n+++ b/.gitignore\\n@@ -1,3 +1,4 @@\\n+righttyper/traverse.abi3.so\\n righttyper.egg-info/\\n */__pycache__/\\n .venv\\n\",\"diff --git a/righttyper/righttyper.py b/righttyper/righttyper.py\\nindex 8df0ba1..22e7812 100644\\n--- a/righttyper/righttyper.py\\n+++ b/righttyper/righttyper.py\\n@@ -123,12 +123,13 @@ def record_start(\\n         func: FuncInfo,\\n         frame_id: int,\\n         arg_types: tuple[TypeInfo, ...],\\n-        self_type: TypeInfo|None\\n+        self_type: TypeInfo|None,\\n+        is_async: bool\\n     ) -> None:\\n         \\\"\\\"\\\"Records a function start.\\\"\\\"\\\"\\n \\n         # print(f\\\"record_start {func}\\\")\\n-        self.pending_samples[(func, frame_id)] = Sample(arg_types, self_type=self_type)\\n+        self.pending_samples[(func, frame_id)] = Sample(arg_types, self_type=self_type, is_async=is_async)\\n \\n \\n     def record_yield(self, func: FuncInfo, frame_id: int, yield_type: TypeInfo) -> bool:\\n@@ -466,7 +467,13 @@ def get_self_type() -> TypeInfo|None:\\n         )\\n     )\\n \\n-    obs.record_start(t, frame_id, arg_values, get_self_type())\\n+    obs.record_start(\\n+        t,\\n+        frame_id,\\n+        arg_values,\\n+        get_self_type(),\\n+        is_async=bool(code.co_flags & (inspect.CO_ASYNC_GENERATOR|inspect.CO_COROUTINE))\\n+    )\\n \\n \\n def in_instrumentation_code(frame: FrameType) -> bool:\\n\",\"diff --git a/righttyper/righttyper_runtime.py b/righttyper/righttyper_runtime.py\\nindex 68bb11e..e195bc0 100644\\n--- a/righttyper/righttyper_runtime.py\\n+++ b/righttyper/righttyper_runtime.py\\n@@ -464,6 +464,10 @@ def type_for_generator(\\n         return type_for_generator(value, value.cr_frame, value.cr_code, \\\"Coroutine\\\")\\n     elif isinstance(value, type) and value is not type:\\n         return TypeInfo(\\\"\\\", \\\"type\\\", args=(get_type_name(value, depth+1),))\\n+    elif type(value).__name__ == 'async_generator_wrapped_value' and type(value).__module__ == 'builtins':\\n+        import righttyper.traverse as tr\\n+        if (v := tr.traverse(value)):\\n+            return get_value_type(v[0], depth+1)\\n \\n \\n     if use_jaxtyping and hasattr(value, \\\"dtype\\\") and hasattr(value, \\\"shape\\\"):\\n\",\"diff --git a/righttyper/righttyper_types.py b/righttyper/righttyper_types.py\\nindex f97c6d0..f1d95e5 100644\\n--- a/righttyper/righttyper_types.py\\n+++ b/righttyper/righttyper_types.py\\n@@ -137,16 +137,17 @@ class Sample:\\n     args: tuple[TypeInfo, ...]\\n     yields: set[TypeInfo] = field(default_factory=set)\\n     returns: TypeInfo = NoneTypeInfo\\n+    is_async: bool = False\\n     self_type: TypeInfo | None = None\\n \\n \\n     def process(self) -> tuple[TypeInfo, ...]:\\n         retval = self.returns\\n         if self.yields:\\n-            if any(str(t) == \\\"builtins.async_generator_wrapped_value\\\" for t in self.yields):\\n-                # FIXME how to unwrap the y without waiting on it?\\n+            y = TypeInfo.from_set(self.yields)\\n+            if self.is_async:\\n                 # FIXME need send type\\n-                y = s = AnyTypeInfo\\n+                s = AnyTypeInfo\\n                 retval = TypeInfo(\\\"typing\\\", \\\"AsyncGenerator\\\", (y, s))\\n             else:\\n                 y = TypeInfo.from_set(self.yields)\\n\",\"diff --git a/righttyper/traverse.cpp b/righttyper/traverse.cpp\\nnew file mode 100644\\nindex 0000000..9d3498b\\n--- /dev/null\\n+++ b/righttyper/traverse.cpp\\n@@ -0,0 +1,80 @@\\n+#define PY_SSIZE_T_CLEAN\\n+extern \\\"C\\\" {\\n+    #include <Python.h>\\n+}\\n+#include <unordered_set>\\n+\\n+\\n+struct TraverseContext {\\n+    PyObject *list;\\n+    std::unordered_set<PyObject *> visited_objects;\\n+};\\n+\\n+\\n+static int\\n+visit_callback(PyObject *object, void *arg) {\\n+    auto *ctx = static_cast<TraverseContext *>(arg);\\n+\\n+    if (ctx->visited_objects.count(object)) {\\n+        return 0;\\n+    }\\n+\\n+    ctx->visited_objects.insert(object);\\n+\\n+    if (PyList_Append(ctx->list, object) == -1) {\\n+        return -1;\\n+    }\\n+\\n+    return 0;\\n+}\\n+\\n+\\n+static PyObject*\\n+call_traverse(PyObject *self, PyObject *const *args, Py_ssize_t nargs) {\\n+    if (nargs != 1) {\\n+        PyErr_SetString(PyExc_TypeError, \\\"call_traverse() takes exactly one argument\\\");\\n+        return nullptr;\\n+    }\\n+\\n+    PyObject *obj = args[0];\\n+\\n+    if (!Py_TYPE(obj)->tp_traverse) {\\n+        PyErr_SetString(PyExc_TypeError, \\\"Object does not support traversal\\\");\\n+        return nullptr;\\n+    }\\n+\\n+    PyObject *result_list = PyList_New(0);\\n+    if (!result_list) {\\n+        return nullptr;\\n+    }\\n+\\n+    TraverseContext ctx{result_list, {}};\\n+\\n+    if (Py_TYPE(obj)->tp_traverse(obj, visit_callback, &ctx) == -1) {\\n+        Py_DECREF(result_list);\\n+        return nullptr;\\n+    }\\n+\\n+    return result_list;\\n+}\\n+\\n+\\n+static PyMethodDef TraverseMethods[] = {\\n+    {\\\"traverse\\\", (PyCFunction)call_traverse, METH_FASTCALL,\\n+     \\\"Call tp_traverse on an object and return visited objects.\\\"},\\n+    {nullptr, nullptr, 0, nullptr}\\n+};\\n+\\n+\\n+static struct PyModuleDef traverse_module = {\\n+    PyModuleDef_HEAD_INIT,\\n+    \\\"traverse\\\",\\n+    \\\"A module to call tp_traverse on Python objects.\\\",\\n+    -1,\\n+    TraverseMethods\\n+};\\n+\\n+\\n+PyMODINIT_FUNC PyInit_traverse(void) {\\n+    return PyModule_Create(&traverse_module);\\n+}\\n\",\"diff --git a/righttyper/righttyper_runtime.py b/righttyper/righttyper_runtime.py\\nindex e195bc0..a283edd 100644\\n--- a/righttyper/righttyper_runtime.py\\n+++ b/righttyper/righttyper_runtime.py\\n@@ -91,8 +91,7 @@ def should_skip_function(\\n         all([not re.search(pattern, code.co_name) \\\\\\n              for pattern in include_functions_pattern])\\n     if (\\n-        code.co_name.startswith(\\\"<\\\")\\n-        or skip_file\\n+        skip_file\\n         or included_in_pattern\\n         or \\\"righttyper_\\\" in code.co_filename\\n     ):\\n\",\"diff --git a/righttyper/righttyper_runtime.py b/righttyper/righttyper_runtime.py\\nindex a283edd..45a8b12 100644\\n--- a/righttyper/righttyper_runtime.py\\n+++ b/righttyper/righttyper_runtime.py\\n@@ -363,7 +363,7 @@ def find_in_class(class_obj: object) -> abc.Callable|None:\\n     return None\\n \\n \\n-def get_value_type(value: Any, /, use_jaxtyping: bool = False, depth: int = 0) -> TypeInfo:\\n+def get_value_type(value: Any, *, use_jaxtyping: bool = False, depth: int = 0) -> TypeInfo:\\n     \\\"\\\"\\\"\\n     get_value_type takes a value (an instance) as input and returns a string representing its type.\\n \\n@@ -403,13 +403,17 @@ def type_for_generator(\\n         )\\n \\n \\n+    def recurse(v: Any) -> TypeInfo:\\n+        return get_value_type(v, use_jaxtyping=use_jaxtyping, depth=depth+1)\\n+\\n+\\n     if isinstance(value, dict):\\n         t = type(value)\\n         args = (TypeInfo(\\\"typing\\\", \\\"Never\\\"), TypeInfo(\\\"typing\\\", \\\"Never\\\"))\\n         try:\\n             if value:\\n                 el = value.random_item() if isinstance(value, RandomDict) else sample_from_collection(value.items())\\n-                args = tuple(get_value_type(fld, depth=depth+1) for fld in el)\\n+                args = tuple(recurse(fld) for fld in el)\\n         except Exception:\\n             pass\\n         return TypeInfo(lookup_type_module(t), t.__qualname__, args=args)\\n@@ -419,7 +423,7 @@ def type_for_generator(\\n         try:\\n             if value:\\n                 el = sample_from_collection(value)\\n-                args = (get_value_type(el, depth=depth+1),)\\n+                args = (recurse(el),)\\n         except Exception:\\n             pass\\n         return TypeInfo(lookup_type_module(t), t.__qualname__, args=args)\\n@@ -428,7 +432,7 @@ def type_for_generator(\\n         try:\\n             if value:\\n                 el = sample_from_collection(value)\\n-                args = (get_value_type(el, depth=depth+1),)\\n+                args = (recurse(el),)\\n         except Exception:\\n             pass\\n         return TypeInfo(\\\"typing\\\", t.__qualname__, args=args)\\n@@ -437,7 +441,7 @@ def type_for_generator(\\n         try:\\n             if value:\\n                 el = sample_from_collection(value)\\n-                args = tuple(get_value_type(fld, depth=depth+1) for fld in el)\\n+                args = tuple(recurse(fld) for fld in el)\\n         except Exception:\\n             pass\\n         return TypeInfo(\\\"typing\\\", \\\"ItemsView\\\", args=args)\\n@@ -449,7 +453,7 @@ def type_for_generator(\\n             args = tuple()\\n             try:\\n                 if value:\\n-                    args = tuple(get_value_type(fld, depth=depth+1) for fld in value)\\n+                    args = tuple(recurse(fld) for fld in value)\\n             except Exception:\\n                 pass\\n             return TypeInfo(\\\"\\\", \\\"tuple\\\", args=args)\\n@@ -465,8 +469,11 @@ def type_for_generator(\\n         return TypeInfo(\\\"\\\", \\\"type\\\", args=(get_type_name(value, depth+1),))\\n     elif type(value).__name__ == 'async_generator_wrapped_value' and type(value).__module__ == 'builtins':\\n         import righttyper.traverse as tr\\n-        if (v := tr.traverse(value)):\\n-            return get_value_type(v[0], depth+1)\\n+        if (len(v := tr.traverse(value)) == 1):\\n+            return recurse(v[0])\\n+        else:\\n+            # something went wrong with the 'traverse' workaround\\n+            return AnyTypeInfo\\n \\n \\n     if use_jaxtyping and hasattr(value, \\\"dtype\\\") and hasattr(value, \\\"shape\\\"):\\n\",\"diff --git a/righttyper/righttyper.py b/righttyper/righttyper.py\\nindex 22e7812..e62e1c3 100644\\n--- a/righttyper/righttyper.py\\n+++ b/righttyper/righttyper.py\\n@@ -43,8 +43,11 @@\\n from righttyper.righttyper_types import (\\n     ArgInfo,\\n     ArgumentName,\\n+    CodeId,\\n     Filename,\\n+    FuncId,\\n     FuncInfo,\\n+    FrameId,\\n     FuncAnnotation,\\n     FunctionName,\\n     TypeInfo,\\n@@ -93,64 +96,77 @@ class Options:\\n \\n @dataclass\\n class Observations:\\n-    # Visited functions' argument names and their defaults' types, if any\\n-    functions_visited: dict[FuncInfo, tuple[ArgInfo, ...]] = field(default_factory=dict)\\n+    # Visited functions' and information about them\\n+    functions_visited: dict[CodeId, FuncInfo] = field(default_factory=dict)\\n \\n-    # Started, but not completed samples by (function, frame ID)\\n-    pending_samples: dict[tuple[FuncInfo, int], Sample] = field(default_factory=dict)\\n+    # Started, but not (yet) completed samples\\n+    pending_samples: dict[tuple[CodeId, FrameId], Sample] = field(default_factory=dict)\\n \\n-    # Completed samples by function\\n-    samples: dict[FuncInfo, set[tuple[TypeInfo, ...]]] = field(default_factory=lambda: defaultdict(set))\\n+    # Completed samples\\n+    samples: dict[CodeId, set[tuple[TypeInfo, ...]]] = field(default_factory=lambda: defaultdict(set))\\n \\n \\n     def record_function(\\n         self,\\n-        func: FuncInfo,\\n+        code: CodeType,\\n         arg_names: tuple[str, ...],\\n         get_default_type: Callable[[str], TypeInfo|None]\\n     ) -> None:\\n-        \\\"\\\"\\\"Records that a function was visited, along with its argument names and any defaults.\\\"\\\"\\\"\\n-\\n-        if func not in self.functions_visited:\\n-            self.functions_visited[func] = tuple(\\n-                ArgInfo(ArgumentName(name), get_default_type(name))\\n-                for name in arg_names\\n+        \\\"\\\"\\\"Records that a function was visited, along with some details about it.\\\"\\\"\\\"\\n+\\n+        code_id = CodeId(id(code))\\n+        if code_id not in self.functions_visited:\\n+            self.functions_visited[code_id] = FuncInfo(\\n+                FuncId(\\n+                    Filename(code.co_filename),\\n+                    code.co_firstlineno,\\n+                    FunctionName(code.co_qualname),\\n+                ),\\n+                tuple(\\n+                    ArgInfo(ArgumentName(name), get_default_type(name))\\n+                    for name in arg_names\\n+                )\\n             )\\n \\n \\n     def record_start(\\n         self,\\n-        func: FuncInfo,\\n-        frame_id: int,\\n+        code: CodeType,\\n+        frame_id: FrameId,\\n         arg_types: tuple[TypeInfo, ...],\\n-        self_type: TypeInfo|None,\\n-        is_async: bool\\n+        self_type: TypeInfo|None\\n     ) -> None:\\n         \\\"\\\"\\\"Records a function start.\\\"\\\"\\\"\\n \\n-        # print(f\\\"record_start {func}\\\")\\n-        self.pending_samples[(func, frame_id)] = Sample(arg_types, self_type=self_type, is_async=is_async)\\n+        # print(f\\\"record_start {code.co_qualname} {arg_types}\\\")\\n+        self.pending_samples[(CodeId(id(code)), frame_id)] = Sample(\\n+            arg_types,\\n+            self_type=self_type,\\n+            is_async=bool(code.co_flags & (inspect.CO_ASYNC_GENERATOR|inspect.CO_COROUTINE))\\n+        )\\n \\n \\n-    def record_yield(self, func: FuncInfo, frame_id: int, yield_type: TypeInfo) -> bool:\\n+    def record_yield(self, code: CodeType, frame_id: FrameId, yield_type: TypeInfo) -> bool:\\n         \\\"\\\"\\\"Records a yield.\\\"\\\"\\\"\\n \\n-        # print(f\\\"record_yield {func}\\\")\\n-        if (sample := self.pending_samples.get((func, frame_id))):\\n+        # print(f\\\"record_yield {code.co_qualname}\\\")\\n+        if (sample := self.pending_samples.get((CodeId(id(code)), frame_id))):\\n             sample.yields.add(yield_type)\\n             return True\\n \\n         return False\\n \\n \\n-    def record_return(self, func: FuncInfo, frame_id: int, return_type: TypeInfo) -> bool:\\n+    def record_return(self, code: CodeType, frame_id: FrameId, return_type: TypeInfo) -> bool:\\n         \\\"\\\"\\\"Records a return.\\\"\\\"\\\"\\n \\n-        # print(f\\\"record_return {func}\\\")\\n-        if (sample := self.pending_samples.get((func, frame_id))):\\n+        # print(f\\\"record_return {code.co_qualname}\\\")\\n+\\n+        code_id = CodeId(id(code))\\n+        if (sample := self.pending_samples.get((code_id, frame_id))):\\n             sample.returns = return_type\\n-            self.samples[func].add(sample.process())\\n-            del self.pending_samples[(func, frame_id)]\\n+            self.samples[code_id].add(sample.process())\\n+            del self.pending_samples[(code_id, frame_id)]\\n             return True\\n \\n         return False\\n@@ -167,21 +183,21 @@ def _transform_types(self, tr: TypeInfo.Transformer) -> None:\\n                     sample_set.add(sprime)\\n \\n \\n-    def collect_annotations(self: Self) -> dict[FuncInfo, FuncAnnotation]:\\n+    def collect_annotations(self: Self) -> dict[FuncId, FuncAnnotation]:\\n         \\\"\\\"\\\"Collects function type annotations from the observed types.\\\"\\\"\\\"\\n \\n         # Finish samples for any generators that are still unfinished\\n         # TODO are there other cases we should handle?\\n-        for (func, _), sample in self.pending_samples.items():\\n+        for (code_id, _), sample in self.pending_samples.items():\\n             if sample.yields:\\n-                self.samples[func].add(sample.process())\\n+                self.samples[code_id].add(sample.process())\\n \\n-        def mk_annotation(t: FuncInfo) -> FuncAnnotation|None:\\n-            args = self.functions_visited[t]\\n-            samples = self.samples[t]\\n+        def mk_annotation(code_id: CodeId) -> FuncAnnotation|None:\\n+            func_info = self.functions_visited[code_id]\\n+            samples = self.samples[code_id]\\n \\n             if (signature := generalize(list(samples))) is None:\\n-                print(f\\\"Error generalizing {t}: inconsistent samples.\\\\n\\\" +\\n+                print(f\\\"Error generalizing {func_info.func_id}: inconsistent samples.\\\\n\\\" +\\n                       f\\\"{[tuple(str(t) for t in s) for s in samples]}\\\")\\n                 return None\\n \\n@@ -206,7 +222,7 @@ def visit(vself, node: TypeInfo) -> TypeInfo:\\n                             })\\n                         )\\n                     )\\n-                    for i, arg in enumerate(args)\\n+                    for i, arg in enumerate(func_info.args)\\n                 ],\\n                 retval=tr.visit(signature[-1])\\n             )\\n@@ -215,8 +231,8 @@ class T(TypeInfo.Transformer):\\n             \\\"\\\"\\\"Updates Callable type declarations based on observations.\\\"\\\"\\\"\\n             def visit(vself, node: TypeInfo) -> TypeInfo:\\n                 # if 'args' is there, the function is already annotated\\n-                if node.func and (options.ignore_annotations or not node.args) and node.func in self.samples:\\n-                    if (ann := mk_annotation(node.func)):\\n+                if node.code_id and (options.ignore_annotations or not node.args) and node.code_id in self.samples:\\n+                    if (ann := mk_annotation(node.code_id)):\\n                         if node.name == 'Callable':\\n                             # TODO: fix callable arguments being strings\\n                             return TypeInfo('typing', 'Callable', args=(\\n@@ -233,9 +249,9 @@ def visit(vself, node: TypeInfo) -> TypeInfo:\\n         self._transform_types(T())\\n \\n         return {\\n-            t: annotation\\n-            for t in self.samples\\n-            if (annotation := mk_annotation(t)) is not None\\n+            self.functions_visited[code_id].func_id: annotation\\n+            for code_id in self.samples\\n+            if (annotation := mk_annotation(code_id)) is not None\\n         }\\n \\n \\n@@ -263,14 +279,8 @@ def enter_handler(code: CodeType, offset: int) -> Any:\\n         frame = frame.f_back\\n         assert code == frame.f_code\\n \\n-        t = FuncInfo(\\n-            Filename(code.co_filename),\\n-            code.co_firstlineno,\\n-            FunctionName(code.co_qualname),\\n-        )\\n-\\n         function = find_function(frame, code)\\n-        process_function_arguments(t, id(frame), inspect.getargvalues(frame), code, function)\\n+        process_function_arguments(code, FrameId(id(frame)), inspect.getargvalues(frame), function)\\n         del frame\\n \\n     return sys.monitoring.DISABLE if options.sampling else None\\n@@ -370,18 +380,12 @@ def process_yield_or_return(\\n         frame = frame.f_back.f_back\\n         assert code == frame.f_code\\n \\n-        t = FuncInfo(\\n-            Filename(code.co_filename),\\n-            code.co_firstlineno,\\n-            FunctionName(code.co_qualname),\\n-        )\\n-\\n         typeinfo = get_value_type(return_value, use_jaxtyping=options.infer_shapes)\\n \\n         if event_type == sys.monitoring.events.PY_YIELD:\\n-            found = obs.record_yield(t, id(frame), typeinfo)\\n+            found = obs.record_yield(code, FrameId(id(frame)), typeinfo)\\n         else:\\n-            found = obs.record_return(t, id(frame), typeinfo)\\n+            found = obs.record_return(code, FrameId(id(frame)), typeinfo)\\n \\n         del frame\\n \\n@@ -391,10 +395,9 @@ def process_yield_or_return(\\n \\n \\n def process_function_arguments(\\n-    t: FuncInfo,\\n-    frame_id: int,\\n-    args: inspect.ArgInfo,\\n     code: CodeType,\\n+    frame_id: FrameId,\\n+    args: inspect.ArgInfo,\\n     function: Callable|None\\n ) -> None:\\n \\n@@ -443,7 +446,8 @@ def get_self_type() -> TypeInfo|None:\\n         return None\\n \\n     obs.record_function(\\n-        t, (\\n+        code,\\n+        (\\n             *(a for a in args.args),\\n             *((args.varargs,) if args.varargs else ()),\\n             *((args.keywords,) if args.keywords else ())\\n@@ -468,11 +472,10 @@ def get_self_type() -> TypeInfo|None:\\n     )\\n \\n     obs.record_start(\\n-        t,\\n+        code,\\n         frame_id,\\n         arg_values,\\n-        get_self_type(),\\n-        is_async=bool(code.co_flags & (inspect.CO_ASYNC_GENERATOR|inspect.CO_COROUTINE))\\n+        get_self_type()\\n     )\\n \\n \\n@@ -598,10 +601,10 @@ def process_file_wrapper(args) -> SignatureChanges|BaseException:\\n \\n def process_all_files() -> list[SignatureChanges]:\\n     fnames = set(\\n-        t.file_name\\n-        for t in obs.functions_visited\\n+        t.func_id.file_name\\n+        for t in obs.functions_visited.values()\\n         if not skip_this_file(\\n-            t.file_name,\\n+            t.func_id.file_name,\\n             options.script_dir,\\n             options.include_all,\\n             options.include_files_pattern\\n\",\"diff --git a/righttyper/righttyper_process.py b/righttyper/righttyper_process.py\\nindex 35d6ed4..7c2b56f 100644\\n--- a/righttyper/righttyper_process.py\\n+++ b/righttyper/righttyper_process.py\\n@@ -6,7 +6,7 @@\\n from righttyper.generate_stubs import PyiTransformer\\n from righttyper.righttyper_types import (\\n     Filename,\\n-    FuncInfo,\\n+    FuncId,\\n     FuncAnnotation,\\n     FunctionName,\\n )\\n@@ -80,7 +80,7 @@ def process_file(\\n     filename: Filename,\\n     output_files: bool,\\n     generate_stubs: bool,\\n-    type_annotations: dict[FuncInfo, FuncAnnotation],\\n+    type_annotations: dict[FuncId, FuncAnnotation],\\n     overwrite: bool,\\n     module_names: list[str],\\n     ignore_annotations: bool = False,\\n\",\"diff --git a/righttyper/righttyper_runtime.py b/righttyper/righttyper_runtime.py\\nindex 45a8b12..9691c15 100644\\n--- a/righttyper/righttyper_runtime.py\\n+++ b/righttyper/righttyper_runtime.py\\n@@ -22,9 +22,10 @@\\n \\n from righttyper.random_dict import RandomDict\\n from righttyper.righttyper_types import (\\n+    CodeId,\\n     Filename,\\n     FunctionName,\\n-    FuncInfo,\\n+    FuncId,\\n     T,\\n     TypeInfo,\\n     NoneTypeInfo,\\n@@ -154,13 +155,10 @@ def format_arg(arg) -> str:\\n         args = tuple()\\n \\n     # Construct the Callable type string\\n-    return TypeInfo(\\\"typing\\\", \\\"Callable\\\", args=args,\\n-                    func=FuncInfo(\\n-                        Filename(func.__code__.co_filename),\\n-                        func.__code__.co_firstlineno,\\n-                        FunctionName(func.__qualname__)\\n-                    ),\\n-                    is_bound=isinstance(func, MethodType)\\n+    return TypeInfo(\\\"typing\\\", \\\"Callable\\\",\\n+        args=args,\\n+        code_id=CodeId(id(func.__code__)),\\n+        is_bound=isinstance(func, MethodType)\\n     )\\n \\n \\n@@ -394,13 +392,7 @@ def type_for_generator(\\n         #    ann = type_from_annotations(f)\\n         #    (now use ann_type.args[-1], the return value)\\n \\n-        return TypeInfo(\\\"typing\\\", name,\\n-            func=FuncInfo(\\n-                Filename(code.co_filename),\\n-                code.co_firstlineno,\\n-                FunctionName(obj.__qualname__)\\n-            )\\n-        )\\n+        return TypeInfo(\\\"typing\\\", name, code_id=CodeId(id(code)))\\n \\n \\n     def recurse(v: Any) -> TypeInfo:\\n\",\"diff --git a/righttyper/righttyper_types.py b/righttyper/righttyper_types.py\\nindex f1d95e5..61029ed 100644\\n--- a/righttyper/righttyper_types.py\\n+++ b/righttyper/righttyper_types.py\\n@@ -11,9 +11,12 @@\\n Filename = NewType(\\\"Filename\\\", str)\\n FunctionName = NewType(\\\"FunctionName\\\", str)\\n \\n+CodeId = NewType(\\\"CodeId\\\", int)     # obtained from id(code) where code is-a CodeType\\n+FrameId = NewType(\\\"FrameId\\\", int)   # similarly from id(frame)\\n+\\n \\n @dataclass(eq=True, frozen=True)\\n-class FuncInfo:\\n+class FuncId:\\n     file_name: Filename\\n     first_code_line: int\\n     func_name: FunctionName\\n@@ -35,8 +38,8 @@ class TypeInfo:\\n     name: str\\n     args: \\\"tuple[TypeInfo|str, ...]\\\" = tuple()    # arguments within []\\n \\n-    func: FuncInfo|None = None              # if a callable, the FuncInfo\\n-    is_bound: bool = False                  # if a callable, whether bound\\n+    code_id: CodeId = CodeId(0)     # if a callable, generator or coroutine, the CodeId\\n+    is_bound: bool = False          # if a callable, whether bound\\n     type_obj: TYPE_OBJ_TYPES|None = None\\n     typevar_index: int = 0\\n     typevar_name: str|None = None   # TODO delete me?\\n@@ -132,6 +135,13 @@ class ArgInfo:\\n     default: TypeInfo|None\\n \\n \\n+@dataclass(eq=True, frozen=True)\\n+class FuncInfo:\\n+    func_id: FuncId\\n+    args: tuple[ArgInfo, ...]\\n+\\n+\\n+\\n @dataclass\\n class Sample:\\n     args: tuple[TypeInfo, ...]\\n\",\"diff --git a/righttyper/unified_transformer.py b/righttyper/unified_transformer.py\\nindex b480563..8426e81 100644\\n--- a/righttyper/unified_transformer.py\\n+++ b/righttyper/unified_transformer.py\\n@@ -8,7 +8,7 @@\\n \\n from righttyper.righttyper_types import (\\n     Filename,\\n-    FuncInfo,\\n+    FuncId,\\n     FuncAnnotation,\\n     FunctionName,\\n     TypeInfo,\\n@@ -101,7 +101,7 @@ class UnifiedTransformer(cst.CSTTransformer):\\n     def __init__(\\n         self,\\n         filename: str,\\n-        type_annotations: dict[FuncInfo, FuncAnnotation],\\n+        type_annotations: dict[FuncId, FuncAnnotation],\\n         override_annotations: bool,\\n         inline_generics: bool,\\n         module_name: str|None,\\n@@ -430,7 +430,7 @@ def leave_FunctionDef(\\n             self.get_metadata(PositionProvider, node).start.line\\n             for node in (original_node, *original_node.decorators)\\n         )\\n-        key = FuncInfo(Filename(self.filename), first_line, FunctionName(name))\\n+        key = FuncId(Filename(self.filename), first_line, FunctionName(name))\\n \\n         if ann := typing.cast(FuncAnnotation, self.type_annotations.get(key)):  # cast to make mypy happy\\n             pre_function = []\\n\",\"diff --git a/setup.py b/setup.py\\nnew file mode 100644\\nindex 0000000..93e7c51\\n--- /dev/null\\n+++ b/setup.py\\n@@ -0,0 +1,33 @@\\n+import setuptools\\n+import sys\\n+import os\\n+\\n+def cxx_version(v):\\n+    return [f\\\"-std={v}\\\" if sys.platform != \\\"win32\\\" else f\\\"/std:{v}\\\"]\\n+\\n+def platform_compile_args():\\n+    # If flags are specified as a global env var, use them: this might happen\\n+    # in a conda build, and is needed to override build configurations on osx\\n+    if flags := os.environ.get(\\\"CXXFLAGS\\\", \\\"\\\").split():\\n+        return flags\\n+\\n+    if sys.platform == 'darwin':\\n+        # default to a multi-arch build\\n+        return ['-arch', 'x86_64', '-arch', 'arm64', '-arch', 'arm64e']\\n+    if sys.platform == 'win32':\\n+        # avoids creating Visual Studio dependencies\\n+        return ['/MT']\\n+    return []\\n+\\n+\\n+setuptools.setup(\\n+    ext_modules= [\\n+        setuptools.Extension(\\n+            'righttyper.traverse',\\n+            sources=['righttyper/traverse.cpp'],\\n+            extra_compile_args=cxx_version('c++17') + platform_compile_args(),\\n+            language='c++',\\n+            py_limited_api=True\\n+        )\\n+    ]\\n+)\\n\"]", "test_patch": "[\"diff --git a/tests/test_integration.py b/tests/test_integration.py\\nindex d2b05b9..217e6b8 100644\\n--- a/tests/test_integration.py\\n+++ b/tests/test_integration.py\\n@@ -549,12 +549,10 @@ def g(f):\\n     output = Path(\\\"t.py\\\").read_text()\\n \\n     assert \\\"def gen() -> Iterator[float|int]:\\\" in output\\n+    assert \\\"def g(f: Iterator[float|int]) -> None\\\" in output\\n \\n-    # FIXME this should be the same Iterator as above\\n-    assert \\\"def g(f: Generator[Any, Any, Any]) -> None\\\" in output\\n \\n-\\n-def test_generator_return(tmp_cwd):\\n+def test_generator_with_return(tmp_cwd):\\n     t = textwrap.dedent(\\\"\\\"\\\"\\\\\\n         def gen():\\n             yield 10\\n@@ -582,9 +580,35 @@ def g(f):\\n     output = Path(\\\"t.py\\\").read_text()\\n \\n     assert \\\"def gen() -> Generator[int, Any, str]:\\\" in output\\n+    assert \\\"def g(f: Generator[int, Any, str]) -> None\\\" in output\\n+\\n+\\n+@pytest.mark.xfail(reason=\\\"Doesn't currently work\\\")\\n+def test_generator_from_annotation(tmp_cwd):\\n+    t = textwrap.dedent(\\\"\\\"\\\"\\\\\\n+        from typing import Generator\\n \\n-    # FIXME this should be the same Generator as above\\n-    assert \\\"def g(f: Generator[Any, Any, Any]) -> None\\\" in output\\n+        def gen() -> Generator[int|str, None, None]:\\n+            yield \\\"\\\"\\n+\\n+        def main():\\n+            for _ in gen():\\n+                pass\\n+\\n+        def g(f):\\n+            pass\\n+\\n+        main()\\n+        g(gen())\\n+        \\\"\\\"\\\")\\n+\\n+    Path(\\\"t.py\\\").write_text(t)\\n+\\n+    subprocess.run([sys.executable, '-m', 'righttyper', '--overwrite', '--output-files',\\n+                    '--no-use-multiprocessing', 't.py'], check=True)\\n+    output = Path(\\\"t.py\\\").read_text()\\n+\\n+    assert \\\"def g(f: Generator[int|str, None, None]) -> None\\\" in output\\n \\n \\n def test_async_generator(tmp_cwd):\\n@@ -611,13 +635,33 @@ def g(f):\\n                     '--no-use-multiprocessing', 't.py'], check=True)\\n     output = Path(\\\"t.py\\\").read_text()\\n \\n-    # FIXME should be AsyncGenerator[int] or AsyncIterator[int]\\n-    assert \\\"def gen() -> AsyncIterator[Any]:\\\" in output\\n-\\n-    # FIXME this should be the same Iterator as above\\n+    # FIXME should be AsyncGenerator[int, None] or AsyncIterator[int]\\n+    assert \\\"def gen() -> AsyncGenerator[Any, Any]:\\\" in output\\n     assert \\\"def g(f: AsyncGenerator[Any, Any]) -> None\\\" in output\\n \\n \\n+def test_coroutine(tmp_cwd):\\n+    Path(\\\"t.py\\\").write_text(textwrap.dedent(\\\"\\\"\\\"\\\\\\n+        import asyncio\\n+\\n+        def foo():\\n+            async def coro():\\n+                return \\\"did it\\\"\\n+\\n+            return coro()\\n+\\n+        asyncio.run(foo())\\n+        \\\"\\\"\\\"\\n+    ))\\n+\\n+    subprocess.run([sys.executable, '-m', 'righttyper', '--overwrite', '--output-files',\\n+                    '--no-use-multiprocessing', 't.py'], check=True)\\n+\\n+    output = Path(\\\"t.py\\\").read_text()\\n+    # FIXME should be Coroutine[None, None, str]\\n+    assert \\\"def foo() -> Coroutine[None, Any, str]:\\\" in output\\n+\\n+\\n def test_generate_stubs(tmp_cwd):\\n     Path(\\\"m.py\\\").write_text(textwrap.dedent(\\\"\\\"\\\"\\\\\\n         import sys\\n@@ -690,25 +734,6 @@ def __str__(self):\\n     subprocess.run([sys.executable, '-m', 'mypy', 'm.py', 't.py'], check=True)\\n \\n \\n-def test_coroutine_type(tmp_cwd):\\n-    Path(\\\"t.py\\\").write_text(textwrap.dedent(\\\"\\\"\\\"\\\\\\n-        def foo():\\n-            async def coro():\\n-                import asyncio\\n-                await asyncio.sleep(1)\\n-            return coro()\\n-\\n-        foo()\\n-        \\\"\\\"\\\"\\n-    ))\\n-\\n-    subprocess.run([sys.executable, '-m', 'righttyper', '--overwrite', '--output-files',\\n-                    '--no-use-multiprocessing', 't.py'], check=True)\\n-\\n-    output = Path(\\\"t.py\\\").read_text()\\n-    assert \\\"def foo() -> Coroutine[Any, Any, Any]:\\\" in output\\n-\\n-\\n def test_module_type(tmp_cwd):\\n     Path(\\\"t.py\\\").write_text(textwrap.dedent(\\\"\\\"\\\"\\\\\\n         import sys\\n@@ -871,6 +896,70 @@ def bar():\\n     assert \\\"def bar() -> Iterator[Callable[[int], float]]:\\\" in output\\n \\n \\n+@pytest.mark.parametrize('ignore_ann', [False, True])\\n+def test_discovered_function_annotated(tmp_cwd, ignore_ann):\\n+    Path(\\\"t.py\\\").write_text(textwrap.dedent(\\\"\\\"\\\"\\\\\\n+        def foo(x: int | float) -> float:\\n+            return x/2\\n+\\n+        def bar(f, x):\\n+            return f(x)\\n+\\n+        bar(foo, 1)\\n+        \\\"\\\"\\\"\\n+    ))\\n+\\n+    subprocess.run([sys.executable, '-m', 'righttyper', '--overwrite', '--output-files',\\n+                    '--no-use-multiprocessing',\\n+                    *(('--ignore-annotations',) if ignore_ann else()),\\n+                    't.py'], check=True)\\n+\\n+    output = Path(\\\"t.py\\\").read_text()\\n+\\n+    if ignore_ann:\\n+        assert \\\"def bar(f: Callable[[int], float], x: int) -> float:\\\" in output\\n+    else:\\n+        assert \\\"def bar(f: Callable[[int | float], float], x: int) -> float:\\\" in output\\n+\\n+\\n+def test_discovered_generator(tmp_cwd):\\n+    Path(\\\"t.py\\\").write_text(textwrap.dedent(\\\"\\\"\\\"\\\\\\n+        def g(x):\\n+            yield from range(x)\\n+\\n+        def f(x):\\n+            for _ in x:\\n+                pass\\n+\\n+        f(g(10))\\n+        \\\"\\\"\\\"\\n+    ))\\n+\\n+    subprocess.run([sys.executable, '-m', 'righttyper', '--overwrite', '--output-files',\\n+                    '--no-use-multiprocessing', 't.py'], check=True)\\n+\\n+    output = Path(\\\"t.py\\\").read_text()\\n+    assert \\\"def f(x: Iterator[int]) -> None:\\\" in output\\n+\\n+\\n+@pytest.mark.skip(reason=\\\"We don't currently process events for <genexpr>\\\")\\n+def test_discovered_genexpr(tmp_cwd):\\n+    Path(\\\"t.py\\\").write_text(textwrap.dedent(\\\"\\\"\\\"\\\\\\n+        def f(x):\\n+            for _ in x:\\n+                pass\\n+\\n+        f((i for i in range(10)))\\n+        \\\"\\\"\\\"\\n+    ))\\n+\\n+    subprocess.run([sys.executable, '-m', 'righttyper', '--overwrite', '--output-files',\\n+                    '--no-use-multiprocessing', 't.py'], check=True)\\n+\\n+    output = Path(\\\"t.py\\\").read_text()\\n+    assert \\\"def f(x: Iterator[int]) -> None:\\\" in output\\n+\\n+\\n def test_module_list_not_lost_with_multiprocessing(tmp_cwd):\\n     Path(\\\"t.py\\\").write_text(textwrap.dedent(\\\"\\\"\\\"\\\\\\n         def foo(t):\\n\",\"diff --git a/tests/test_typing.py b/tests/test_typing.py\\nindex 99d07e3..11fe3dd 100644\\n--- a/tests/test_typing.py\\n+++ b/tests/test_typing.py\\n@@ -1,4 +1,4 @@\\n-from righttyper.righttyper_types import TypeInfo, NoneTypeInfo, Sample\\n+from righttyper.righttyper_types import TypeInfo, NoneTypeInfo, AnyTypeInfo, Sample\\n from righttyper.typeinfo import merged_types\\n import righttyper.righttyper_runtime as rt\\n from collections.abc import Iterable\\n@@ -131,7 +131,7 @@ def test_get_value_type():\\n     assert 0 == next(o), \\\"changed state\\\"\\n \\n     o = (i for i in range(10))\\n-    assert \\\"typing.Generator[typing.Any, typing.Any, typing.Any]\\\" == get_value_type(o)\\n+    assert \\\"typing.Generator\\\" == get_value_type(o)\\n     assert 0 == next(o), \\\"changed state\\\"\\n \\n     Point = namedtuple('Point', ['x', 'y'])\\n@@ -149,8 +149,8 @@ async def async_range(start):\\n         for i in range(start):\\n             yield i\\n \\n-    assert \\\"typing.AsyncGenerator[typing.Any, typing.Any]\\\" == get_value_type(async_range(10))\\n-    assert \\\"typing.AsyncGenerator[typing.Any, typing.Any]\\\" == get_value_type(aiter(async_range(10)))\\n+    assert \\\"typing.AsyncGenerator\\\" == get_value_type(async_range(10))\\n+    assert \\\"typing.AsyncGenerator\\\" == get_value_type(aiter(async_range(10)))\\n \\n \\n @pytest.mark.filterwarnings(\\\"ignore:coroutine .* never awaited\\\")\\n@@ -159,7 +159,7 @@ async def coro():\\n         import asyncio\\n         await asyncio.sleep(1)\\n \\n-    assert \\\"typing.Coroutine[typing.Any, typing.Any, typing.Any]\\\" == get_value_type(coro())\\n+    assert \\\"typing.Coroutine\\\" == get_value_type(coro())\\n \\n \\n @pytest.mark.skipif(importlib.util.find_spec('numpy') is None, reason='missing module numpy')\\n@@ -404,7 +404,7 @@ class D(B): pass\\n str_ti = TypeInfo(\\\"\\\", \\\"str\\\", type_obj=str)\\n int_ti = TypeInfo(\\\"\\\", \\\"int\\\", type_obj=int)\\n bool_ti = TypeInfo(\\\"\\\", \\\"bool\\\", type_obj=bool)\\n-any_ti = TypeInfo(\\\"typing\\\", \\\"Any\\\")\\n+any_ti = AnyTypeInfo\\n generator_ti = lambda *a: TypeInfo(\\\"typing\\\", \\\"Generator\\\", tuple(a))\\n iterator_ti = lambda *a: TypeInfo(\\\"typing\\\", \\\"Iterator\\\", tuple(a))\\n union_ti = lambda *a: TypeInfo(\\\"types\\\", \\\"UnionType\\\", tuple(a), type_obj=types.UnionType)\\n@@ -475,9 +475,3 @@ def dog(a, b, c):\\n     sample = generate_sample(dog, 1, \\\"hi\\\", True)\\n     assert sample == Sample((int_ti, str_ti, bool_ti,), {int_ti, str_ti}, bool_ti)\\n     assert sample.process() == (int_ti, str_ti, bool_ti, generator_ti(union_ti(int_ti, str_ti), any_ti, bool_ti))\\n-\\n-\\n-def test_sample_process_asynciterator():\\n-    # TODO: do with real async test\\n-    sample = Sample(tuple(), yields={TypeInfo(\\\"builtins\\\", \\\"async_generator_wrapped_value\\\")})\\n-    assert sample.process() == (TypeInfo(\\\"typing\\\", \\\"AsyncIterator\\\", (any_ti,)),)\\n\",\"diff --git a/.github/workflows/release.yml b/.github/workflows/release.yml\\nindex d5014ec..8b9c584 100644\\n--- a/.github/workflows/release.yml\\n+++ b/.github/workflows/release.yml\\n@@ -4,12 +4,22 @@ on:\\n   release:\\n     types: [published]\\n \\n+  workflow_dispatch:\\n+\\n permissions:\\n   contents: read\\n \\n jobs:\\n   release:\\n-    runs-on: ubuntu-latest\\n+    runs-on: ${{ matrix.os }}\\n+    container: ${{ matrix.container }}\\n+    strategy:\\n+      matrix:\\n+        python_version: '3.12'\\n+        os: ['ubuntu-latest', 'macos-13']\\n+        include:\\n+          - os: ubuntu-latest\\n+            container: quay.io/pypa/manylinux_2_28_x86_64 # https://github.com/pypa/manylinux\\n \\n     steps:\\n     - uses: actions/checkout@v4\\n@@ -17,7 +27,7 @@ jobs:\\n     - name: Set up Python\\n       uses: actions/setup-python@v5\\n       with:\\n-        python-version: '3.x'\\n+        python-version: ${{ matrix.python_version }}\\n \\n     - name: Install dependencies\\n       run: |\\n@@ -27,7 +37,16 @@ jobs:\\n     - name: Build package\\n       run: python -m build\\n \\n+    - name: Upload test package\\n+      if: github.event_name != 'release'\\n+      uses: pypa/gh-action-pypi-publish@release/v1\\n+      with:\\n+        user: __token__\\n+        password: ${{ secrets.TEST_PYPI_API_TOKEN }}\\n+        repository-url: https://test.pypi.org/legacy/\\n+\\n     - name: Publish package\\n+      if: github.event_name == 'release'\\n       uses: pypa/gh-action-pypi-publish@release/v1\\n       with:\\n         user: __token__\\n\",\"diff --git a/tests/test_integration.py b/tests/test_integration.py\\nindex 217e6b8..5b23189 100644\\n--- a/tests/test_integration.py\\n+++ b/tests/test_integration.py\\n@@ -636,8 +636,8 @@ def g(f):\\n     output = Path(\\\"t.py\\\").read_text()\\n \\n     # FIXME should be AsyncGenerator[int, None] or AsyncIterator[int]\\n-    assert \\\"def gen() -> AsyncGenerator[Any, Any]:\\\" in output\\n-    assert \\\"def g(f: AsyncGenerator[Any, Any]) -> None\\\" in output\\n+    assert \\\"def gen() -> AsyncGenerator[int, Any]:\\\" in output\\n+    assert \\\"def g(f: AsyncGenerator[int, Any]) -> None\\\" in output\\n \\n \\n def test_coroutine(tmp_cwd):\\n\",\"diff --git a/tests/test_integration.py b/tests/test_integration.py\\nindex 5b23189..5be5c89 100644\\n--- a/tests/test_integration.py\\n+++ b/tests/test_integration.py\\n@@ -942,7 +942,6 @@ def f(x):\\n     assert \\\"def f(x: Iterator[int]) -> None:\\\" in output\\n \\n \\n-@pytest.mark.skip(reason=\\\"We don't currently process events for <genexpr>\\\")\\n def test_discovered_genexpr(tmp_cwd):\\n     Path(\\\"t.py\\\").write_text(textwrap.dedent(\\\"\\\"\\\"\\\\\\n         def f(x):\\n@@ -960,6 +959,26 @@ def f(x):\\n     assert \\\"def f(x: Iterator[int]) -> None:\\\" in output\\n \\n \\n+def test_discovered_genexpr_two_in_same_line(tmp_cwd):\\n+    # TODO this is a bit risky: we identify the functions (and genexpr) by filename,\\n+    # first code line and name.  These two genexpr have thus the same name!\\n+    # We could add the first code column...\\n+    Path(\\\"t.py\\\").write_text(textwrap.dedent(\\\"\\\"\\\"\\\\\\n+        def f(x):\\n+            for _ in x:\\n+                pass\\n+\\n+        f((i for i in range(10))); f((s for s in ['a', 'b']))\\n+        \\\"\\\"\\\"\\n+    ))\\n+\\n+    subprocess.run([sys.executable, '-m', 'righttyper', '--overwrite', '--output-files',\\n+                    '--no-use-multiprocessing', 't.py'], check=True)\\n+\\n+    output = Path(\\\"t.py\\\").read_text()\\n+    assert \\\"def f(x: Iterator[int|str]) -> None:\\\" in output\\n+\\n+\\n def test_module_list_not_lost_with_multiprocessing(tmp_cwd):\\n     Path(\\\"t.py\\\").write_text(textwrap.dedent(\\\"\\\"\\\"\\\\\\n         def foo(t):\\n\",\"diff --git a/tests/test_integration.py b/tests/test_integration.py\\nindex 5be5c89..0d46473 100644\\n--- a/tests/test_integration.py\\n+++ b/tests/test_integration.py\\n@@ -965,10 +965,12 @@ def test_discovered_genexpr_two_in_same_line(tmp_cwd):\\n     # We could add the first code column...\\n     Path(\\\"t.py\\\").write_text(textwrap.dedent(\\\"\\\"\\\"\\\\\\n         def f(x):\\n-            for _ in x:\\n-                pass\\n+            return sum(1 for _ in x)\\n+\\n+        def g(x):\\n+            return sum(1 for _ in x)\\n \\n-        f((i for i in range(10))); f((s for s in ['a', 'b']))\\n+        f((i for i in range(10))) + g((s for s in ['a', 'b']))\\n         \\\"\\\"\\\"\\n     ))\\n \\n@@ -976,7 +978,8 @@ def f(x):\\n                     '--no-use-multiprocessing', 't.py'], check=True)\\n \\n     output = Path(\\\"t.py\\\").read_text()\\n-    assert \\\"def f(x: Iterator[int|str]) -> None:\\\" in output\\n+    assert \\\"def f(x: Iterator[int]) -> int:\\\" in output\\n+    assert \\\"def g(x: Iterator[str]) -> int:\\\" in output\\n \\n \\n def test_module_list_not_lost_with_multiprocessing(tmp_cwd):\\n\",\"diff --git a/tests/test_transformer.py b/tests/test_transformer.py\\nindex 558c6a1..557f0e4 100644\\n--- a/tests/test_transformer.py\\n+++ b/tests/test_transformer.py\\n@@ -4,7 +4,7 @@\\n import textwrap\\n from righttyper.unified_transformer import UnifiedTransformer, types_in_annotation, used_names\\n from righttyper.righttyper_types import (\\n-    FuncInfo,\\n+    FuncId,\\n     Filename,\\n     FunctionName,\\n     ArgumentName,\\n@@ -65,10 +65,10 @@ def get_function(m: cst.Module, funcname: str) -> str|None:\\n     return None\\n \\n \\n-def get_funcinfo(filename: str, m: cst.Module, funcname: str) -> FuncInfo:\\n-    \\\"\\\"\\\"Returns a FuncInfo for the given function, if found in 'm'\\\"\\\"\\\"\\n+def get_funcid(filename: str, m: cst.Module, funcname: str) -> FuncId:\\n+    \\\"\\\"\\\"Returns a FuncId for the given function, if found in 'm'\\\"\\\"\\\"\\n     if (f := find_function(m, funcname)):\\n-        return FuncInfo(\\n+        return FuncId(\\n             Filename(filename),\\n             f[1],\\n             FunctionName(funcname)\\n@@ -105,8 +105,8 @@ def baz(z):\\n             return z/2\\n     \\\"\\\"\\\"))\\n \\n-    foo = get_funcinfo('foo.py', code, 'foo')\\n-    baz = get_funcinfo('foo.py', code, 'baz')\\n+    foo = get_funcid('foo.py', code, 'foo')\\n+    baz = get_funcid('foo.py', code, 'baz')\\n     t = UnifiedTransformer(\\n             filename='foo.py',\\n             type_annotations = {\\n@@ -178,9 +178,9 @@ def baz(cls, z):\\n                 return z/2\\n     \\\"\\\"\\\"))\\n \\n-    foo = get_funcinfo('foo.py', code, 'C.foo')\\n-    bar = get_funcinfo('foo.py', code, 'C.bar')\\n-    baz = get_funcinfo('foo.py', code, 'C.baz')\\n+    foo = get_funcid('foo.py', code, 'C.foo')\\n+    bar = get_funcid('foo.py', code, 'C.bar')\\n+    baz = get_funcid('foo.py', code, 'C.baz')\\n     t = UnifiedTransformer(\\n             filename='foo.py',\\n             type_annotations = {\\n@@ -257,8 +257,8 @@ def bar(z):\\n             return bar(x+y)\\n     \\\"\\\"\\\"))\\n \\n-    foo = get_funcinfo('foo.py', code, 'foo')\\n-    bar = get_funcinfo('foo.py', code, 'foo.<locals>.bar')\\n+    foo = get_funcid('foo.py', code, 'foo')\\n+    bar = get_funcid('foo.py', code, 'foo.<locals>.bar')\\n     t = UnifiedTransformer(\\n             filename='foo.py',\\n             type_annotations = {\\n@@ -303,8 +303,8 @@ def bar(self, x: float) -> int:\\n                 return x/2\\n     \\\"\\\"\\\"))\\n \\n-    foo = get_funcinfo('foo.py', code, 'foo')\\n-    bar = get_funcinfo('foo.py', code, 'C.bar')\\n+    foo = get_funcid('foo.py', code, 'foo')\\n+    bar = get_funcid('foo.py', code, 'C.bar')\\n     t = UnifiedTransformer(\\n             filename='foo.py',\\n             type_annotations = {\\n@@ -345,7 +345,7 @@ def test_transform_adds_typing_import_for_typing_names():\\n         def foo(x): ...\\n     \\\"\\\"\\\"))\\n \\n-    foo = get_funcinfo('foo.py', code, 'foo')\\n+    foo = get_funcid('foo.py', code, 'foo')\\n     t = UnifiedTransformer(\\n             filename='foo.py',\\n             type_annotations = {\\n@@ -382,7 +382,7 @@ def foo(x, y):\\n             return x/2\\n     \\\"\\\"\\\"))\\n \\n-    foo = get_funcinfo('foo.py', code, 'foo')\\n+    foo = get_funcid('foo.py', code, 'foo')\\n     t = UnifiedTransformer(\\n             filename='foo.py',\\n             type_annotations = {\\n@@ -428,7 +428,7 @@ def foo(x, y):\\n             return x/2\\n     \\\"\\\"\\\"))\\n \\n-    foo = get_funcinfo('foo.py', code, 'foo')\\n+    foo = get_funcid('foo.py', code, 'foo')\\n     t = UnifiedTransformer(\\n             filename='foo.py',\\n             type_annotations = {\\n@@ -478,7 +478,7 @@ def bar(x):   # type: (Any) -> None\\n             pass\\n     \\\"\\\"\\\"))\\n \\n-    foo = get_funcinfo('foo.py', code, 'foo')\\n+    foo = get_funcid('foo.py', code, 'foo')\\n     t = UnifiedTransformer(\\n             filename='foo.py',\\n             type_annotations = {\\n@@ -528,7 +528,7 @@ def bar(\\n             pass\\n     \\\"\\\"\\\"))\\n \\n-    foo = get_funcinfo('foo.py', code, 'foo')\\n+    foo = get_funcid('foo.py', code, 'foo')\\n     t = UnifiedTransformer(\\n             filename='foo.py',\\n             type_annotations = {\\n@@ -584,7 +584,7 @@ def bar(\\n             pass\\n     \\\"\\\"\\\"))\\n \\n-    foo = get_funcinfo('foo.py', code, 'foo')\\n+    foo = get_funcid('foo.py', code, 'foo')\\n     t = UnifiedTransformer(\\n             filename='foo.py',\\n             type_annotations = {\\n@@ -638,9 +638,9 @@ def bar(x, y):\\n             return F((x+y)/2)\\n     \\\"\\\"\\\"))\\n \\n-    foo = get_funcinfo('foo.py', code, 'foo')\\n-    f_foo = get_funcinfo('foo.py', code, 'F.foo')\\n-    bar = get_funcinfo('foo.py', code, 'bar')\\n+    foo = get_funcid('foo.py', code, 'foo')\\n+    f_foo = get_funcid('foo.py', code, 'F.foo')\\n+    bar = get_funcid('foo.py', code, 'bar')\\n     t = UnifiedTransformer(\\n             filename='foo.py',\\n             type_annotations = {\\n@@ -706,7 +706,7 @@ def foo(x, y, z): ...\\n         import r    # imported after 'def foo', so can't be used in annotation\\n     \\\"\\\"\\\"))\\n \\n-    foo = get_funcinfo('foo.py', code, 'foo')\\n+    foo = get_funcid('foo.py', code, 'foo')\\n     t = UnifiedTransformer(\\n             filename='foo.py',\\n             type_annotations = {\\n@@ -758,7 +758,7 @@ def foo(x, y): ...\\n         import r    # imported after 'def foo', so can't be used in annotation\\n     \\\"\\\"\\\"))\\n \\n-    foo = get_funcinfo('foo.py', code, 'foo')\\n+    foo = get_funcid('foo.py', code, 'foo')\\n     t = UnifiedTransformer(\\n             filename='foo.py',\\n             type_annotations = {\\n@@ -801,7 +801,7 @@ def test_imports_subdomain_if_needed():\\n         def foo(x): ...\\n     \\\"\\\"\\\"))\\n \\n-    foo = get_funcinfo('foo.py', code, 'foo')\\n+    foo = get_funcid('foo.py', code, 'foo')\\n     t = UnifiedTransformer(\\n             filename='foo.py',\\n             type_annotations = {\\n@@ -850,7 +850,7 @@ def bar(x: \\\"ast.For\\\") -> \\\"m.T\\\": ...\\n \\n     import ast\\n \\n-    foo = get_funcinfo('foo.py', code, 'foo')\\n+    foo = get_funcid('foo.py', code, 'foo')\\n     t = UnifiedTransformer(\\n             filename='foo.py',\\n             type_annotations = {\\n@@ -906,7 +906,7 @@ def foo(x): ...\\n \\n     import ast\\n \\n-    foo = get_funcinfo('foo.py', code, 'foo')\\n+    foo = get_funcid('foo.py', code, 'foo')\\n     t = UnifiedTransformer(\\n             filename='foo.py',\\n             type_annotations = {\\n@@ -962,7 +962,7 @@ def test_relative_import():\\n         def foo(x, y, z): ...\\n     \\\"\\\"\\\"))\\n \\n-    foo = get_funcinfo('foo.py', code, 'foo')\\n+    foo = get_funcid('foo.py', code, 'foo')\\n     t = UnifiedTransformer(\\n             filename='foo.py',\\n             type_annotations = {\\n@@ -1011,10 +1011,10 @@ def foo(self, x): ...\\n         def f(a, b): ...\\n     \\\"\\\"\\\"))\\n \\n-    foobar = get_funcinfo('foo.py', code, 'foo.<locals>.bar')\\n-    Cfoo = get_funcinfo('foo.py', code, 'C.foo')\\n-    Dfoo = get_funcinfo('foo.py', code, 'C.D.foo')\\n-    f = get_funcinfo('foo.py', code, 'f')\\n+    foobar = get_funcid('foo.py', code, 'foo.<locals>.bar')\\n+    Cfoo = get_funcid('foo.py', code, 'C.foo')\\n+    Dfoo = get_funcid('foo.py', code, 'C.D.foo')\\n+    f = get_funcid('foo.py', code, 'f')\\n     t = UnifiedTransformer(\\n             filename='foo.py',\\n             type_annotations = {\\n@@ -1088,8 +1088,8 @@ def bar(x):\\n             pass\\n     \\\"\\\"\\\"))\\n \\n-    foo = get_funcinfo('foo.py', code, 'foo')\\n-    bar = get_funcinfo('foo.py', code, 'bar')\\n+    foo = get_funcid('foo.py', code, 'foo')\\n+    bar = get_funcid('foo.py', code, 'bar')\\n     t = UnifiedTransformer(\\n             filename='foo.py',\\n             type_annotations = {\\n@@ -1153,8 +1153,8 @@ def bar(x):\\n             pass\\n     \\\"\\\"\\\"))\\n \\n-    foo = get_funcinfo('foo.py', code, 'foo')\\n-    bar = get_funcinfo('foo.py', code, 'bar')\\n+    foo = get_funcid('foo.py', code, 'foo')\\n+    bar = get_funcid('foo.py', code, 'bar')\\n     t = UnifiedTransformer(\\n             filename='foo.py',\\n             type_annotations = {\\n@@ -1207,7 +1207,7 @@ def test_if_type_checking_insertion():\\n         def foo(x): ...\\n     \\\"\\\"\\\"))\\n \\n-    foo = get_funcinfo('foo.py', code, 'foo')\\n+    foo = get_funcid('foo.py', code, 'foo')\\n     t = UnifiedTransformer(\\n             filename='foo.py',\\n             type_annotations = {\\n@@ -1246,7 +1246,7 @@ def test_import_conflicts_with_import():\\n         def foo(x, y): ...\\n     \\\"\\\"\\\"))\\n \\n-    foo = get_funcinfo('foo.py', code, 'foo')\\n+    foo = get_funcid('foo.py', code, 'foo')\\n     t = UnifiedTransformer(\\n             filename='foo.py',\\n             type_annotations = {\\n@@ -1301,7 +1301,7 @@ def c(): pass\\n         def foo(x, y): ...\\n     \\\"\\\"\\\"))\\n \\n-    foo = get_funcinfo('foo.py', code, 'foo')\\n+    foo = get_funcid('foo.py', code, 'foo')\\n     t = UnifiedTransformer(\\n             filename='foo.py',\\n             type_annotations = {\\n@@ -1357,7 +1357,7 @@ def foo(x, y): ...\\n         c: int = 10\\n     \\\"\\\"\\\"))\\n \\n-    foo = get_funcinfo('foo.py', code, 'foo')\\n+    foo = get_funcid('foo.py', code, 'foo')\\n     t = UnifiedTransformer(\\n             filename='foo.py',\\n             type_annotations = {\\n@@ -1412,7 +1412,7 @@ def test_import_conflicts_with_with():\\n         def foo(x): ...\\n     \\\"\\\"\\\"))\\n \\n-    foo = get_funcinfo('foo.py', code, 'foo')\\n+    foo = get_funcid('foo.py', code, 'foo')\\n     t = UnifiedTransformer(\\n             filename='foo.py',\\n             type_annotations = {\\n@@ -1455,7 +1455,7 @@ def test_import_conflicts_alias_for_module():\\n         def foo(x): ...\\n     \\\"\\\"\\\"))\\n \\n-    foo = get_funcinfo('foo.py', code, 'foo')\\n+    foo = get_funcid('foo.py', code, 'foo')\\n     t = UnifiedTransformer(\\n             filename='foo.py',\\n             type_annotations = {\\n@@ -1505,7 +1505,7 @@ def f(self):\\n             pass\\n     \\\"\\\"\\\"))\\n \\n-    f = get_funcinfo('foo.py', code, 'C.f')\\n+    f = get_funcid('foo.py', code, 'C.f')\\n     t = UnifiedTransformer(\\n             filename='foo.py',\\n             type_annotations = {\\n@@ -1549,7 +1549,7 @@ def g(x):\\n                 pass\\n     \\\"\\\"\\\"))\\n \\n-    g = get_funcinfo('foo.py', code, 'C.f.<locals>.g')\\n+    g = get_funcid('foo.py', code, 'C.f.<locals>.g')\\n     t = UnifiedTransformer(\\n             filename='foo.py',\\n             type_annotations = {\\n@@ -1601,10 +1601,10 @@ def j(x):\\n                         pass\\n     \\\"\\\"\\\"))\\n \\n-    g = get_funcinfo('foo.py', code, 'C.f.<locals>.g')\\n-    h = get_funcinfo('foo.py', code, 'C.f.<locals>.g.<locals>.h')\\n-    i = get_funcinfo('foo.py', code, 'C.f.<locals>.D.i')\\n-    j = get_funcinfo('foo.py', code, 'C.f.<locals>.D.i.<locals>.j')\\n+    g = get_funcid('foo.py', code, 'C.f.<locals>.g')\\n+    h = get_funcid('foo.py', code, 'C.f.<locals>.g.<locals>.h')\\n+    i = get_funcid('foo.py', code, 'C.f.<locals>.D.i')\\n+    j = get_funcid('foo.py', code, 'C.f.<locals>.D.i.<locals>.j')\\n     tuple_int_float = TypeInfo.from_type(tuple, args=(\\n         TypeInfo.from_type(int, module=''),\\n         TypeInfo.from_type(float, module='')\\n@@ -1662,7 +1662,7 @@ def f(self):\\n             pass\\n     \\\"\\\"\\\"))\\n \\n-    f = get_funcinfo('foo.py', code, 'C.f')\\n+    f = get_funcid('foo.py', code, 'C.f')\\n     t = UnifiedTransformer(\\n             filename='foo.py',\\n             type_annotations = {\\n@@ -1772,7 +1772,7 @@ def add(a, b):\\n     \\\"\\\"\\\"))\\n \\n     T1 = make_typevar([str, int], 1)\\n-    f = get_funcinfo('foo.py', code, 'add')\\n+    f = get_funcid('foo.py', code, 'add')\\n     t = UnifiedTransformer(\\n             filename='foo.py',\\n             type_annotations = {\\n@@ -1806,7 +1806,7 @@ def add(a, b: int|str):\\n     \\\"\\\"\\\"))\\n \\n     T1 = make_typevar([str, int], 1)\\n-    f = get_funcinfo('foo.py', code, 'add')\\n+    f = get_funcid('foo.py', code, 'add')\\n     t = UnifiedTransformer(\\n             filename='foo.py',\\n             type_annotations = {\\n@@ -1846,7 +1846,7 @@ def add(a, b) -> int|str:\\n     \\\"\\\"\\\"))\\n \\n     T1 = make_typevar([str, int], 1)\\n-    f = get_funcinfo('foo.py', code, 'add')\\n+    f = get_funcid('foo.py', code, 'add')\\n     t = UnifiedTransformer(\\n             filename='foo.py',\\n             type_annotations = {\\n@@ -1885,7 +1885,7 @@ def add(a, b: bool):\\n     \\\"\\\"\\\"))\\n \\n     T1 = make_typevar([str, int], 1)\\n-    f = get_funcinfo('foo.py', code, 'add')\\n+    f = get_funcid('foo.py', code, 'add')\\n     t = UnifiedTransformer(\\n             filename='foo.py',\\n             type_annotations = {\\n@@ -1918,7 +1918,7 @@ def add[X: (int, bool)](a, b: X):\\n     \\\"\\\"\\\"))\\n \\n     T1 = make_typevar([str, int], 1)\\n-    f = get_funcinfo('foo.py', code, 'add')\\n+    f = get_funcid('foo.py', code, 'add')\\n     t = UnifiedTransformer(\\n             filename='foo.py',\\n             type_annotations = {\\n@@ -1951,7 +1951,7 @@ def foo(a, b, c, d):\\n \\n     T1 = make_typevar([int, str], 1)\\n     T2 = make_typevar([int, str], 2)\\n-    f = get_funcinfo('foo.py', code, 'foo')\\n+    f = get_funcid('foo.py', code, 'foo')\\n     t = UnifiedTransformer(\\n             filename='foo.py',\\n             type_annotations = {\\n@@ -1986,7 +1986,7 @@ def add(a, b):\\n     \\\"\\\"\\\"))\\n \\n     T1 = make_typevar([int, str], 1)\\n-    f = get_funcinfo('foo.py', code, 'add')\\n+    f = get_funcid('foo.py', code, 'add')\\n     t = UnifiedTransformer(\\n             filename='foo.py',\\n             type_annotations = {\\n@@ -2019,7 +2019,7 @@ def add(a, b):\\n     \\\"\\\"\\\"))\\n \\n     T1 = make_typevar([int, str], 1)\\n-    f = get_funcinfo('foo.py', code, 'add')\\n+    f = get_funcid('foo.py', code, 'add')\\n     t = UnifiedTransformer(\\n             filename='foo.py',\\n             type_annotations = {\\n\",\"diff --git a/.github/workflows/tests.yml b/.github/workflows/tests.yml\\nindex b9461dc..1b51cde 100644\\n--- a/.github/workflows/tests.yml\\n+++ b/.github/workflows/tests.yml\\n@@ -29,7 +29,7 @@ jobs:\\n     - name: install dependencies\\n       run: |\\n         python3 -m pip install pytest pytest-asyncio pytest-mock hypothesis ml_dtypes mypy\\n-        python3 -m pip install .\\n+        python3 -m pip install -e .\\n \\n     - name: run tests\\n       run: |\\n\",\"diff --git a/.github/workflows/tests.yml b/.github/workflows/tests.yml\\nindex 1b51cde..2c9a45a 100644\\n--- a/.github/workflows/tests.yml\\n+++ b/.github/workflows/tests.yml\\n@@ -28,8 +28,7 @@ jobs:\\n \\n     - name: install dependencies\\n       run: |\\n-        python3 -m pip install pytest pytest-asyncio pytest-mock hypothesis ml_dtypes mypy\\n-        python3 -m pip install -e .\\n+        python3 -m pip install -e '.[tests]'\\n \\n     - name: run tests\\n       run: |\\n\",\"diff --git a/.github/workflows/tests.yml b/.github/workflows/tests.yml\\nindex 2c9a45a..1b51cde 100644\\n--- a/.github/workflows/tests.yml\\n+++ b/.github/workflows/tests.yml\\n@@ -28,7 +28,8 @@ jobs:\\n \\n     - name: install dependencies\\n       run: |\\n-        python3 -m pip install -e '.[tests]'\\n+        python3 -m pip install pytest pytest-asyncio pytest-mock hypothesis ml_dtypes mypy\\n+        python3 -m pip install -e .\\n \\n     - name: run tests\\n       run: |\"]", "hints_text": ""}

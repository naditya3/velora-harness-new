{"instance_id": "735750642286906", "repo": "adtzlr/felupe", "base_commit": "92c01ece7742d2198f7701bbb83b7136e9bb43b7", "problem_statement": "Allow result of sparse-solver to be directly added to the field:\\n...without calling `field += np.split(dfield, field.offsets)`", "FAIL_TO_PASS": ["tests/test_field.py::test_3d_mixed", "tests/test_tools.py::test_newton_mixed"], "PASS_TO_PASS": ["tests/test_region.py::test_region", "tests/test_dof.py::test_mpc_mixed", "tests/test_bilinearform.py::test_form_decorator", "tests/test_form.py::test_axi", "tests/test_mechanics.py::test_solidbody", "tests/test_element.py::test_hex8", "tests/test_element.py::test_hex27", "tests/test_mechanics.py::test_solidbody_axi", "tests/test_math.py::test_math", "tests/test_constitution.py::test_kinematics", "tests/test_constitution.py::test_linear_planestrain", "tests/test_element.py::test_tet_mini", "tests/test_element.py::test_hex0", "tests/test_mesh.py::test_triangulate", "tests/test_element.py::test_tri_mini", "tests/test_tools.py::test_newton", "tests/test_element.py::test_tet4", "tests/test_element.py::test_line2", "tests/test_dof.py::test_mpc", "tests/test_form.py::test_bilinearform", "tests/test_element.py::test_quad0", "tests/test_quadrature.py::test_triangle", "tests/test_dof.py::test_boundary", "tests/test_element.py::test_tri3", "tests/test_constitution.py::test_nh", "tests/test_tools.py::test_newton_body", "tests/test_element.py::test_aol", "tests/test_quadrature.py::test_gausslegendre", "tests/test_form.py::test_bilinearform_broadcast", "tests/test_math.py::test_math_field", "tests/test_solve.py::test_solve", "tests/test_dof.py::test_loadcase", "tests/test_tools.py::test_newton_plane", "tests/test_element.py::test_hex20", "tests/test_form.py::test_linearform", "tests/test_tools.py::test_solve_mixed_check", "tests/test_field.py::test_3d", "tests/test_element.py::test_tri6", "tests/test_tools.py::test_newton_linearelastic", "tests/test_mechanics.py::test_simple", "tests/test_mesh.py::test_meshes", "tests/test_mechanics_tensor.py::test_solidbody_tensor", "tests/test_form.py::test_linearform_broadcast", "tests/test_constitution.py::test_linear", "tests/test_mesh.py::test_mirror", "tests/test_field.py::test_axi", "tests/test_element.py::test_quad4", "tests/test_quadrature.py::test_tetra", "tests/test_form.py::test_mixed", "tests/test_tools.py::test_newton_simple", "tests/test_mechanics.py::test_pressure", "tests/test_basis.py::test_basis", "tests/test_constitution.py::test_linear_planestress", "tests/test_quadrature.py::test_gausslegendre_boundary", "tests/test_mechanics.py::test_solidbody_mixed", "tests/test_element.py::test_tet10"], "language": "python", "test_command": "source /saved/ENV || source /saved/*/ENV && tox -- --no-header -rA --tb=no -p no:cacheprovider --continue-on-collection-errors", "test_output_parser": "python/parse_log_pytest_v3", "image_storage_uri": "vmvm-registry.fbinfra.net/repomate_image_activ_pytest/adtzlr_felupe:92c01ece7742d2198f7701bbb83b7136e9bb43b7", "patch": "[\"diff --git a/README.md b/README.md\\nindex a126fcc0..8f51ff50 100644\\n--- a/README.md\\n+++ b/README.md\\n@@ -55,10 +55,12 @@ All notable changes to this project will be documented in this file. The format\\n - Add `SolidBodyTensor` for tensor-based material definitions with state variables.\\n - Add `bodies` argument to `newtonrhapson()`.\\n - Add a container class for fields, `FieldContainer` (renamed from `FieldMixed`).\\n+- Add `len(field)` method for `FieldContainer` (length = number of fields).\\n \\n ### Changed\\n - Unify handling of `Field` and `FieldMixed`.\\n - Constitutive models use lists as in- and output (consistency between single- and mixed-formulations).\\n+- Allow field updates directly from 1d sparse-solved vector without splitted by field-offsets.\\n \\n ### Fixed\\n - Fix `tovoigt()` helper for data with more or less than two trailing axes and 2D tensors.\\n\",\"diff --git a/docs/howto/composite.rst b/docs/howto/composite.rst\\nindex 527ad644..e804be0c 100644\\n--- a/docs/howto/composite.rst\\n+++ b/docs/howto/composite.rst\\n@@ -51,9 +51,7 @@ The displacement boundaries are created on the total field.\\n \\n ..  code-block:: python\\n \\n-    boundaries, dof0, dof1, ext0 = fe.dof.uniaxial(\\n-        field, move=-0.25\\n-    )\\n+    boundaries, dof0, dof1, ext0 = fe.dof.uniaxial(field, move=-0.25)\\n \\n \\n The rubber is associated to a Neo-Hookean material formulation whereas the steel is modeled by a linear elastic material formulation. For each material a solid body is created.\\n@@ -80,14 +78,14 @@ Inside the Newton-Rhapson iterations both the internal force vector and the tang\\n         K+= steel.assemble.matrix()\\n \\n         system = fe.solve.partition(field, K, dof1, dof0, r)\\n-        dfield = np.split(fe.solve.solve(*system, ext0), field.offsets)\\n+        dfield = fe.solve.solve(*system, ext0)\\n \\n         field += dfield\\n         \\n         r = rubber.assemble.vector(field_rubber)\\n         r+= steel.assemble.vector(field_steel)\\n \\n-        norm = fe.math.norm(dfield[0])\\n+        norm = fe.math.norm(dfield)\\n         print(iteration, norm)\\n \\n         if norm < 1e-12:\\n\",\"diff --git a/docs/tutorial/beam.rst b/docs/tutorial/beam.rst\\nindex 77835aef..7af7c56c 100644\\n--- a/docs/tutorial/beam.rst\\n+++ b/docs/tutorial/beam.rst\\n@@ -81,7 +81,7 @@ The linear equation system may now be solved. First, a partition into active and\\n ..  code-block:: python\\n \\n     system = fe.solve.partition(field, stiffness, dof1, dof0, r=-bodyforce)\\n-    field += np.split(fe.solve.solve(*system), field.offsets)\\n+    field += fe.solve.solve(*system)\\n \\n     fe.save(region, field, filename=\\\"bodyforce.vtk\\\")\\n \\n\",\"diff --git a/docs/tutorial/gettingstarted.rst b/docs/tutorial/gettingstarted.rst\\nindex af44fcd3..d985be72 100644\\n--- a/docs/tutorial/gettingstarted.rst\\n+++ b/docs/tutorial/gettingstarted.rst\\n@@ -65,7 +65,7 @@ In a second step fields may be added to the Region which may be either scalar or\\n     dudX = displacement.grad()\\n \\n \\n-Next, the field is added to a field container. The deformation gradient is obtained by a sum of the identity and the displacement gradient.\\n+Next, the field is added to a field container, which handles one or several (vector) fields. Like a field, the field container also provides the ``extract(grad=True, add_identity=True, sym=False)`` method, returning a list of interpolated field values or gradients. E.g., the deformation gradient is obtained by a sum of the identity and the displacement gradient.\\n \\n ..  code-block:: python\\n \\n@@ -106,7 +106,7 @@ The material behavior has to be provided by the first Piola-Kirchhoff stress ten\\n Boundary Conditions\\n ~~~~~~~~~~~~~~~~~~~\\n \\n-Next we enforce boundary conditions on the displacement field. Boundary conditions are stored as a dictionary of multiple boundary instances. First, the left end of the cube is fixed. Displacements on the right end are fixed in directions y and z whereas displacements in direction x are prescribed with a user-defined value. A boundary instance hold useful attributes like ``points`` or ``dof``.\\n+Next we enforce boundary conditions on the displacement field. Boundaries are stored as a dictionary of multiple boundary instances. First, the left end of the cube is fixed. Displacements on the right end are fixed in directions y and z whereas displacements in direction x are prescribed with a user-defined value. A boundary instance hold useful attributes like ``points`` or ``dof``.\\n \\n ..  code-block:: python\\n     \\n@@ -147,7 +147,7 @@ The integral (or weak) forms of equilibrium equations are defined by the :class:\\n     bilinearform = felupe.IntegralForm(A(F), field, dV, u=field, grad_v=[True], grad_u=[True])\\n \\n \\n-Assembly of both forms lead to the (point-based) internal forces and the (sparse) stiffness matrix.\\n+The assembly of both forms lead to the (point-based) internal force vector and the (sparse) stiffness matrix.\\n \\n ..  code-block:: python\\n \\n@@ -183,7 +183,7 @@ The default solver of FElupe is `SuperLU <https://docs.scipy.org/doc/scipy/refer\\n     # from pypardiso import spsolve\\n \\n     system = felupe.solve.partition(field, K, dof1, dof0, r)\\n-    dfield = felupe.solve.solve(*system, ext0, solver=spsolve).reshape(*u.shape)\\n+    dfield = felupe.solve.solve(*system, ext0, solver=spsolve)#.reshape(*u.shape)\\n     # field += dfield\\n \\n \\n@@ -201,9 +201,9 @@ A very simple newton-rhapson code looks like this:\\n         K = bilinearform.assemble()\\n \\n         system = felupe.solve.partition(field, K, dof1, dof0, r)\\n-        dfield = np.split(felupe.solve.solve(*system, ext0, solver=spsolve), field.offsets)\\n+        dfield = felupe.solve.solve(*system, ext0, solver=spsolve)\\n \\n-        norm = np.linalg.norm(dfield[0])\\n+        norm = np.linalg.norm(dfield)\\n         print(iteration, norm)\\n         field += dfield\\n \\n\",\"diff --git a/docs/tutorial/hellofelupe.rst b/docs/tutorial/hellofelupe.rst\\nindex 66fc2109..fa234803 100644\\n--- a/docs/tutorial/hellofelupe.rst\\n+++ b/docs/tutorial/hellofelupe.rst\\n@@ -25,7 +25,7 @@ A quarter model of a solid cube with hyperelastic material behavior is subjected\\n    :width: 400px\\n \\n \\n-First, let's import FElupe and create a meshed cube out of hexahedron cells with ``n=11`` points per axis. A numeric region created on the mesh represents our solid body. A vector-valued displacement field is initiated on the region.\\n+First, let's import FElupe and create a meshed cube out of hexahedron cells with ``n=11`` points per axis. A numeric region created on the mesh represents our solid body. A vector-valued displacement field is initiated on the region. Next, a field container is created on top of the displacement field.\\n \\n ..  code-block:: python\\n \\n@@ -36,23 +36,24 @@ First, let's import FElupe and create a meshed cube out of hexahedron cells with\\n     displacement = fe.Field(region, dim=3)\\n     field = fe.FieldContainer([displacement])\\n \\n-A uniaxial loadcase is applied on the displacement field. This involves setting up symmetry planes as well as the absolute value of the prescribed displacement at the mesh-points on the right-end face of the cube. The right-end face is clamped: only displacements in direction x are allowed.\\n+A uniaxial loadcase is applied on the displacement field stored inside the field container. This involves setting up symmetry planes as well as the absolute value of the prescribed displacement at the mesh-points on the right-end face of the cube. The right-end face is clamped: only displacements in direction x are allowed.\\n \\n ..  code-block:: python\\n \\n     boundaries, dof0, dof1, ext0 = fe.dof.uniaxial(field, move=0.2, clamped=True)\\n \\n-The material behavior is defined through a built-in Neo-Hookean material formulation.\\n+The material behavior is defined through a built-in Neo-Hookean material formulation. The  constitutive isotropic hyperelastic material formulation is applied on the displacement field by the definition of a solid body.\\n \\n ..  code-block:: python\\n \\n     umat = fe.NeoHooke(mu=1.0, bulk=2.0)\\n+    body = fe.SolidBody(umat=umat, field=field)\\n \\n Inside a Newton-Rhapson procedure, the internal force vector and the tangent stiffness matrix are generated by assembling both linear and bilinear forms of static equilibrium. Finally, the solution of the incremental displacements is calculated und updated until convergence is reached.\\n \\n ..  code-block:: python\\n \\n-    res = fe.newtonrhapson(field, umat=umat, dof1=dof1, dof0=dof0, ext0=ext0)\\n+    res = fe.newtonrhapson(field, bodies=[body], dof1=dof1, dof0=dof0, ext0=ext0)\\n \\n Results are saved as VTK-files.\\n     \\n\",\"diff --git a/docs/tutorial/platewithhole.rst b/docs/tutorial/platewithhole.rst\\nindex e4aa2680..02c4edf2 100644\\n--- a/docs/tutorial/platewithhole.rst\\n+++ b/docs/tutorial/platewithhole.rst\\n@@ -97,7 +97,7 @@ The linear equation system may now be solved. First, a partition into active and\\n ..  code-block:: python\\n \\n     system = fe.solve.partition(field, K, dof1, dof0)\\n-    field += np.split(fe.solve.solve(*system, ext0), field.offsets)\\n+    field += fe.solve.solve(*system, ext0)\\n \\n Let's evaluate the deformation gradient from the displacement field and calculate the stress tensor. This process is also called *stress recovery*.\\n \\n\",\"diff --git a/docs/tutorial/shear.rst b/docs/tutorial/shear.rst\\nindex 53d9b28c..ea3afa21 100644\\n--- a/docs/tutorial/shear.rst\\n+++ b/docs/tutorial/shear.rst\\n@@ -26,9 +26,7 @@ shear stress as a function of ?\\n \\n \\n Let's create the mesh. An additional center-point is created for a multi-point\\n-constraint (MPC). By default, FElupe stores points not connected to any cells in\\n-:attr:`Mesh.points_without_cells` and adds them to the list of inactive\\n-degrees of freedom. Hence, we have to drop our MPC-centerpoint from that list.\\n+constraint (MPC).\\n \\n ..  code-block:: python\\n \\n@@ -45,7 +43,6 @@ degrees of freedom. Hence, we have to drop our MPC-centerpoint from that list.\\n     mesh = fe.Rectangle((0, 0), (L, H), n=(round(L / a), round(H / a)))\\n     mesh.points = np.vstack((mesh.points, [0, 2 * H]))\\n     mesh.update(mesh.cells)\\n-    mesh.points_without_cells = np.array([], dtype=bool)\\n \\n .. image:: images/shear_mesh.png\\n    :width: 400px\\n@@ -65,7 +62,7 @@ as well as the absolute value of the prescribed shear movement in direction\\n     displacement = fe.Field(region, dim=2)\\n     pressure     = fe.Field(region)\\n     volumeratio  = fe.Field(region, values=1)\\n-    fields       = fe.FieldMixed((displacement, pressure, volumeratio))\\n+    fields       = fe.FieldContainer([displacement, pressure, volumeratio])\\n     \\n     f0 = lambda y: np.isclose(y, 0)\\n     f2 = lambda y: np.isclose(y, 2* H)\\n@@ -76,7 +73,7 @@ as well as the absolute value of the prescribed shear movement in direction\\n     }\\n     \\n     dof0, dof1 = fe.dof.partition(fields, boundaries)\\n-    ext0 = fe.dof.apply(displacement, boundaries, dof0)\\n+    ext0 = fe.dof.apply(fields, boundaries, dof0)\\n \\n \\n The micro-sphere material formulation is used for the rubber. It is defined\\n@@ -87,7 +84,7 @@ install matADi with ``pip install matadi`` first).\\n \\n     import matadi as mat\\n \\n-    umat = fe.MatadiMaterial(\\n+    umat = mat.ThreeFieldVariationPlaneStrain(\\n         mat.MaterialHyperelasticPlaneStrain(\\n             mat.models.miehe_goektepe_lulei, \\n             mu=0.1475, \\n@@ -132,24 +129,24 @@ of the top plate are saved.\\n     for move in UX[1:]:\\n         \\n         boundaries[\\\"control\\\"].value = move\\n-        ext0 = fe.dof.apply(displacement, boundaries, dof0)\\n+        ext0 = fe.dof.apply(fields, boundaries, dof0)\\n     \\n         for iteration in range(8):\\n         \\n-            r_int = fe.IntegralFormMixed(\\n-                fun=umat.gradient(*fields.extract()),\\n+            r_int = fe.IntegralForm(\\n+                fun=umat.gradient(fields.extract()),\\n                 v=fields,\\n                 dV=region.dV,\\n             ).assemble(parallel=True).toarray()\\n             \\n-            r_MPC = MPC.residuals(fields[0])\\n+            r_MPC = MPC.residuals(fields)\\n             r_MPC.resize(r_int.shape)\\n             r_MPC = r_MPC.toarray()\\n         \\n             r = r_int + r_MPC\\n             \\n-            K = fe.IntegralFormMixed(\\n-                fun=umat.hessian(*fields.extract()),\\n+            K = fe.IntegralForm(\\n+                fun=umat.hessian(fields.extract()),\\n                 v=fields,\\n                 dV=region.dV,\\n                 u=fields,\\n@@ -159,7 +156,7 @@ of the top plate are saved.\\n             K += K_MPC\\n         \\n             system = fe.solve.partition(fields, K, dof1, dof0, r)\\n-            fields += np.split(fe.solve.solve(*system, ext0), fields.offsets)\\n+            fields += fe.solve.solve(*system, ext0)\\n             \\n             if iteration > 0:\\n                 \\n\",\"diff --git a/felupe/__init__.py b/felupe/__init__.py\\nindex 88a0bac0..287b142e 100644\\n--- a/felupe/__init__.py\\n+++ b/felupe/__init__.py\\n@@ -30,9 +30,9 @@\\n     RegionLagrange,\\n )\\n from ._assembly import (\\n-    #IntegralForm,\\n+    # IntegralForm,\\n     IntegralFormMixed as IntegralForm,\\n-    #IntegralFormAxisymmetric,\\n+    # IntegralFormAxisymmetric,\\n     # LinearForm,\\n     # BilinearForm,\\n     # LinearFormMixed as LinearForm,\\n@@ -41,7 +41,7 @@\\n     Form,\\n )\\n from ._basis import (\\n-     BasisMixed as Basis,\\n+    BasisMixed as Basis,\\n )\\n from ._field import (\\n     Field,\\n\",\"diff --git a/felupe/_field/_container.py b/felupe/_field/_container.py\\nindex 52b148c5..f0ed8b34 100644\\n--- a/felupe/_field/_container.py\\n+++ b/felupe/_field/_container.py\\n@@ -30,7 +30,7 @@\\n \\n \\n class FieldContainer:\\n-    \\\"\\\"\\\"A container for fields based on a list or tuple of :class:`Field` \\n+    \\\"\\\"\\\"A container for fields based on a list or tuple of :class:`Field`\\n     instances.\\\"\\\"\\\"\\n \\n     def __init__(self, fields):\\n@@ -40,7 +40,7 @@ def __init__(self, fields):\\n \\n         # get field values\\n         self.values = tuple(f.values for f in self.fields)\\n-        \\n+\\n         # get sizes of fields and calculate offsets\\n         self.fieldsizes = [f.indices.dof.size for f in self.fields]\\n         self.offsets = np.cumsum(self.fieldsizes)[:-1]\\n@@ -82,6 +82,8 @@ def copy(self):\\n \\n     def __add__(self, newvalues):\\n         fields = deepcopy(self)\\n+        if len(newvalues) != len(self.fields):\\n+            newvalues = np.split(newvalues, self.offsets)\\n \\n         for field, dfield in zip(fields, newvalues):\\n             field += dfield\\n@@ -90,6 +92,8 @@ def __add__(self, newvalues):\\n \\n     def __sub__(self, newvalues):\\n         fields = deepcopy(self)\\n+        if len(newvalues) != len(self.fields):\\n+            newvalues = np.split(newvalues, self.offsets)\\n \\n         for field, dfield in zip(fields, newvalues):\\n             field -= dfield\\n@@ -98,6 +102,8 @@ def __sub__(self, newvalues):\\n \\n     def __mul__(self, newvalues):\\n         fields = deepcopy(self)\\n+        if len(newvalues) != len(self.fields):\\n+            newvalues = np.split(newvalues, self.offsets)\\n \\n         for field, dfield in zip(fields, newvalues):\\n             field *= dfield\\n@@ -106,6 +112,8 @@ def __mul__(self, newvalues):\\n \\n     def __truediv__(self, newvalues):\\n         fields = deepcopy(self)\\n+        if len(newvalues) != len(self.fields):\\n+            newvalues = np.split(newvalues, self.offsets)\\n \\n         for field, dfield in zip(fields, newvalues):\\n             field /= dfield\\n@@ -113,21 +121,29 @@ def __truediv__(self, newvalues):\\n         return fields\\n \\n     def __iadd__(self, newvalues):\\n+        if len(newvalues) != len(self.fields):\\n+            newvalues = np.split(newvalues, self.offsets)\\n         for field, dfield in zip(self.fields, newvalues):\\n             field += dfield\\n         return self\\n \\n     def __isub__(self, newvalues):\\n+        if len(newvalues) != len(self.fields):\\n+            newvalues = np.split(newvalues, self.offsets)\\n         for field, dfield in zip(self.fields, newvalues):\\n             field -= dfield\\n         return self\\n \\n     def __imul__(self, newvalues):\\n+        if len(newvalues) != len(self.fields):\\n+            newvalues = np.split(newvalues, self.offsets)\\n         for field, dfield in zip(self.fields, newvalues):\\n             field *= dfield\\n         return self\\n \\n     def __itruediv__(self, newvalues):\\n+        if len(newvalues) != len(self.fields):\\n+            newvalues = np.split(newvalues, self.offsets)\\n         for field, dfield in zip(self.fields, newvalues):\\n             field /= dfield\\n         return self\\n@@ -136,3 +152,8 @@ def __getitem__(self, idx):\\n         \\\"Slice-based access to underlying fields.\\\"\\n \\n         return self.fields[idx]\\n+\\n+    def __len__(self):\\n+        \\\"Number of fields inside the container.\\\"\\n+\\n+        return len(self.fields)\\n\",\"diff --git a/felupe/constitution/_kinematics.py b/felupe/constitution/_kinematics.py\\nindex 41292bfa..9c5e2818 100644\\n--- a/felupe/constitution/_kinematics.py\\n+++ b/felupe/constitution/_kinematics.py\\n@@ -92,7 +92,7 @@ def gradient(self, extract, parallel=None):\\n         ndarray\\n             Gradient of line change\\n         \\\"\\\"\\\"\\n-        \\n+\\n         F = extract[0]\\n \\n         if parallel is None:\\n@@ -136,7 +136,7 @@ def function(self, extract, N=None, parallel=None):\\n         ndarray\\n             Cofactor matrix of the deformation gradient\\n         \\\"\\\"\\\"\\n-        \\n+\\n         F = extract[0]\\n         J = det(F)\\n \\n@@ -257,7 +257,7 @@ def hessian(self, extract, parallel=None):\\n         ndarray\\n             Hessian of the determinant of the deformation gradient\\n         \\\"\\\"\\\"\\n-        \\n+\\n         F = extract[0]\\n \\n         if parallel is None:\\n@@ -265,6 +265,10 @@ def hessian(self, extract, parallel=None):\\n \\n         J = self.function([F])[0]\\n         dJdF = self.gradient([F])[0]\\n-        return [(\\n-            dya(dJdF, dJdF, parallel=parallel) - cdya_il(dJdF, dJdF, parallel=parallel)\\n-        ) / J]\\n+        return [\\n+            (\\n+                dya(dJdF, dJdF, parallel=parallel)\\n+                - cdya_il(dJdF, dJdF, parallel=parallel)\\n+            )\\n+            / J\\n+        ]\\n\",\"diff --git a/felupe/constitution/_mixed.py b/felupe/constitution/_mixed.py\\nindex d461044a..bde7c74e 100644\\n--- a/felupe/constitution/_mixed.py\\n+++ b/felupe/constitution/_mixed.py\\n@@ -265,9 +265,9 @@ def gradient(self, extract):\\n             List of gradients w.r.t. the input variables F, p and J\\n \\n         \\\"\\\"\\\"\\n-        \\n+\\n         F, p, J = extract\\n-        \\n+\\n         self.detF = det(F)\\n         self.iFT = transpose(inv(F))\\n         self.Fb = (J / self.detF) ** (1 / 3) * F\\n@@ -315,9 +315,9 @@ def hessian(self, extract):\\n             List of hessians in upper triangle order\\n \\n         \\\"\\\"\\\"\\n-        \\n+\\n         F, p, J = extract\\n-        \\n+\\n         self.detF = det(F)\\n         self.iFT = transpose(inv(F))\\n         self.Fb = (J / self.detF) ** (1 / 3) * F\\n\",\"diff --git a/felupe/constitution/_models.py b/felupe/constitution/_models.py\\nindex 013250af..8ce17528 100644\\n--- a/felupe/constitution/_models.py\\n+++ b/felupe/constitution/_models.py\\n@@ -114,7 +114,7 @@ def gradient(self, extract, E=None, nu=None):\\n             Stress tensor (3x3)\\n \\n         \\\"\\\"\\\"\\n-        \\n+\\n         F = extract[0]\\n \\n         if E is None:\\n@@ -147,7 +147,7 @@ def hessian(self, extract=None, E=None, nu=None, shape=(1, 1), region=None):\\n         Arguments\\n         ---------\\n         extract : list of ndarray, optional\\n-            List with Deformation gradient ``F`` (3x3) as first item \\n+            List with Deformation gradient ``F`` (3x3) as first item\\n             (default is None)\\n         E : float, optional\\n             Young's modulus (default is None)\\n@@ -164,7 +164,6 @@ def hessian(self, extract=None, E=None, nu=None, shape=(1, 1), region=None):\\n             elasticity tensor (3x3x3x3)\\n \\n         \\\"\\\"\\\"\\n-        \\n \\n         if extract is None:\\n             if region is not None:\\n@@ -256,7 +255,7 @@ def gradient(self, extract=None, E=None, nu=None):\\n             Stress tensor (3x3)\\n \\n         \\\"\\\"\\\"\\n-        \\n+\\n         F = extract[0]\\n \\n         if E is None:\\n@@ -299,7 +298,6 @@ def hessian(self, extract=None, E=None, nu=None, shape=(1, 1), region=None):\\n \\n         \\\"\\\"\\\"\\n \\n-\\n         if E is None:\\n             E = self.E\\n \\n@@ -406,7 +404,7 @@ def gradient(self, extract, E=None, nu=None):\\n         Arguments\\n         ---------\\n         extract : list of ndarray\\n-            List with In-plane components (2x2) of the Deformation gradient \\n+            List with In-plane components (2x2) of the Deformation gradient\\n             ``F``as first item\\n         E : float, optional\\n             Young's modulus (default is None)\\n@@ -433,7 +431,7 @@ def hessian(self, extract, E=None, nu=None):\\n         Arguments\\n         ---------\\n         extract : list of ndarray\\n-            List with In-plane components (2x2) of the Deformation gradient \\n+            List with In-plane components (2x2) of the Deformation gradient\\n             ``F``as first item\\n         E : float, optional\\n             Young's modulus (default is None)\\n@@ -461,7 +459,7 @@ def strain(self, extract, E=None, nu=None):\\n         Arguments\\n         ---------\\n         extract : list of ndarray\\n-            List with In-plane components (2x2) of the Deformation gradient \\n+            List with In-plane components (2x2) of the Deformation gradient\\n             ``F``as first item\\n         E : float, optional\\n             Young's modulus (default is None)\\n@@ -473,7 +471,7 @@ def strain(self, extract, E=None, nu=None):\\n         e : ndarray\\n             Strain tensor (3x3)\\n         \\\"\\\"\\\"\\n-        \\n+\\n         F = extract[0]\\n \\n         e = np.zeros((3, 3, *F.shape[-2:]))\\n@@ -491,7 +489,7 @@ def stress(self, extract, E=None, nu=None):\\n         Arguments\\n         ---------\\n         extract : list of ndarray\\n-            List with In-plane components (2x2) of the Deformation gradient \\n+            List with In-plane components (2x2) of the Deformation gradient\\n             ``F``as first item\\n         E : float, optional\\n             Young's modulus (default is None)\\n@@ -504,7 +502,7 @@ def stress(self, extract, E=None, nu=None):\\n             Stress tensor (3x3)\\n \\n         \\\"\\\"\\\"\\n-        \\n+\\n         F = extract[0]\\n \\n         if E is None:\\n@@ -544,7 +542,7 @@ def gradient(self, extract, E=None, nu=None):\\n         Arguments\\n         ---------\\n         extract : list of ndarray\\n-            List with In-plane components (2x2) of the Deformation gradient \\n+            List with In-plane components (2x2) of the Deformation gradient\\n             ``F``as first item\\n         E : float, optional\\n             Young's modulus (default is None)\\n@@ -557,9 +555,9 @@ def gradient(self, extract, E=None, nu=None):\\n             In-plane components of stress tensor (2x2)\\n \\n         \\\"\\\"\\\"\\n-        \\n+\\n         F = extract[0]\\n-        \\n+\\n         if E is None:\\n             E = self.E\\n \\n@@ -581,7 +579,7 @@ def hessian(self, extract=None, E=None, nu=None, shape=(1, 1), region=None):\\n         Arguments\\n         ---------\\n         extract : list of ndarray, optional\\n-            List with In-plane components (2x2) of the Deformation gradient \\n+            List with In-plane components (2x2) of the Deformation gradient\\n             ``F``as first item (default is None)\\n         E : float, optional\\n             Young's  modulus (default is None)\\n@@ -632,7 +630,7 @@ def strain(self, extract, E=None, nu=None):\\n         Arguments\\n         ---------\\n         extract : list of ndarray\\n-            List with In-plane components (2x2) of the Deformation gradient \\n+            List with In-plane components (2x2) of the Deformation gradient\\n             ``F``as first item\\n         E : float, optional\\n             Young's modulus (default is None)\\n@@ -644,7 +642,7 @@ def strain(self, extract, E=None, nu=None):\\n         e : ndarray\\n             Strain tensor (3x3)\\n         \\\"\\\"\\\"\\n-        \\n+\\n         F = extract[0]\\n \\n         if E is None:\\n@@ -669,7 +667,7 @@ def stress(self, extract, E=None, nu=None):\\n         Arguments\\n         ---------\\n         extract : list of ndarray\\n-            List with In-plane components (2x2) of the Deformation gradient \\n+            List with In-plane components (2x2) of the Deformation gradient\\n             ``F``as first item\\n         E : float, optional\\n             Young's modulus (default is None)\\n@@ -682,10 +680,12 @@ def stress(self, extract, E=None, nu=None):\\n             Stress tensor (3x3)\\n \\n         \\\"\\\"\\\"\\n-        \\n+\\n         F = extract[0]\\n-        \\n-        return [np.pad(self.gradient(F, E=E, nu=nu)[0], ((0, 1), (0, 1), (0, 0), (0, 0)))]\\n+\\n+        return [\\n+            np.pad(self.gradient(F, E=E, nu=nu)[0], ((0, 1), (0, 1), (0, 0), (0, 0)))\\n+        ]\\n \\n \\n class NeoHooke:\\n@@ -826,7 +826,7 @@ def function(self, extract, mu=None, bulk=None):\\n         bulk : float, optional\\n             Bulk modulus (default is None)\\n         \\\"\\\"\\\"\\n-        \\n+\\n         F = extract[0]\\n \\n         if mu is None:\\n@@ -855,7 +855,7 @@ def gradient(self, extract, mu=None, bulk=None):\\n         bulk : float, optional\\n             Bulk modulus (default is None)\\n         \\\"\\\"\\\"\\n-        \\n+\\n         F = extract[0]\\n \\n         if mu is None:\\n@@ -885,7 +885,7 @@ def hessian(self, extract, mu=None, bulk=None):\\n         bulk : float, optional\\n             Bulk modulus (default is None)\\n         \\\"\\\"\\\"\\n-        \\n+\\n         F = extract[0]\\n \\n         if mu is None:\\n\",\"diff --git a/felupe/dof/_multipoint.py b/felupe/dof/_multipoint.py\\nindex af307f09..85365a0f 100644\\n--- a/felupe/dof/_multipoint.py\\n+++ b/felupe/dof/_multipoint.py\\n@@ -68,7 +68,9 @@ def residuals(self, field):\\n         c = self.centerpoint\\n         for t in self.points:\\n             for d in self.axes:\\n-                N = self.multiplier * (-field.fields[0].values[t, d] + field.fields[0].values[c, d])\\n+                N = self.multiplier * (\\n+                    -field.fields[0].values[t, d] + field.fields[0].values[c, d]\\n+                )\\n                 r[t, d] = -N\\n                 r[c, d] += N\\n         return sparse.COO(r).reshape((-1, 1)).tocsr()\\n\",\"diff --git a/felupe/math/_field.py b/felupe/math/_field.py\\nindex 1c459da3..99a3c13e 100644\\n--- a/felupe/math/_field.py\\n+++ b/felupe/math/_field.py\\n@@ -43,7 +43,7 @@ def extract(field, grad=True, sym=False, add_identity=True):\\n \\n def values(field):\\n     \\\"Return values of a field or a tuple of fields.\\\"\\n-    \\n+\\n     return np.concatenate([f.values.ravel() for f in field.fields])\\n \\n \\n\",\"diff --git a/felupe/mechanics/_solidbody_pressure.py b/felupe/mechanics/_solidbody_pressure.py\\nindex 0cb5fb54..5da283fc 100644\\n--- a/felupe/mechanics/_solidbody_pressure.py\\n+++ b/felupe/mechanics/_solidbody_pressure.py\\n@@ -42,9 +42,9 @@ def __init__(self, field, pressure=None):\\n         self.results = Results()\\n         self.results.kinematics = self._extract(self.field)\\n         self.results.pressure = pressure\\n-        \\n+\\n         self.assemble = Assemble(vector=self._vector, matrix=self._matrix)\\n-        \\n+\\n         self._area_change = AreaChange()\\n \\n     def _extract(self, field):\\n@@ -68,7 +68,7 @@ def _vector(\\n             self._normals,\\n             parallel=parallel,\\n         )\\n-        \\n+\\n         if pressure is not None:\\n             self.results.pressure = pressure\\n             fun[0] *= self.results.pressure\\n@@ -90,17 +90,17 @@ def _matrix(\\n \\n             self.update(field)\\n             self.results.kinematics = self._extract(self.field)\\n-        \\n+\\n         fun = self._area_change.gradient(\\n             self.results.kinematics,\\n             self._normals,\\n             parallel=parallel,\\n         )\\n-        \\n+\\n         if pressure is not None:\\n             self.results.pressure = pressure\\n             fun[0] *= self.results.pressure\\n-            \\n+\\n         self.results.stiffness = IntegralFormMixed(\\n             fun=fun,\\n             v=self.field,\\n\",\"diff --git a/felupe/tools/_newton.py b/felupe/tools/_newton.py\\nindex d5c552fe..4881fb43 100644\\n--- a/felupe/tools/_newton.py\\n+++ b/felupe/tools/_newton.py\\n@@ -99,11 +99,15 @@ def jac_bodies(bodies, parallel=False, jit=False):\\n def fun(x, umat, parallel=False, jit=False, grad=True, add_identity=True, sym=False):\\n     \\\"Force residuals from assembly of equilibrium (weak form).\\\"\\n \\n-    return IntegralFormMixed(\\n-        fun=umat.gradient(x.extract(grad=grad, add_identity=add_identity, sym=sym)),\\n-        v=x,\\n-        dV=x.region.dV,\\n-    ).assemble(parallel=parallel, jit=jit).toarray()[:, 0]\\n+    return (\\n+        IntegralFormMixed(\\n+            fun=umat.gradient(x.extract(grad=grad, add_identity=add_identity, sym=sym)),\\n+            v=x,\\n+            dV=x.region.dV,\\n+        )\\n+        .assemble(parallel=parallel, jit=jit)\\n+        .toarray()[:, 0]\\n+    )\\n \\n \\n def jac(x, umat, parallel=False, jit=False, grad=True, add_identity=True, sym=False):\\n@@ -123,7 +127,7 @@ def solve(A, b, x, dof1, dof0, offsets=None, ext0=None, solver=spsolve):\\n     system = fesolve.partition(x, A, dof1, dof0, -b)\\n     dx = fesolve.solve(*system, ext0, solver=solver)\\n \\n-    return np.split(dx, offsets)\\n+    return dx\\n \\n \\n def check(dx, x, f, tol):\\n@@ -222,13 +226,8 @@ def newtonrhapson(\\n         # solve linear system and update solution\\n         sig = inspect.signature(solve)\\n \\n-        try:\\n-            offsets = x.offsets\\n-        except:\\n-            offsets = []\\n-        \\n-        keys = [\\\"x\\\", \\\"dof1\\\", \\\"dof0\\\", \\\"offsets\\\", \\\"ext0\\\", \\\"solver\\\"]\\n-        values = [x, dof1, dof0, offsets, ext0, solver]\\n+        keys = [\\\"x\\\", \\\"dof1\\\", \\\"dof0\\\", \\\"ext0\\\", \\\"solver\\\"]\\n+        values = [x, dof1, dof0, ext0, solver]\\n \\n         for key, value in zip(keys, values):\\n \\n\",\"diff --git a/felupe/tools/_post.py b/felupe/tools/_post.py\\nindex 71ee69c3..779e1611 100644\\n--- a/felupe/tools/_post.py\\n+++ b/felupe/tools/_post.py\\n@@ -33,9 +33,9 @@\\n def force(field, r, boundary, offsets=[]):\\n     if issparse(r):\\n         r = r.toarray()\\n-    return (\\n-        ((np.split(r, offsets)[0]).reshape(-1, field[0].dim))[boundary.points]\\n-    ).sum(0)\\n+    return (((np.split(r, offsets)[0]).reshape(-1, field[0].dim))[boundary.points]).sum(\\n+        0\\n+    )\\n \\n \\n def moment(field, r, boundary, point=np.zeros(3), offsets=[]):\\n\",\"diff --git a/felupe/tools/_save.py b/felupe/tools/_save.py\\nindex 8e5d3abf..fab0833b 100644\\n--- a/felupe/tools/_save.py\\n+++ b/felupe/tools/_save.py\\n@@ -44,7 +44,7 @@ def save(\\n \\n     u = fields.fields[0]\\n     mesh = region.mesh\\n-    \\n+\\n     offsets = fields.offsets\\n \\n     if point_data is None:\\n\"]", "test_patch": "[\"diff --git a/tests/test_field.py b/tests/test_field.py\\nindex 0a293474..ec3b5ecf 100644\\n--- a/tests/test_field.py\\n+++ b/tests/test_field.py\\n@@ -173,6 +173,18 @@ def test_3d_mixed():\\n     f -= df\\n     f *= df\\n     f /= df\\n+    \\n+    df_1d = np.concatenate([dfi.ravel() for dfi in df])\\n+    \\n+    f + df_1d\\n+    f - df_1d\\n+    f * df_1d\\n+    f / df_1d\\n+\\n+    f += df_1d\\n+    f -= df_1d\\n+    f *= df_1d\\n+    f /= df_1d\\n \\n     v = u.copy()\\n     g = f.copy()\\n\",\"diff --git a/tests/test_tools.py b/tests/test_tools.py\\nindex dbef4e38..d1053c62 100644\\n--- a/tests/test_tools.py\\n+++ b/tests/test_tools.py\\n@@ -282,6 +282,8 @@ def test_newton_mixed():\\n     p = fe.Field(region0)\\n     J = fe.Field(region0, values=1)\\n     field = fe.FieldContainer((u, p, J))\\n+    \\n+    assert len(field) == 3\\n \\n     boundaries, dof0, dof1, ext0 = fe.dof.uniaxial(\\n         field, move=0.2, clamped=True\"]", "hints_text": ""}

{"instance_id": "698551933092953", "repo": "abhinavsingh/proxy.py", "base_commit": "f2b9a632bcf0165cfc1562ac5cbbc505d1fd0310", "problem_statement": "Consider using memoryview where applicable:\\n**Describe the solution you'd like**\\r\\nConsider using Python `memoryview` where applicable for zero-copy.\\r\\n", "FAIL_TO_PASS": ["http.test_protocol_handler.TestHttpProtocolHandler.test_proxy_connection_failed", "common.test_utils.TestSocketConnectionUtils.test_new_socket_connection_dual", "http.test_protocol_handler.TestHttpProtocolHandler.test_proxy_authentication_failed", "http.test_web_server.TestWebServerPlugin.test_default_web_server_returns_404"], "PASS_TO_PASS": ["plugin.test_http_proxy_plugins.TestHttpProxyPluginExamples.test_man_in_the_middle_plugin", "common.test_utils.TestSocketConnectionUtils.test_decorator", "http.test_http_parser.TestHttpParser.test_get_partial_parse1", "http.test_http_parser.TestHttpParser.test_response_parse", "http.test_web_server.TestWebServerPlugin.test_on_client_connection_called_on_teardown", "common.test_pki.TestPki.test_ssl_config", "common.test_text_bytes.TestTextBytes.test_bytes", "http.test_http_parser.TestHttpParser.test_chunked_response_parse", "http.test_http_parser.TestHttpParser.test_response_partial_parse", "http.test_http_parser.TestHttpParser.test_line_rcvd_to_rcving_headers_state_change", "http.test_http_parser.TestHttpParser.test_get_full_parse", "common.test_pki.TestPki.test_gen_public_key", "core.test_acceptor_pool.TestAcceptorPool.test_setup_and_shutdown", "common.test_utils.TestSocketConnectionUtils.test_context_manager", "http.test_http_parser.TestHttpParser.test_pipelined_chunked_response_parse", "http.test_http_parser.TestHttpParser.test_response_parse_without_content_length", "http.test_chunk_parser.TestChunkParser.test_to_chunks", "http.test_http_proxy.TestHttpProxyPlugin.test_proxy_plugin_before_upstream_connection_can_teardown", "http.test_http_request_rejected.TestHttpRequestRejected.test_status_code_response", "http.test_http_parser.TestHttpParser.test_post_partial_parse", "http.test_http_parser.TestHttpParser.test_post_full_parse", "plugin.test_http_proxy_plugins.TestHttpProxyPluginExamples.test_proposed_rest_api_plugin", "http.test_http_parser.TestHttpParser.test_find_line_returns_None", "common.test_text_bytes.TestTextBytes.test_text", "http.test_web_server.TestWebServerPlugin.test_static_web_server_serves", "http.test_http_parser.TestHttpParser.test_build_response", "http.test_http_proxy.TestHttpProxyPlugin.test_proxy_plugin_initialized", "test_set_open_file_limit.TestSetOpenFileLimit.test_set_open_file_limit_not_called_coz_upper_bound_check", "core.test_acceptor.TestAcceptor.test_accepts_client_from_server_socket", "test_set_open_file_limit.TestSetOpenFileLimit.test_set_open_file_limit_not_called", "core.test_acceptor.TestAcceptor.test_continues_when_no_events", "http.test_websocket_client.TestWebsocketClient.test_handshake", "http.test_http_request_rejected.TestHttpRequestRejected.test_empty_response", "http.test_web_server.TestWebServerPlugin.test_pac_file_served_from_buffer", "http.test_http_parser.TestHttpParser.test_pipelined_response_parse", "http.test_http_parser.TestHttpParser.test_is_http_1_1_keep_alive", "test_main.TestMain.test_basic_auth", "http.test_http_parser.TestHttpParser.test_find_line", "http.test_http_parser.TestHttpParser.test_chunked_request_parse", "test_main.TestMain.test_main_py2_exit", "http.test_http_parser.TestHttpParser.test_build_request", "http.test_http_parser.TestHttpParser.test_get_partial_parse2", "http.test_http_parser.TestHttpParser.test_header_raises", "common.test_pki.TestPki.test_ssl_config_no_ext", "common.test_pki.TestPki.test_extfile", "http.test_http_parser.TestHttpParser.test_is_not_http_1_1_keep_alive_with_close_header", "http.test_web_server.TestWebServerPlugin.test_pac_file_served_from_disk", "common.test_pki.TestPki.test_gen_csr", "http.test_http_parser.TestHttpParser.test_connect_request_without_host_header_request_parse", "http.test_http_parser.TestHttpParser.test_has_header", "http.test_http_parser.TestHttpParser.test_request_parse_without_content_length", "http.test_protocol_handler.TestHttpProtocolHandler.test_http_get", "plugin.test_http_proxy_plugins.TestHttpProxyPluginExamples.test_modify_post_data_plugin", "common.test_utils.TestSocketConnectionUtils.test_new_socket_connection_ipv6", "common.test_utils.TestSocketConnectionUtils.test_new_socket_connection_ipv4", "common.test_pki.TestPki.test_gen_private_key", "http.test_http_parser.TestHttpParser.test_build_header", "plugin.test_http_proxy_plugins.TestHttpProxyPluginExamples.test_redirect_to_custom_server_plugin", "test_main.TestMain.test_main_py3_runs", "common.test_pki.TestPki.test_run_openssl_command", "http.test_web_server.TestWebServerPlugin.test_static_web_server_serves_404", "http.test_websocket_frame.TestWebsocketFrame.test_build_with_mask", "http.test_http_parser.TestHttpParser.test_is_http_1_1_keep_alive_with_non_close_connection_header", "test_main.TestMain.test_main_version", "common.test_text_bytes.TestTextBytes.test_text_nochange", "http.test_http_proxy.TestHttpProxyPlugin.test_proxy_plugin_on_and_before_upstream_connection", "test_main.TestMain.test_init_with_no_arguments", "common.test_pki.TestPki.test_get_ext_config", "plugin.test_http_proxy_plugins.TestHttpProxyPluginExamples.test_filter_by_upstream_host_plugin", "http.test_websocket_frame.TestWebsocketFrame.test_parse_with_mask", "http.test_http_parser.TestHttpParser.test_set_host_port_raises", "common.test_text_bytes.TestTextBytes.test_bytes_int", "http.test_chunk_parser.TestChunkParser.test_chunk_parse_basic", "http.test_protocol_handler.TestHttpProtocolHandler.test_authenticated_proxy_http_get", "common.test_text_bytes.TestTextBytes.test_text_int", "http.test_http_parser.TestHttpParser.test_build_response_adds_content_length_header", "test_main.TestMain.test_pid_file_is_written_and_removed", "http.test_http_request_rejected.TestHttpRequestRejected.test_body_response", "http.test_http_parser.TestHttpParser.test_connect_request_with_crlf_as_separate_chunk", "http.test_chunk_parser.TestChunkParser.test_chunk_parse_issue_27", "common.test_pki.TestPki.test_sign_csr", "http.test_http_parser.TestHttpParser.test_is_not_http_1_1_keep_alive_for_http_1_0", "http.test_http_parser.TestHttpParser.test_build_url_none", "test_set_open_file_limit.TestSetOpenFileLimit.test_set_open_file_limit", "common.test_text_bytes.TestTextBytes.test_bytes_nochange", "common.test_pki.TestPki.test_extfile_no_ext"], "language": "python", "test_command": "source /saved/ENV || source /saved/*/ENV && /usr/bin/python3 /app/repo/unittest_loader_no_traceback.py ./tests", "test_output_parser": "python/parse_log_unittest", "image_storage_uri": "vmvm-registry.fbinfra.net/repomate_image_activ_python_unittest/abhinavsingh_proxy.py:f2b9a632bcf0165cfc1562ac5cbbc505d1fd0310", "patch": "[\"diff --git a/proxy/core/connection.py b/proxy/core/connection.py\\nindex 8c19a601bd..d94869755a 100644\\n--- a/proxy/core/connection.py\\n+++ b/proxy/core/connection.py\\n@@ -55,7 +55,7 @@ def send(self, data: bytes) -> int:\\n         \\\"\\\"\\\"Users must handle BrokenPipeError exceptions\\\"\\\"\\\"\\n         return self.connection.send(data)\\n \\n-    def recv(self, buffer_size: int = DEFAULT_BUFFER_SIZE) -> Optional[bytes]:\\n+    def recv(self, buffer_size: int = DEFAULT_BUFFER_SIZE) -> Optional[memoryview]:\\n         \\\"\\\"\\\"Users must handle socket.error exceptions\\\"\\\"\\\"\\n         data: bytes = self.connection.recv(buffer_size)\\n         if len(data) == 0:\\n@@ -64,7 +64,7 @@ def recv(self, buffer_size: int = DEFAULT_BUFFER_SIZE) -> Optional[bytes]:\\n             'received %d bytes from %s' %\\n             (len(data), self.tag))\\n         # logger.info(data)\\n-        return data\\n+        return memoryview(data)\\n \\n     def close(self) -> bool:\\n         if not self.closed:\\n\",\"diff --git a/proxy/http/handler.py b/proxy/http/handler.py\\nindex bf74a5bac5..07bc002fdb 100644\\n--- a/proxy/http/handler.py\\n+++ b/proxy/http/handler.py\\n@@ -87,7 +87,7 @@ def read_from_descriptors(self, r: List[Union[int, HasFileno]]) -> bool:\\n         return False  # pragma: no cover\\n \\n     @abstractmethod\\n-    def on_client_data(self, raw: bytes) -> Optional[bytes]:\\n+    def on_client_data(self, raw: memoryview) -> Optional[memoryview]:\\n         return raw  # pragma: no cover\\n \\n     @abstractmethod\\n@@ -322,7 +322,7 @@ def handle_readables(self, readables: List[Union[int, HasFileno]]) -> bool:\\n                         (self.client.tag, self.client.connection, e))\\n                 return True\\n \\n-            if not client_data:\\n+            if client_data is None:\\n                 logger.debug('Client closed connection, tearing down...')\\n                 self.client.closed = True\\n                 return True\\n@@ -346,7 +346,8 @@ def handle_readables(self, readables: List[Union[int, HasFileno]]) -> bool:\\n                 # valid request.\\n                 if client_data and self.request.state != httpParserStates.COMPLETE:\\n                     # Parse http request\\n-                    self.request.parse(client_data)\\n+                    # TODO(abhinavsingh): Remove .tobytes after parser is memoryview compliant\\n+                    self.request.parse(client_data.tobytes())\\n                     if self.request.state == httpParserStates.COMPLETE:\\n                         # Invoke plugin.on_request_complete\\n                         for plugin in self.plugins.values():\\n\",\"diff --git a/proxy/http/proxy.py b/proxy/http/proxy.py\\nindex 9dfe836e4a..cfbaebd614 100644\\n--- a/proxy/http/proxy.py\\n+++ b/proxy/http/proxy.py\\n@@ -88,7 +88,7 @@ def handle_client_request(\\n         return request  # pragma: no cover\\n \\n     @abstractmethod\\n-    def handle_upstream_chunk(self, chunk: bytes) -> bytes:\\n+    def handle_upstream_chunk(self, chunk: memoryview) -> memoryview:\\n         \\\"\\\"\\\"Handler called right after receiving raw response from upstream server.\\n \\n         For HTTPS connections, chunk will be encrypted unless\\n@@ -182,7 +182,7 @@ def read_from_descriptors(self, r: List[Union[int, HasFileno]]) -> bool:\\n                         (self.server.tag, self.server.connection, e))\\n                 return True\\n \\n-            if not raw:\\n+            if raw is None:\\n                 logger.debug('Server closed connection, tearing down...')\\n                 return True\\n \\n@@ -200,12 +200,14 @@ def read_from_descriptors(self, r: List[Union[int, HasFileno]]) -> bool:\\n                 if self.response.state == httpParserStates.COMPLETE:\\n                     self.handle_pipeline_response(raw)\\n                 else:\\n-                    self.response.parse(raw)\\n+                    # TODO(abhinavsingh): Remove .tobytes after parser is memoryview compliant\\n+                    self.response.parse(raw.tobytes())\\n                     self.emit_response_events()\\n             else:\\n                 self.response.total_size += len(raw)\\n             # queue raw data for client\\n-            self.client.queue(raw)\\n+            # TODO(abhinavsingh): Remove .tobytes after queue management is memoryview compliant\\n+            self.client.queue(raw.tobytes())\\n         return False\\n \\n     def on_client_connection_close(self) -> None:\\n@@ -250,7 +252,7 @@ def on_response_chunk(self, chunk: bytes) -> bytes:\\n         #     self.access_log()\\n         return chunk\\n \\n-    def on_client_data(self, raw: bytes) -> Optional[bytes]:\\n+    def on_client_data(self, raw: memoryview) -> Optional[memoryview]:\\n         if not self.request.has_upstream_server():\\n             return raw\\n \\n@@ -261,7 +263,8 @@ def on_client_data(self, raw: bytes) -> Optional[bytes]:\\n                 if self.pipeline_request is None:\\n                     self.pipeline_request = HttpParser(\\n                         httpParserTypes.REQUEST_PARSER)\\n-                self.pipeline_request.parse(raw)\\n+                # TODO(abhinavsingh): Remove .tobytes after parser is memoryview compliant\\n+                self.pipeline_request.parse(raw.tobytes())\\n                 if self.pipeline_request.state == httpParserStates.COMPLETE:\\n                     for plugin in self.plugins.values():\\n                         assert self.pipeline_request is not None\\n@@ -273,7 +276,8 @@ def on_client_data(self, raw: bytes) -> Optional[bytes]:\\n                     self.server.queue(self.pipeline_request.build())\\n                     self.pipeline_request = None\\n             else:\\n-                self.server.queue(raw)\\n+                # TODO(abhinavsingh): Remove .tobytes after queue management is memoryview compliant\\n+                self.server.queue(raw.tobytes())\\n             return None\\n         else:\\n             return raw\\n@@ -351,11 +355,12 @@ def on_request_complete(self) -> Union[socket.socket, bool]:\\n                     disable_headers=self.flags.disable_headers))\\n         return False\\n \\n-    def handle_pipeline_response(self, raw: bytes) -> None:\\n+    def handle_pipeline_response(self, raw: memoryview) -> None:\\n         if self.pipeline_response is None:\\n             self.pipeline_response = HttpParser(\\n                 httpParserTypes.RESPONSE_PARSER)\\n-        self.pipeline_response.parse(raw)\\n+        # TODO(abhinavsingh): Remove .tobytes after parser is memoryview compliant\\n+        self.pipeline_response.parse(raw.tobytes())\\n         if self.pipeline_response.state == httpParserStates.COMPLETE:\\n             self.pipeline_response = None\\n \\n\",\"diff --git a/proxy/http/server.py b/proxy/http/server.py\\nindex cfa3288934..5a1dfec4a4 100644\\n--- a/proxy/http/server.py\\n+++ b/proxy/http/server.py\\n@@ -257,9 +257,10 @@ def write_to_descriptors(self, w: List[Union[int, HasFileno]]) -> bool:\\n     def read_from_descriptors(self, r: List[Union[int, HasFileno]]) -> bool:\\n         pass\\n \\n-    def on_client_data(self, raw: bytes) -> Optional[bytes]:\\n+    def on_client_data(self, raw: memoryview) -> Optional[memoryview]:\\n         if self.switched_protocol == httpProtocolTypes.WEBSOCKET:\\n-            remaining = raw\\n+            # TODO(abhinavsingh): Remove .tobytes after websocket frame parser is memoryview compliant\\n+            remaining = raw.tobytes()\\n             frame = WebsocketFrame()\\n             while remaining != b'':\\n                 # TODO: Teardown if invalid protocol exception\\n@@ -283,7 +284,8 @@ def on_client_data(self, raw: bytes) -> Optional[bytes]:\\n             if self.pipeline_request is None:\\n                 self.pipeline_request = HttpParser(\\n                     httpParserTypes.REQUEST_PARSER)\\n-            self.pipeline_request.parse(raw)\\n+            # TODO(abhinavsingh): Remove .tobytes after parser is memoryview compliant\\n+            self.pipeline_request.parse(raw.tobytes())\\n             if self.pipeline_request.state == httpParserStates.COMPLETE:\\n                 self.route.handle_request(self.pipeline_request)\\n                 if not self.pipeline_request.is_http_1_1_keep_alive():\\n\",\"diff --git a/proxy/http/websocket.py b/proxy/http/websocket.py\\nindex 2408099a95..113726f0de 100644\\n--- a/proxy/http/websocket.py\\n+++ b/proxy/http/websocket.py\\n@@ -234,12 +234,13 @@ def run_once(self) -> bool:\\n         for key, mask in events:\\n             if mask & selectors.EVENT_READ and self.on_message:\\n                 raw = self.recv()\\n-                if raw is None or raw == b'':\\n+                if raw is None or raw.tobytes() == b'':\\n                     self.closed = True\\n                     logger.debug('Websocket connection closed by server')\\n                     return True\\n                 frame = WebsocketFrame()\\n-                frame.parse(raw)\\n+                # TODO(abhinavsingh): Remove .tobytes after parser is memoryview compliant\\n+                frame.parse(raw.tobytes())\\n                 self.on_message(frame)\\n             elif mask & selectors.EVENT_WRITE:\\n                 logger.debug(self.buffer)\\n\",\"diff --git a/proxy/plugin/cache/base.py b/proxy/plugin/cache/base.py\\nindex 5a9f5fed8a..2061bef0a6 100644\\n--- a/proxy/plugin/cache/base.py\\n+++ b/proxy/plugin/cache/base.py\\n@@ -50,7 +50,7 @@ def handle_client_request(self, request: HttpParser) -> Optional[HttpParser]:\\n         assert self.store\\n         return self.store.cache_request(request)\\n \\n-    def handle_upstream_chunk(self, chunk: bytes) -> bytes:\\n+    def handle_upstream_chunk(self, chunk: memoryview) -> memoryview:\\n         assert self.store\\n         return self.store.cache_response_chunk(chunk)\\n \\n\",\"diff --git a/proxy/plugin/cache/store/base.py b/proxy/plugin/cache/store/base.py\\nindex e382a96ab0..d15c5a6da3 100644\\n--- a/proxy/plugin/cache/store/base.py\\n+++ b/proxy/plugin/cache/store/base.py\\n@@ -28,7 +28,7 @@ def cache_request(self, request: HttpParser) -> Optional[HttpParser]:\\n         return request\\n \\n     @abstractmethod\\n-    def cache_response_chunk(self, chunk: bytes) -> bytes:\\n+    def cache_response_chunk(self, chunk: memoryview) -> memoryview:\\n         return chunk\\n \\n     @abstractmethod\\n\",\"diff --git a/proxy/plugin/cache/store/disk.py b/proxy/plugin/cache/store/disk.py\\nindex 3de1b073c4..cf108c61e0 100644\\n--- a/proxy/plugin/cache/store/disk.py\\n+++ b/proxy/plugin/cache/store/disk.py\\n@@ -37,9 +37,9 @@ def open(self, request: HttpParser) -> None:\\n     def cache_request(self, request: HttpParser) -> Optional[HttpParser]:\\n         return request\\n \\n-    def cache_response_chunk(self, chunk: bytes) -> bytes:\\n+    def cache_response_chunk(self, chunk: memoryview) -> memoryview:\\n         if self.cache_file:\\n-            self.cache_file.write(chunk)\\n+            self.cache_file.write(chunk.tobytes())\\n         return chunk\\n \\n     def close(self) -> None:\\n\",\"diff --git a/proxy/plugin/filter_by_upstream.py b/proxy/plugin/filter_by_upstream.py\\nindex 759af8f963..a919bd15be 100644\\n--- a/proxy/plugin/filter_by_upstream.py\\n+++ b/proxy/plugin/filter_by_upstream.py\\n@@ -36,7 +36,7 @@ def handle_client_request(\\n             self, request: HttpParser) -> Optional[HttpParser]:\\n         return request\\n \\n-    def handle_upstream_chunk(self, chunk: bytes) -> bytes:\\n+    def handle_upstream_chunk(self, chunk: memoryview) -> memoryview:\\n         return chunk\\n \\n     def on_upstream_connection_close(self) -> None:\\n\",\"diff --git a/proxy/plugin/man_in_the_middle.py b/proxy/plugin/man_in_the_middle.py\\nindex 2a16ed64da..cc3ab63e7e 100644\\n--- a/proxy/plugin/man_in_the_middle.py\\n+++ b/proxy/plugin/man_in_the_middle.py\\n@@ -27,10 +27,10 @@ def handle_client_request(\\n             self, request: HttpParser) -> Optional[HttpParser]:\\n         return request\\n \\n-    def handle_upstream_chunk(self, chunk: bytes) -> bytes:\\n-        return build_http_response(\\n+    def handle_upstream_chunk(self, chunk: memoryview) -> memoryview:\\n+        return memoryview(build_http_response(\\n             httpStatusCodes.OK,\\n-            reason=b'OK', body=b'Hello from man in the middle')\\n+            reason=b'OK', body=b'Hello from man in the middle'))\\n \\n     def on_upstream_connection_close(self) -> None:\\n         pass\\n\",\"diff --git a/proxy/plugin/mock_rest_api.py b/proxy/plugin/mock_rest_api.py\\nindex 1415a456ac..316e7a8109 100644\\n--- a/proxy/plugin/mock_rest_api.py\\n+++ b/proxy/plugin/mock_rest_api.py\\n@@ -81,7 +81,7 @@ def handle_client_request(\\n             ))\\n         return None\\n \\n-    def handle_upstream_chunk(self, chunk: bytes) -> bytes:\\n+    def handle_upstream_chunk(self, chunk: memoryview) -> memoryview:\\n         return chunk\\n \\n     def on_upstream_connection_close(self) -> None:\\n\",\"diff --git a/proxy/plugin/modify_post_data.py b/proxy/plugin/modify_post_data.py\\nindex bdc4550a80..98b89daf5c 100644\\n--- a/proxy/plugin/modify_post_data.py\\n+++ b/proxy/plugin/modify_post_data.py\\n@@ -40,7 +40,7 @@ def handle_client_request(\\n             request.add_header(b'Content-Type', b'application/json')\\n         return request\\n \\n-    def handle_upstream_chunk(self, chunk: bytes) -> bytes:\\n+    def handle_upstream_chunk(self, chunk: memoryview) -> memoryview:\\n         return chunk\\n \\n     def on_upstream_connection_close(self) -> None:\\n\",\"diff --git a/proxy/plugin/redirect_to_custom_server.py b/proxy/plugin/redirect_to_custom_server.py\\nindex cea287ce03..d2118e5fea 100644\\n--- a/proxy/plugin/redirect_to_custom_server.py\\n+++ b/proxy/plugin/redirect_to_custom_server.py\\n@@ -38,7 +38,7 @@ def handle_client_request(\\n             self, request: HttpParser) -> Optional[HttpParser]:\\n         return request\\n \\n-    def handle_upstream_chunk(self, chunk: bytes) -> bytes:\\n+    def handle_upstream_chunk(self, chunk: memoryview) -> memoryview:\\n         return chunk\\n \\n     def on_upstream_connection_close(self) -> None:\\n\",\"diff --git a/proxy/plugin/shortlink.py b/proxy/plugin/shortlink.py\\nindex 6cca81daa1..9211469edf 100644\\n--- a/proxy/plugin/shortlink.py\\n+++ b/proxy/plugin/shortlink.py\\n@@ -77,7 +77,7 @@ def handle_client_request(\\n             return None\\n         return request\\n \\n-    def handle_upstream_chunk(self, chunk: bytes) -> bytes:\\n+    def handle_upstream_chunk(self, chunk: memoryview) -> memoryview:\\n         return chunk\\n \\n     def on_upstream_connection_close(self) -> None:\\n\",\"diff --git a/proxy/common/utils.py b/proxy/common/utils.py\\nindex ae9a13d2fa..981a3ec025 100644\\n--- a/proxy/common/utils.py\\n+++ b/proxy/common/utils.py\\n@@ -120,20 +120,20 @@ def build_websocket_handshake_request(\\n     )\\n \\n \\n-def build_websocket_handshake_response(accept: bytes) -> bytes:\\n+def build_websocket_handshake_response(accept: bytes) -> memoryview:\\n     \\\"\\\"\\\"\\n     Build and returns a Websocket handshake response packet.\\n \\n     :param accept: Sec-WebSocket-Accept header value\\n     \\\"\\\"\\\"\\n-    return build_http_response(\\n+    return memoryview(build_http_response(\\n         101, reason=b'Switching Protocols',\\n         headers={\\n             b'Upgrade': b'websocket',\\n             b'Connection': b'Upgrade',\\n             b'Sec-WebSocket-Accept': accept\\n         }\\n-    )\\n+    ))\\n \\n \\n def find_http_line(raw: bytes) -> Tuple[Optional[bytes], bytes]:\\n\",\"diff --git a/proxy/core/connection.py b/proxy/core/connection.py\\nindex d94869755a..2df1068b4d 100644\\n--- a/proxy/core/connection.py\\n+++ b/proxy/core/connection.py\\n@@ -12,7 +12,7 @@\\n import ssl\\n import logging\\n from abc import ABC, abstractmethod\\n-from typing import NamedTuple, Optional, Union, Tuple\\n+from typing import NamedTuple, Optional, Union, Tuple, List\\n \\n from ..common.constants import DEFAULT_BUFFER_SIZE\\n from ..common.utils import new_socket_connection\\n@@ -41,7 +41,7 @@ class TcpConnection(ABC):\\n     a socket connection object.\\\"\\\"\\\"\\n \\n     def __init__(self, tag: int):\\n-        self.buffer: bytes = b''\\n+        self.buffer: List[memoryview] = []\\n         self.closed: bool = False\\n         self.tag: str = 'server' if tag == tcpConnectionTypes.SERVER else 'client'\\n \\n@@ -72,23 +72,22 @@ def close(self) -> bool:\\n             self.closed = True\\n         return self.closed\\n \\n-    def buffer_size(self) -> int:\\n-        return len(self.buffer)\\n-\\n     def has_buffer(self) -> bool:\\n-        return self.buffer_size() > 0\\n+        return len(self.buffer) > 0\\n \\n-    def queue(self, data: bytes) -> int:\\n-        self.buffer += data\\n-        return len(data)\\n+    def queue(self, mv: memoryview) -> None:\\n+        self.buffer.append(mv)\\n \\n     def flush(self) -> int:\\n         \\\"\\\"\\\"Users must handle BrokenPipeError exceptions\\\"\\\"\\\"\\n-        if self.buffer_size() == 0:\\n+        if not self.has_buffer():\\n             return 0\\n-        sent: int = self.send(self.buffer)\\n-        # logger.info(self.buffer[:sent])\\n-        self.buffer = self.buffer[sent:]\\n+        mv = self.buffer[0]\\n+        sent: int = self.send(mv.tobytes())\\n+        if sent == len(mv):\\n+            self.buffer.pop(0)\\n+        else:\\n+            self.buffer[0] = memoryview(mv.tobytes()[sent:])\\n         logger.debug('flushed %d bytes to %s' % (sent, self.tag))\\n         return sent\\n \\n\",\"diff --git a/proxy/dashboard/dashboard.py b/proxy/dashboard/dashboard.py\\nindex b053414afc..845bd071b8 100644\\n--- a/proxy/dashboard/dashboard.py\\n+++ b/proxy/dashboard/dashboard.py\\n@@ -67,14 +67,14 @@ def handle_request(self, request: HttpParser) -> None:\\n         elif request.path in (\\n                 b'/dashboard',\\n                 b'/dashboard/proxy.html'):\\n-            self.client.queue(build_http_response(\\n+            self.client.queue(memoryview(build_http_response(\\n                 httpStatusCodes.PERMANENT_REDIRECT, reason=b'Permanent Redirect',\\n                 headers={\\n                     b'Location': b'/dashboard/',\\n                     b'Content-Length': b'0',\\n                     b'Connection': b'close',\\n                 }\\n-            ))\\n+            )))\\n \\n     def on_websocket_open(self) -> None:\\n         logger.info('app ws opened')\\n@@ -104,6 +104,6 @@ def on_websocket_close(self) -> None:\\n \\n     def reply(self, data: Dict[str, Any]) -> None:\\n         self.client.queue(\\n-            WebsocketFrame.text(\\n+            memoryview(WebsocketFrame.text(\\n                 bytes_(\\n-                    json.dumps(data))))\\n+                    json.dumps(data)))))\\n\",\"diff --git a/proxy/dashboard/inspect_traffic.py b/proxy/dashboard/inspect_traffic.py\\nindex 862c5aca14..df82a37f90 100644\\n--- a/proxy/dashboard/inspect_traffic.py\\n+++ b/proxy/dashboard/inspect_traffic.py\\n@@ -37,12 +37,12 @@ def handle_message(self, message: Dict[str, Any]) -> None:\\n             # inspection can only be enabled if --enable-events is used\\n             if not self.flags.enable_events:\\n                 self.client.queue(\\n-                    WebsocketFrame.text(\\n+                    memoryview(WebsocketFrame.text(\\n                         bytes_(\\n                             json.dumps(\\n                                 {'id': message['id'], 'response': 'not enabled'})\\n                         )\\n-                    )\\n+                    ))\\n                 )\\n             else:\\n                 self.subscriber.subscribe(\\n@@ -61,6 +61,6 @@ def handle_message(self, message: Dict[str, Any]) -> None:\\n     def callback(client: TcpClientConnection, event: Dict[str, Any]) -> None:\\n         event['push'] = 'inspect_traffic'\\n         client.queue(\\n-            WebsocketFrame.text(\\n+            memoryview(WebsocketFrame.text(\\n                 bytes_(\\n-                    json.dumps(event))))\\n+                    json.dumps(event)))))\\n\",\"diff --git a/proxy/dashboard/plugin.py b/proxy/dashboard/plugin.py\\nindex 0574bca97c..7c5b9a3b9a 100644\\n--- a/proxy/dashboard/plugin.py\\n+++ b/proxy/dashboard/plugin.py\\n@@ -51,6 +51,6 @@ def disconnected(self) -> None:\\n \\n     def reply(self, data: Dict[str, Any]) -> None:\\n         self.client.queue(\\n-            WebsocketFrame.text(\\n+            memoryview(WebsocketFrame.text(\\n                 bytes_(\\n-                    json.dumps(data))))\\n+                    json.dumps(data)))))\\n\",\"diff --git a/proxy/http/exception.py b/proxy/http/exception.py\\nindex 18035388e8..f568394006 100644\\n--- a/proxy/http/exception.py\\n+++ b/proxy/http/exception.py\\n@@ -24,7 +24,7 @@ class HttpProtocolException(Exception):\\n     inherit HttpProtocolException base class. Implement response() method\\n     to optionally return custom response to client.\\\"\\\"\\\"\\n \\n-    def response(self, request: HttpParser) -> Optional[bytes]:\\n+    def response(self, request: HttpParser) -> Optional[memoryview]:\\n         return None  # pragma: no cover\\n \\n \\n@@ -44,21 +44,21 @@ def __init__(self,\\n         self.headers: Optional[Dict[bytes, bytes]] = headers\\n         self.body: Optional[bytes] = body\\n \\n-    def response(self, _request: HttpParser) -> Optional[bytes]:\\n+    def response(self, _request: HttpParser) -> Optional[memoryview]:\\n         if self.status_code:\\n-            return build_http_response(\\n+            return memoryview(build_http_response(\\n                 status_code=self.status_code,\\n                 reason=self.reason,\\n                 headers=self.headers,\\n                 body=self.body\\n-            )\\n+            ))\\n         return None\\n \\n \\n class ProxyConnectionFailed(HttpProtocolException):\\n     \\\"\\\"\\\"Exception raised when HttpProxyPlugin is unable to establish connection to upstream server.\\\"\\\"\\\"\\n \\n-    RESPONSE_PKT = build_http_response(\\n+    RESPONSE_PKT = memoryview(build_http_response(\\n         httpStatusCodes.BAD_GATEWAY,\\n         reason=b'Bad Gateway',\\n         headers={\\n@@ -66,14 +66,14 @@ class ProxyConnectionFailed(HttpProtocolException):\\n             b'Connection': b'close'\\n         },\\n         body=b'Bad Gateway'\\n-    )\\n+    ))\\n \\n     def __init__(self, host: str, port: int, reason: str):\\n         self.host: str = host\\n         self.port: int = port\\n         self.reason: str = reason\\n \\n-    def response(self, _request: HttpParser) -> bytes:\\n+    def response(self, _request: HttpParser) -> memoryview:\\n         return self.RESPONSE_PKT\\n \\n \\n@@ -81,7 +81,7 @@ class ProxyAuthenticationFailed(HttpProtocolException):\\n     \\\"\\\"\\\"Exception raised when Http Proxy auth is enabled and\\n     incoming request doesn't present necessary credentials.\\\"\\\"\\\"\\n \\n-    RESPONSE_PKT = build_http_response(\\n+    RESPONSE_PKT = memoryview(build_http_response(\\n         httpStatusCodes.PROXY_AUTH_REQUIRED,\\n         reason=b'Proxy Authentication Required',\\n         headers={\\n@@ -89,7 +89,7 @@ class ProxyAuthenticationFailed(HttpProtocolException):\\n             b'Proxy-Authenticate': b'Basic',\\n             b'Connection': b'close',\\n         },\\n-        body=b'Proxy Authentication Required')\\n+        body=b'Proxy Authentication Required'))\\n \\n-    def response(self, _request: HttpParser) -> bytes:\\n+    def response(self, _request: HttpParser) -> memoryview:\\n         return self.RESPONSE_PKT\\n\",\"diff --git a/proxy/http/handler.py b/proxy/http/handler.py\\nindex 07bc002fdb..28d14f1fe3 100644\\n--- a/proxy/http/handler.py\\n+++ b/proxy/http/handler.py\\n@@ -96,7 +96,7 @@ def on_request_complete(self) -> Union[socket.socket, bool]:\\n         return False  # pragma: no cover\\n \\n     @abstractmethod\\n-    def on_response_chunk(self, chunk: bytes) -> bytes:\\n+    def on_response_chunk(self, chunk: List[memoryview]) -> List[memoryview]:\\n         \\\"\\\"\\\"Handle data chunks as received from the server.\\n \\n         Return optionally modified chunk to return back to client.\\\"\\\"\\\"\\n@@ -215,8 +215,8 @@ def shutdown(self) -> None:\\n \\n             logger.debug(\\n                 'Closing client connection %r '\\n-                'at address %r with pending client buffer size %d bytes' %\\n-                (self.client.connection, self.client.addr, self.client.buffer_size()))\\n+                'at address %r has buffer %s' %\\n+                (self.client.connection, self.client.addr, self.client.has_buffer()))\\n \\n             conn = self.client.connection\\n             # Unwrap if wrapped before shutdown.\\n@@ -281,10 +281,12 @@ def flush(self) -> None:\\n             self.selector.unregister(self.client.connection)\\n \\n     def handle_writables(self, writables: List[Union[int, HasFileno]]) -> bool:\\n-        if self.client.buffer_size() > 0 and self.client.connection in writables:\\n+        if self.client.has_buffer() and self.client.connection in writables:\\n             logger.debug('Client is ready for writes, flushing buffer')\\n             self.last_activity = time.time()\\n \\n+            # TODO(abhinavsingh): This hook could just reside within server recv block\\n+            # instead of invoking when flushed to client.\\n             # Invoke plugin.on_response_chunk\\n             chunk = self.client.buffer\\n             for plugin in self.plugins.values():\\n\",\"diff --git a/proxy/http/inspector.py b/proxy/http/inspector.py\\nindex b8d44134b2..662bf894ee 100644\\n--- a/proxy/http/inspector.py\\n+++ b/proxy/http/inspector.py\\n@@ -112,7 +112,7 @@ def handle_devtools_message(self, message: Dict[str, Any]) -> None:\\n \\n         data['id'] = message['id']\\n         frame.data = bytes_(json.dumps(data))\\n-        self.client.queue(frame.build())\\n+        self.client.queue(memoryview(frame.build()))\\n \\n \\n class CoreEventsToDevtoolsProtocol:\\n@@ -136,9 +136,9 @@ def transformer(client: TcpClientConnection,\\n             # drop core events unrelated to Devtools\\n             return\\n         client.queue(\\n-            WebsocketFrame.text(\\n+            memoryview(WebsocketFrame.text(\\n                 bytes_(\\n-                    json.dumps(data))))\\n+                    json.dumps(data)))))\\n \\n     @staticmethod\\n     def request_complete(event: Dict[str, Any]) -> Dict[str, Any]:\\n\",\"diff --git a/proxy/http/proxy.py b/proxy/http/proxy.py\\nindex cfbaebd614..e5b6434da2 100644\\n--- a/proxy/http/proxy.py\\n+++ b/proxy/http/proxy.py\\n@@ -104,10 +104,10 @@ def on_upstream_connection_close(self) -> None:\\n class HttpProxyPlugin(HttpProtocolHandlerPlugin):\\n     \\\"\\\"\\\"HttpProtocolHandler plugin which implements HttpProxy specifications.\\\"\\\"\\\"\\n \\n-    PROXY_TUNNEL_ESTABLISHED_RESPONSE_PKT = build_http_response(\\n+    PROXY_TUNNEL_ESTABLISHED_RESPONSE_PKT = memoryview(build_http_response(\\n         httpStatusCodes.OK,\\n         reason=b'Connection established'\\n-    )\\n+    ))\\n \\n     # Used to synchronize with other HttpProxyPlugin instances while\\n     # generating certificates\\n@@ -206,8 +206,7 @@ def read_from_descriptors(self, r: List[Union[int, HasFileno]]) -> bool:\\n             else:\\n                 self.response.total_size += len(raw)\\n             # queue raw data for client\\n-            # TODO(abhinavsingh): Remove .tobytes after queue management is memoryview compliant\\n-            self.client.queue(raw.tobytes())\\n+            self.client.queue(raw)\\n         return False\\n \\n     def on_client_connection_close(self) -> None:\\n@@ -238,10 +237,10 @@ def on_client_connection_close(self) -> None:\\n             pass\\n         finally:\\n             logger.debug(\\n-                'Closed server connection with pending server buffer size %d bytes' %\\n-                self.server.buffer_size())\\n+                'Closed server connection, has buffer %s' %\\n+                self.server.has_buffer())\\n \\n-    def on_response_chunk(self, chunk: bytes) -> bytes:\\n+    def on_response_chunk(self, chunk: List[memoryview]) -> List[memoryview]:\\n         # TODO: Allow to output multiple access_log lines\\n         # for each request over a pipelined HTTP connection (not for HTTPS).\\n         # However, this must also be accompanied by resetting both request\\n@@ -273,11 +272,11 @@ def on_client_data(self, raw: memoryview) -> Optional[memoryview]:\\n                             return None\\n                         self.pipeline_request = r\\n                     assert self.pipeline_request is not None\\n-                    self.server.queue(self.pipeline_request.build())\\n+                    # TODO(abhinavsingh): Remove memoryview wrapping here after parser is fully memoryview compliant\\n+                    self.server.queue(memoryview(self.pipeline_request.build()))\\n                     self.pipeline_request = None\\n             else:\\n-                # TODO(abhinavsingh): Remove .tobytes after queue management is memoryview compliant\\n-                self.server.queue(raw.tobytes())\\n+                self.server.queue(raw)\\n             return None\\n         else:\\n             return raw\\n@@ -351,8 +350,8 @@ def on_request_complete(self) -> Union[socket.socket, bool]:\\n                 [(b'Via', b'1.1 %s' % PROXY_AGENT_HEADER_VALUE)])\\n             # Disable args.disable_headers before dispatching to upstream\\n             self.server.queue(\\n-                self.request.build(\\n-                    disable_headers=self.flags.disable_headers))\\n+                memoryview(self.request.build(\\n+                    disable_headers=self.flags.disable_headers)))\\n         return False\\n \\n     def handle_pipeline_response(self, raw: memoryview) -> None:\\n\",\"diff --git a/proxy/http/server.py b/proxy/http/server.py\\nindex 5a1dfec4a4..e548647d84 100644\\n--- a/proxy/http/server.py\\n+++ b/proxy/http/server.py\\n@@ -85,7 +85,7 @@ class HttpWebServerPacFilePlugin(HttpWebServerBasePlugin):\\n \\n     def __init__(self, *args: Any, **kwargs: Any) -> None:\\n         super().__init__(*args, **kwargs)\\n-        self.pac_file_response: Optional[bytes] = None\\n+        self.pac_file_response: Optional[memoryview] = None\\n         self.cache_pac_file_response()\\n \\n     def routes(self) -> List[Tuple[int, bytes]]:\\n@@ -116,30 +116,30 @@ def cache_pac_file_response(self) -> None:\\n                     content = f.read()\\n             except IOError:\\n                 content = bytes_(self.flags.pac_file)\\n-            self.pac_file_response = build_http_response(\\n+            self.pac_file_response = memoryview(build_http_response(\\n                 200, reason=b'OK', headers={\\n                     b'Content-Type': b'application/x-ns-proxy-autoconfig',\\n                     b'Content-Encoding': b'gzip',\\n                 }, body=gzip.compress(content)\\n-            )\\n+            ))\\n \\n \\n class HttpWebServerPlugin(HttpProtocolHandlerPlugin):\\n     \\\"\\\"\\\"HttpProtocolHandler plugin which handles incoming requests to local web server.\\\"\\\"\\\"\\n \\n-    DEFAULT_404_RESPONSE = build_http_response(\\n+    DEFAULT_404_RESPONSE = memoryview(build_http_response(\\n         httpStatusCodes.NOT_FOUND,\\n         reason=b'NOT FOUND',\\n         headers={b'Server': PROXY_AGENT_HEADER_VALUE,\\n                  b'Connection': b'close'}\\n-    )\\n+    ))\\n \\n-    DEFAULT_501_RESPONSE = build_http_response(\\n+    DEFAULT_501_RESPONSE = memoryview(build_http_response(\\n         httpStatusCodes.NOT_IMPLEMENTED,\\n         reason=b'NOT IMPLEMENTED',\\n         headers={b'Server': PROXY_AGENT_HEADER_VALUE,\\n                  b'Connection': b'close'}\\n-    )\\n+    ))\\n \\n     def __init__(\\n             self,\\n@@ -166,13 +166,13 @@ def __init__(\\n                     self.routes[protocol][path] = instance\\n \\n     @staticmethod\\n-    def read_and_build_static_file_response(path: str) -> bytes:\\n+    def read_and_build_static_file_response(path: str) -> memoryview:\\n         with open(path, 'rb') as f:\\n             content = f.read()\\n         content_type = mimetypes.guess_type(path)[0]\\n         if content_type is None:\\n             content_type = 'text/plain'\\n-        return build_http_response(\\n+        return memoryview(build_http_response(\\n             httpStatusCodes.OK,\\n             reason=b'OK',\\n             headers={\\n@@ -181,7 +181,7 @@ def read_and_build_static_file_response(path: str) -> bytes:\\n                 b'Content-Encoding': b'gzip',\\n                 b'Connection': b'close',\\n             },\\n-            body=gzip.compress(content))\\n+            body=gzip.compress(content)))\\n \\n     def serve_file_or_404(self, path: str) -> bool:\\n         \\\"\\\"\\\"Read and serves a file from disk.\\n@@ -295,7 +295,7 @@ def on_client_data(self, raw: memoryview) -> Optional[memoryview]:\\n                 self.pipeline_request = None\\n         return raw\\n \\n-    def on_response_chunk(self, chunk: bytes) -> bytes:\\n+    def on_response_chunk(self, chunk: List[memoryview]) -> List[memoryview]:\\n         return chunk\\n \\n     def on_client_connection_close(self) -> None:\\n\",\"diff --git a/proxy/plugin/mock_rest_api.py b/proxy/plugin/mock_rest_api.py\\nindex 316e7a8109..270c864408 100644\\n--- a/proxy/plugin/mock_rest_api.py\\n+++ b/proxy/plugin/mock_rest_api.py\\n@@ -67,18 +67,18 @@ def handle_client_request(\\n             return request\\n         assert request.path\\n         if request.path in self.REST_API_SPEC:\\n-            self.client.queue(build_http_response(\\n+            self.client.queue(memoryview(build_http_response(\\n                 httpStatusCodes.OK,\\n                 reason=b'OK',\\n                 headers={b'Content-Type': b'application/json'},\\n                 body=bytes_(json.dumps(\\n                     self.REST_API_SPEC[request.path]))\\n-            ))\\n+            )))\\n         else:\\n-            self.client.queue(build_http_response(\\n+            self.client.queue(memoryview(build_http_response(\\n                 httpStatusCodes.NOT_FOUND,\\n                 reason=b'NOT FOUND', body=b'Not Found'\\n-            ))\\n+            )))\\n         return None\\n \\n     def handle_upstream_chunk(self, chunk: memoryview) -> memoryview:\\n\",\"diff --git a/proxy/plugin/shortlink.py b/proxy/plugin/shortlink.py\\nindex 9211469edf..309fc1fbc2 100644\\n--- a/proxy/plugin/shortlink.py\\n+++ b/proxy/plugin/shortlink.py\\n@@ -58,22 +58,22 @@ def handle_client_request(\\n         if request.host and request.host != b'localhost' and DOT not in request.host:\\n             if request.host in self.SHORT_LINKS:\\n                 path = SLASH if not request.path else request.path\\n-                self.client.queue(build_http_response(\\n+                self.client.queue(memoryview(build_http_response(\\n                     httpStatusCodes.SEE_OTHER, reason=b'See Other',\\n                     headers={\\n                         b'Location': b'http://' + self.SHORT_LINKS[request.host] + path,\\n                         b'Content-Length': b'0',\\n                         b'Connection': b'close',\\n                     }\\n-                ))\\n+                )))\\n             else:\\n-                self.client.queue(build_http_response(\\n+                self.client.queue(memoryview(build_http_response(\\n                     httpStatusCodes.NOT_FOUND, reason=b'NOT FOUND',\\n                     headers={\\n                         b'Content-Length': b'0',\\n                         b'Connection': b'close',\\n                     }\\n-                ))\\n+                )))\\n             return None\\n         return request\\n \\n\",\"diff --git a/proxy/plugin/web_server_route.py b/proxy/plugin/web_server_route.py\\nindex dd52658f87..48f917a729 100644\\n--- a/proxy/plugin/web_server_route.py\\n+++ b/proxy/plugin/web_server_route.py\\n@@ -32,11 +32,11 @@ def routes(self) -> List[Tuple[int, bytes]]:\\n \\n     def handle_request(self, request: HttpParser) -> None:\\n         if request.path == b'/http-route-example':\\n-            self.client.queue(build_http_response(\\n-                httpStatusCodes.OK, body=b'HTTP route response'))\\n+            self.client.queue(memoryview(build_http_response(\\n+                httpStatusCodes.OK, body=b'HTTP route response')))\\n         elif request.path == b'/https-route-example':\\n-            self.client.queue(build_http_response(\\n-                httpStatusCodes.OK, body=b'HTTPS route response'))\\n+            self.client.queue(memoryview(build_http_response(\\n+                httpStatusCodes.OK, body=b'HTTPS route response')))\\n \\n     def on_websocket_open(self) -> None:\\n         logger.info('Websocket open')\\n\",\"diff --git a/proxy/core/connection.py b/proxy/core/connection.py\\nindex 2df1068b4d..7b5fe6c953 100644\\n--- a/proxy/core/connection.py\\n+++ b/proxy/core/connection.py\\n@@ -55,7 +55,8 @@ def send(self, data: bytes) -> int:\\n         \\\"\\\"\\\"Users must handle BrokenPipeError exceptions\\\"\\\"\\\"\\n         return self.connection.send(data)\\n \\n-    def recv(self, buffer_size: int = DEFAULT_BUFFER_SIZE) -> Optional[memoryview]:\\n+    def recv(\\n+            self, buffer_size: int = DEFAULT_BUFFER_SIZE) -> Optional[memoryview]:\\n         \\\"\\\"\\\"Users must handle socket.error exceptions\\\"\\\"\\\"\\n         data: bytes = self.connection.recv(buffer_size)\\n         if len(data) == 0:\\n\",\"diff --git a/proxy/core/event.py b/proxy/core/event.py\\nindex a9fe995596..8bd3b0b5ef 100644\\n--- a/proxy/core/event.py\\n+++ b/proxy/core/event.py\\n@@ -184,7 +184,9 @@ def subscribe(self, callback: Callable[[Dict[str, Any]], None]) -> None:\\n         self.relay_thread.start()\\n         self.relay_sub_id = uuid.uuid4().hex\\n         self.event_queue.subscribe(self.relay_sub_id, self.relay_channel)\\n-        logger.debug('Subscribed relay sub id %s from core events', self.relay_sub_id)\\n+        logger.debug(\\n+            'Subscribed relay sub id %s from core events',\\n+            self.relay_sub_id)\\n \\n     def unsubscribe(self) -> None:\\n         if self.relay_sub_id is None:\\n@@ -199,7 +201,9 @@ def unsubscribe(self) -> None:\\n         self.event_queue.unsubscribe(self.relay_sub_id)\\n         self.relay_shutdown.set()\\n         self.relay_thread.join()\\n-        logger.debug('Un-subscribed relay sub id %s from core events', self.relay_sub_id)\\n+        logger.debug(\\n+            'Un-subscribed relay sub id %s from core events',\\n+            self.relay_sub_id)\\n \\n         self.relay_thread = None\\n         self.relay_shutdown = None\\n\",\"diff --git a/proxy/http/handler.py b/proxy/http/handler.py\\nindex 28d14f1fe3..569a23c929 100644\\n--- a/proxy/http/handler.py\\n+++ b/proxy/http/handler.py\\n@@ -348,7 +348,8 @@ def handle_readables(self, readables: List[Union[int, HasFileno]]) -> bool:\\n                 # valid request.\\n                 if client_data and self.request.state != httpParserStates.COMPLETE:\\n                     # Parse http request\\n-                    # TODO(abhinavsingh): Remove .tobytes after parser is memoryview compliant\\n+                    # TODO(abhinavsingh): Remove .tobytes after parser is\\n+                    # memoryview compliant\\n                     self.request.parse(client_data.tobytes())\\n                     if self.request.state == httpParserStates.COMPLETE:\\n                         # Invoke plugin.on_request_complete\\n\",\"diff --git a/proxy/http/parser.py b/proxy/http/parser.py\\nindex 24b410cb40..c30cc8aef8 100644\\n--- a/proxy/http/parser.py\\n+++ b/proxy/http/parser.py\\n@@ -117,7 +117,9 @@ def set_line_attributes(self) -> None:\\n                 self.host, self.port = self.url.hostname, self.url.port \\\\\\n                     if self.url.port else 80\\n             else:\\n-                raise KeyError('Invalid request. Method: %r, Url: %r' % (self.method, self.url))\\n+                raise KeyError(\\n+                    'Invalid request. Method: %r, Url: %r' %\\n+                    (self.method, self.url))\\n             self.path = self.build_url()\\n \\n     def is_chunked_encoded(self) -> bool:\\n\",\"diff --git a/proxy/http/proxy.py b/proxy/http/proxy.py\\nindex e5b6434da2..1ea74e2fb9 100644\\n--- a/proxy/http/proxy.py\\n+++ b/proxy/http/proxy.py\\n@@ -200,7 +200,8 @@ def read_from_descriptors(self, r: List[Union[int, HasFileno]]) -> bool:\\n                 if self.response.state == httpParserStates.COMPLETE:\\n                     self.handle_pipeline_response(raw)\\n                 else:\\n-                    # TODO(abhinavsingh): Remove .tobytes after parser is memoryview compliant\\n+                    # TODO(abhinavsingh): Remove .tobytes after parser is\\n+                    # memoryview compliant\\n                     self.response.parse(raw.tobytes())\\n                     self.emit_response_events()\\n             else:\\n@@ -262,7 +263,8 @@ def on_client_data(self, raw: memoryview) -> Optional[memoryview]:\\n                 if self.pipeline_request is None:\\n                     self.pipeline_request = HttpParser(\\n                         httpParserTypes.REQUEST_PARSER)\\n-                # TODO(abhinavsingh): Remove .tobytes after parser is memoryview compliant\\n+                # TODO(abhinavsingh): Remove .tobytes after parser is\\n+                # memoryview compliant\\n                 self.pipeline_request.parse(raw.tobytes())\\n                 if self.pipeline_request.state == httpParserStates.COMPLETE:\\n                     for plugin in self.plugins.values():\\n@@ -272,8 +274,11 @@ def on_client_data(self, raw: memoryview) -> Optional[memoryview]:\\n                             return None\\n                         self.pipeline_request = r\\n                     assert self.pipeline_request is not None\\n-                    # TODO(abhinavsingh): Remove memoryview wrapping here after parser is fully memoryview compliant\\n-                    self.server.queue(memoryview(self.pipeline_request.build()))\\n+                    # TODO(abhinavsingh): Remove memoryview wrapping here after\\n+                    # parser is fully memoryview compliant\\n+                    self.server.queue(\\n+                        memoryview(\\n+                            self.pipeline_request.build()))\\n                     self.pipeline_request = None\\n             else:\\n                 self.server.queue(raw)\\n@@ -358,7 +363,8 @@ def handle_pipeline_response(self, raw: memoryview) -> None:\\n         if self.pipeline_response is None:\\n             self.pipeline_response = HttpParser(\\n                 httpParserTypes.RESPONSE_PARSER)\\n-        # TODO(abhinavsingh): Remove .tobytes after parser is memoryview compliant\\n+        # TODO(abhinavsingh): Remove .tobytes after parser is memoryview\\n+        # compliant\\n         self.pipeline_response.parse(raw.tobytes())\\n         if self.pipeline_response.state == httpParserStates.COMPLETE:\\n             self.pipeline_response = None\\n\",\"diff --git a/proxy/http/server.py b/proxy/http/server.py\\nindex e548647d84..65aee44b2e 100644\\n--- a/proxy/http/server.py\\n+++ b/proxy/http/server.py\\n@@ -259,7 +259,8 @@ def read_from_descriptors(self, r: List[Union[int, HasFileno]]) -> bool:\\n \\n     def on_client_data(self, raw: memoryview) -> Optional[memoryview]:\\n         if self.switched_protocol == httpProtocolTypes.WEBSOCKET:\\n-            # TODO(abhinavsingh): Remove .tobytes after websocket frame parser is memoryview compliant\\n+            # TODO(abhinavsingh): Remove .tobytes after websocket frame parser\\n+            # is memoryview compliant\\n             remaining = raw.tobytes()\\n             frame = WebsocketFrame()\\n             while remaining != b'':\\n@@ -284,7 +285,8 @@ def on_client_data(self, raw: memoryview) -> Optional[memoryview]:\\n             if self.pipeline_request is None:\\n                 self.pipeline_request = HttpParser(\\n                     httpParserTypes.REQUEST_PARSER)\\n-            # TODO(abhinavsingh): Remove .tobytes after parser is memoryview compliant\\n+            # TODO(abhinavsingh): Remove .tobytes after parser is memoryview\\n+            # compliant\\n             self.pipeline_request.parse(raw.tobytes())\\n             if self.pipeline_request.state == httpParserStates.COMPLETE:\\n                 self.route.handle_request(self.pipeline_request)\\n\",\"diff --git a/proxy/http/websocket.py b/proxy/http/websocket.py\\nindex 113726f0de..68294114ab 100644\\n--- a/proxy/http/websocket.py\\n+++ b/proxy/http/websocket.py\\n@@ -239,7 +239,8 @@ def run_once(self) -> bool:\\n                     logger.debug('Websocket connection closed by server')\\n                     return True\\n                 frame = WebsocketFrame()\\n-                # TODO(abhinavsingh): Remove .tobytes after parser is memoryview compliant\\n+                # TODO(abhinavsingh): Remove .tobytes after parser is\\n+                # memoryview compliant\\n                 frame.parse(raw.tobytes())\\n                 self.on_message(frame)\\n             elif mask & selectors.EVENT_WRITE:\\n\",\"diff --git a/proxy/common/utils.py b/proxy/common/utils.py\\nindex 981a3ec025..ae9a13d2fa 100644\\n--- a/proxy/common/utils.py\\n+++ b/proxy/common/utils.py\\n@@ -120,20 +120,20 @@ def build_websocket_handshake_request(\\n     )\\n \\n \\n-def build_websocket_handshake_response(accept: bytes) -> memoryview:\\n+def build_websocket_handshake_response(accept: bytes) -> bytes:\\n     \\\"\\\"\\\"\\n     Build and returns a Websocket handshake response packet.\\n \\n     :param accept: Sec-WebSocket-Accept header value\\n     \\\"\\\"\\\"\\n-    return memoryview(build_http_response(\\n+    return build_http_response(\\n         101, reason=b'Switching Protocols',\\n         headers={\\n             b'Upgrade': b'websocket',\\n             b'Connection': b'Upgrade',\\n             b'Sec-WebSocket-Accept': accept\\n         }\\n-    ))\\n+    )\\n \\n \\n def find_http_line(raw: bytes) -> Tuple[Optional[bytes], bytes]:\\n\",\"diff --git a/proxy/http/server.py b/proxy/http/server.py\\nindex 65aee44b2e..8120718a21 100644\\n--- a/proxy/http/server.py\\n+++ b/proxy/http/server.py\\n@@ -202,9 +202,9 @@ def try_upgrade(self) -> bool:\\n             if self.request.has_header(b'upgrade') and \\\\\\n                     self.request.header(b'upgrade').lower() == b'websocket':\\n                 self.client.queue(\\n-                    build_websocket_handshake_response(\\n+                    memoryview(build_websocket_handshake_response(\\n                         WebsocketFrame.key_to_accept(\\n-                            self.request.header(b'Sec-WebSocket-Key'))))\\n+                            self.request.header(b'Sec-WebSocket-Key')))))\\n                 self.switched_protocol = httpProtocolTypes.WEBSOCKET\\n             else:\\n                 self.client.queue(self.DEFAULT_501_RESPONSE)\\n\",\"diff --git a/proxy/common/utils.py b/proxy/common/utils.py\\nindex ae9a13d2fa..47c4c9a4f1 100644\\n--- a/proxy/common/utils.py\\n+++ b/proxy/common/utils.py\\n@@ -16,7 +16,7 @@\\n from types import TracebackType\\n from typing import Optional, Dict, Any, List, Tuple, Type, Callable\\n \\n-from .constants import HTTP_1_1, COLON, WHITESPACE, CRLF\\n+from .constants import HTTP_1_1, COLON, WHITESPACE, CRLF, DEFAULT_TIMEOUT\\n \\n \\n def text_(s: Any, encoding: str = 'utf-8', errors: str = 'strict') -> Any:\\n@@ -148,17 +148,20 @@ def find_http_line(raw: bytes) -> Tuple[Optional[bytes], bytes]:\\n     return line, rest\\n \\n \\n-def new_socket_connection(addr: Tuple[str, int]) -> socket.socket:\\n+def new_socket_connection(\\n+        addr: Tuple[str, int], timeout: int = DEFAULT_TIMEOUT) -> socket.socket:\\n     conn = None\\n     try:\\n         ip = ipaddress.ip_address(addr[0])\\n         if ip.version == 4:\\n             conn = socket.socket(\\n                 socket.AF_INET, socket.SOCK_STREAM, 0)\\n+            conn.settimeout(timeout)\\n             conn.connect(addr)\\n         else:\\n             conn = socket.socket(\\n                 socket.AF_INET6, socket.SOCK_STREAM, 0)\\n+            conn.settimeout(timeout)\\n             conn.connect((addr[0], addr[1], 0, 0))\\n     except ValueError:\\n         pass    # does not appear to be an IPv4 or IPv6 address\\n@@ -167,7 +170,7 @@ def new_socket_connection(addr: Tuple[str, int]) -> socket.socket:\\n         return conn\\n \\n     # try to establish dual stack IPv4/IPv6 connection.\\n-    return socket.create_connection(addr)\\n+    return socket.create_connection(addr, timeout=timeout)\\n \\n \\n class socket_connection(contextlib.ContextDecorator):\\n\"]", "test_patch": "[\"diff --git a/tests/http/test_protocol_handler.py b/tests/http/test_protocol_handler.py\\nindex 4113ee05fe..1356e9c55a 100644\\n--- a/tests/http/test_protocol_handler.py\\n+++ b/tests/http/test_protocol_handler.py\\n@@ -86,7 +86,7 @@ def assert_tunnel_response(\\n         self.assertTrue(\\n             cast(HttpProxyPlugin, self.protocol_handler.plugins['HttpProxyPlugin']).server is not None)\\n         self.assertEqual(\\n-            self.protocol_handler.client.buffer,\\n+            self.protocol_handler.client.buffer[0],\\n             HttpProxyPlugin.PROXY_TUNNEL_ESTABLISHED_RESPONSE_PKT)\\n         mock_server_connection.assert_called_once()\\n         server.connect.assert_called_once()\\n@@ -94,7 +94,7 @@ def assert_tunnel_response(\\n         server.closed = False\\n \\n         parser = HttpParser(httpParserTypes.RESPONSE_PARSER)\\n-        parser.parse(self.protocol_handler.client.buffer)\\n+        parser.parse(self.protocol_handler.client.buffer[0].tobytes())\\n         self.assertEqual(parser.state, httpParserStates.COMPLETE)\\n         assert parser.code is not None\\n         self.assertEqual(int(parser.code), 200)\\n@@ -158,7 +158,7 @@ def test_proxy_connection_failed(self) -> None:\\n         ])\\n         self.protocol_handler.run_once()\\n         self.assertEqual(\\n-            self.protocol_handler.client.buffer,\\n+            self.protocol_handler.client.buffer[0],\\n             ProxyConnectionFailed.RESPONSE_PKT)\\n \\n     @mock.patch('selectors.DefaultSelector')\\n@@ -184,7 +184,7 @@ def test_proxy_authentication_failed(\\n         ])\\n         self.protocol_handler.run_once()\\n         self.assertEqual(\\n-            self.protocol_handler.client.buffer,\\n+            self.protocol_handler.client.buffer[0],\\n             ProxyAuthenticationFailed.RESPONSE_PKT)\\n \\n     @mock.patch('selectors.DefaultSelector')\\n\",\"diff --git a/tests/http/test_web_server.py b/tests/http/test_web_server.py\\nindex 6b2148c07f..aeea532351 100644\\n--- a/tests/http/test_web_server.py\\n+++ b/tests/http/test_web_server.py\\n@@ -107,7 +107,7 @@ def test_default_web_server_returns_404(\\n             self.protocol_handler.request.state,\\n             httpParserStates.COMPLETE)\\n         self.assertEqual(\\n-            self.protocol_handler.client.buffer,\\n+            self.protocol_handler.client.buffer[0],\\n             HttpWebServerPlugin.DEFAULT_404_RESPONSE)\\n \\n     @mock.patch('selectors.DefaultSelector')\\n\",\"diff --git a/tests/plugin/test_http_proxy_plugins.py b/tests/plugin/test_http_proxy_plugins.py\\nindex b347a880b8..b17d5729e5 100644\\n--- a/tests/plugin/test_http_proxy_plugins.py\\n+++ b/tests/plugin/test_http_proxy_plugins.py\\n@@ -112,7 +112,7 @@ def test_proposed_rest_api_plugin(\\n \\n         mock_server_conn.assert_not_called()\\n         self.assertEqual(\\n-            self.protocol_handler.client.buffer,\\n+            self.protocol_handler.client.buffer[0].tobytes(),\\n             build_http_response(\\n                 httpStatusCodes.OK, reason=b'OK',\\n                 headers={b'Content-Type': b'application/json'},\\n@@ -172,7 +172,7 @@ def test_filter_by_upstream_host_plugin(\\n \\n         mock_server_conn.assert_not_called()\\n         self.assertEqual(\\n-            self.protocol_handler.client.buffer,\\n+            self.protocol_handler.client.buffer[0].tobytes(),\\n             build_http_response(\\n                 status_code=httpStatusCodes.I_AM_A_TEAPOT,\\n                 reason=b'I\\\\'m a tea pot',\\n@@ -247,7 +247,7 @@ def closed() -> bool:\\n                 reason=b'OK', body=b'Original Response From Upstream')\\n         self.protocol_handler.run_once()\\n         self.assertEqual(\\n-            self.protocol_handler.client.buffer,\\n+            self.protocol_handler.client.buffer[0].tobytes(),\\n             build_http_response(\\n                 httpStatusCodes.OK,\\n                 reason=b'OK', body=b'Hello from man in the middle')\\n\",\"diff --git a/tests/plugin/test_http_proxy_plugins_with_tls_interception.py b/tests/plugin/test_http_proxy_plugins_with_tls_interception.py\\nindex 5f2def28d1..2ef478c4e7 100644\\n--- a/tests/plugin/test_http_proxy_plugins_with_tls_interception.py\\n+++ b/tests/plugin/test_http_proxy_plugins_with_tls_interception.py\\n@@ -135,7 +135,7 @@ def send(raw: bytes) -> int:\\n         self._conn.send.assert_called_with(\\n             HttpProxyPlugin.PROXY_TUNNEL_ESTABLISHED_RESPONSE_PKT\\n         )\\n-        self.assertEqual(self.protocol_handler.client.buffer, b'')\\n+        self.assertFalse(self.protocol_handler.client.has_buffer())\\n \\n     def test_modify_post_data_plugin(self) -> None:\\n         original = b'{\\\"key\\\": \\\"value\\\"}'\\n@@ -186,7 +186,7 @@ def test_man_in_the_middle_plugin(self) -> None:\\n                 reason=b'OK', body=b'Original Response From Upstream')\\n         self.protocol_handler.run_once()\\n         self.assertEqual(\\n-            self.protocol_handler.client.buffer,\\n+            self.protocol_handler.client.buffer[0].tobytes(),\\n             build_http_response(\\n                 httpStatusCodes.OK,\\n                 reason=b'OK', body=b'Hello from man in the middle')\\n\",\"diff --git a/Makefile b/Makefile\\nindex 7173b55465..c3ae9c7cc7 100644\\n--- a/Makefile\\n+++ b/Makefile\\n@@ -27,6 +27,7 @@ autopep8:\\n \\tautopep8 --recursive --in-place --aggressive proxy/*.py\\n \\tautopep8 --recursive --in-place --aggressive proxy/*/*.py\\n \\tautopep8 --recursive --in-place --aggressive tests/*.py\\n+\\tautopep8 --recursive --in-place --aggressive tests/*/*.py\\n \\tautopep8 --recursive --in-place --aggressive setup.py\\n \\n https-certificates:\\n\",\"diff --git a/proxy/testing/test_case.py b/proxy/testing/test_case.py\\nindex 8f5f5a1dbe..69c1f70204 100644\\n--- a/proxy/testing/test_case.py\\n+++ b/proxy/testing/test_case.py\\n@@ -40,7 +40,8 @@ def setUpClass(cls) -> None:\\n         cls.INPUT_ARGS.append(str(cls.PROXY_PORT))\\n \\n         cls.PROXY = Proxy(input_args=cls.INPUT_ARGS)\\n-        cls.PROXY.flags.plugins[b'HttpProxyBasePlugin'].append(CacheResponsesPlugin)\\n+        cls.PROXY.flags.plugins[b'HttpProxyBasePlugin'].append(\\n+            CacheResponsesPlugin)\\n \\n         cls.PROXY.__enter__()\\n         cls.wait_for_server(cls.PROXY_PORT)\\n\",\"diff --git a/tests/common/test_pki.py b/tests/common/test_pki.py\\nindex a896de1ecb..d3796787bf 100644\\n--- a/tests/common/test_pki.py\\n+++ b/tests/common/test_pki.py\\n@@ -22,13 +22,24 @@ def test_run_openssl_command(self, mock_popen: mock.Mock) -> None:\\n         command = ['my', 'custom', 'command']\\n         mock_popen.return_value.returncode = 0\\n         self.assertTrue(pki.run_openssl_command(command, 10))\\n-        mock_popen.assert_called_with(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\\n+        mock_popen.assert_called_with(\\n+            command,\\n+            stdout=subprocess.PIPE,\\n+            stderr=subprocess.PIPE)\\n \\n     def test_get_ext_config(self) -> None:\\n         self.assertEqual(pki.get_ext_config(None, None), b'')\\n         self.assertEqual(pki.get_ext_config([], None), b'')\\n-        self.assertEqual(pki.get_ext_config(['proxy.py'], None), b'\\\\nsubjectAltName=DNS:proxy.py')\\n-        self.assertEqual(pki.get_ext_config(None, 'serverAuth'), b'\\\\nextendedKeyUsage=serverAuth')\\n+        self.assertEqual(\\n+            pki.get_ext_config(\\n+                ['proxy.py'],\\n+                None),\\n+            b'\\\\nsubjectAltName=DNS:proxy.py')\\n+        self.assertEqual(\\n+            pki.get_ext_config(\\n+                None,\\n+                'serverAuth'),\\n+            b'\\\\nextendedKeyUsage=serverAuth')\\n         self.assertEqual(pki.get_ext_config(['proxy.py'], 'serverAuth'),\\n                          b'\\\\nsubjectAltName=DNS:proxy.py\\\\nextendedKeyUsage=serverAuth')\\n         self.assertEqual(pki.get_ext_config(['proxy.py', 'www.proxy.py'], 'serverAuth'),\\n@@ -44,7 +55,10 @@ def test_ssl_config(self) -> None:\\n         with pki.ssl_config(['proxy.py']) as (config_path, has_extension):\\n             self.assertTrue(has_extension)\\n             with open(config_path, 'rb') as config:\\n-                self.assertEqual(config.read(), pki.DEFAULT_CONFIG + b'\\\\n[PROXY]\\\\nsubjectAltName=DNS:proxy.py')\\n+                self.assertEqual(\\n+                    config.read(),\\n+                    pki.DEFAULT_CONFIG +\\n+                    b'\\\\n[PROXY]\\\\nsubjectAltName=DNS:proxy.py')\\n \\n     def test_extfile_no_ext(self) -> None:\\n         with pki.ext_file() as config_path:\\n@@ -54,7 +68,9 @@ def test_extfile_no_ext(self) -> None:\\n     def test_extfile(self) -> None:\\n         with pki.ext_file(['proxy.py']) as config_path:\\n             with open(config_path, 'rb') as config:\\n-                self.assertEqual(config.read(), b'\\\\nsubjectAltName=DNS:proxy.py')\\n+                self.assertEqual(\\n+                    config.read(),\\n+                    b'\\\\nsubjectAltName=DNS:proxy.py')\\n \\n     def test_gen_private_key(self) -> None:\\n         pass\\n\",\"diff --git a/tests/testing/test_embed.py b/tests/testing/test_embed.py\\nindex 43dffbd544..f9c0a98385 100644\\n--- a/tests/testing/test_embed.py\\n+++ b/tests/testing/test_embed.py\\n@@ -8,9 +8,9 @@\\n     :copyright: (c) 2013-present by Abhinav Singh and contributors.\\n     :license: BSD, see LICENSE for more details.\\n \\\"\\\"\\\"\\n-import json\\n import http.client\\n import urllib.request\\n+import urllib.error\\n \\n from proxy import TestCase\\n from proxy.common.constants import DEFAULT_CLIENT_RECVBUF_SIZE, PROXY_AGENT_HEADER_VALUE\\n@@ -70,8 +70,10 @@ def make_http_request_using_proxy(self) -> None:\\n             'http': 'http://localhost:%d' % self.PROXY_PORT,\\n         })\\n         opener = urllib.request.build_opener(proxy_handler)\\n-        r: http.client.HTTPResponse = opener.open('http://httpbin.org/get')\\n-        self.assertEqual(r.status, 200)\\n-        data = json.loads(r.read(DEFAULT_CLIENT_RECVBUF_SIZE))\\n-        self.assertEqual(data['args'], {})\\n-        self.assertEqual(data['headers']['Host'], 'httpbin.org')\\n+        with self.assertRaises(urllib.error.HTTPError) as e:\\n+            r: http.client.HTTPResponse = opener.open(\\n+                'http://localhost:%d/' %\\n+                self.PROXY_PORT, timeout=10)\\n+            self.assertEqual(r.status, 404)\\n+            self.assertEqual(r.headers.get('server'), PROXY_AGENT_HEADER_VALUE)\\n+            self.assertEqual(r.headers.get('connection'), b'close')\\n\",\"diff --git a/tests/common/test_utils.py b/tests/common/test_utils.py\\nindex 5db1d508b4..27ada7ba9f 100644\\n--- a/tests/common/test_utils.py\\n+++ b/tests/common/test_utils.py\\n@@ -12,7 +12,7 @@\\n import unittest\\n from unittest import mock\\n \\n-from proxy.common.constants import DEFAULT_IPV6_HOSTNAME, DEFAULT_IPV4_HOSTNAME, DEFAULT_PORT\\n+from proxy.common.constants import DEFAULT_IPV6_HOSTNAME, DEFAULT_IPV4_HOSTNAME, DEFAULT_PORT, DEFAULT_TIMEOUT\\n from proxy.common.utils import new_socket_connection, socket_connection\\n \\n \\n@@ -41,7 +41,7 @@ def test_new_socket_connection_ipv6(self, mock_socket: mock.Mock) -> None:\\n     @mock.patch('socket.create_connection')\\n     def test_new_socket_connection_dual(self, mock_socket: mock.Mock) -> None:\\n         conn = new_socket_connection(self.addr_dual)\\n-        mock_socket.assert_called_with(self.addr_dual)\\n+        mock_socket.assert_called_with(self.addr_dual, timeout=DEFAULT_TIMEOUT)\\n         self.assertEqual(conn, mock_socket.return_value)\\n \\n     @mock.patch('proxy.common.utils.new_socket_connection')\\n\",\"diff --git a/tests/testing/test_embed.py b/tests/testing/test_embed.py\\nindex f9c0a98385..8b57f709be 100644\\n--- a/tests/testing/test_embed.py\\n+++ b/tests/testing/test_embed.py\\n@@ -70,7 +70,7 @@ def make_http_request_using_proxy(self) -> None:\\n             'http': 'http://localhost:%d' % self.PROXY_PORT,\\n         })\\n         opener = urllib.request.build_opener(proxy_handler)\\n-        with self.assertRaises(urllib.error.HTTPError) as e:\\n+        with self.assertRaises(urllib.error.HTTPError):\\n             r: http.client.HTTPResponse = opener.open(\\n                 'http://localhost:%d/' %\\n                 self.PROXY_PORT, timeout=10)\\n\",\"diff --git a/tests/testing/test_embed.py b/tests/testing/test_embed.py\\nindex 8b57f709be..c201782859 100644\\n--- a/tests/testing/test_embed.py\\n+++ b/tests/testing/test_embed.py\\n@@ -8,6 +8,7 @@\\n     :copyright: (c) 2013-present by Abhinav Singh and contributors.\\n     :license: BSD, see LICENSE for more details.\\n \\\"\\\"\\\"\\n+import unittest\\n import http.client\\n import urllib.request\\n import urllib.error\\n@@ -19,6 +20,7 @@\\n from proxy.http.methods import httpMethods\\n \\n \\n+@unittest.skipIf(True, 'Disabled as it hang on GitHub actions')\\n class TestProxyPyEmbedded(TestCase):\\n     \\\"\\\"\\\"This test case is a demonstration of proxy.TestCase and also serves as\\n     integration test suite for proxy.py.\\\"\\\"\\\"\\n\",\"diff --git a/proxy/testing/test_case.py b/proxy/testing/test_case.py\\nindex 69c1f70204..5fbf0cb348 100644\\n--- a/proxy/testing/test_case.py\\n+++ b/proxy/testing/test_case.py\\n@@ -13,6 +13,7 @@\\n from typing import Optional, List, Generator, Any\\n \\n from ..proxy import Proxy\\n+from ..common.constants import DEFAULT_TIMEOUT\\n from ..common.utils import get_available_port, new_socket_connection\\n from ..plugin import CacheResponsesPlugin\\n \\n@@ -47,8 +48,9 @@ def setUpClass(cls) -> None:\\n         cls.wait_for_server(cls.PROXY_PORT)\\n \\n     @staticmethod\\n-    def wait_for_server(proxy_port: int) -> None:\\n+    def wait_for_server(proxy_port: int, wait_for_seconds: int = DEFAULT_TIMEOUT) -> None:\\n         \\\"\\\"\\\"Wait for proxy.py server to come up.\\\"\\\"\\\"\\n+        start_time = time.time()\\n         while True:\\n             try:\\n                 conn = new_socket_connection(\\n@@ -58,6 +60,9 @@ def wait_for_server(proxy_port: int) -> None:\\n             except ConnectionRefusedError:\\n                 time.sleep(0.1)\\n \\n+            if time.time() - start_time > wait_for_seconds:\\n+                break\\n+\\n     @classmethod\\n     def tearDownClass(cls) -> None:\\n         assert cls.PROXY\\n\",\"diff --git a/tests/testing/test_embed.py b/tests/testing/test_embed.py\\nindex c201782859..d7032c2f9a 100644\\n--- a/tests/testing/test_embed.py\\n+++ b/tests/testing/test_embed.py\\n@@ -8,6 +8,7 @@\\n     :copyright: (c) 2013-present by Abhinav Singh and contributors.\\n     :license: BSD, see LICENSE for more details.\\n \\\"\\\"\\\"\\n+import os\\n import unittest\\n import http.client\\n import urllib.request\\n@@ -20,7 +21,8 @@\\n from proxy.http.methods import httpMethods\\n \\n \\n-@unittest.skipIf(True, 'Disabled as it hang on GitHub actions')\\n+@unittest.skipIf(os.environ.get('GITHUB_ACTIONS', False),\\n+                 'Disabled on GitHub actions because proxy.py setup hangs')\\n class TestProxyPyEmbedded(TestCase):\\n     \\\"\\\"\\\"This test case is a demonstration of proxy.TestCase and also serves as\\n     integration test suite for proxy.py.\\\"\\\"\\\"\\n\",\"diff --git a/tests/testing/test_embed.py b/tests/testing/test_embed.py\\nindex d7032c2f9a..8b57f709be 100644\\n--- a/tests/testing/test_embed.py\\n+++ b/tests/testing/test_embed.py\\n@@ -8,8 +8,6 @@\\n     :copyright: (c) 2013-present by Abhinav Singh and contributors.\\n     :license: BSD, see LICENSE for more details.\\n \\\"\\\"\\\"\\n-import os\\n-import unittest\\n import http.client\\n import urllib.request\\n import urllib.error\\n@@ -21,8 +19,6 @@\\n from proxy.http.methods import httpMethods\\n \\n \\n-@unittest.skipIf(os.environ.get('GITHUB_ACTIONS', False),\\n-                 'Disabled on GitHub actions because proxy.py setup hangs')\\n class TestProxyPyEmbedded(TestCase):\\n     \\\"\\\"\\\"This test case is a demonstration of proxy.TestCase and also serves as\\n     integration test suite for proxy.py.\\\"\\\"\\\"\\n\",\"diff --git a/proxy/testing/test_case.py b/proxy/testing/test_case.py\\nindex 5fbf0cb348..67341bb2ea 100644\\n--- a/proxy/testing/test_case.py\\n+++ b/proxy/testing/test_case.py\\n@@ -61,7 +61,7 @@ def wait_for_server(proxy_port: int, wait_for_seconds: int = DEFAULT_TIMEOUT) ->\\n                 time.sleep(0.1)\\n \\n             if time.time() - start_time > wait_for_seconds:\\n-                break\\n+                raise TimeoutError('Timed out while waiting for proxy.py to start...')\\n \\n     @classmethod\\n     def tearDownClass(cls) -> None:\\n\",\"diff --git a/tests/testing/test_test_case.py b/tests/testing/test_test_case.py\\nnew file mode 100644\\nindex 0000000000..a3b3e3c76d\\n--- /dev/null\\n+++ b/tests/testing/test_test_case.py\\n@@ -0,0 +1,21 @@\\n+# -*- coding: utf-8 -*-\\n+\\\"\\\"\\\"\\n+    proxy.py\\n+    ~~~~~~~~\\n+     Fast, Lightweight, Pluggable, TLS interception capable proxy server focused on\\n+    Network monitoring, controls & Application development, testing, debugging.\\n+\\n+    :copyright: (c) 2013-present by Abhinav Singh and contributors.\\n+    :license: BSD, see LICENSE for more details.\\n+\\\"\\\"\\\"\\n+import unittest\\n+import proxy\\n+\\n+from proxy.common.utils import get_available_port\\n+\\n+\\n+class TestTestCase(unittest.TestCase):\\n+\\n+    def test_wait_for_server(self) -> None:\\n+        with self.assertRaises(TimeoutError):\\n+            proxy.TestCase.wait_for_server(get_available_port(), wait_for_seconds=1)\\n\",\"diff --git a/tests/testing/test_embed.py b/tests/testing/test_embed.py\\nindex 8b57f709be..d7032c2f9a 100644\\n--- a/tests/testing/test_embed.py\\n+++ b/tests/testing/test_embed.py\\n@@ -8,6 +8,8 @@\\n     :copyright: (c) 2013-present by Abhinav Singh and contributors.\\n     :license: BSD, see LICENSE for more details.\\n \\\"\\\"\\\"\\n+import os\\n+import unittest\\n import http.client\\n import urllib.request\\n import urllib.error\\n@@ -19,6 +21,8 @@\\n from proxy.http.methods import httpMethods\\n \\n \\n+@unittest.skipIf(os.environ.get('GITHUB_ACTIONS', False),\\n+                 'Disabled on GitHub actions because proxy.py setup hangs')\\n class TestProxyPyEmbedded(TestCase):\\n     \\\"\\\"\\\"This test case is a demonstration of proxy.TestCase and also serves as\\n     integration test suite for proxy.py.\\\"\\\"\\\"\"]", "hints_text": ""}

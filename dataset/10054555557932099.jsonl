{"instance_id": "10054555557932099", "repo": "sqlfluff/sqlfluff", "base_commit": "f3f59af615bf20c0d78929336f04851372140939", "problem_statement": "Nuisance: L052 (require_final_semicolon = True) does not reliably add `;` if L009 is on and EOF line does not exist already:\\nIf:\\r\\n- Rule 009 is not excluded (default)\\r\\n- There is no single trailing newline (as rule 009 requires)\\r\\n- Rule 052 parameter `require_final_semicolon = True` (not default)\\r\\n\\r\\nThen `sqlfluff fix` adds newline, but does not add a semicolon (`;`).\\r\\n\\r\\nRelated experiments:\\r\\n- Value of another 052's parameter `semicolon_newline = True/False` does not affect the mechanics\\r\\n- While ```[sqlfluff] exclude_rules = L009``` makes `;` appear always as expected\\r\\n\\r\\n## Query\\r\\n```\\r\\nSELECT\\r\\n    a\\r\\nFROM foo\\r\\n```\\r\\n\\r\\n## Expected Behaviour\\r\\n```\\r\\nSELECT a\\r\\nFROM foo;\\r\\n\\r\\n```\\r\\n\\r\\n## Observed Behaviour\\r\\n```\\r\\nSELECT a,\\r\\nFROM foo\\r\\n\\r\\n```\\r\\n\\r\\n## Steps to Reproduce\\r\\nI believe any setup will have such error if \\r\\n```\\r\\n[sqlfluff:rules:L052] \\r\\nrequire_final_semicolon = True\\r\\n```\\r\\nadded to the `.sqlfluff`\\r\\n\\r\\n## Dialect\\r\\n- bigquery\\r\\n\\r\\n## Version\\r\\n- sqlfluff, version 0.8.2\\r\\n\\r\\n## Configuration\\r\\n```\\r\\n[sqlfluff]\\r\\ntemplater = jinja\\r\\ndialect = bigquery\\r\\n# exclude_rules = L009\\r\\n\\r\\n[sqlfluff:rules:L052] \\r\\nrequire_final_semicolon = True\\r\\n```\\r\\n", "FAIL_TO_PASS": ["test/core/rules/config_test.py::test__rules__runaway_fail_catch", "test/rules/std_L009_L052_test.py::test__rules__std_L009_and_L052_interaction"], "PASS_TO_PASS": [], "language": "python", "test_command": "source /saved/ENV || source /saved/*/ENV && pytest --no-header -rA --tb=no -p no:cacheprovider --continue-on-collection-errors", "test_output_parser": "python/parse_log_pytest_v3", "image_storage_uri": "vmvm-registry.fbinfra.net/repomate_image_activ_pytest/sqlfluff_sqlfluff:f3f59af615bf20c0d78929336f04851372140939", "patch": "[\"diff --git a/src/sqlfluff/core/parser/segments/base.py b/src/sqlfluff/core/parser/segments/base.py\\nindex 3b8e43435fc..b8eb2d68b76 100644\\n--- a/src/sqlfluff/core/parser/segments/base.py\\n+++ b/src/sqlfluff/core/parser/segments/base.py\\n@@ -973,7 +973,11 @@ def apply_fixes(self, fixes):\\n                             if f.edit_type == \\\"delete\\\":\\n                                 # We're just getting rid of this segment.\\n                                 seg = None\\n-                            elif f.edit_type in (\\\"edit\\\", \\\"create\\\"):\\n+                            elif f.edit_type in (\\n+                                \\\"edit\\\",\\n+                                \\\"create_before\\\",\\n+                                \\\"create_after\\\",\\n+                            ):\\n                                 # We're doing a replacement (it could be a single segment or an iterable)\\n                                 if isinstance(f.edit, BaseSegment):\\n                                     seg_buffer.append(f.edit)  # pragma: no cover TODO?\\n@@ -981,9 +985,12 @@ def apply_fixes(self, fixes):\\n                                     for s in f.edit:\\n                                         seg_buffer.append(s)\\n \\n-                                if f.edit_type == \\\"create\\\":\\n-                                    # in the case of a creation, also add this segment on the end\\n+                                if f.edit_type == \\\"create_before\\\":\\n+                                    # in the case of a creation before, also add this segment on the end\\n                                     seg_buffer.append(seg)\\n+                                elif f.edit_type == \\\"create_after\\\":\\n+                                    # in the case of a creation after, also add this segment to the start\\n+                                    seg_buffer.insert(0, seg)\\n                             else:  # pragma: no cover\\n                                 raise ValueError(\\n                                     \\\"Unexpected edit_type: {!r} in {!r}\\\".format(\\n\",\"diff --git a/src/sqlfluff/core/rules/base.py b/src/sqlfluff/core/rules/base.py\\nindex 5d633b8d144..3a32175b9ce 100644\\n--- a/src/sqlfluff/core/rules/base.py\\n+++ b/src/sqlfluff/core/rules/base.py\\n@@ -113,7 +113,12 @@ class LintFix:\\n     \\\"\\\"\\\"\\n \\n     def __init__(self, edit_type, anchor: BaseSegment, edit=None):\\n-        if edit_type not in [\\\"create\\\", \\\"edit\\\", \\\"delete\\\"]:  # pragma: no cover\\n+        if edit_type not in (\\n+            \\\"create_before\\\",\\n+            \\\"create_after\\\",\\n+            \\\"edit\\\",\\n+            \\\"delete\\\",\\n+        ):  # pragma: no cover\\n             raise ValueError(f\\\"Unexpected edit_type: {edit_type}\\\")\\n         self.edit_type = edit_type\\n         if not anchor:  # pragma: no cover\\n@@ -153,7 +158,7 @@ def is_trivial(self):\\n \\n         Removing these makes the routines which process fixes much faster.\\n         \\\"\\\"\\\"\\n-        if self.edit_type == \\\"create\\\":\\n+        if self.edit_type in (\\\"create_before\\\", \\\"create_after\\\"):\\n             if isinstance(self.edit, BaseSegment):\\n                 if len(self.edit.raw) == 0:  # pragma: no cover TODO?\\n                     return True\\n@@ -166,7 +171,7 @@ def is_trivial(self):\\n     def __repr__(self):\\n         if self.edit_type == \\\"delete\\\":\\n             detail = f\\\"delete:{self.anchor.raw!r}\\\"\\n-        elif self.edit_type in (\\\"edit\\\", \\\"create\\\"):\\n+        elif self.edit_type in (\\\"edit\\\", \\\"create_before\\\", \\\"create_after\\\"):\\n             if hasattr(self.edit, \\\"raw\\\"):\\n                 new_detail = self.edit.raw  # pragma: no cover TODO?\\n             else:\\n@@ -433,6 +438,32 @@ def _process_lint_result(res):\\n \\n     # HELPER METHODS --------\\n \\n+    def is_final_segment(self, context: RuleContext) -> bool:\\n+        \\\"\\\"\\\"Is the current segment the final segment in the parse tree.\\\"\\\"\\\"\\n+        if len(self.filter_meta(context.siblings_post)) > 0:\\n+            # This can only fail on the last segment\\n+            return False\\n+        elif len(context.segment.segments) > 0:\\n+            # This can only fail on the last base segment\\n+            return False\\n+        elif context.segment.is_meta:\\n+            # We can't fail on a meta segment\\n+            return False\\n+        else:\\n+            # We know we are at a leaf of the tree but not necessarily at the end of the tree.\\n+            # Therefore we look backwards up the parent stack and ask if any of the parent segments\\n+            # have another non-meta child segment after the current one.\\n+            child_segment = context.segment\\n+            for parent_segment in context.parent_stack[::-1]:\\n+                possible_children = [\\n+                    s for s in parent_segment.segments if not s.is_meta\\n+                ]\\n+                if len(possible_children) > possible_children.index(child_segment) + 1:\\n+                    return False\\n+                child_segment = parent_segment\\n+\\n+        return True\\n+\\n     @staticmethod\\n     def filter_meta(segments, keep_meta=False):\\n         \\\"\\\"\\\"Filter the segments to non-meta.\\n\",\"diff --git a/src/sqlfluff/rules/L003.py b/src/sqlfluff/rules/L003.py\\nindex eae869ad0bb..7d08e80d822 100644\\n--- a/src/sqlfluff/rules/L003.py\\n+++ b/src/sqlfluff/rules/L003.py\\n@@ -200,7 +200,7 @@ def _coerce_indent_to(\\n         elif len(\\\"\\\".join(elem.raw for elem in current_indent_buffer)) == 0:\\n             fixes = [\\n                 LintFix(\\n-                    \\\"create\\\",\\n+                    \\\"create_before\\\",\\n                     current_anchor,\\n                     WhitespaceSegment(\\n                         raw=desired_indent,\\n@@ -697,7 +697,7 @@ def _process_current_line(\\n                             # Add in an extra bit of whitespace for the indent\\n                             fixes=[\\n                                 LintFix(\\n-                                    \\\"create\\\",\\n+                                    \\\"create_before\\\",\\n                                     trigger_segment,\\n                                     WhitespaceSegment(\\n                                         raw=self._make_indent(\\n@@ -718,7 +718,7 @@ def _process_current_line(\\n                         ),\\n                         fixes=[\\n                             LintFix(\\n-                                \\\"create\\\",\\n+                                \\\"create_before\\\",\\n                                 trigger_segment,\\n                                 WhitespaceSegment(\\n                                     # Make the minimum indent for it to be ok.\\n\",\"diff --git a/src/sqlfluff/rules/L006.py b/src/sqlfluff/rules/L006.py\\nindex b14161fb1e8..c1775964566 100644\\n--- a/src/sqlfluff/rules/L006.py\\n+++ b/src/sqlfluff/rules/L006.py\\n@@ -164,7 +164,7 @@ def _eval(self, context: RuleContext) -> EvalResultType:\\n                             ),\\n                             fixes=[\\n                                 LintFix(\\n-                                    \\\"create\\\",\\n+                                    \\\"create_before\\\",\\n                                     # NB the anchor here is always in the parent and not anchor\\n                                     anchor=sub_seg,\\n                                     edit=WhitespaceSegment(raw=\\\" \\\"),\\n@@ -191,7 +191,7 @@ def _eval(self, context: RuleContext) -> EvalResultType:\\n                             ),\\n                             fixes=[\\n                                 LintFix(\\n-                                    \\\"create\\\",\\n+                                    \\\"create_before\\\",\\n                                     # NB the anchor here is always in the parent and not anchor\\n                                     anchor=next_seg,\\n                                     edit=WhitespaceSegment(raw=\\\" \\\"),\\n\",\"diff --git a/src/sqlfluff/rules/L009.py b/src/sqlfluff/rules/L009.py\\nindex 5f54644a6e5..b5da61445ef 100644\\n--- a/src/sqlfluff/rules/L009.py\\n+++ b/src/sqlfluff/rules/L009.py\\n@@ -81,25 +81,9 @@ def _eval(self, context: RuleContext) -> Optional[LintResult]:\\n         for this rule, we discard the others into the kwargs argument.\\n \\n         \\\"\\\"\\\"\\n-        if len(self.filter_meta(context.siblings_post)) > 0:\\n-            # This can only fail on the last segment\\n+        # We only care about the final segment of the parse tree.\\n+        if not self.is_final_segment(context):\\n             return None\\n-        elif len(context.segment.segments) > 0:\\n-            # This can only fail on the last base segment\\n-            return None\\n-        elif context.segment.is_meta:\\n-            # We can't fail on a meta segment\\n-            return None\\n-        else:\\n-            # So this looks like the end of the file, but we\\n-            # need to check that each parent segment is also the last.\\n-            # We do this with reference to the templated file, because it's\\n-            # the best we can do given the information available.\\n-            file_len = len(context.segment.pos_marker.templated_file.templated_str)\\n-            pos = context.segment.pos_marker.templated_slice.stop\\n-            # Does the length of the file equal the end of the templated position?\\n-            if file_len != pos:\\n-                return None\\n \\n         # Include current segment for complete stack.\\n         complete_stack: List[BaseSegment] = list(context.raw_stack)\\n@@ -121,13 +105,19 @@ def _eval(self, context: RuleContext) -> Optional[LintResult]:\\n             # No need for fix if single new line exists.\\n             return None\\n         elif len(eof_newline_segments) == 0:\\n-            # We're going to make an edit because we're appending to the end and there's\\n-            # no segment after it to match on. Otherwise we would never get a match!\\n+            # We make an edit to create this segment after the child of the FileSegment.\\n+            if len(context.parent_stack) == 1:\\n+                edit_segment = context.segment\\n+            else:\\n+                edit_segment = context.parent_stack[1]\\n+\\n             return LintResult(\\n                 anchor=anchor_segment,\\n                 fixes=[\\n                     LintFix(\\n-                        \\\"edit\\\", context.segment, [context.segment, NewlineSegment()]\\n+                        \\\"create_after\\\",\\n+                        edit_segment,\\n+                        [NewlineSegment()],\\n                     )\\n                 ],\\n             )\\n\",\"diff --git a/src/sqlfluff/rules/L011.py b/src/sqlfluff/rules/L011.py\\nindex 4b39c19fed8..cb99b58bd4e 100644\\n--- a/src/sqlfluff/rules/L011.py\\n+++ b/src/sqlfluff/rules/L011.py\\n@@ -98,7 +98,11 @@ def _eval(self, context: RuleContext) -> Optional[LintResult]:\\n                     return LintResult(\\n                         anchor=context.segment,\\n                         fixes=[\\n-                            LintFix(\\\"create\\\", context.segment.segments[0], insert_buff)\\n+                            LintFix(\\n+                                \\\"create_before\\\",\\n+                                context.segment.segments[0],\\n+                                insert_buff,\\n+                            )\\n                         ],\\n                     )\\n         return None\\n\",\"diff --git a/src/sqlfluff/rules/L015.py b/src/sqlfluff/rules/L015.py\\nindex 23eae0ba03d..a5f19c2b5f8 100644\\n--- a/src/sqlfluff/rules/L015.py\\n+++ b/src/sqlfluff/rules/L015.py\\n@@ -68,7 +68,7 @@ def _eval(self, context: RuleContext) -> Optional[LintResult]:\\n             ):\\n                 fixes.append(\\n                     LintFix(\\n-                        \\\"create\\\",\\n+                        \\\"create_before\\\",\\n                         first_element,\\n                         WhitespaceSegment(),\\n                     )\\n\",\"diff --git a/src/sqlfluff/rules/L016.py b/src/sqlfluff/rules/L016.py\\nindex 00be028a3ed..86e4163a3ee 100644\\n--- a/src/sqlfluff/rules/L016.py\\n+++ b/src/sqlfluff/rules/L016.py\\n@@ -143,7 +143,7 @@ def generate_fixes_to_coerce(\\n                     # Create a newline and a similar indent\\n                     fixes.append(\\n                         LintFix(\\n-                            \\\"create\\\",\\n+                            \\\"create_before\\\",\\n                             create_anchor,\\n                             [\\n                                 NewlineSegment(),\\n@@ -164,7 +164,7 @@ def generate_fixes_to_coerce(\\n                     # Create a newline, create an indent of the relevant size\\n                     fixes.append(\\n                         LintFix(\\n-                            \\\"create\\\",\\n+                            \\\"create_before\\\",\\n                             create_anchor,\\n                             [\\n                                 NewlineSegment(),\\n@@ -539,7 +539,9 @@ def _eval(self, context: RuleContext) -> Optional[LintResult]:\\n                 # Create a newline before this one with the existing comment, an\\n                 # identical indent AND a terminating newline, copied from the current\\n                 # target segment.\\n-                create_buffer = [LintFix(\\\"create\\\", this_line[0], create_elements)]\\n+                create_buffer = [\\n+                    LintFix(\\\"create_before\\\", this_line[0], create_elements)\\n+                ]\\n                 return LintResult(\\n                     anchor=context.segment, fixes=delete_buffer + create_buffer\\n                 )\\n\",\"diff --git a/src/sqlfluff/rules/L018.py b/src/sqlfluff/rules/L018.py\\nindex 86f4b402b99..10bed5c1f16 100644\\n--- a/src/sqlfluff/rules/L018.py\\n+++ b/src/sqlfluff/rules/L018.py\\n@@ -102,7 +102,7 @@ def indent_size_up_to(segs):\\n                                 anchor=seg,\\n                                 fixes=[\\n                                     LintFix(\\n-                                        \\\"create\\\",\\n+                                        \\\"create_before\\\",\\n                                         seg,\\n                                         WhitespaceSegment(\\\" \\\" * (-indent_diff)),\\n                                     )\\n@@ -125,7 +125,7 @@ def indent_size_up_to(segs):\\n                                 # We can move it back, it's all whitespace\\n                                 fixes = [\\n                                     LintFix(\\n-                                        \\\"create\\\",\\n+                                        \\\"create_before\\\",\\n                                         seg,\\n                                         [WhitespaceSegment(with_indent_str)],\\n                                     )\\n@@ -137,7 +137,7 @@ def indent_size_up_to(segs):\\n                                 # We have to move it to a newline\\n                                 fixes = [\\n                                     LintFix(\\n-                                        \\\"create\\\",\\n+                                        \\\"create_before\\\",\\n                                         seg,\\n                                         [\\n                                             NewlineSegment(),\\n\",\"diff --git a/src/sqlfluff/rules/L019.py b/src/sqlfluff/rules/L019.py\\nindex 74448127f1e..5a3e5d1fb2b 100644\\n--- a/src/sqlfluff/rules/L019.py\\n+++ b/src/sqlfluff/rules/L019.py\\n@@ -185,7 +185,7 @@ def _eval(self, context: RuleContext) -> Optional[LintResult]:\\n                                 for d in memory[\\\"whitespace_deletions\\\"]\\n                             ],\\n                             LintFix(\\n-                                \\\"create\\\",\\n+                                \\\"create_before\\\",\\n                                 anchor=self._get_following_seg(\\n                                     context.raw_stack, last_code_seg\\n                                 ),\\n@@ -220,7 +220,7 @@ def _eval(self, context: RuleContext) -> Optional[LintResult]:\\n                         fixes=[\\n                             LintFix(\\\"delete\\\", anchor=last_comma_seg),\\n                             LintFix(\\n-                                \\\"create\\\",\\n+                                \\\"create_before\\\",\\n                                 anchor=context.segment,\\n                                 edit=[last_comma_seg, new_whitespace_seg],\\n                             ),\\n\",\"diff --git a/src/sqlfluff/rules/L022.py b/src/sqlfluff/rules/L022.py\\nindex a8300947e65..b1f5746ee0c 100644\\n--- a/src/sqlfluff/rules/L022.py\\n+++ b/src/sqlfluff/rules/L022.py\\n@@ -132,7 +132,7 @@ def _eval(self, context: RuleContext) -> Optional[List[LintResult]]:\\n \\n                     # Based on the current location of the comma we insert newlines\\n                     # to correct the issue.\\n-                    fix_type = \\\"create\\\"  # In most cases we just insert newlines.\\n+                    fix_type = \\\"create_before\\\"  # In most cases we just insert newlines.\\n                     if comma_style == \\\"oneline\\\":\\n                         # Here we respect the target comma style to insert at the relevant point.\\n                         if self.comma_style == \\\"trailing\\\":\\n\",\"diff --git a/src/sqlfluff/rules/L023.py b/src/sqlfluff/rules/L023.py\\nindex e0f0553644d..e8aad35ccd1 100644\\n--- a/src/sqlfluff/rules/L023.py\\n+++ b/src/sqlfluff/rules/L023.py\\n@@ -71,7 +71,7 @@ def _eval(self, context: RuleContext) -> Optional[List[LintResult]]:\\n                                 # There's nothing between. Just add a whitespace\\n                                 fixes = [\\n                                     LintFix(\\n-                                        \\\"create\\\",\\n+                                        \\\"create_before\\\",\\n                                         seg,\\n                                         [WhitespaceSegment()],\\n                                     )\\n\",\"diff --git a/src/sqlfluff/rules/L036.py b/src/sqlfluff/rules/L036.py\\nindex 6318dbc140c..d6f84111e27 100644\\n--- a/src/sqlfluff/rules/L036.py\\n+++ b/src/sqlfluff/rules/L036.py\\n@@ -148,7 +148,7 @@ def _eval_multiple_select_target_elements(self, select_targets_info, segment):\\n                     loop_while=lambda s: s.is_type(\\\"whitespace\\\", \\\"comma\\\") or s.is_meta,\\n                 )\\n                 fixes += [LintFix(\\\"delete\\\", ws) for ws in ws_to_delete]\\n-                fixes.append(LintFix(\\\"create\\\", select_target, NewlineSegment()))\\n+                fixes.append(LintFix(\\\"create_before\\\", select_target, NewlineSegment()))\\n \\n             # If we are at the last select target check if the FROM clause\\n             # is on the same line, and if so move it to its own line.\\n@@ -165,7 +165,9 @@ def _eval_multiple_select_target_elements(self, select_targets_info, segment):\\n                     )\\n                     fixes.append(\\n                         LintFix(\\n-                            \\\"create\\\", select_targets_info.from_segment, NewlineSegment()\\n+                            \\\"create_before\\\",\\n+                            select_targets_info.from_segment,\\n+                            NewlineSegment(),\\n                         )\\n                     )\\n \\n@@ -406,7 +408,9 @@ def _eval_single_select_target_element(\\n                 ]\\n                 fixes.append(\\n                     LintFix(\\n-                        \\\"create\\\", select_targets_info.from_segment, NewlineSegment()\\n+                        \\\"create_before\\\",\\n+                        select_targets_info.from_segment,\\n+                        NewlineSegment(),\\n                     )\\n                 )\\n                 return LintResult(anchor=select_clause, fixes=fixes)\\n\",\"diff --git a/src/sqlfluff/rules/L037.py b/src/sqlfluff/rules/L037.py\\nindex b587d3d3768..32e3998b72f 100644\\n--- a/src/sqlfluff/rules/L037.py\\n+++ b/src/sqlfluff/rules/L037.py\\n@@ -102,7 +102,7 @@ def _eval(self, context: RuleContext) -> Optional[List[LintResult]]:\\n                     # Since ASC is default in SQL, add in ASC for fix\\n                     lint_fixes.append(\\n                         LintFix(\\n-                            \\\"create\\\",\\n+                            \\\"create_before\\\",\\n                             col_info.separator,\\n                             [WhitespaceSegment(), KeywordSegment(\\\"ASC\\\")],\\n                         )\\n\",\"diff --git a/src/sqlfluff/rules/L041.py b/src/sqlfluff/rules/L041.py\\nindex 80d3cd38c1a..cb8c5092136 100644\\n--- a/src/sqlfluff/rules/L041.py\\n+++ b/src/sqlfluff/rules/L041.py\\n@@ -78,7 +78,7 @@ def _eval(self, context: RuleContext) -> Optional[LintResult]:\\n                 # E.g. \\\"\\\\n\\\" -> \\\" DISTINCT\\\\n.\\n                 LintFix(\\\"delete\\\", newline_between),\\n                 LintFix(\\n-                    \\\"create\\\",\\n+                    \\\"create_before\\\",\\n                     context.segment.segments[newline_idx + 1],\\n                     replace_newline_with,\\n                 ),\\n\",\"diff --git a/src/sqlfluff/rules/L051.py b/src/sqlfluff/rules/L051.py\\nindex 903be7904c3..75e028200e3 100644\\n--- a/src/sqlfluff/rules/L051.py\\n+++ b/src/sqlfluff/rules/L051.py\\n@@ -48,7 +48,7 @@ def _eval(self, context: RuleContext) -> Optional[LintResult]:\\n             context.segment.segments[0],\\n             fixes=[\\n                 LintFix(\\n-                    \\\"create\\\",\\n+                    \\\"create_before\\\",\\n                     context.segment.segments[0],\\n                     [KeywordSegment(\\\"INNER\\\"), WhitespaceSegment()],\\n                 )\\n\",\"diff --git a/src/sqlfluff/rules/L052.py b/src/sqlfluff/rules/L052.py\\nindex 74536d35608..fdfb14d315e 100644\\n--- a/src/sqlfluff/rules/L052.py\\n+++ b/src/sqlfluff/rules/L052.py\\n@@ -89,7 +89,9 @@ def _eval(self, context: RuleContext) -> Optional[LintResult]:\\n \\n                 if len(newline_deletions) == 0:\\n                     # Create missing newline.\\n-                    fixes.append(LintFix(\\\"create\\\", context.segment, NewlineSegment()))\\n+                    fixes.append(\\n+                        LintFix(\\\"create_before\\\", context.segment, NewlineSegment())\\n+                    )\\n                 if len(newline_deletions) > 1:\\n                     # Remove excess newlines.\\n                     fixes.extend(LintFix(\\\"delete\\\", d) for d in newline_deletions[1:])\\n@@ -104,25 +106,9 @@ def _eval(self, context: RuleContext) -> Optional[LintResult]:\\n         # this rule looks to enforce that it is there.\\n         # Therefore we first locate the end of the file.\\n         if self.require_final_semicolon:\\n-            if len(self.filter_meta(context.siblings_post)) > 0:\\n-                # This can only fail on the last segment\\n+            # We only care about the final segment of the parse tree.\\n+            if not self.is_final_segment(context):\\n                 return None\\n-            elif len(context.segment.segments) > 0:\\n-                # This can only fail on the last base segment\\n-                return None\\n-            elif context.segment.is_meta:\\n-                # We can't fail on a meta segment\\n-                return None\\n-            else:\\n-                # So this looks like the end of the file, but we\\n-                # need to check that each parent segment is also the last.\\n-                # We do this with reference to the templated file, because it's\\n-                # the best we can do given the information available.\\n-                file_len = len(context.segment.pos_marker.templated_file.templated_str)\\n-                pos = context.segment.pos_marker.templated_slice.stop\\n-                # Does the length of the file equal the end of the templated position?\\n-                if file_len != pos:\\n-                    return None\\n \\n             # Include current segment for complete stack.\\n             complete_stack: List[BaseSegment] = list(context.raw_stack)\\n\"]", "test_patch": "[\"diff --git a/test/core/rules/config_test.py b/test/core/rules/config_test.py\\nindex d062cb1ecb6..836ca68eb60 100644\\n--- a/test/core/rules/config_test.py\\n+++ b/test/core/rules/config_test.py\\n@@ -29,7 +29,7 @@ def _eval(self, context):\\n         if context.segment.is_type(\\\"star\\\"):\\n             return LintResult(\\n                 anchor=context.segment,\\n-                fixes=[LintFix(\\\"create\\\", context.segment, NewlineSegment())],\\n+                fixes=[LintFix(\\\"create_before\\\", context.segment, NewlineSegment())],\\n             )\\n \\n \\n\",\"diff --git a/test/rules/std_L009_L052_test.py b/test/rules/std_L009_L052_test.py\\nnew file mode 100644\\nindex 00000000000..eb2804010f3\\n--- /dev/null\\n+++ b/test/rules/std_L009_L052_test.py\\n@@ -0,0 +1,23 @@\\n+\\\"\\\"\\\"Tests the python routines within L009 and L052.\\\"\\\"\\\"\\n+from sqlfluff.core import FluffConfig\\n+from sqlfluff.core import Linter\\n+\\n+\\n+def test__rules__std_L009_and_L052_interaction() -> None:\\n+    \\\"\\\"\\\"Test interaction between L009 and L052 doesn't stop L052 from being applied.\\\"\\\"\\\"\\n+    # Test sql with no final newline and no final semicolon.\\n+    sql = \\\"SELECT foo FROM bar\\\"\\n+\\n+    # Ensure final semicolon requirement is active.\\n+    cfg = FluffConfig()\\n+    cfg.set_value(config_path=[\\\"rules\\\", \\\"L052\\\", \\\"require_final_semicolon\\\"], val=True)\\n+    linter = Linter(config=cfg)\\n+\\n+    # Return linted/fixed file.\\n+    linted_file = linter.lint_string(sql, fix=True)\\n+\\n+    # Check expected lint errors are raised.\\n+    assert set([v.rule.code for v in linted_file.violations]) == {\\\"L009\\\", \\\"L052\\\"}\\n+\\n+    # Check file is fixed.\\n+    assert linted_file.fix_string()[0] == \\\"SELECT foo FROM bar;\\\\n\\\"\"]", "hints_text": ""}

{"instance_id": "1042812134659325", "repo": "maxfischer2781/bootpeg", "base_commit": "cbf7973b92b942c340f842522d2d44227d7ff344", "problem_statement": "Add start/end of source terminals:\\nSimilar to the special terminals ``Anything``/``.``, ``Nothing``/``ε``, add terminals for start and end of the source. These should implicitly match at start/end position, respectively.\\r\\n\\r\\nPossible standard symbols are the RegEx ``^``/``$`` for start/end.", "FAIL_TO_PASS": ["tests/test_examples/test_math.py::test_parsing[12.5"], "PASS_TO_PASS": ["tests/test_grammars/test_bpeg.py::test_roundtrip[clause6]", "tests/test_examples/test_math.py::test_parsing[-3/4-expected2]", "tests/test_grammars/test_peg.py::test_roundtrip[clause6]", "tests/test_helpers.py::test_unescape[u16]", "tests/test_grammars/test_bpeg.py::test_roundtrip[clause13]", "tests/test_grammars/test_peg.py::test_roundtrip[clause1]", "tests/test_grammars/test_peg.py::test_parse_short", "tests/test_grammars/test_bpeg.py::test_roundtrip[clause3]", "tests/test_grammars/test_bpeg.py::test_multiuse_actions[a]", "tests/test_grammars/test_bpeg.py::test_roundtrip[clause8]", "tests/test_grammars/test_peg.py::test_roundtrip[clause0]", "tests/test_grammars/test_peg.py::test_roundtrip[clause3]", "tests/test_grammars/test_peg.py::test_roundtrip[clause10]", "tests/test_grammars/test_bpeg.py::test_roundtrip[clause10]", "tests/test_helpers.py::test_unescape[octal]", "tests/test_grammars/test_bpeg.py::test_roundtrip[clause4]", "tests/test_grammars/test_bpeg.py::test_roundtrip[clause2]", "tests/test_grammars/test_peg.py::test_roundtrip[clause9]", "tests/test_examples/test_math.py::test_parsing[8", "tests/test_grammars/test_bpeg.py::test_multiuse_actions[bcde]", "tests/test_boot.py::test_bootstrap", "tests/test_grammars/test_peg.py::test_roundtrip[clause12]", "tests/test_grammars/test_bpeg.py::test_roundtrip[clause12]", "tests/test_grammars/test_peg.py::test_roundtrip[clause4]", "tests/test_grammars/test_bpeg.py::test_roundtrip[clause15]", "tests/test_examples/test_math.py::test_parsing[1-expected0]", "tests/test_grammars/test_peg.py::test_parse_reference", "tests/test_grammars/test_peg.py::test_roundtrip[clause14]", "tests/test_examples/test_math.py::test_parsing[2/2-expected1]", "tests/test_grammars/test_bpeg.py::test_roundtrip[clause5]", "tests/test_grammars/test_peg.py::test_roundtrip[clause13]", "tests/test_grammars/test_bpeg.py::test_roundtrip[clause14]", "tests/test_grammars/test_peg.py::test_roundtrip[clause2]", "tests/test_grammars/test_bpeg.py::test_roundtrip[clause11]", "tests/test_examples/test_math.py::test_as_main", "tests/test_grammars/test_bpeg.py::test_roundtrip[clause1]", "tests/test_grammars/test_bpeg.py::test_roundtrip[clause0]", "tests/test_grammars/test_bpeg.py::test_not_anything", "tests/test_examples/test_math.py::test_parsing[-3/-4-expected4]", "tests/test_grammars/test_peg.py::test_roundtrip[clause11]", "tests/test_grammars/test_bpeg.py::test_commit[top:\\n", "tests/test_examples/test_math.py::test_parsing[3/-4-expected3]", "tests/test_grammars/test_bpeg.py::test_roundtrip[clause9]", "tests/test_grammars/test_peg.py::test_roundtrip[clause7]", "tests/test_grammars/test_peg.py::test_roundtrip[clause8]", "tests/test_grammars/test_peg.py::test_roundtrip[clause5]", "tests/test_helpers.py::test_unescape[named]", "tests/test_examples/test_math.py::test_parsing[3.5", "tests/test_grammars/test_bpeg.py::test_roundtrip[clause7]"], "language": "python", "test_command": "source /saved/ENV || source /saved/*/ENV && pytest --no-header -rA --tb=no -p no:cacheprovider --continue-on-collection-errors", "test_output_parser": "python/parse_log_pytest_v3", "image_storage_uri": "vmvm-registry.fbinfra.net/repomate_image_activ_pytest/maxfischer2781_bootpeg:cbf7973b92b942c340f842522d2d44227d7ff344", "patch": "", "test_patch": "[\"diff --git a/tests/test_boot.py b/tests/test_boot.py\\nindex 50d7c04..ae91072 100644\\n--- a/tests/test_boot.py\\n+++ b/tests/test_boot.py\\n@@ -1,30 +1,25 @@\\n+import importlib_resources\\n+import pickle\\n+\\n import pytest\\n \\n-from bootpeg.pika import boot\\n+from bootpeg import create_parser, bootpeg_actions\\n+from bootpeg.apegs import boot\\n \\n \\n def test_bootstrap():\\n-    boot_peg = boot.boot_path.read_text()\\n-    parser = boot.min_parser\\n+    source = importlib_resources.read_text(\\\"bootpeg.grammars\\\", \\\"bpeg.bpeg\\\")\\n+    parser = boot.boot_parser\\n     # ensure each parser handles itself\\n-    for _ in range(2):\\n-        parser = boot.boot(parser, boot_peg)\\n+    for _ in range(5):\\n+        parser = create_parser(source, parser, bootpeg_actions)\\n \\n \\n-def test_escalate():\\n-    full_peg = boot.full_path.read_text()\\n-    parser = boot.bootpeg()\\n+@pytest.mark.parametrize(\\\"protocol\\\", list(range(2, pickle.HIGHEST_PROTOCOL + 1)))\\n+def test_pickle(protocol):\\n+    \\\"\\\"\\\"Ensure that parsers can be pickled\\\"\\\"\\\"\\n+    source = importlib_resources.read_text(\\\"bootpeg.grammars\\\", \\\"bpeg.bpeg\\\")\\n+    parser = boot.boot_parser\\n     for _ in range(2):\\n-        parser = boot.boot(parser, full_peg)\\n-\\n-\\n-def test_features():\\n-    full_peg = boot.full_path.read_text()\\n-    parser = boot.boot(boot.bootpeg(), full_peg)\\n-    opt_repeat = boot.boot(parser, 'rule:\\\\n    | [ \\\" \\\"+ ]\\\\n')\\n-    non_repeat = boot.boot(parser, 'rule:\\\\n    | \\\" \\\"*\\\\n')\\n-    assert opt_repeat.clauses == non_repeat.clauses\\n-    with pytest.raises(TypeError):\\n-        boot.boot(parser, 'rule:\\\\n    | [ \\\" \\\"+ ] { .missing }\\\\n')\\n-    with pytest.raises(TypeError):\\n-        boot.boot(parser, 'rule:\\\\n    | extra=([ \\\" \\\"+ ]) { () }\\\\n')\\n+        parser = pickle.loads(pickle.dumps(parser, protocol=protocol))\\n+        parser = create_parser(source, parser, bootpeg_actions)\\n\",\"diff --git a/tests/test_examples/test_math.py b/tests/test_examples/test_math.py\\nindex 277f178..517f231 100644\\n--- a/tests/test_examples/test_math.py\\n+++ b/tests/test_examples/test_math.py\\n@@ -26,7 +26,7 @@ def test_as_main():\\n     (\\\"-3/-4\\\", math.Rational(False, 3, 4)),\\n     (\\\"3.5 * -2\\\", math.Rational(True, 7, 1)),\\n     (\\\"12.5 - 2 + 3.5\\\", math.Rational(False, 14, 1)),\\n-    # (\\\"12.5 + 3.5 - 2\\\", math.Rational(False, 14, 1)),\\n+    (\\\"12.5 + 3.5 - 2\\\", math.Rational(False, 14, 1)),\\n     (\\\"8 - 2 - 2 - 2 - 2\\\", math.Rational(False, 0, 1)),\\n     (\\\"8 + 2 + 2 + 2 + 2\\\", math.Rational(False, 16, 1)),\\n ]\\n\",\"diff --git a/tests/test_grammars/test_bpeg.py b/tests/test_grammars/test_bpeg.py\\nindex e93174b..3acc8ba 100644\\n--- a/tests/test_grammars/test_bpeg.py\\n+++ b/tests/test_grammars/test_bpeg.py\\n@@ -2,37 +2,44 @@\\n \\n from bootpeg import create_parser\\n from bootpeg.grammars import bpeg\\n-from bootpeg.pika.front import (\\n-    Rule,\\n-    Literal,\\n-    Nothing,\\n-    Anything,\\n+\\n+from bootpeg.apegs import (\\n+    Value,\\n+    Range,\\n+    Any,\\n+    Empty,\\n     Sequence,\\n     Choice,\\n     Repeat,\\n-    Not,\\n     And,\\n+    Not,\\n+    Entail,\\n+    Capture,\\n+    Transform,\\n     Reference,\\n-    Range,\\n-    Delimited,\\n-    CapturedParseFailure,\\n+    Rule,\\n+    ParseFailure,\\n )\\n \\n \\n clauses = [\\n-    Nothing(),\\n-    Anything(1),\\n-    *(Literal(literal) for literal in (\\\"A\\\", \\\"x\\\", \\\"ß\\\", \\\" \\\")),\\n-    Sequence(Literal(\\\"A\\\"), Literal(\\\"B\\\"), Literal(\\\"A\\\")),\\n-    Sequence(Literal(\\\" \\\"), Literal(\\\" \\\")),\\n-    Choice(Literal(\\\"a\\\"), Literal(\\\"b\\\"), Nothing()),\\n-    Repeat(Literal(\\\"x\\\")),\\n-    Repeat(Sequence(Literal(\\\"x\\\"), Literal(\\\"y\\\"), Literal(\\\"z\\\"))),\\n-    Not(Literal(\\\"a\\\")),\\n-    And(Literal(\\\"a\\\")),\\n+    Empty(),\\n+    Any(1),\\n+    *(Value(literal) for literal in (\\\"A\\\", \\\"x\\\", \\\"ß\\\", \\\" \\\")),\\n+    Sequence(Value(\\\"A\\\"), Value(\\\"B\\\"), Value(\\\"A\\\")),\\n+    Sequence(Value(\\\" \\\"), Value(\\\" \\\")),\\n+    Choice(Value(\\\"a\\\"), Value(\\\"b\\\"), Empty()),\\n+    Repeat(Value(\\\"x\\\")),\\n+    Repeat(Sequence(Value(\\\"x\\\"), Value(\\\"y\\\"), Value(\\\"z\\\"))),\\n+    Not(Value(\\\"a\\\")),\\n+    And(Value(\\\"a\\\")),\\n     Reference(\\\"some_rule\\\"),\\n     Range(\\\"a\\\", \\\"b\\\"),\\n-    Delimited(Literal(\\\"'\\\"), Literal(\\\"'\\\")),\\n+    Entail(Value(\\\"a\\\"), Value(\\\"b\\\")),\\n+    Sequence(Value(\\\"head\\\"), Entail(Value(\\\"a\\\"), Value(\\\"b\\\"))),\\n+    Capture(Value(\\\"expr\\\"), \\\"name\\\", True),\\n+    Capture(Value(\\\"expr\\\"), \\\"name\\\", False),\\n+    Transform(Value(\\\"body\\\"), \\\"{True}\\\"),\\n ]\\n \\n \\n@@ -41,40 +48,34 @@ def test_roundtrip(clause):\\n     clause = clause\\n     literal = bpeg.unparse(clause)\\n     assert literal\\n-    parsed_rule: Rule = bpeg.parse(f\\\"parse_test:\\\\n    | {literal}\\\\n\\\").clauses[\\n-        \\\"parse_test\\\"\\n-    ]\\n-    assert parsed_rule.sub_clauses[0] == clause\\n+    parsed_rule: Rule = bpeg.parse(f\\\"parse_test:\\\\n    | {literal}\\\\n\\\").rules[0]\\n+    assert parsed_rule.sub_clause.sub_clauses[0] == clause\\n \\n \\n-commit_failures = ((\\\"top:\\\\n | ~\\\\n\\\", {9}),)\\n+commit_failures = ((\\\"top:\\\\n | ~\\\\n\\\", 9),)\\n \\n \\n-@pytest.mark.parametrize(\\\"source, positions\\\", commit_failures)\\n-def test_commit(source, positions):\\n+@pytest.mark.parametrize(\\\"source, position\\\", commit_failures)\\n+def test_commit(source, position):\\n     try:\\n         bpeg.parse(source)\\n-    except CapturedParseFailure as cpf:\\n-        assert cpf.positions == positions\\n+    except ParseFailure as pf:\\n+        assert pf.index == position\\n     else:\\n-        assert not positions, \\\"Expected parse failures, found none\\\"\\n+        assert not position, \\\"Expected parse failures, found none\\\"\\n \\n \\n @pytest.mark.parametrize(\\\"source\\\", [\\\"a\\\", \\\"bcde\\\"])\\n def test_multiuse_actions(source):\\n     \\\"\\\"\\\"Test that using the same capture multiple times is valid\\\"\\\"\\\"\\n-    multiuse_parse = create_parser(\\n-        \\\"top:\\\\n    | a=(.*) { (.a, .a) }\\\\n\\\", bpeg, actions={}\\n-    )\\n+    multiuse_parse = create_parser(\\\"top:\\\\n    | a=(.*) { (a, a) }\\\\n\\\", bpeg)\\n     result = multiuse_parse(source)\\n     assert result == (source, source)\\n \\n \\n def test_not_anything():\\n-    \\\"\\\"\\\"Test that ``Anything`` does not match after the end\\\"\\\"\\\"\\n-    not_anything_parse = create_parser(\\n-        \\\"top:\\\\n    | a=(.) !. { (.a) }\\\\n\\\", bpeg, actions={}\\n-    )\\n+    \\\"\\\"\\\"Test that ``Any`` does not match after the end\\\"\\\"\\\"\\n+    not_anything_parse = create_parser(\\\"top:\\\\n    | a=(.) !. { (a) }\\\\n\\\", bpeg)\\n     assert not_anything_parse(\\\"b\\\") == \\\"b\\\"\\n-    with pytest.raises(Exception):\\n+    with pytest.raises(ParseFailure):\\n         not_anything_parse(\\\"bb\\\")\\n\",\"diff --git a/tests/test_grammars/test_peg.py b/tests/test_grammars/test_peg.py\\nindex a04c78d..66fce15 100644\\n--- a/tests/test_grammars/test_peg.py\\n+++ b/tests/test_grammars/test_peg.py\\n@@ -4,35 +4,43 @@\\n \\n from bootpeg import create_parser\\n from bootpeg.grammars import peg\\n-from bootpeg.pika.front import (\\n-    Rule,\\n-    Literal,\\n-    Nothing,\\n-    Anything,\\n+from bootpeg.apegs import (\\n+    Value,\\n+    Range,\\n+    Any,\\n+    Empty,\\n     Sequence,\\n     Choice,\\n     Repeat,\\n-    Not,\\n     And,\\n+    Not,\\n+    Entail,\\n+    Capture,\\n+    Transform,\\n     Reference,\\n-    Range,\\n-    Delimited,\\n+    Rule,\\n+    Parser,\\n )\\n \\n \\n roundtrip_clauses = [\\n-    Nothing(),\\n-    Anything(1),\\n-    *(Literal(literal) for literal in (\\\"A\\\", \\\"x\\\", \\\"ß\\\", \\\" \\\")),\\n-    Sequence(Literal(\\\"A\\\"), Literal(\\\"B\\\"), Literal(\\\"A\\\")),\\n-    Sequence(Literal(\\\" \\\"), Literal(\\\" \\\")),\\n-    Choice(Literal(\\\"a\\\"), Literal(\\\"b\\\"), Nothing()),\\n-    Repeat(Literal(\\\"x\\\")),\\n-    Repeat(Sequence(Literal(\\\"x\\\"), Literal(\\\"y\\\"), Literal(\\\"z\\\"))),\\n-    Not(Literal(\\\"a\\\")),\\n-    And(Literal(\\\"a\\\")),\\n+    Empty(),\\n+    Any(1),\\n+    *(Value(literal) for literal in (\\\"A\\\", \\\"x\\\", \\\"ß\\\", \\\" \\\")),\\n+    Sequence(Value(\\\"A\\\"), Value(\\\"B\\\"), Value(\\\"A\\\")),\\n+    Sequence(Value(\\\" \\\"), Value(\\\" \\\")),\\n+    Choice(Value(\\\"a\\\"), Value(\\\"b\\\"), Empty()),\\n+    Repeat(Value(\\\"x\\\")),\\n+    Repeat(Sequence(Value(\\\"x\\\"), Value(\\\"y\\\"), Value(\\\"z\\\"))),\\n+    Not(Value(\\\"a\\\")),\\n+    And(Value(\\\"a\\\")),\\n     Reference(\\\"some_rule\\\"),\\n     Range(\\\"a\\\", \\\"b\\\"),\\n+    Entail(Value(\\\"a\\\"), Value(\\\"b\\\")),\\n+    Sequence(Value(\\\"head\\\"), Entail(Value(\\\"a\\\"), Value(\\\"b\\\"))),\\n+    Capture(Value(\\\"expr\\\"), \\\"name\\\", True),\\n+    Capture(Value(\\\"expr\\\"), \\\"name\\\", False),\\n+    Transform(Value(\\\"body\\\"), \\\"{True}\\\"),\\n ]\\n \\n \\n@@ -41,29 +49,8 @@ def test_roundtrip(clause):\\n     clause = clause\\n     literal = peg.unparse(clause)\\n     assert literal\\n-    parsed_rule: Rule = peg.parse(f\\\"parse_test <- {literal}\\\\n\\\").clauses[\\\"parse_test\\\"]\\n-    assert parsed_rule.sub_clauses[0] == clause\\n-\\n-\\n-emulated_clauses = [\\n-    (\\n-        Delimited(Literal(\\\"A\\\"), Literal(\\\"B\\\")),\\n-        Sequence(\\n-            Literal(\\\"A\\\"),\\n-            Choice(Repeat(Sequence(Not(Literal(\\\"B\\\")), Anything(1))), Nothing()),\\n-            Literal(\\\"B\\\"),\\n-        ),\\n-    ),\\n-]\\n-\\n-\\n-@pytest.mark.parametrize(\\\"clause, emulation\\\", emulated_clauses)\\n-def test_roundtrip_emulate(clause, emulation):\\n-    clause = clause\\n-    literal = peg.unparse(clause)\\n-    assert literal\\n-    parsed_rule: Rule = peg.parse(f\\\"parse_test <- {literal}\\\\n\\\").clauses[\\\"parse_test\\\"]\\n-    assert parsed_rule.sub_clauses[0] == emulation\\n+    parsed_rule: Rule = peg.parse(f\\\"parse_test <- {literal}\\\\n\\\").rules[0]\\n+    assert parsed_rule.sub_clause == clause\\n \\n \\n sys.setrecursionlimit(30000)\\n@@ -72,7 +59,7 @@ def test_roundtrip_emulate(clause, emulation):\\n # Some fixes due to errors in the original grammar\\n peg_grammar = r\\\"\\\"\\\"\\n # Hierarchical syntax\\n-Grammar    <- (Spacing Definition)+ # EndOfFile\\n+Grammar    <- (Spacing Definition)+ EndOfFile\\n Definition <- Identifier LEFTARROW Expression Spacing\\n \\n Expression <- Sequence (SLASH Sequence)*\\n@@ -119,8 +106,13 @@ def test_roundtrip_emulate(clause, emulation):\\n \\n def test_parse_reference():\\n     \\\"\\\"\\\"Parse the PEG reference grammar\\\"\\\"\\\"\\n-    parse = create_parser(peg_grammar, actions={}, dialect=peg, top=\\\"Grammar\\\")\\n-    assert parse(peg_grammar)\\n+    parse = create_parser(peg_grammar, dialect=peg)\\n+    # reference PEG does not understand results, but bootpeg requires them\\n+    parse = Parser(\\n+        Rule(parse.rules[0].name, Transform(parse.rules[0].sub_clause, \\\"()\\\")),\\n+        *parse.rules[1:],\\n+    )\\n+    assert parse(peg_grammar) == ()\\n \\n \\n def test_parse_short():\\n\",\"diff --git a/tests/test_helpers.py b/tests/test_helpers.py\\nindex fe59ca6..1cbfa03 100644\\n--- a/tests/test_helpers.py\\n+++ b/tests/test_helpers.py\\n@@ -1,6 +1,6 @@\\n import pytest\\n \\n-from bootpeg.pika.front import unescape\\n+from bootpeg.grammars.peg import unescape\\n \\n \\n named_escapes = [\"]", "hints_text": ""}

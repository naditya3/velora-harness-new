{"instance_id": "1253286512864748", "repo": "starsimhub/starsim", "base_commit": "1bb2fddaa15d5e9cf39ddc1f51145b99bcfcb54c", "problem_statement": "Refactor RNG PPF revisions:\\nIssues arising from #420 :\\r\\n- [x] Convert `ss.random()` etc. into subclasses of `ss.Dist` rather than functions\\r\\n- [x] Move `filter` to `ss.bernoulli()` subclass\\r\\n- [ ] Make `ss.choice` CRN-safe (in general and in `syphilis.py`)\\r\\n- [ ] Write CRN-safe `randround`\\r\\n- [x] Handle missing slots more elegantly\\r\\n- [ ] Change defaults to `strict=True, auto=True` which auto-increments the RNG after use\\r\\n- [x] Tidy/check `has_array_pars` logic\\r\\n- [ ] Handle the many `TODO` comments\\r\\n- [ ] Check that `test_syphilis.py` is doing the right thing on this branch\\r\\n- [ ] Check performance (see below)\\r\\n\\r\\nSee also https://github.com/starsimhub/starsim/issues/408\\r\\n\\r\\nFor performance, currently this branch is much slower on `benchmark_full.py`, although this might have to do with that particular test, since other things don't seem to be slower (e.g. the test suite takes about 4.5 s on both this branch and `main`):\\r\\n```\\r\\npython benchmark_full.py \\r\\nStarsim 0.3.0 (2024-03-18) — © 2023-2024 by IDM\\r\\n—————————————————————\\r\\nAverage: 5296 ± 39 ms\\r\\n—————————————————————\\r\\n\\r\\n\\r\\nSwitched to branch 'main'\\r\\n\\r\\npython benchmark_full.py \\r\\nStarsim 0.2.10 (2024-03-18) — © 2023-2024 by IDM\\r\\n——————————————————————\\r\\nAverage: 3363 ± 221 ms\\r\\n——————————————————————\\r\\n```", "FAIL_TO_PASS": ["tests/test_random.py::test_jump", "tests/test_random.py::test_reset", "tests/test_dists.py::test_dist", "tests/test_syphilis.py::test_syph", "tests/test_random.py::test_random", "tests/test_dists.py::test_custom_dists", "tests/test_random.py::test_seed", "tests/test_distributions.py::test_basic", "tests/test_baselines.py::test_baseline", "tests/test_dists.py::test_dists", "tests/test_distributions.py::test_array", "tests/test_random.py::test_rvs", "tests/test_distributions.py::test_scalar", "tests/test_distributions.py::test_callable", "tests/test_syphilis.py::test_syph_intvs"], "PASS_TO_PASS": ["tests/test_simple.py::test_simple", "tests/test_diseases.py::test_ncd", "tests/test_simple.py::test_components", "tests/test_rngcontainer.py::test_seed", "tests/test_diseases.py::test_multidisease", "tests/test_base.py::test_networks", "tests/test_base.py::test_people", "tests/test_rngcontainer.py::test_order", "tests/test_demographics.py::test_constant_pop", "tests/test_dcp.py::test_dcp_until", "tests/test_simple.py::test_parallel", "tests/test_demographics.py::test_nigeria", "tests/test_simple.py::test_simple_vax", "tests/test_dists.py::test_scipy", "tests/test_dcp.py::test_dcp", "tests/test_samples.py::test_samples", "tests/test_simple.py::test_demo", "tests/test_diseases.py::test_gavi", "tests/test_base.py::test_microsim", "tests/test_samples.py::test_dataset", "tests/test_demographics.py::test_module_adding", "tests/test_rngcontainer.py::test_reset", "tests/test_base.py::test_ppl_construction", "tests/test_rngcontainer.py::test_jump", "tests/test_diseases.py::test_sir", "tests/test_baselines.py::test_benchmark", "tests/test_simple.py::test_default", "tests/test_simple.py::test_sir_epi"], "language": "python", "test_command": "source /saved/ENV || source /saved/*/ENV && pytest --no-header -rA --tb=no -p no:cacheprovider --continue-on-collection-errors", "test_output_parser": "python/parse_log_pytest_v3", "image_storage_uri": "vmvm-registry.fbinfra.net/repomate_image_activ_pytest/starsimhub_starsim:1bb2fddaa15d5e9cf39ddc1f51145b99bcfcb54c", "patch": "", "test_patch": "[\"diff --git a/starsim/interventions.py b/starsim/interventions.py\\nindex 7747e7b4..2822d94a 100644\\n--- a/starsim/interventions.py\\n+++ b/starsim/interventions.py\\n@@ -392,7 +392,7 @@ def get_accept_inds(self, sim):\\n         accept_uids = np.array([], dtype=int)\\r\\n         eligible_uids = self.check_eligibility(sim)  # Apply eligiblity\\r\\n         if len(eligible_uids):\\r\\n-            self.coverage_dist.kwds['p'] = self.prob[0]\\r\\n+            self.coverage_dist.set(p=self.prob[0])\\r\\n             accept_uids = self.coverage_dist.filter(eligible_uids)\\r\\n         return accept_uids\\r\\n \\r\\n@@ -498,7 +498,7 @@ def apply(self, sim):\\n             ti = sc.findinds(self.timepoints, sim.ti)[0]\\r\\n             prob = self.prob[ti]  # Get the proportion of people who will be tested this timestep\\r\\n             is_eligible = self.check_eligibility(sim)  # Check eligibility\\r\\n-            self.coverage_dist.kwds['p'] = prob\\r\\n+            self.coverage_dist.set(p=prob)\\r\\n             accept_uids = self.coverage_dist.filter(ss.true(is_eligible))\\r\\n \\r\\n             if len(accept_uids):\\r\\n\",\"diff --git a/tests/baseline.json b/tests/baseline.json\\nindex 3e8692d2..598ba2de 100644\\n--- a/tests/baseline.json\\n+++ b/tests/baseline.json\\n@@ -1,17 +1,17 @@\\n {\\n   \\\"summary\\\": {\\n-    \\\"n_alive\\\": 9662.104761904762,\\n-    \\\"new_deaths\\\": 6.866666666666666,\\n-    \\\"cum_deaths\\\": 706.0,\\n+    \\\"n_alive\\\": 9674.078431372549,\\n+    \\\"new_deaths\\\": 6.647058823529412,\\n+    \\\"cum_deaths\\\": 669.0,\\n     \\\"pregnancy_pregnancies\\\": 0.0,\\n     \\\"pregnancy_births\\\": 0.0,\\n     \\\"pregnancy_cbr\\\": 0.0,\\n     \\\"hiv_n_on_art\\\": 0.0,\\n-    \\\"hiv_n_susceptible\\\": 8879.514285714286,\\n-    \\\"hiv_n_infected\\\": 782.5904761904762,\\n-    \\\"hiv_prevalence\\\": 0.08107777762449975,\\n-    \\\"hiv_new_infections\\\": 14.761904761904763,\\n-    \\\"hiv_cum_infections\\\": 1546.0,\\n-    \\\"hiv_new_deaths\\\": 6.866666666666666\\n+    \\\"hiv_n_susceptible\\\": 8900.813725490196,\\n+    \\\"hiv_n_infected\\\": 773.2647058823529,\\n+    \\\"hiv_prevalence\\\": 0.07997036887697175,\\n+    \\\"hiv_new_infections\\\": 14.558823529411764,\\n+    \\\"hiv_cum_infections\\\": 1482.0,\\n+    \\\"hiv_new_deaths\\\": 6.647058823529412\\n   }\\n-}\\n+}\\n\\\\ No newline at end of file\\n\",\"diff --git a/tests/benchmark.json b/tests/benchmark.json\\nindex 4effebe5..eb4dc6c7 100644\\n--- a/tests/benchmark.json\\n+++ b/tests/benchmark.json\\n@@ -1,13 +1,13 @@\\n {\\n   \\\"time\\\": {\\n     \\\"people\\\": 0.001,\\n-    \\\"initialize\\\": 0.022,\\n-    \\\"run\\\": 0.28\\n+    \\\"initialize\\\": 0.028,\\n+    \\\"run\\\": 0.276\\n   },\\n   \\\"parameters\\\": {\\n     \\\"n_agents\\\": 10000,\\n     \\\"n_years\\\": 20,\\n     \\\"dt\\\": 0.2\\n   },\\n-  \\\"cpu_performance\\\": 0.9663878728158621\\n-}\\n+  \\\"cpu_performance\\\": 0.9093911904728096\\n+}\\n\\\\ No newline at end of file\\n\",\"diff --git a/tests/test_diseases.py b/tests/test_diseases.py\\nindex fc479b63..dc8bf92c 100644\\n--- a/tests/test_diseases.py\\n+++ b/tests/test_diseases.py\\n@@ -29,10 +29,10 @@ def test_sir():\\n     sir.pars.beta = {'random': 0.1}\\r\\n \\r\\n     # You can also change the parameters of the default lognormal distribution directly\\r\\n-    sir.pars.dur_inf.kwds.loc = 5\\r\\n+    sir.pars.dur_inf.set(loc=5)\\r\\n \\r\\n     # Or use a function, here a lambda that makes the mean for each agent equal to their age divided by 10\\r\\n-    sir.pars.dur_inf.kwds.loc = lambda self, sim, uids: sim.people.age[uids] / 10\\r\\n+    sir.pars.dur_inf.set(loc = lambda self, sim, uids: sim.people.age[uids] / 10)\\r\\n \\r\\n     sim = ss.Sim(people=ppl, diseases=sir, networks=networks)\\r\\n     sim.run()\\r\\n\",\"diff --git a/tests/test_distributions.py b/tests/test_distributions.py\\nindex a83ff2ab..d6fe2a49 100644\\n--- a/tests/test_distributions.py\\n+++ b/tests/test_distributions.py\\n@@ -18,7 +18,7 @@ def test_basic():\\n     \\\"\\\"\\\" Basic scipy.stats test \\\"\\\"\\\"\\n     sc.heading('Test basic scipy.stats usage')\\n     spsdist = sps.norm(loc=1, scale=1) # Make a distribution\\n-    d = ss.Dist(dist=spsdist).initialize() # Convert it to Starsim\\n+    d = ss.Dist(dist=spsdist).initialize(slots=np.arange(n)) # Convert it to Starsim\\n     sample = d.rvs(1)  # Draw a sample\\n \\n     # Draw some samples\\n@@ -29,7 +29,7 @@ def test_basic():\\n     # Draw UID samples\\n     d.reset()\\n     uids = np.array([0,3,4])\\n-    samples_uid = d.urvs(uids=uids)\\n+    samples_uid = d.rvs(uids)\\n     \\n     # Print and test\\n     for s in [sample, samples, samples_uid]:\\n@@ -47,11 +47,12 @@ def test_scalar(n=n):\\n \\n     loc = 1\\n     scale = 4\\n-    spsdist = sps.uniform(loc=loc, scale=scale)\\n-    d = ss.Dist(spsdist).initialize()\\n-\\n     uids = np.array([1,3,5,9])\\n-    draws = d.urvs(uids)\\n+    \\n+    spsdist = sps.uniform(loc=loc, scale=scale)\\n+    d = ss.Dist(spsdist).initialize(slots=np.arange(uids.max()+1))\\n+    \\n+    draws = d.rvs(uids)\\n     print(f'Uniform sample for uids {uids} returned {draws}')\\n \\n     assert len(draws) == len(uids), 'Incorrect number of draws'\\n@@ -68,21 +69,23 @@ def test_callable(n=n):\\n     np.random.seed(1) # Since not random number safe here!\\n     sim = sc.prettyobj()\\n     sim.n = 10\\n-    sim.uid = np.arange(sim.n)\\n-    sim.age = np.random.uniform(0, 90, size=sim.n)\\n+    sim.people = sc.prettyobj()\\n+    sim.people.uid = np.arange(sim.n)\\n+    sim.people.slot = np.arange(sim.n)\\n+    sim.people.age = np.random.uniform(0, 90, size=sim.n)\\n \\n     # Define a parameter as a lambda function\\n-    loc = lambda module, sim, uids: sim.age[uids]\\n+    loc = lambda module, sim, uids: sim.people.age[uids]\\n     scale = 1\\n     d = ss.normal(loc=loc).initialize(sim=sim)\\n \\n     uids = np.array([1, 3, 7, 9])\\n-    draws = d.urvs(uids)\\n-    print(f'Input ages were: {sim.age[uids]}')\\n+    draws = d.rvs(uids)\\n+    print(f'Input ages were: {sim.people.age[uids]}')\\n     print(f'Output samples were: {draws}')\\n \\n-    meandiff = np.abs(sim.age[uids] - draws).mean()\\n-    assert meandiff < scale\\n+    meandiff = np.abs(sim.people.age[uids] - draws).mean()\\n+    assert meandiff < scale*3\\n     return d\\n \\n \\n@@ -94,8 +97,8 @@ def test_array(n=n):\\n     low  = np.array([1, 100]) # Low\\n     high = np.array([3, 125]) # High\\n \\n-    d = ss.uniform(low=low, high=high).initialize()\\n-    draws = d.urvs(uids)\\n+    d = ss.uniform(low=low, high=high).initialize(slots=np.arange(uids.max()+1))\\n+    draws = d.rvs(uids)\\n     print(f'Uniform sample for uids {uids} returned {draws}')\\n \\n     assert len(draws) == len(uids)\\n@@ -118,7 +121,7 @@ def test_repeat_slot():\\n \\n     # Draw values\\n     d = ss.uniform(low=low, high=high).initialize()\\n-    draws = d.urvs(uids)\\n+    draws = d.rvs(uids)\\n     \\n     # Print and test\\n     print(f'Uniform sample for slots {slots} returned {draws}')\\n\",\"diff --git a/tests/test_dists.py b/tests/test_dists.py\\nindex 59c24d8b..32e044c4 100644\\n--- a/tests/test_dists.py\\n+++ b/tests/test_dists.py\\n@@ -31,7 +31,7 @@ def plot_rvs(rvs, times=None, nrows=None):\\n def test_dist(m=m):\\n     \\\"\\\"\\\" Test the Dist class \\\"\\\"\\\"\\n     sc.heading('Testing the basic Dist call')\\n-    dist = ss.Dist('random', 'test')\\n+    dist = ss.Dist(distname='random', name='test')\\n     dist.initialize()\\n     rvs = dist(m)\\n     print(rvs)\\n@@ -47,7 +47,7 @@ def test_custom_dists(n=n, do_plot=False):\\n     dists = sc.objdict()\\n     rvs = sc.objdict()\\n     times = sc.objdict()\\n-    for name in ss.dists.dist_list:\\n+    for name in ss.dist_list:\\n         func = getattr(ss, name)\\n         dist = func(name='test')\\n         dist.initialize()\\n@@ -77,8 +77,8 @@ def test_dists(n=n, do_plot=False):\\n         # Create a complex object containing various distributions\\n         obj = sc.prettyobj()\\n         obj.a = sc.objdict()\\n-        obj.a.mylist = [ss.random(), ss.Dist('uniform', low=2, high=3)]\\n-        obj.b = dict(d3=ss.weibull(a=2), d4=ss.delta(v=0.3))\\n+        obj.a.mylist = [ss.random(), ss.Dist(distname='uniform', low=2, high=3)]\\n+        obj.b = dict(d3=ss.weibull(c=2), d4=ss.delta(v=0.3))\\n         dists = ss.Dists(obj)\\n         \\n         # Call each distribution twice\\n\",\"diff --git a/tests/test_random.py b/tests/test_random.py\\nindex f02f5c82..d81b2f76 100644\\n--- a/tests/test_random.py\\n+++ b/tests/test_random.py\\n@@ -11,8 +11,7 @@\\n \\n def make_dist(seed=1, name='test', **kwargs):\\n     \\\"\\\"\\\" Make a default distribution for testing \\\"\\\"\\\"\\n-    dist = ss.Dist(dist='random', name=name, seed=seed, **kwargs)\\n-    dist.initialize()\\n+    dist = ss.Dist(distname='random', name=name, seed=seed, **kwargs)\\n     return dist\\n \\n \\n@@ -78,18 +77,21 @@ def test_seed(n=n):\\n     return draws0, draws1\\n \\n \\n-def test_urvs(n=n):\\n+def test_rvs(n=n):\\n     \\\"\\\"\\\" Simple sample from distribution by UID \\\"\\\"\\\"\\n     sc.heading('Testing UID sample')\\n     \\n+    slots = np.arange(n+1)\\n     dist = make_dist()\\n+    dist.initialize(slots=slots)\\n     uids = np.arange(0, n, 2) # every other to make it interesting\\n-    draws = dist.urvs(uids)\\n+    draws = dist.rvs(uids)\\n     print(f'Created seed and sampled: {draws}')\\n     assert len(draws) == len(uids)\\n     \\n     # Draws without UIDs should match the first element only\\n     dist2 = make_dist()\\n+    dist2.initialize(slots=slots)\\n     draws2 = dist2.rvs(len(uids))\\n     assert draws[0] == draws2[0]\\n     assert not np.array_equal(draws, draws2)\\n@@ -106,6 +108,6 @@ def test_urvs(n=n):\\n     o2 = test_reset(n)\\n     o3 = test_jump(n)\\n     o4 = test_seed(n)\\n-    o5 = test_urvs(n)\\n+    o5 = test_rvs(n)\\n \\n     T.toc()\\n\",\"diff --git a/tests/test_syphilis.py b/tests/test_syphilis.py\\nindex 70fe90dd..eae90a10 100644\\n--- a/tests/test_syphilis.py\\n+++ b/tests/test_syphilis.py\\n@@ -30,8 +30,8 @@ def make_syph_sim(dt=1, n_agents=500):\\n     # Marital\\r\\n     mf = ss.MFNet(\\r\\n         pars = dict(\\r\\n-            duration = ss.lognorm_o(mean=1/24, stdev=0.5),\\r\\n-            acts = ss.lognorm_o(mean=80, stdev=30),\\r\\n+            duration = ss.lognorm_ex(mean=1/24, stdev=0.5),\\r\\n+            acts = ss.lognorm_ex(mean=80, stdev=30),\\r\\n         )\\r\\n     )\\r\\n     maternal = ss.MaternalNet()\\r\\n\",\"diff --git a/tests/test_worlds.py b/tests/test_worlds.py\\nnew file mode 100644\\nindex 00000000..4ab92dd0\\n--- /dev/null\\n+++ b/tests/test_worlds.py\\n@@ -0,0 +1,121 @@\\n+\\\"\\\"\\\" Test minimally different worlds \\\"\\\"\\\"\\n+\\n+import sciris as sc\\n+import numpy as np\\n+import starsim as ss\\n+import pylab as pl\\n+\\n+\\n+class CountInf(ss.Intervention):\\n+    \\\"\\\"\\\" Store every infection state in a timepoints x people array \\\"\\\"\\\"\\n+    def initialize(self, sim):\\n+        n_agents = len(sim.people)\\n+        self.arr = np.zeros((sim.npts, n_agents))\\n+        self.n_agents = n_agents\\n+        return\\n+    \\n+    def apply(self, sim):\\n+        self.arr[sim.ti, :] = np.array(sim.diseases.sir.infected)[:self.n_agents]\\n+        return\\n+\\n+\\n+class OneMore(ss.Intervention):\\n+    \\\"\\\"\\\" Add one additional agent and infection \\\"\\\"\\\"\\n+    def apply(self, sim):\\n+        if sim.ti == 0:\\n+            # Create an extra agent\\n+            preg = ss.Pregnancy(rel_fertility=0) # Ensure no default births\\n+            preg.initialize(sim)\\n+            new_uids = np.array([len(sim.people)]) # Hack since make_embryos doesn't return UIDs\\n+            preg.make_embryos(sim, np.array([0])) # Assign 0th agent to be the \\\"mother\\\"\\n+            assert len(new_uids) == 1\\n+            sim.people.age[new_uids] = -100 # Set to a very low number to never reach debut age\\n+            \\n+            # Infect that agent\\n+            sir = sim.diseases.sir\\n+            sir.set_prognoses(sim, new_uids)\\n+            sir.ti_recovered[new_uids] = sim.ti + 1 # Reset recovery time to next timestep\\n+            \\n+            # Reset the random states\\n+            p = sir.pars\\n+            for dist in [p.dur_inf, p.p_death]:\\n+                dist.jump(sim.ti+1)\\n+\\n+        return\\n+\\n+\\n+def plot_infs(s1, s2):\\n+    \\\"\\\"\\\" Compare infection arrays from two sims \\\"\\\"\\\"\\n+    a1 = s1.interventions.countinf.arr\\n+    a2 = s2.interventions.countinf.arr\\n+    \\n+    fig = pl.figure()\\n+    pl.subplot(1,3,1)\\n+    pl.pcolormesh(a1.T)\\n+    pl.xlabel('Timestep')\\n+    pl.ylabel('Person')\\n+    pl.title('Baseline')\\n+    \\n+    pl.subplot(1,3,2)\\n+    pl.pcolormesh(a2.T)\\n+    pl.title('OneMore')\\n+    \\n+    pl.subplot(1,3,3)\\n+    pl.pcolormesh(a2.T - a1.T)\\n+    pl.title('Difference')\\n+    \\n+    sc.figlayout()\\n+    return fig\\n+\\n+\\n+def test_worlds(do_plot=False):\\n+    \\n+    res = sc.objdict()\\n+    \\n+    pars = dict(\\n+        start = 2000,\\n+        end = 2100,\\n+        n_agents = 200,\\n+        verbose = 0.05,\\n+        diseases = dict(\\n+            type = 'sir',\\n+            init_prev = 0.1,\\n+            beta = 1.0,\\n+            dur_inf = 20,\\n+            p_death = 0, # Here since analyzer can't handle variable numbers of people\\n+        ),\\n+        networks = dict(\\n+            type = 'embedding',\\n+            duration = 5, # Must be shorter than dur_inf for SIR transmission to occur\\n+        ),\\n+    )\\n+    s1 = ss.Sim(pars=pars, interventions=CountInf())\\n+    s2 = ss.Sim(pars=pars, interventions=[CountInf(), OneMore()])\\n+    \\n+    s1.run()\\n+    s2.run()\\n+    \\n+    sum1 = s1.summarize()\\n+    sum2 = s2.summarize()\\n+    res.sum1 = sum1\\n+    res.sum2 = sum2\\n+    \\n+    if do_plot:\\n+        s1.plot()\\n+        plot_infs(s1, s2)\\n+        pl.show()\\n+    \\n+    assert len(s2.people) == len(s1.people) + 1\\n+    assert sum2.sir_cum_infections == sum1.sir_cum_infections + 1\\n+    assert (s1.interventions.countinf.arr != s2.interventions.countinf.arr).sum() == 0\\n+        \\n+    return res\\n+    \\n+\\n+if __name__ == '__main__':\\n+    T = sc.timer()\\n+    do_plot = True\\n+    \\n+    res = test_worlds(do_plot=do_plot)\\n+    \\n+    T.toc()\\n\\\\ No newline at end of file\"]", "hints_text": ""}

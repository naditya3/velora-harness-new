{"instance_id": "1397321588170857", "repo": "ihmeuw/vivarium", "base_commit": "9a077fdbf0ddb8ec232c13d0175c4f451439973a", "problem_statement": "Simulation logging can't distinguish between unique simulation contexts:\\n`vivarium` is structured to allow multiple simulation contexts to live in a single python process, but logging is done in interactive settings with global loggers.  This means log messages can't distinguish between simulations if they're run from the same Python process.  E.g.\\r\\n```\\r\\n>>> from vivarium.examples.disease_model import get_disease_model_simulation\\r\\n>>> sim1 = get_disease_model_simulation()\\r\\n2023-02-25 14:54:45.034 | DEBUG    | vivarium.framework.values:register_value_modifier:392 - Registering metrics.1.results_manager.get_results as modifier to metrics\\r\\n2023-02-25 14:54:45.035 | DEBUG    | vivarium.framework.values:_register_value_producer:338 - Registering value pipeline mortality_rate\\r\\n2023-02-25 14:54:45.035 | DEBUG    | vivarium.framework.values:_register_value_producer:338 - Registering value pipeline lower_respiratory_infections.cause_specific_mortality_rate\\r\\n2023-02-25 14:54:45.035 | DEBUG    | vivarium.framework.values:register_value_modifier:392 - Registering mortality_rate.1.diseasemodel.lower_respiratory_infections.delete_cause_specific_mortality as modifier to mortality_rate\\r\\n2023-02-25 14:54:45.035 | DEBUG    | vivarium.framework.values:register_value_modifier:392 - Registering metrics.2.diseasemodel.lower_respiratory_infections.metrics as modifier to metrics\\r\\n2023-02-25 14:54:45.035 | DEBUG    | vivarium.framework.values:_register_value_producer:338 - Registering value pipeline susceptible_to_lower_respiratory_infections.excess_mortality_rate\\r\\n2023-02-25 14:54:45.035 | DEBUG    | vivarium.framework.values:_register_value_producer:338 - Registering value pipeline susceptible_to_lower_respiratory_infections.excess_mortality_rate.population_attributable_fraction\\r\\n2023-02-25 14:54:45.035 | DEBUG    | vivarium.framework.values:register_value_modifier:392 - Registering mortality_rate.2.diseasestate.susceptible_to_lower_respiratory_infections.add_in_excess_mortality as modifier to mortality_rate\\r\\n2023-02-25 14:54:45.036 | DEBUG    | vivarium.framework.values:_register_value_producer:338 - Registering value pipeline infected_with_lower_respiratory_infections.incidence_rate\\r\\n2023-02-25 14:54:45.036 | DEBUG    | vivarium.framework.values:_register_value_producer:338 - Registering value pipeline infected_with_lower_respiratory_infections.incidence_rate.population_attributable_fraction\\r\\n2023-02-25 14:54:45.036 | DEBUG    | vivarium.framework.values:_register_value_producer:338 - Registering value pipeline infected_with_lower_respiratory_infections.excess_mortality_rate\\r\\n2023-02-25 14:54:45.036 | DEBUG    | vivarium.framework.values:_register_value_producer:338 - Registering value pipeline infected_with_lower_respiratory_infections.excess_mortality_rate.population_attributable_fraction\\r\\n2023-02-25 14:54:45.036 | DEBUG    | vivarium.framework.values:register_value_modifier:392 - Registering mortality_rate.3.diseasestate.infected_with_lower_respiratory_infections.add_in_excess_mortality as modifier to mortality_rate\\r\\n2023-02-25 14:54:45.036 | DEBUG    | vivarium.framework.values:_register_value_producer:338 - Registering value pipeline infected_with_lower_respiratory_infections.remission_rate\\r\\n2023-02-25 14:54:45.037 | DEBUG    | vivarium.framework.values:_register_value_producer:338 - Registering value pipeline infected_with_lower_respiratory_infections.remission_rate.population_attributable_fraction\\r\\n2023-02-25 14:54:45.037 | DEBUG    | vivarium.framework.values:_register_value_producer:338 - Registering value pipeline child_wasting.base_proportion_exposed\\r\\n2023-02-25 14:54:45.037 | DEBUG    | vivarium.framework.values:_register_value_producer:338 - Registering value pipeline child_wasting.proportion_exposed\\r\\n2023-02-25 14:54:45.037 | DEBUG    | vivarium.framework.values:_register_value_producer:338 - Registering value pipeline child_wasting.exposure\\r\\n2023-02-25 14:54:45.037 | DEBUG    | vivarium.framework.values:_register_value_producer:338 - Registering value pipeline effect_of_child_wasting_on_infected_with_lower_respiratory_infections.incidence_rate.relative_risk\\r\\n2023-02-25 14:54:45.038 | DEBUG    | vivarium.framework.values:register_value_modifier:392 - Registering infected_with_lower_respiratory_infections.incidence_rate.population_attributable_fraction.1.effect_of_child_wasting_on_infected_with_lower_respiratory_infections.incidence_rate.population_attributable_fraction as modifier to infected_with_lower_respiratory_infections.incidence_rate.population_attributable_fraction\\r\\n2023-02-25 14:54:45.038 | DEBUG    | vivarium.framework.values:register_value_modifier:392 - Registering infected_with_lower_respiratory_infections.incidence_rate.1.effect_of_child_wasting_on_infected_with_lower_respiratory_infections.incidence_rate.rate_adjustment as modifier to infected_with_lower_respiratory_infections.incidence_rate\\r\\n2023-02-25 14:54:45.038 | DEBUG    | vivarium.framework.values:register_value_modifier:392 - Registering child_wasting.proportion_exposed.1.sqlns.intervention_effect as modifier to child_wasting.proportion_exposed\\r\\n2023-02-25 14:54:45.038 | DEBUG    | vivarium.framework.values:_register_value_producer:338 - Registering value pipeline sqlns.effect_size\\r\\n2023-02-25 14:54:45.038 | DEBUG    | vivarium.framework.values:register_value_modifier:392 - Registering metrics.3.observer.metrics as modifier to metrics\\r\\n2023-02-25 14:54:45.038 | DEBUG    | vivarium.framework.values:_register_value_producer:338 - Registering value pipeline metrics\\r\\n>>> sim2 = get_disease_model_simulation()\\r\\n2023-02-25 14:54:56.029 | DEBUG    | vivarium.framework.values:register_value_modifier:392 - Registering metrics.1.results_manager.get_results as modifier to metrics\\r\\n2023-02-25 14:54:56.029 | DEBUG    | vivarium.framework.values:_register_value_producer:338 - Registering value pipeline mortality_rate\\r\\n2023-02-25 14:54:56.029 | DEBUG    | vivarium.framework.values:_register_value_producer:338 - Registering value pipeline lower_respiratory_infections.cause_specific_mortality_rate\\r\\n2023-02-25 14:54:56.030 | DEBUG    | vivarium.framework.values:register_value_modifier:392 - Registering mortality_rate.1.diseasemodel.lower_respiratory_infections.delete_cause_specific_mortality as modifier to mortality_rate\\r\\n2023-02-25 14:54:56.030 | DEBUG    | vivarium.framework.values:register_value_modifier:392 - Registering metrics.2.diseasemodel.lower_respiratory_infections.metrics as modifier to metrics\\r\\n2023-02-25 14:54:56.030 | DEBUG    | vivarium.framework.values:_register_value_producer:338 - Registering value pipeline susceptible_to_lower_respiratory_infections.excess_mortality_rate\\r\\n2023-02-25 14:54:56.030 | DEBUG    | vivarium.framework.values:_register_value_producer:338 - Registering value pipeline susceptible_to_lower_respiratory_infections.excess_mortality_rate.population_attributable_fraction\\r\\n2023-02-25 14:54:56.030 | DEBUG    | vivarium.framework.values:register_value_modifier:392 - Registering mortality_rate.2.diseasestate.susceptible_to_lower_respiratory_infections.add_in_excess_mortality as modifier to mortality_rate\\r\\n2023-02-25 14:54:56.030 | DEBUG    | vivarium.framework.values:_register_value_producer:338 - Registering value pipeline infected_with_lower_respiratory_infections.incidence_rate\\r\\n2023-02-25 14:54:56.030 | DEBUG    | vivarium.framework.values:_register_value_producer:338 - Registering value pipeline infected_with_lower_respiratory_infections.incidence_rate.population_attributable_fraction\\r\\n2023-02-25 14:54:56.031 | DEBUG    | vivarium.framework.values:_register_value_producer:338 - Registering value pipeline infected_with_lower_respiratory_infections.excess_mortality_rate\\r\\n2023-02-25 14:54:56.031 | DEBUG    | vivarium.framework.values:_register_value_producer:338 - Registering value pipeline infected_with_lower_respiratory_infections.excess_mortality_rate.population_attributable_fraction\\r\\n2023-02-25 14:54:56.031 | DEBUG    | vivarium.framework.values:register_value_modifier:392 - Registering mortality_rate.3.diseasestate.infected_with_lower_respiratory_infections.add_in_excess_mortality as modifier to mortality_rate\\r\\n2023-02-25 14:54:56.031 | DEBUG    | vivarium.framework.values:_register_value_producer:338 - Registering value pipeline infected_with_lower_respiratory_infections.remission_rate\\r\\n2023-02-25 14:54:56.031 | DEBUG    | vivarium.framework.values:_register_value_producer:338 - Registering value pipeline infected_with_lower_respiratory_infections.remission_rate.population_attributable_fraction\\r\\n2023-02-25 14:54:56.031 | DEBUG    | vivarium.framework.values:_register_value_producer:338 - Registering value pipeline child_wasting.base_proportion_exposed\\r\\n2023-02-25 14:54:56.031 | DEBUG    | vivarium.framework.values:_register_value_producer:338 - Registering value pipeline child_wasting.proportion_exposed\\r\\n2023-02-25 14:54:56.031 | DEBUG    | vivarium.framework.values:_register_value_producer:338 - Registering value pipeline child_wasting.exposure\\r\\n2023-02-25 14:54:56.032 | DEBUG    | vivarium.framework.values:_register_value_producer:338 - Registering value pipeline effect_of_child_wasting_on_infected_with_lower_respiratory_infections.incidence_rate.relative_risk\\r\\n2023-02-25 14:54:56.032 | DEBUG    | vivarium.framework.values:register_value_modifier:392 - Registering infected_with_lower_respiratory_infections.incidence_rate.population_attributable_fraction.1.effect_of_child_wasting_on_infected_with_lower_respiratory_infections.incidence_rate.population_attributable_fraction as modifier to infected_with_lower_respiratory_infections.incidence_rate.population_attributable_fraction\\r\\n2023-02-25 14:54:56.032 | DEBUG    | vivarium.framework.values:register_value_modifier:392 - Registering infected_with_lower_respiratory_infections.incidence_rate.1.effect_of_child_wasting_on_infected_with_lower_respiratory_infections.incidence_rate.rate_adjustment as modifier to infected_with_lower_respiratory_infections.incidence_rate\\r\\n2023-02-25 14:54:56.032 | DEBUG    | vivarium.framework.values:register_value_modifier:392 - Registering child_wasting.proportion_exposed.1.sqlns.intervention_effect as modifier to child_wasting.proportion_exposed\\r\\n2023-02-25 14:54:56.032 | DEBUG    | vivarium.framework.values:_register_value_producer:338 - Registering value pipeline sqlns.effect_size\\r\\n2023-02-25 14:54:56.032 | DEBUG    | vivarium.framework.values:register_value_modifier:392 - Registering metrics.3.observer.metrics as modifier to metrics\\r\\n2023-02-25 14:54:56.033 | DEBUG    | vivarium.framework.values:_register_value_producer:338 - Registering value pipeline metrics\\r\\n>>> sim1.step()\\r\\n2023-02-25 14:55:04.430 | DEBUG    | vivarium.framework.engine:step:198 - 2022-01-01 00:00:00\\r\\n>>> sim2.step()\\r\\n2023-02-25 14:55:09.652 | DEBUG    | vivarium.framework.engine:step:198 - 2022-01-01 00:00:00\\r\\n>>>\\r\\n```\\r\\n\\r\\nThis should be fairly straightforward to fix.  Steps:\\r\\n\\r\\n#. Add a way for SimulationContext objects to generate a unique name\\r\\n#. Make logging a proper subsystem of vivarium and bind the emitted logs to the simulation context\\nLogging in interactive settings is verbose and not configurable:\\nWorking in a notebook or REPL with vivarium simulations is pretty unpleasant.  The logging level is set to `DEBUG` by default, which throws a bunch of not very helpful information at the user.  It's also not configurable in any way.  After tackling https://github.com/ihmeuw/vivarium/issues/282, the next thing to do should be to allow user level configuration of the logging and change the default level in the interactive setting to be much less noisy.", "FAIL_TO_PASS": ["tests/framework/results/test_interface.py::test_register_observation[valid_on_time_step__prepare]", "tests/framework/results/test_manager.py::test_register_stratification_no_pipelines[vectorized_mapper]", "tests/framework/results/test_manager.py::test_register_stratification_with_column_and_pipelines[non-vectorized_mapper]", "tests/framework/results/test_context.py::test__get_stratifications[bogus_exclude]", "tests/framework/results/test_interface.py::test_register_observation[valid_pipelines]", "tests/framework/results/test_interface.py::test_unhashable_pipeline", "tests/framework/results/test_manager.py::test_add_observation_nop_stratifications[additional_and_exclude_no_operation]", "tests/framework/results/test_manager.py::test_register_stratification_with_pipelines[vectorized_mapper]", "tests/framework/results/test_manager.py::test_register_stratification_no_pipelines[non-vectorized_mapper]", "tests/framework/results/test_manager.py::test_add_observation_nop_stratifications[exclude_no_operation]", "tests/framework/results/test_context.py::test_add_stratification[non-vectorized_mapper]", "tests/framework/results/test_context.py::test_add_observation[valid_on_collect_metrics]", "tests/framework/results/test_context.py::test__get_stratifications[one_add_one_exclude]", "tests/framework/results/test_context.py::test_add_observation[valid_on_time_step__prepare]", "tests/framework/results/test_manager.py::test_register_stratification_with_column_and_pipelines[vectorized_mapper]", "tests/framework/results/test_interface.py::test_register_observations", "tests/framework/results/test_context.py::test_add_stratification[vectorized_mapper]", "tests/framework/results/test_manager.py::test_add_observation_nop_stratifications[additional_no_operation]", "tests/framework/results/test_manager.py::test_register_stratification_with_pipelines[non-vectorized_mapper]", "tests/framework/results/test_interface.py::test_register_observation[valid_on_collect_metrics]", "tests/framework/results/test_context.py::test_double_add_observation[valid_on_collect_metrics]"], "PASS_TO_PASS": [], "language": "python", "test_command": "source /saved/ENV || source /saved/*/ENV && pytest --no-header -rA --tb=no -p no:cacheprovider --continue-on-collection-errors", "test_output_parser": "python/parse_log_pytest_v3", "image_storage_uri": "vmvm-registry.fbinfra.net/repomate_image_activ_pytest/ihmeuw_vivarium:9a077fdbf0ddb8ec232c13d0175c4f451439973a", "patch": "[\"diff --git a/docs/nitpick-exceptions b/docs/nitpick-exceptions\\nindex a4347276f..2e2cea8b4 100644\\n--- a/docs/nitpick-exceptions\\n+++ b/docs/nitpick-exceptions\\n@@ -7,6 +7,9 @@ py:class pandas.core.frame.DataFrame\\n py:class pandas.core.series.Series\\n py:class pandas.core.generic.PandasObject\\n \\n+# loguru\\n+py:class loguru._logger.Logger\\n+\\n # vivarium\\n # Type aliases don't play nicely with sphinx when you import them\\n # elsewhere.  Works fine for static type checker though.  I think this\\n\",\"diff --git a/docs/source/api_reference/framework/logging/index.rst b/docs/source/api_reference/framework/logging/index.rst\\nnew file mode 100644\\nindex 000000000..c2715b68f\\n--- /dev/null\\n+++ b/docs/source/api_reference/framework/logging/index.rst\\n@@ -0,0 +1,7 @@\\n+.. automodule:: vivarium.framework.logging\\n+\\n+.. toctree::\\n+   :maxdepth: 2\\n+   :glob:\\n+\\n+   *\\n\",\"diff --git a/docs/source/api_reference/framework/logging/manager.rst b/docs/source/api_reference/framework/logging/manager.rst\\nnew file mode 100644\\nindex 000000000..df4290f42\\n--- /dev/null\\n+++ b/docs/source/api_reference/framework/logging/manager.rst\\n@@ -0,0 +1 @@\\n+.. automodule:: vivarium.framework.logging.manager\\n\",\"diff --git a/docs/source/api_reference/framework/logging/utilities.rst b/docs/source/api_reference/framework/logging/utilities.rst\\nnew file mode 100644\\nindex 000000000..75d687dd9\\n--- /dev/null\\n+++ b/docs/source/api_reference/framework/logging/utilities.rst\\n@@ -0,0 +1 @@\\n+.. automodule:: vivarium.framework.logging.utilities\\n\",\"diff --git a/docs/source/concepts/logging.rst b/docs/source/concepts/logging.rst\\nnew file mode 100644\\nindex 000000000..4c3f0cc6d\\n--- /dev/null\\n+++ b/docs/source/concepts/logging.rst\\n@@ -0,0 +1,9 @@\\n+.. _logging_concept:\\n+\\n+=================\\n+Framework Logging\\n+=================\\n+\\n+.. todo::\\n+\\n+   Everything here.\\n\",\"diff --git a/src/vivarium/framework/artifact/manager.py b/src/vivarium/framework/artifact/manager.py\\nindex f64f8c91f..eb6a008ae 100644\\n--- a/src/vivarium/framework/artifact/manager.py\\n+++ b/src/vivarium/framework/artifact/manager.py\\n@@ -12,7 +12,6 @@\\n from typing import Any, Sequence, Union\\n \\n import pandas as pd\\n-from loguru import logger\\n \\n from vivarium.config_tree import ConfigTree\\n from vivarium.framework.artifact.artifact import Artifact\\n@@ -37,6 +36,7 @@ def name(self):\\n \\n     def setup(self, builder):\\n         \\\"\\\"\\\"Performs this component's simulation setup.\\\"\\\"\\\"\\n+        self.logger = builder.logging.get_logger(self.name)\\n         # because not all columns are accessible via artifact filter terms, apply config filters separately\\n         self.config_filter_term = validate_filter_term(\\n             builder.configuration.input_data.artifact_filter_term\\n@@ -63,9 +63,9 @@ def _load_artifact(self, configuration: ConfigTree) -> Union[Artifact, None]:\\n             return None\\n         artifact_path = parse_artifact_path_config(configuration)\\n         base_filter_terms = get_base_filter_terms(configuration)\\n-        logger.debug(f\\\"Running simulation from artifact located at {artifact_path}.\\\")\\n-        logger.debug(f\\\"Artifact base filter terms are {base_filter_terms}.\\\")\\n-        logger.debug(f\\\"Artifact additional filter terms are {self.config_filter_term}.\\\")\\n+        self.logger.info(f\\\"Running simulation from artifact located at {artifact_path}.\\\")\\n+        self.logger.info(f\\\"Artifact base filter terms are {base_filter_terms}.\\\")\\n+        self.logger.info(f\\\"Artifact additional filter terms are {self.config_filter_term}.\\\")\\n         return Artifact(artifact_path, base_filter_terms)\\n \\n     def load(self, entity_key: str, **column_filters: _Filter) -> Any:\\n\",\"diff --git a/src/vivarium/framework/engine.py b/src/vivarium/framework/engine.py\\nindex 269daeb2b..0a3a67330 100644\\n--- a/src/vivarium/framework/engine.py\\n+++ b/src/vivarium/framework/engine.py\\n@@ -24,7 +24,6 @@\\n \\n import numpy as np\\n import pandas as pd\\n-from loguru import logger\\n \\n from vivarium.config_tree import ConfigTree\\n from vivarium.exceptions import VivariumError\\n@@ -34,6 +33,7 @@\\n from .components import ComponentInterface\\n from .event import EventInterface\\n from .lifecycle import LifeCycleInterface\\n+from .logging import LoggingInterface\\n from .lookup import LookupTableInterface\\n from .metrics import Metrics\\n from .plugins import PluginManager\\n@@ -101,8 +101,8 @@ def __init__(\\n         configuration: Union[Dict, ConfigTree] = None,\\n         plugin_configuration: Union[Dict, ConfigTree] = None,\\n         sim_name: str = None,\\n+        logging_verbosity: int = 1,\\n     ):\\n-\\n         self._name = self._get_context_name(sim_name)\\n \\n         # Bootstrap phase: Parse arguments, make private managers\\n@@ -120,7 +120,12 @@ def __init__(\\n \\n         self._plugin_manager = PluginManager(model_specification.plugins)\\n \\n-        # TODO: Setup logger here.\\n+        self._logging = self._plugin_manager.get_plugin(\\\"logging\\\")\\n+        self._logging.configure_logging(\\n+            simulation_name=self.name,\\n+            verbosity=logging_verbosity,\\n+        )\\n+        self._logger = self._logging.get_logger()\\n \\n         self._builder = Builder(self.configuration, self._plugin_manager)\\n \\n@@ -152,12 +157,13 @@ def __init__(\\n             setattr(self, f\\\"_{name}\\\", controller)\\n \\n         # The order the managers are added is important.  It represents the\\n-        # order in which they will be set up.  The clock is required by\\n-        # several of the other managers, including the lifecycle manager.  The\\n+        # order in which they will be set up.  The logging manager and the clock are\\n+        # required by several of the other managers, including the lifecycle manager. The\\n         # lifecycle manager is also required by most managers. The randomness\\n         # manager requires the population manager.  The remaining managers need\\n         # no ordering.\\n         managers = [\\n+            self._logging,\\n             self._clock,\\n             self._lifecycle,\\n             self._resource,\\n@@ -221,7 +227,7 @@ def initialize_simulants(self):\\n         self._clock.step_forward()\\n \\n     def step(self):\\n-        logger.debug(self._clock.time)\\n+        self._logger.debug(self._clock.time)\\n         for event in self.time_step_events:\\n             self._lifecycle.set_state(event)\\n             self.time_step_emitters[event](self._population.get_population(True).index)\\n@@ -236,7 +242,7 @@ def finalize(self):\\n         self.end_emitter(self._population.get_population(True).index)\\n         unused_config_keys = self.configuration.unused_keys()\\n         if unused_config_keys:\\n-            logger.debug(\\n+            self._logger.warning(\\n                 f\\\"Some configuration keys not used during run: {unused_config_keys}.\\\"\\n             )\\n \\n@@ -246,13 +252,13 @@ def report(self, print_results=True):\\n             self._population.get_population(True).index\\n         )\\n         if print_results:\\n-            logger.debug(\\\"\\\\n\\\" + pformat(metrics))\\n+            self._logger.info(\\\"\\\\n\\\" + pformat(metrics))\\n             performance_metrics = self.get_performance_metrics()\\n             performance_metrics = performance_metrics.to_string(\\n                 index=False,\\n                 float_format=lambda x: f\\\"{x:.2f}\\\",\\n             )\\n-            logger.debug(\\\"\\\\n\\\" + performance_metrics)\\n+            self._logger.info(\\\"\\\\n\\\" + performance_metrics)\\n \\n         return metrics\\n \\n@@ -293,6 +299,8 @@ class Builder:\\n \\n     Attributes\\n     ----------\\n+    logging: LoggingInterface\\n+        Provides access to the :ref:`logging<logging_concept>` system.\\n     lookup: LookupTableInterface\\n         Provides access to simulant-specific data via the\\n         :ref:`lookup table<lookup_concept>` abstraction.\\n@@ -331,6 +339,9 @@ class Builder:\\n     def __init__(self, configuration, plugin_manager):\\n         self.configuration = configuration\\n \\n+        self.logging = plugin_manager.get_plugin_interface(\\n+            \\\"logging\\\"\\n+        )  # type: LoggingInterface\\n         self.lookup = plugin_manager.get_plugin_interface(\\n             \\\"lookup\\\"\\n         )  # type: LookupTableInterface\\n\",\"diff --git a/src/vivarium/framework/logging/__init__.py b/src/vivarium/framework/logging/__init__.py\\nnew file mode 100644\\nindex 000000000..921796c5a\\n--- /dev/null\\n+++ b/src/vivarium/framework/logging/__init__.py\\n@@ -0,0 +1,12 @@\\n+\\\"\\\"\\\"\\n+=======\\n+Logging\\n+=======\\n+\\n+\\\"\\\"\\\"\\n+from vivarium.framework.logging.manager import LoggingInterface, LoggingManager\\n+from vivarium.framework.logging.utilities import (\\n+    configure_logging_to_file,\\n+    configure_logging_to_terminal,\\n+    list_loggers,\\n+)\\n\",\"diff --git a/src/vivarium/framework/logging/manager.py b/src/vivarium/framework/logging/manager.py\\nnew file mode 100644\\nindex 000000000..9009184a4\\n--- /dev/null\\n+++ b/src/vivarium/framework/logging/manager.py\\n@@ -0,0 +1,56 @@\\n+\\\"\\\"\\\"\\n+=====================\\n+The Logging Subsystem\\n+=====================\\n+\\n+\\\"\\\"\\\"\\n+from loguru import logger\\n+from loguru._logger import Logger\\n+\\n+from vivarium.framework.logging.utilities import configure_logging_to_terminal\\n+\\n+\\n+class LoggingManager:\\n+    def __init__(self):\\n+        self._simulation_name = None\\n+\\n+    def configure_logging(\\n+        self,\\n+        simulation_name: str,\\n+        verbosity: int = 0,\\n+        long_format: bool = True,\\n+    ) -> None:\\n+        self._simulation_name = simulation_name\\n+        if self._terminal_logging_not_configured():\\n+            configure_logging_to_terminal(verbosity=verbosity, long_format=long_format)\\n+\\n+    @staticmethod\\n+    def _terminal_logging_not_configured() -> bool:\\n+        # This hacks into the internals of loguru to see if we've already configured a\\n+        # terminal sink. Loguru maintains a global increment of the loggers it has generated\\n+        # and has a default logger configured with id 0. All code paths in this library that\\n+        # configure logging handlers delete the default handler with id 0, add a terminal\\n+        # logging handler (with id 1) and potentially have a file logging handler with id 2.\\n+        # This behavior is based on sequencing of the handle definition. This is a bit\\n+        # fragile since it depends on a loguru's internals as well as the stability of code\\n+        # paths in vivarium, but both are quite stable at this point, so I think it's pretty,\\n+        # low risk.\\n+        return 1 not in logger._core.handlers\\n+\\n+    @property\\n+    def name(self):\\n+        return \\\"logging_manager\\\"\\n+\\n+    def get_logger(self, component_name: str = None) -> Logger:\\n+        bind_args = {\\\"simulation\\\": self._simulation_name}\\n+        if component_name:\\n+            bind_args[\\\"component\\\"] = component_name\\n+        return logger.bind(**bind_args)\\n+\\n+\\n+class LoggingInterface:\\n+    def __init__(self, manager: LoggingManager):\\n+        self._manager = manager\\n+\\n+    def get_logger(self, component_name: str = None) -> Logger:\\n+        return self._manager.get_logger(component_name)\\n\",\"diff --git a/src/vivarium/framework/logging/utilities.py b/src/vivarium/framework/logging/utilities.py\\nnew file mode 100644\\nindex 000000000..5f0de2f66\\n--- /dev/null\\n+++ b/src/vivarium/framework/logging/utilities.py\\n@@ -0,0 +1,159 @@\\n+\\\"\\\"\\\"\\n+=================\\n+Logging Utilities\\n+=================\\n+\\n+This module contains utilities for configuring logging.\\n+\\n+\\\"\\\"\\\"\\n+import logging\\n+import sys\\n+from pathlib import Path\\n+\\n+from loguru import logger\\n+\\n+\\n+def configure_logging_to_terminal(verbosity: int, long_format: bool = True) -> None:\\n+    \\\"\\\"\\\"Configure logging to print to the sys.stdout.\\n+\\n+    Parameters\\n+    ----------\\n+    verbosity\\n+        The verbosity level of the logging. 0 logs at the WARNING level, 1 logs\\n+        at the INFO level, and 2 logs at the DEBUG level.\\n+    long_format\\n+        Whether to use the long format for logging messages, which includes explicit\\n+        information about the simulation context and component in the log messages.\\n+\\n+    \\\"\\\"\\\"\\n+    _clear_default_configuration()\\n+    _add_logging_sink(\\n+        sink=sys.stdout,\\n+        verbosity=verbosity,\\n+        long_format=long_format,\\n+        colorize=True,\\n+        serialize=False,\\n+    )\\n+\\n+\\n+def configure_logging_to_file(output_directory: Path) -> None:\\n+    \\\"\\\"\\\"Configure logging to write to a file in the provided output directory.\\n+\\n+    Parameters\\n+    ----------\\n+    output_directory\\n+        The directory to write the log file to.\\n+\\n+    \\\"\\\"\\\"\\n+    log_file = output_directory / \\\"simulation.log\\\"\\n+    _add_logging_sink(\\n+        log_file,\\n+        verbosity=2,\\n+        long_format=True,\\n+        colorize=False,\\n+        serialize=False,\\n+    )\\n+\\n+\\n+def _clear_default_configuration():\\n+    try:\\n+        logger.remove(0)  # Clear default configuration\\n+    except ValueError:\\n+        pass\\n+\\n+\\n+def _add_logging_sink(\\n+    sink,\\n+    verbosity: int,\\n+    long_format: bool,\\n+    colorize: bool,\\n+    serialize: bool,\\n+) -> int:\\n+    \\\"\\\"\\\"Add a logging sink to the logger.\\n+\\n+    Parameters\\n+    ----------\\n+    sink\\n+        The sink to add.  Can be a file path, a file object, or a callable.\\n+    verbosity\\n+        The verbosity level.  0 is the default and will only log warnings and errors.\\n+        1 will log info messages.  2 will log debug messages.\\n+    long_format\\n+        Whether to use the long format for logging messages.  The long format includes\\n+        the simulation name and component name.  The short format only includes the\\n+        file name and line number.\\n+    colorize\\n+        Whether to colorize the log messages.\\n+    serialize\\n+        Whether to serialize log messages.  This is useful when logging to\\n+        a file or a database.\\n+\\n+    \\\"\\\"\\\"\\n+    log_formatter = _LogFormatter(long_format)\\n+    logging_level = _get_log_level(verbosity)\\n+    return logger.add(\\n+        sink,\\n+        colorize=colorize,\\n+        level=logging_level,\\n+        format=log_formatter.format,\\n+        serialize=serialize,\\n+    )\\n+\\n+\\n+class _LogFormatter:\\n+    time = \\\"<green>{time:YYYY-MM-DD HH:mm:ss.SSS}</green>\\\"\\n+    level = \\\"<level>{level: <8}</level>\\\"\\n+    simulation = \\\"<cyan>{extra[simulation]}</cyan> - <cyan>{name}</cyan>:<cyan>{line}</cyan>\\\"\\n+    simulation_and_component = (\\n+        \\\"<cyan>{extra[simulation]}</cyan>-<cyan>{extra[component]}</cyan>:<cyan>{line}</cyan>\\\"\\n+    )\\n+    short_name_and_line = \\\"<cyan>{name}</cyan>:<cyan>{line}</cyan>\\\"\\n+    message = \\\"<level>{message}</level>\\\"\\n+\\n+    def __init__(self, long_format: bool = False):\\n+        self.long_format = long_format\\n+\\n+    def format(self, record):\\n+        fmt = self.time + \\\" | \\\"\\n+\\n+        if self.long_format:\\n+            fmt += self.level + \\\" | \\\"\\n+\\n+        if self.long_format and \\\"simulation\\\" in record[\\\"extra\\\"]:\\n+            if \\\"component\\\" in record[\\\"extra\\\"]:\\n+                fmt += self.simulation_and_component + \\\" - \\\"\\n+            else:\\n+                fmt += self.simulation + \\\" - \\\"\\n+        else:\\n+            fmt += self.short_name_and_line + \\\" - \\\"\\n+\\n+        fmt += self.message + \\\"\\\\n{exception}\\\"\\n+        return fmt\\n+\\n+\\n+def _get_log_level(verbosity: int):\\n+    if verbosity == 0:\\n+        return \\\"WARNING\\\"\\n+    elif verbosity == 1:\\n+        return \\\"INFO\\\"\\n+    elif verbosity >= 2:\\n+        return \\\"DEBUG\\\"\\n+\\n+\\n+def list_loggers():\\n+    \\\"\\\"\\\"Utility function for analyzing the logging environment.\\\"\\\"\\\"\\n+    root_logger = logging.getLogger()\\n+    print(\\\"Root logger: \\\", root_logger)\\n+    for h in root_logger.handlers:\\n+        print(f\\\"     %s\\\" % h)\\n+\\n+    print(\\\"Other loggers\\\")\\n+    print(\\\"=============\\\")\\n+    for name, logger_ in logging.Logger.manager.loggerDict.items():\\n+        print(\\\"+ [%-20s] %s \\\" % (name, logger_))\\n+        if not isinstance(logger_, logging.PlaceHolder):\\n+            handlers = list(logger_.handlers)\\n+            if not handlers:\\n+                print(\\\"     No handlers\\\")\\n+            for h in logger_.handlers:\\n+                print(\\\"     %s\\\" % h)\\n\",\"diff --git a/src/vivarium/framework/plugins.py b/src/vivarium/framework/plugins.py\\nindex 26e6d9cbf..58cf6d296 100644\\n--- a/src/vivarium/framework/plugins.py\\n+++ b/src/vivarium/framework/plugins.py\\n@@ -14,6 +14,10 @@\\n from .utilities import import_by_path\\n \\n _MANAGERS = {\\n+    \\\"logging\\\": {\\n+        \\\"controller\\\": \\\"vivarium.framework.logging.LoggingManager\\\",\\n+        \\\"builder_interface\\\": \\\"vivarium.framework.logging.LoggingInterface\\\",\\n+    },\\n     \\\"lookup\\\": {\\n         \\\"controller\\\": \\\"vivarium.framework.lookup.LookupTableManager\\\",\\n         \\\"builder_interface\\\": \\\"vivarium.framework.lookup.LookupTableInterface\\\",\\n\",\"diff --git a/src/vivarium/framework/resource.py b/src/vivarium/framework/resource.py\\nindex 5d6f6b2a9..656c023bd 100644\\n--- a/src/vivarium/framework/resource.py\\n+++ b/src/vivarium/framework/resource.py\\n@@ -20,7 +20,6 @@\\n from typing import Any, Callable, Iterable, List\\n \\n import networkx as nx\\n-from loguru import logger\\n \\n from vivarium.exceptions import VivariumError\\n \\n@@ -152,6 +151,9 @@ def sorted_nodes(self):\\n                 )\\n         return self._sorted_nodes\\n \\n+    def setup(self, builder):\\n+        self.logger = builder.logging.get_logger(self.name)\\n+\\n     def add_resources(\\n         self,\\n         resource_type: str,\\n@@ -250,7 +252,7 @@ def _to_graph(self) -> nx.DiGraph:\\n                 if dependency not in self._resource_group_map:\\n                     # Warn here because this sometimes happens naturally\\n                     # if observer components are missing from a simulation.\\n-                    logger.warning(\\n+                    self.logger.warning(\\n                         f\\\"Resource {dependency} is not provided by any component but is needed to \\\"\\n                         f\\\"compute {resource_group}.\\\"\\n                     )\\n\",\"diff --git a/src/vivarium/framework/results/context.py b/src/vivarium/framework/results/context.py\\nindex ead10c968..f51416db7 100644\\n--- a/src/vivarium/framework/results/context.py\\n+++ b/src/vivarium/framework/results/context.py\\n@@ -3,7 +3,6 @@\\n from typing import Callable, Dict, List, Tuple\\n \\n import pandas as pd\\n-from loguru import logger\\n \\n from vivarium.framework.results.exceptions import ResultsConfigurationError\\n from vivarium.framework.results.stratification import Stratification\\n@@ -19,15 +18,29 @@ class ResultsContext:\\n     \\\"\\\"\\\"\\n \\n     def __init__(self):\\n-        self._default_stratifications: List[str] = []\\n-        self._stratifications: List[Stratification] = []\\n-        # keys are event names: [\\\"time_step__prepare\\\", \\\"time_step\\\", \\\"time_step__cleanup\\\", \\\"collect_metrics\\\"]\\n-        # values are dicts with key (filter, grouper) value (measure, aggregator_sources, aggregator, additional_keys)\\n-        self._observations = defaultdict(lambda: defaultdict(list))\\n+        self.default_stratifications: List[str] = []\\n+        self.stratifications: List[Stratification] = []\\n+        # keys are event names: [\\n+        #     \\\"time_step__prepare\\\",\\n+        #     \\\"time_step\\\",\\n+        #     \\\"time_step__cleanup\\\",\\n+        #     \\\"collect_metrics\\\",\\n+        # ]\\n+        # values are dicts with\\n+        #     key (filter, grouper)\\n+        #     value (measure, aggregator_sources, aggregator, additional_keys)\\n+        self.observations = defaultdict(lambda: defaultdict(list))\\n+\\n+    @property\\n+    def name(self):\\n+        return \\\"results_context\\\"\\n+\\n+    def setup(self, builder):\\n+        self.logger = builder.logging.get_logger(self.name)\\n \\n     # noinspection PyAttributeOutsideInit\\n     def set_default_stratifications(self, default_grouping_columns: List[str]):\\n-        if self._default_stratifications:\\n+        if self.default_stratifications:\\n             raise ResultsConfigurationError(\\n                 \\\"Multiple calls are being made to set default grouping columns \\\"\\n                 \\\"for results production.\\\"\\n@@ -37,7 +50,7 @@ def set_default_stratifications(self, default_grouping_columns: List[str]):\\n                 \\\"Attempting to set an empty list as the default grouping columns \\\"\\n                 \\\"for results production.\\\"\\n             )\\n-        self._default_stratifications = default_grouping_columns\\n+        self.default_stratifications = default_grouping_columns\\n \\n     def add_stratification(\\n         self,\\n@@ -69,11 +82,12 @@ def add_stratification(\\n         Returns\\n         ------\\n         None\\n+\\n         \\\"\\\"\\\"\\n-        if len([s.name for s in self._stratifications if s.name == name]):\\n+        if len([s.name for s in self.stratifications if s.name == name]):\\n             raise ValueError(f\\\"Name `{name}` is already used\\\")\\n         stratification = Stratification(name, sources, categories, mapper, is_vectorized)\\n-        self._stratifications.append(stratification)\\n+        self.stratifications.append(stratification)\\n \\n     def add_observation(\\n         self,\\n@@ -86,21 +100,21 @@ def add_observation(\\n         when: str = \\\"collect_metrics\\\",\\n         **additional_keys: str,\\n     ):\\n-        self._warn_check_stratifications(additional_stratifications, excluded_stratifications)\\n+\\n         stratifications = self._get_stratifications(\\n             additional_stratifications, excluded_stratifications\\n         )\\n-        self._observations[when][(pop_filter, stratifications)].append(\\n+        self.observations[when][(pop_filter, stratifications)].append(\\n             (name, aggregator_sources, aggregator, additional_keys)\\n         )\\n \\n     def gather_results(self, population: pd.DataFrame, event_name: str) -> Dict[str, float]:\\n         # Optimization: We store all the producers by pop_filter and stratifications\\n         # so that we only have to apply them once each time we compute results.\\n-        for stratification in self._stratifications:\\n+        for stratification in self.stratifications:\\n             population = stratification(population)\\n \\n-        for (pop_filter, stratifications), observations in self._observations[\\n+        for (pop_filter, stratifications), observations in self.observations[\\n             event_name\\n         ].items():\\n             # Results production can be simplified to\\n@@ -139,7 +153,7 @@ def _get_stratifications(\\n         excluded_stratifications: List[str] = (),\\n     ) -> Tuple[str, ...]:\\n         stratifications = list(\\n-            set(self._default_stratifications) - set(excluded_stratifications)\\n+            set(self.default_stratifications) - set(excluded_stratifications)\\n             | set(additional_stratifications)\\n         )\\n         # Makes sure measure identifiers have fields in the same relative order.\\n@@ -184,27 +198,3 @@ def _format(field, param):\\n             )\\n             results[key] = val\\n         return results\\n-\\n-    def _warn_check_stratifications(\\n-        self, additional_stratifications, excluded_stratifications\\n-    ):\\n-        \\\"\\\"\\\"Check additional and excluded stratifications if they'd not affect\\n-        stratifications (i.e., would be NOP), and emit warning.\\\"\\\"\\\"\\n-        nop_additional = [\\n-            s for s in additional_stratifications if s in self._default_stratifications\\n-        ]\\n-        if len(nop_additional):\\n-            warnings.warn(\\n-                f\\\"Specified additional stratifications are already included by default: {nop_additional}\\\",\\n-                UserWarning,\\n-            )\\n-        nop_exclude = [\\n-            s for s in excluded_stratifications if s not in self._default_stratifications\\n-        ]\\n-        if len(nop_exclude):\\n-            warnings.warn(\\n-                f\\\"Specified excluded stratifications are already not included by default: {nop_exclude}\\\",\\n-                UserWarning,\\n-            )\\n-        if len(nop_additional) or len(nop_exclude):\\n-            logger.debug(f\\\"Default stratifications are: {self._default_stratifications}\\\")\\n\",\"diff --git a/src/vivarium/framework/results/manager.py b/src/vivarium/framework/results/manager.py\\nindex 8cb7abc56..e8cfee6f4 100644\\n--- a/src/vivarium/framework/results/manager.py\\n+++ b/src/vivarium/framework/results/manager.py\\n@@ -47,6 +47,7 @@ def metrics(self):\\n \\n     # noinspection PyAttributeOutsideInit\\n     def setup(self, builder: \\\"Builder\\\"):\\n+        self.logger = builder.logging.get_logger(self.name)\\n         self.population_view = builder.population.get_view([])\\n         self.clock = builder.time.clock()\\n         self.step_size = builder.time.step_size()\\n@@ -179,6 +180,7 @@ def register_observation(\\n         excluded_stratifications: List[str] = (),\\n         when: str = \\\"collect_metrics\\\",\\n     ) -> None:\\n+        self._warn_check_stratifications(additional_stratifications, excluded_stratifications)\\n         self._results_context.add_observation(\\n             name,\\n             pop_filter,\\n@@ -217,3 +219,27 @@ def get_results(self, index, metrics):\\n         # Shim for now to allow incremental transition to new results system.\\n         metrics.update(self.metrics)\\n         return metrics\\n+\\n+    def _warn_check_stratifications(\\n+        self, additional_stratifications, excluded_stratifications\\n+    ):\\n+        \\\"\\\"\\\"Check additional and excluded stratifications if they'd not affect\\n+        stratifications (i.e., would be NOP), and emit warning.\\\"\\\"\\\"\\n+        nop_additional = [\\n+            s\\n+            for s in additional_stratifications\\n+            if s in self._results_context.default_stratifications\\n+        ]\\n+        if len(nop_additional):\\n+            self.logger.warning(\\n+                f\\\"Specified additional stratifications are already included by default: {nop_additional}\\\",\\n+            )\\n+        nop_exclude = [\\n+            s\\n+            for s in excluded_stratifications\\n+            if s not in self._results_context.default_stratifications\\n+        ]\\n+        if len(nop_exclude):\\n+            self.logger.warning(\\n+                f\\\"Specified excluded stratifications are already not included by default: {nop_exclude}\\\",\\n+            )\\n\",\"diff --git a/src/vivarium/framework/values.py b/src/vivarium/framework/values.py\\nindex 61afb5bec..0466758d7 100644\\n--- a/src/vivarium/framework/values.py\\n+++ b/src/vivarium/framework/values.py\\n@@ -18,7 +18,6 @@\\n \\n import numpy as np\\n import pandas as pd\\n-from loguru import logger\\n \\n from vivarium.exceptions import VivariumError\\n from vivarium.framework.utilities import from_yearly\\n@@ -258,6 +257,7 @@ def name(self):\\n         return \\\"values_manager\\\"\\n \\n     def setup(self, builder):\\n+        self.logger = builder.logging.get_logger(self.name)\\n         self.step_size = builder.time.step_size()\\n         builder.event.register_listener(\\\"post_setup\\\", self.on_post_setup)\\n \\n@@ -273,7 +273,7 @@ def on_post_setup(self, _):\\n         # modifiers to values that aren't required in a simulation.\\n         unsourced_pipelines = [p for p, v in self._pipelines.items() if not v.source]\\n         if unsourced_pipelines:\\n-            logger.warning(f\\\"Unsourced pipelines: {unsourced_pipelines}\\\")\\n+            self.logger.warning(f\\\"Unsourced pipelines: {unsourced_pipelines}\\\")\\n \\n         # register_value_producer and register_value_modifier record the\\n         # dependency structure for the pipeline source and pipeline modifiers,\\n@@ -335,7 +335,7 @@ def _register_value_producer(\\n         preferred_post_processor: Callable,\\n     ):\\n         \\\"\\\"\\\"Configure the named value pipeline with a source, combiner, and post-processor.\\\"\\\"\\\"\\n-        logger.debug(f\\\"Registering value pipeline {value_name}\\\")\\n+        self.logger.debug(f\\\"Registering value pipeline {value_name}\\\")\\n         pipeline = self._pipelines[value_name]\\n         if pipeline.source:\\n             raise DynamicValueError(\\n@@ -389,7 +389,7 @@ def register_value_modifier(\\n         pipeline.mutators.append(modifier)\\n \\n         name = f\\\"{value_name}.{len(pipeline.mutators)}.{modifier_name}\\\"\\n-        logger.debug(f\\\"Registering {name} as modifier to {value_name}\\\")\\n+        self.logger.debug(f\\\"Registering {name} as modifier to {value_name}\\\")\\n         dependencies = self._convert_dependencies(\\n             modifier, requires_columns, requires_values, requires_streams\\n         )\\n\",\"diff --git a/src/vivarium/interface/utilities.py b/src/vivarium/interface/utilities.py\\nindex 89f5fff24..8d4275ab7 100644\\n--- a/src/vivarium/interface/utilities.py\\n+++ b/src/vivarium/interface/utilities.py\\n@@ -8,13 +8,11 @@\\n \\n \\\"\\\"\\\"\\n import functools\\n-import sys\\n from datetime import datetime\\n from pathlib import Path\\n from typing import Union\\n \\n import yaml\\n-from loguru import logger\\n \\n from vivarium.exceptions import VivariumError\\n \\n@@ -124,6 +122,7 @@ def get_output_model_name_string(\\n     -------\\n     str\\n         A model name string for use in output labeling.\\n+\\n     \\\"\\\"\\\"\\n     if artifact_path:\\n         model_name = Path(artifact_path).stem\\n@@ -146,29 +145,3 @@ def get_output_root(\\n     model_name = get_output_model_name_string(artifact_path, model_specification_file)\\n     output_root = Path(results_directory + f\\\"/{model_name}/{launch_time}\\\")\\n     return output_root\\n-\\n-\\n-def add_logging_sink(sink, verbose, colorize=False, serialize=False):\\n-    message_format = (\\n-        \\\"<green>{time:YYYY-MM-DD HH:mm:ss.SSS}</green> | \\\"\\n-        \\\"<cyan>{name}</cyan>:<cyan>{function}</cyan>:<cyan>{line}</cyan> \\\"\\n-        \\\"- <level>{message}</level>\\\"\\n-    )\\n-    if verbose:\\n-        logger.add(\\n-            sink, colorize=colorize, level=\\\"DEBUG\\\", format=message_format, serialize=serialize\\n-        )\\n-    else:\\n-        logger.add(\\n-            sink, colorize=colorize, level=\\\"ERROR\\\", format=message_format, serialize=serialize\\n-        )\\n-\\n-\\n-def configure_logging_to_terminal(verbose):\\n-    logger.remove(0)  # Clear default configuration\\n-    add_logging_sink(sys.stdout, verbose, colorize=True)\\n-\\n-\\n-def configure_logging_to_file(output_directory):\\n-    master_log = output_directory / \\\"simulation.log\\\"\\n-    add_logging_sink(master_log, verbose=True)\\n\"]", "test_patch": "[\"diff --git a/src/vivarium/interface/cli.py b/src/vivarium/interface/cli.py\\nindex 1a5866ffb..80f08fec0 100644\\n--- a/src/vivarium/interface/cli.py\\n+++ b/src/vivarium/interface/cli.py\\n@@ -16,7 +16,7 @@\\n         - | Runs a single simulation from a model specification file.\\n     *   - | **test**\\n         - | Runs an example simulation that comes packaged with ``vivarium``.\\n-           | Useful as an installation test.\\n+          | Useful as an installation test.\\n     *   - | **profile**\\n         - | Produces a profile of a simulation using the python\\n           | :mod:`cProfile` module\\n@@ -42,13 +42,13 @@\\n \\n from vivarium.examples import disease_model\\n from vivarium.framework.engine import run_simulation\\n-from vivarium.framework.utilities import handle_exceptions\\n-\\n-from .utilities import (\\n+from vivarium.framework.logging import (\\n     configure_logging_to_file,\\n     configure_logging_to_terminal,\\n-    get_output_root,\\n )\\n+from vivarium.framework.utilities import handle_exceptions\\n+\\n+from .utilities import get_output_root\\n \\n \\n @click.group()\\n@@ -81,7 +81,18 @@ def simulate():\\n     help=\\\"The directory to write results to. A folder will be created \\\"\\n     \\\"in this directory with the same name as the configuration file.\\\",\\n )\\n-@click.option(\\\"--verbose\\\", \\\"-v\\\", is_flag=True, help=\\\"Report each time step.\\\")\\n+@click.option(\\n+    \\\"--verbose\\\",\\n+    \\\"-v\\\",\\n+    is_flag=True,\\n+    help=\\\"Logs verbosely. Useful for debugging and development.\\\",\\n+)\\n+@click.option(\\n+    \\\"--quiet\\\",\\n+    \\\"-q\\\",\\n+    is_flag=True,\\n+    help=\\\"Suppresses all logging except for warnings and errors.\\\",\\n+)\\n @click.option(\\n     \\\"--pdb\\\",\\n     \\\"with_debugger\\\",\\n@@ -93,7 +104,8 @@ def run(\\n     location: str,\\n     artifact_path: Path,\\n     results_directory: Path,\\n-    verbose: int,\\n+    verbose: bool,\\n+    quiet: bool,\\n     with_debugger: bool,\\n ):\\n     \\\"\\\"\\\"Run a simulation from the command line.\\n@@ -103,8 +115,13 @@ def run(\\n     Within the results directory, which defaults to ~/vivarium_results if none\\n     is provided, a subdirectory will be created with the same name as the\\n     MODEL_SPECIFICATION if one does not exist. Results will be written to a\\n-    further subdirectory named after the start time of the simulation run.\\\"\\\"\\\"\\n-    configure_logging_to_terminal(verbose)\\n+    further subdirectory named after the start time of the simulation run.\\n+\\n+    \\\"\\\"\\\"\\n+    if verbose and quiet:\\n+        raise click.UsageError(\\\"Cannot be both verbose and quiet.\\\")\\n+    verbosity = 1 + int(verbose) - int(quiet)\\n+    configure_logging_to_terminal(verbosity=verbosity, long_format=False)\\n \\n     start = time()\\n \\n@@ -113,7 +130,7 @@ def run(\\n     _ = os.umask(0o002)\\n     results_root.mkdir(parents=True, exist_ok=False)\\n \\n-    configure_logging_to_file(results_root)\\n+    configure_logging_to_file(output_directory=results_root)\\n     shutil.copy(model_specification, results_root / \\\"model_specification.yaml\\\")\\n \\n     output_data = {\\\"results_directory\\\": str(results_root)}\\n@@ -139,7 +156,7 @@ def test():\\n     \\\"\\\"\\\"Run a test simulation using the ``disease_model.yaml`` model specification\\n     provided in the examples directory.\\n     \\\"\\\"\\\"\\n-    configure_logging_to_terminal(verbose=True)\\n+    configure_logging_to_terminal(verbosity=2, long_format=False)\\n     model_specification = disease_model.get_model_specification_path()\\n \\n     main = handle_exceptions(run_simulation, logger, with_debugger=False)\\n@@ -151,15 +168,18 @@ def test():\\n \\n @simulate.command()\\n @click.argument(\\n-    \\\"model_specification\\\", type=click.Path(exists=True, dir_okay=False, resolve_path=True)\\n+    \\\"model_specification\\\",\\n+    type=click.Path(exists=True, dir_okay=False, resolve_path=True),\\n )\\n @click.option(\\n     \\\"--results_directory\\\",\\n     \\\"-o\\\",\\n     type=click.Path(resolve_path=True),\\n     default=Path(\\\"~/vivarium_results/\\\").expanduser(),\\n-    help=\\\"The directory to write results to. A folder will be created \\\"\\n-    \\\"in this directory with the same name as the configuration file.\\\",\\n+    help=(\\n+        \\\"The directory to write results to. A folder will be created \\\"\\n+        \\\"in this directory with the same name as the configuration file.\\\"\\n+    ),\\n )\\n @click.option(\\n     \\\"--process/--no-process\\\",\\n@@ -170,9 +190,7 @@ def test():\\n     ),\\n )\\n def profile(model_specification, results_directory, process):\\n-    \\\"\\\"\\\"Run a simulation based on the provided MODEL_SPECIFICATION and profile\\n-    the run.\\n-    \\\"\\\"\\\"\\n+    \\\"\\\"\\\"Run a simulation based on the provided MODEL_SPECIFICATION and profile the run.\\\"\\\"\\\"\\n     model_specification = Path(model_specification)\\n     results_directory = Path(results_directory)\\n \\n@@ -180,7 +198,7 @@ def profile(model_specification, results_directory, process):\\n         \\\"yaml\\\", \\\"stats\\\"\\n     )\\n     command = f'run_simulation(\\\"{model_specification}\\\")'\\n-    cProfile.runctx(command, globals=globals(), locals=locals(), filename=out_stats_file)\\n+    cProfile.runctx(command, globals=globals(), locals=locals(), filename=str(out_stats_file))\\n \\n     if process:\\n         out_txt_file = results_directory / (out_stats_file.name + \\\".txt\\\")\\n\",\"diff --git a/tests/conftest.py b/tests/conftest.py\\nindex b5206c2f2..19cb6c4cb 100644\\n--- a/tests/conftest.py\\n+++ b/tests/conftest.py\\n@@ -2,6 +2,8 @@\\n \\n import pytest\\n import tables\\n+from _pytest.logging import LogCaptureFixture\\n+from loguru import logger\\n \\n from vivarium.framework.configuration import (\\n     build_model_specification,\\n@@ -10,6 +12,13 @@\\n from vivarium.testing_utilities import metadata\\n \\n \\n+@pytest.fixture\\n+def caplog(caplog: LogCaptureFixture):\\n+    handler_id = logger.add(caplog.handler, format=\\\"{message}\\\")\\n+    yield caplog\\n+    logger.remove(handler_id)\\n+\\n+\\n @pytest.fixture\\n def base_config():\\n     config = build_simulation_configuration()\\n\",\"diff --git a/tests/framework/results/test_context.py b/tests/framework/results/test_context.py\\nindex 64a8e31e3..87ecdb0e7 100644\\n--- a/tests/framework/results/test_context.py\\n+++ b/tests/framework/results/test_context.py\\n@@ -29,11 +29,11 @@\\n def test_add_stratification(name, sources, categories, mapper, is_vectorized):\\n     ctx = ResultsContext()\\n     assert not verify_stratification_added(\\n-        ctx._stratifications, name, sources, categories, mapper, is_vectorized\\n+        ctx.stratifications, name, sources, categories, mapper, is_vectorized\\n     )\\n     ctx.add_stratification(name, sources, categories, mapper, is_vectorized)\\n     assert verify_stratification_added(\\n-        ctx._stratifications, name, sources, categories, mapper, is_vectorized\\n+        ctx.stratifications, name, sources, categories, mapper, is_vectorized\\n     )\\n \\n \\n@@ -106,7 +106,7 @@ def test_add_observation(\\n ):\\n     ctx = ResultsContext()\\n     ctx._default_stratifications = [\\\"age\\\", \\\"sex\\\"]\\n-    assert len(ctx._observations) == 0\\n+    assert len(ctx.observations) == 0\\n     ctx.add_observation(\\n         name,\\n         pop_filter,\\n@@ -116,7 +116,7 @@ def test_add_observation(\\n         excluded_stratifications,\\n         when,\\n     )\\n-    assert len(ctx._observations) == 1\\n+    assert len(ctx.observations) == 1\\n \\n \\n @pytest.mark.parametrize(\\n@@ -140,7 +140,7 @@ def test_double_add_observation(\\n     the context.\\\"\\\"\\\"\\n     ctx = ResultsContext()\\n     ctx._default_stratifications = [\\\"age\\\", \\\"sex\\\"]\\n-    assert len(ctx._observations) == 0\\n+    assert len(ctx.observations) == 0\\n     ctx.add_observation(\\n         name,\\n         pop_filter,\\n@@ -159,35 +159,7 @@ def test_double_add_observation(\\n         excluded_stratifications,\\n         when,\\n     )\\n-    assert len(ctx._observations) == 1\\n-\\n-\\n-@pytest.mark.parametrize(\\n-    \\\"default, additional, excluded, match\\\",\\n-    [\\n-        ([\\\"age\\\", \\\"sex\\\"], [\\\"age\\\"], [], \\\"age\\\"),\\n-        ([\\\"age\\\", \\\"sex\\\"], [], [\\\"eye_color\\\"], \\\"eye_color\\\"),\\n-        ([\\\"age\\\", \\\"sex\\\"], [\\\"age\\\"], [\\\"eye_color\\\"], \\\"age|eye_color\\\"),\\n-    ],\\n-    ids=[\\n-        \\\"additional_no_operation\\\",\\n-        \\\"exclude_no_operation\\\",\\n-        \\\"additional_and_exclude_no_operation\\\",\\n-    ],\\n-)\\n-def test_add_observation_nop_stratifications(default, additional, excluded, match):\\n-    ctx = ResultsContext()\\n-    ctx._default_stratifications = default\\n-    with pytest.warns(UserWarning, match=match):\\n-        ctx.add_observation(\\n-            \\\"name\\\",\\n-            'alive == \\\"alive\\\"',\\n-            [],\\n-            _aggregate_state_person_time,\\n-            additional,\\n-            excluded,\\n-            \\\"collect_metrics\\\",\\n-        )\\n+    assert len(ctx.observations) == 1\\n \\n \\n @pytest.mark.parametrize(\\n@@ -213,7 +185,7 @@ def test__get_stratifications(\\n ):\\n     ctx = ResultsContext()\\n     # default_stratifications would normally be set via ResultsInterface.set_default_stratifications()\\n-    ctx._default_stratifications = default_stratifications\\n+    ctx.default_stratifications = default_stratifications\\n     stratifications = ctx._get_stratifications(\\n         additional_stratifications, excluded_stratifications\\n     )\\n\",\"diff --git a/tests/framework/results/test_interface.py b/tests/framework/results/test_interface.py\\nindex 080cf066c..45c4bd91c 100644\\n--- a/tests/framework/results/test_interface.py\\n+++ b/tests/framework/results/test_interface.py\\n@@ -76,7 +76,7 @@ def test_register_observation(\\n     mocker.patch.object(builder, \\\"value.get_value\\\")\\n     builder.value.get_value = MethodType(mock_get_value, builder)\\n     mgr.setup(builder)\\n-    assert len(interface._manager._results_context._observations) == 0\\n+    assert len(interface._manager._results_context.observations) == 0\\n     interface.register_observation(\\n         name,\\n         pop_filter,\\n@@ -87,13 +87,13 @@ def test_register_observation(\\n         additional_stratifications,\\n         excluded_stratifications,\\n     )\\n-    assert len(interface._manager._results_context._observations) == 1\\n+    assert len(interface._manager._results_context.observations) == 1\\n \\n \\n def test_register_observations():\\n     mgr = ResultsManager()\\n     interface = ResultsInterface(mgr)\\n-    assert len(interface._manager._results_context._observations) == 0\\n+    assert len(interface._manager._results_context.observations) == 0\\n     interface.register_observation(\\n         \\\"living_person_time\\\",\\n         'alive == \\\"alive\\\" and undead == False',\\n@@ -105,7 +105,7 @@ def test_register_observations():\\n         [],\\n         \\\"collect_metrics\\\",\\n     )\\n-    assert len(interface._manager._results_context._observations) == 1\\n+    assert len(interface._manager._results_context.observations) == 1\\n     interface.register_observation(\\n         \\\"undead_person_time\\\",\\n         \\\"undead == True\\\",\\n@@ -117,13 +117,13 @@ def test_register_observations():\\n         [],\\n         \\\"time_step__prepare\\\",\\n     )\\n-    assert len(interface._manager._results_context._observations) == 2\\n+    assert len(interface._manager._results_context.observations) == 2\\n \\n \\n def test_unhashable_pipeline():\\n     mgr = ResultsManager()\\n     interface = ResultsInterface(mgr)\\n-    assert len(interface._manager._results_context._observations) == 0\\n+    assert len(interface._manager._results_context.observations) == 0\\n     with pytest.raises(TypeError, match=\\\"unhashable\\\"):\\n         interface.register_observation(\\n             \\\"living_person_time\\\",\\n\",\"diff --git a/tests/framework/results/test_manager.py b/tests/framework/results/test_manager.py\\nindex f017355fc..52bd028ed 100644\\n--- a/tests/framework/results/test_manager.py\\n+++ b/tests/framework/results/test_manager.py\\n@@ -1,6 +1,7 @@\\n from types import MethodType\\n \\n import pytest\\n+from loguru import logger\\n \\n from vivarium.framework.results.manager import ResultsManager\\n \\n@@ -53,7 +54,7 @@ def test_register_stratification_no_pipelines(\\n     for item in sources:\\n         assert item in mgr._required_columns\\n     assert verify_stratification_added(\\n-        mgr._results_context._stratifications,\\n+        mgr._results_context.stratifications,\\n         name,\\n         sources,\\n         categories,\\n@@ -95,7 +96,7 @@ def test_register_stratification_with_pipelines(\\n     for item in sources:\\n         assert item in mgr._required_values\\n     assert verify_stratification_added(\\n-        mgr._results_context._stratifications,\\n+        mgr._results_context.stratifications,\\n         name,\\n         sources,\\n         categories,\\n@@ -143,7 +144,7 @@ def test_register_stratification_with_column_and_pipelines(\\n     all_sources = sources.copy()\\n     all_sources.append(mocked_column_name)\\n     assert verify_stratification_added(\\n-        mgr._results_context._stratifications,\\n+        mgr._results_context.stratifications,\\n         name,\\n         all_sources,\\n         categories,\\n@@ -188,3 +189,38 @@ def test_register_binned_stratification_raises(bins, labels):\\n         raise mgr.register_binned_stratification(\\n             BIN_SOURCE, \\\"column\\\", BIN_BINNED_COLUMN, bins, labels\\n         )\\n+\\n+\\n+@pytest.mark.parametrize(\\n+    \\\"default, additional, excluded, match\\\",\\n+    [\\n+        ([\\\"age\\\", \\\"sex\\\"], [\\\"age\\\"], [], [\\\"age\\\"]),\\n+        ([\\\"age\\\", \\\"sex\\\"], [], [\\\"eye_color\\\"], [\\\"eye_color\\\"]),\\n+        ([\\\"age\\\", \\\"sex\\\"], [\\\"age\\\"], [\\\"eye_color\\\"], [\\\"age\\\", \\\"eye_color\\\"]),\\n+    ],\\n+    ids=[\\n+        \\\"additional_no_operation\\\",\\n+        \\\"exclude_no_operation\\\",\\n+        \\\"additional_and_exclude_no_operation\\\",\\n+    ],\\n+)\\n+def test_add_observation_nop_stratifications(\\n+    default, additional, excluded, match, mocker, caplog\\n+):\\n+    mgr = ResultsManager()\\n+    builder = mocker.Mock()\\n+    mgr.setup(builder)\\n+    mgr.logger = logger\\n+\\n+    mgr._results_context.default_stratifications = default\\n+    mgr.register_observation(\\n+        \\\"name\\\",\\n+        'alive == \\\"alive\\\"',\\n+        [],\\n+        lambda: None,\\n+        additional_stratifications=additional,\\n+        excluded_stratifications=excluded,\\n+        when=\\\"collect_metrics\\\",\\n+    )\\n+    for m in match:\\n+        assert m in caplog.text\\n\",\"diff --git a/tests/framework/test_engine.py b/tests/framework/test_engine.py\\nindex 2baf7e16f..1bdaa7206 100644\\n--- a/tests/framework/test_engine.py\\n+++ b/tests/framework/test_engine.py\\n@@ -10,6 +10,7 @@\\n from vivarium.framework.engine import SimulationContext as SimulationContext_\\n from vivarium.framework.event import EventInterface, EventManager\\n from vivarium.framework.lifecycle import LifeCycleInterface, LifeCycleManager\\n+from vivarium.framework.logging import LoggingInterface, LoggingManager\\n from vivarium.framework.lookup import LookupTableInterface, LookupTableManager\\n from vivarium.framework.metrics import Metrics\\n from vivarium.framework.population import PopulationInterface, PopulationManager\\n@@ -43,7 +44,7 @@ def components():\\n \\n @pytest.fixture\\n def log(mocker):\\n-    return mocker.patch(\\\"vivarium.framework.engine.logger\\\")\\n+    return mocker.patch(\\\"vivarium.framework.logging.manager.logger\\\")\\n \\n \\n def test_SimulationContext_get_sim_name(SimulationContext):\\n@@ -58,6 +59,7 @@ def test_SimulationContext_get_sim_name(SimulationContext):\\n def test_SimulationContext_init_default(SimulationContext, components):\\n     sim = SimulationContext(components=components)\\n \\n+    assert isinstance(sim._logging, LoggingManager)\\n     assert isinstance(sim._lifecycle, LifeCycleManager)\\n     assert isinstance(sim._component_manager, ComponentManager)\\n     assert isinstance(sim._clock, DateTimeClock)\\n@@ -73,6 +75,8 @@ def test_SimulationContext_init_default(SimulationContext, components):\\n     assert isinstance(sim._builder, Builder)\\n     assert sim._builder.configuration is sim.configuration\\n \\n+    assert isinstance(sim._builder.logging, LoggingInterface)\\n+    assert sim._builder.logging._manager is sim._logging\\n     assert isinstance(sim._builder.lookup, LookupTableInterface)\\n     assert sim._builder.lookup._manager is sim._tables\\n     assert isinstance(sim._builder.value, ValuesInterface)\\n@@ -98,6 +102,7 @@ def test_SimulationContext_init_default(SimulationContext, components):\\n \\n     # Ordering matters.\\n     managers = [\\n+        sim._logging,\\n         sim._clock,\\n         sim._lifecycle,\\n         sim._resource,\"]", "hints_text": ""}

{"instance_id": "744446474915567", "repo": "pyccel/pyccel", "base_commit": "c36ca7071eaed1c6775d87308acf618092fd3197", "problem_statement": "Remove _sympystr methods:\\nIf a class only has a `_sympystr` method then the method should be converted to a `__str__` magic method instead. If the `__str__` (or `__repr__`) already exists then the `_sympystr` method can just be removed.\\nRemove sympy inheritance (Basic, Expr, etc):\\nThe inheritance from sympy is occasionally the cause of various bugs. In addition, changes to pyccel mean that it no longer needs this inheritance. It should therefore be removed. Instead all nodes in the pyccel ast should inherit from `pyccel.ast.basic.Basic`", "FAIL_TO_PASS": ["tests/pyccel/test_pyccel.py::test_expressions[c]", "tests/pyccel/test_pyccel.py::test_print_sp_and_end[c]", "tests/pyccel/test_pyccel.py::test_print_strings[c]", "tests/pyccel/test_pyccel.py::test_c_arrays[c]"], "PASS_TO_PASS": ["tests/ndarrays/test_ndarrays.c::test_indexing_int64", "tests/ndarrays/test_ndarrays.c::test_slicing_int64", "tests/pyccel/test_pyccel.py::test_hope_benchmarks[scripts/hope_benchmarks_decorators/fib.py]", "tests/ndarrays/test_ndarrays.c::test_slicing_cdouble", "tests/ndarrays/test_ndarrays.c::test_slicing_int8", "tests/ndarrays/test_ndarrays.c::test_indexing_cdouble", "tests/ndarrays/test_ndarrays.c::test_indexing_double", "tests/pyccel/test_pyccel.py::test_print_sp_and_end[fortran]", "tests/ndarrays/test_ndarrays.c::test_array_fill_int32", "tests/ndarrays/test_ndarrays.c::test_array_fill_cdouble", "tests/ndarrays/test_ndarrays.c::test_array_zeros_int32", "tests/ndarrays/test_ndarrays.c::test_indexing_int8", "tests/ndarrays/test_ndarrays.c::test_slicing_int16", "tests/ndarrays/test_ndarrays.c::test_slicing_double", "tests/ndarrays/test_ndarrays.c::test_array_fill_int64", "tests/ndarrays/test_ndarrays.c::test_array_fill_double", "tests/ndarrays/test_ndarrays.c::test_indexing_int32", "tests/ndarrays/test_ndarrays.c::test_array_fill_int8", "tests/ndarrays/test_ndarrays.c::test_indexing_int16", "tests/ndarrays/test_ndarrays.c::test_array_fill_int16", "tests/ndarrays/test_ndarrays.c::test_slicing_int32", "tests/ndarrays/test_ndarrays.c::test_array_zeros_double", "tests/ndarrays/test_ndarrays.c::test_array_zeros_cdouble"], "language": "python", "test_command": "source /saved/ENV || source /saved/*/ENV && pytest --no-header -rA --tb=no -p no:cacheprovider --continue-on-collection-errors", "test_output_parser": "python/parse_log_pytest_v3", "image_storage_uri": "vmvm-registry.fbinfra.net/repomate_image_activ_pytest/pyccel_pyccel:c36ca7071eaed1c6775d87308acf618092fd3197", "patch": "[\"diff --git a/pyccel/ast/basic.py b/pyccel/ast/basic.py\\nindex 29cf187..4620d68 100644\\n--- a/pyccel/ast/basic.py\\n+++ b/pyccel/ast/basic.py\\n@@ -10,13 +10,13 @@ They are:\\n - PyccelAstNode which describes each PyccelAstNode\\n \\\"\\\"\\\"\\n import ast\\n-from sympy.core.basic import Basic as sp_Basic\\n \\n __all__ = ('Basic', 'PyccelAstNode')\\n \\n dict_keys   = type({}.keys())\\n dict_values = type({}.values())\\n iterable_types = (list, tuple, dict_keys, dict_values)\\n+iterable = lambda x : isinstance(x, iterable_types)\\n \\n #==============================================================================\\n class Immutable:\\n@@ -24,15 +24,11 @@ class Immutable:\\n     from Basic \\\"\\\"\\\"\\n \\n #==============================================================================\\n-class Basic(sp_Basic):\\n+class Basic:\\n     \\\"\\\"\\\"Basic class for Pyccel AST.\\\"\\\"\\\"\\n     _fst = None\\n     _ignored_types = (Immutable, type)\\n \\n-    def __new__(cls, *args, **kwargs):\\n-        hashable_args  = [a if not isinstance(a, list) else tuple(a) for a in args]\\n-        return sp_Basic.__new__(cls, *hashable_args)\\n-\\n     def __init__(self):\\n         self._user_nodes = []\\n         self._fst = []\\n@@ -50,8 +46,8 @@ class Basic(sp_Basic):\\n                 c = convert_to_literal(c)\\n                 setattr(self, c_name, c)\\n \\n-            elif isinstance(c, iterable_types):\\n-                if any(isinstance(ci, iterable_types) for ci in c):\\n+            elif iterable(c):\\n+                if any(iterable(ci) for ci in c):\\n                     raise TypeError(\\\"Basic child cannot be a tuple of tuples\\\")\\n                 c = tuple(ci if (not isinstance(ci, (int, float, complex, str, bool)) \\\\\\n                                  or self.ignore(ci)) \\\\\\n@@ -184,8 +180,8 @@ class Basic(sp_Basic):\\n             return\\n         self._recursion_in_progress = True\\n \\n-        if isinstance(original, iterable_types):\\n-            assert(isinstance(replacement, iterable_types))\\n+        if iterable(original):\\n+            assert(iterable(replacement))\\n             assert(len(original) == len(replacement))\\n         else:\\n             original = (original,)\\n@@ -196,7 +192,7 @@ class Basic(sp_Basic):\\n             rep = replacement[idx]\\n             if not self.ignore(found_node):\\n                 found_node.remove_user_node(self)\\n-            if isinstance(rep, iterable_types):\\n+            if iterable(rep):\\n                 for r in rep:\\n                     if not self.ignore(r):\\n                         r.set_current_user_node(self)\\n@@ -223,7 +219,7 @@ class Basic(sp_Basic):\\n                             new_vi = prepare_sub(vi)\\n                         elif not self.ignore(vi):\\n                             vi.substitute(original, replacement, excluded_nodes)\\n-                    if isinstance(new_vi, iterable_types):\\n+                    if iterable(new_vi):\\n                         new_v.extend(new_vi)\\n                     else:\\n                         new_v.append(new_vi)\\n@@ -296,14 +292,6 @@ class Basic(sp_Basic):\\n         \\\"\\\"\\\"\\n         return len(self._user_nodes)==0\\n \\n-    def __eq__(self, other):\\n-        #TODO: Remove with sympy inheritance\\n-        return id(self) == id(other)\\n-\\n-    def __hash__(self):\\n-        #TODO: Remove with sympy inheritance\\n-        return id(self)\\n-\\n class PyccelAstNode(Basic):\\n     \\\"\\\"\\\"Class from which all nodes containing objects inherit\\n     \\\"\\\"\\\"\\n\",\"diff --git a/pyccel/ast/datatypes.py b/pyccel/ast/datatypes.py\\nindex dffba04..0b21da6 100644\\n--- a/pyccel/ast/datatypes.py\\n+++ b/pyccel/ast/datatypes.py\\n@@ -9,12 +9,11 @@\\n Classes and methods that handle supported datatypes in C/Fortran.\\n \\\"\\\"\\\"\\n \\n-from .basic import Basic\\n+import numpy\\n \\n-from sympy.core.singleton import Singleton\\n-from sympy.core.compatibility import with_metaclass\\n+from pyccel.utilities.metaclasses import Singleton\\n \\n-import numpy\\n+from .basic import Basic\\n \\n # TODO [YG, 12.03.2020] verify why we need all these types\\n # NOTE: symbols not used in pyccel are commented out\\n@@ -93,7 +92,7 @@ default_precision = {'real': 8,\\n                     'float':8}\\n dtype_and_precision_registry = { 'real':('real',default_precision['float']),\\n                                  'double':('real',default_precision['float']),\\n-                                 'float':('real',default_precision['float']),       # sympy.Float\\n+                                 'float':('real',default_precision['float']),\\n                                  'pythonfloat':('real',default_precision['float']), # built-in float\\n                                  'float32':('real',4),\\n                                  'float64':('real',8),\\n@@ -112,7 +111,7 @@ dtype_and_precision_registry = { 'real':('real',default_precision['float']),\\n                                  'pythonbool' :('bool',default_precision['bool'])}\\n \\n \\n-class DataType(with_metaclass(Singleton)):\\n+class DataType(metaclass=Singleton):\\n     \\\"\\\"\\\"Base class representing native datatypes\\\"\\\"\\\"\\n     _name = '__UNDEFINED__'\\n \\n@@ -291,9 +290,9 @@ def is_with_construct_datatype(dtype):\\n def datatype(arg):\\n     \\\"\\\"\\\"Returns the datatype singleton for the given dtype.\\n \\n-    arg : str or sympy expression\\n+    arg : str or pyccel expression\\n         If a str ('bool', 'int', 'real','complex', or 'void'), return the\\n-        singleton for the corresponding dtype. If a sympy expression, return\\n+        singleton for the corresponding dtype. If a pyccel expression, return\\n         the datatype that best fits the expression. This is determined from the\\n         assumption system. For more control, use the `DataType` class directly.\\n \\n@@ -315,7 +314,7 @@ def datatype(arg):\\n def str_dtype(dtype):\\n \\n     \\\"\\\"\\\"\\n-    This function takes a datatype and returns a sympy datatype as a string\\n+    This function takes a datatype and returns a pyccel datatype as a string\\n \\n     Example\\n     -------\\n\",\"diff --git a/pyccel/ast/functionalexpr.py b/pyccel/ast/functionalexpr.py\\nindex e4ce2af..f6adcff 100644\\n--- a/pyccel/ast/functionalexpr.py\\n+++ b/pyccel/ast/functionalexpr.py\\n@@ -6,11 +6,9 @@\\n #------------------------------------------------------------------------------------------#\\n \\n from .basic import Basic\\n-from sympy.core.expr  import AtomicExpr\\n \\n __all__ = (\\n     'FunctionalFor',\\n-    'FunctionalMap',\\n     'FunctionalMax',\\n     'FunctionalMin',\\n     'FunctionalSum',\\n@@ -59,24 +57,27 @@ class FunctionalFor(Basic):\\n         return self._index\\n \\n #==============================================================================\\n-class GeneratorComprehension(AtomicExpr, Basic):\\n-    _attribute_nodes = ()\\n+class GeneratorComprehension(FunctionalFor):\\n+    \\\"\\\"\\\" Super class for all functions which reduce generator expressions to scalars\\n+    \\\"\\\"\\\"\\n \\n #==============================================================================\\n-class FunctionalSum(GeneratorComprehension, FunctionalFor):\\n-    _attribute_nodes = FunctionalFor._attribute_nodes\\n+class FunctionalSum(GeneratorComprehension):\\n+    \\\"\\\"\\\" Represents a call to sum for a list argument\\n+    >>> sum([i in range(5)])\\n+    \\\"\\\"\\\"\\n     name = 'sum'\\n \\n #==============================================================================\\n-class FunctionalMax(GeneratorComprehension, FunctionalFor):\\n-    _attribute_nodes = FunctionalFor._attribute_nodes\\n+class FunctionalMax(GeneratorComprehension):\\n+    \\\"\\\"\\\" Represents a call to max for a list argument\\n+    >>> max([i in range(5)])\\n+    \\\"\\\"\\\"\\n     name = 'max'\\n #==============================================================================\\n \\n-class FunctionalMin(GeneratorComprehension, FunctionalFor):\\n-    _attribute_nodes = FunctionalFor._attribute_nodes\\n+class FunctionalMin(GeneratorComprehension):\\n+    \\\"\\\"\\\" Represents a call to min for a list argument\\n+    >>> min([i in range(5)])\\n+    \\\"\\\"\\\"\\n     name = 'min'\\n-\\n-#==============================================================================\\n-class FunctionalMap(GeneratorComprehension, FunctionalFor):\\n-    _attribute_nodes = FunctionalFor._attribute_nodes\\n\",\"diff --git a/pyccel/ast/headers.py b/pyccel/ast/headers.py\\nindex a375b2a..09a59b2 100644\\n--- a/pyccel/ast/headers.py\\n+++ b/pyccel/ast/headers.py\\n@@ -4,20 +4,18 @@\\n # go to https://github.com/pyccel/pyccel/blob/master/LICENSE for full license details.     #\\n #------------------------------------------------------------------------------------------#\\n \\n-from sympy.utilities.iterables import iterable\\n-\\n-from ..errors.errors import Errors\\n-from ..errors.messages import TEMPLATE_IN_UNIONTYPE\\n-from .core import Basic\\n-from .core import ValuedArgument\\n-from .core import FunctionDef, Interface, FunctionAddress\\n-from .core import create_incremented_string\\n-from .datatypes import datatype, DataTypeFactory, UnionType\\n-from .macros import Macro, MacroShape, construct_macro\\n-from .variable import DottedName, DottedVariable\\n-from .variable import Variable\\n-from .variable import ValuedVariable\\n-from .internals import PyccelSymbol\\n+from ..errors.errors    import Errors\\n+from ..errors.messages  import TEMPLATE_IN_UNIONTYPE\\n+from .basic             import Basic, iterable\\n+from .core              import ValuedArgument\\n+from .core              import FunctionDef, Interface, FunctionAddress\\n+from .core              import create_incremented_string\\n+from .datatypes         import datatype, DataTypeFactory, UnionType\\n+from .internals         import PyccelSymbol\\n+from .macros            import Macro, MacroShape, construct_macro\\n+from .variable          import DottedName, DottedVariable\\n+from .variable          import Variable\\n+from .variable          import ValuedVariable\\n \\n __all__ = (\\n     'ClassHeader',\\n@@ -154,9 +152,6 @@ class Template(Header):\\n     >>> T = Template('T', [d_var0, d_var1])\\n     \\\"\\\"\\\"\\n \\n-    def __new__(cls, *args, **kwargs):\\n-        return super().__new__(cls)\\n-\\n     def __init__(self, name, dtypes):\\n         super().__init__()\\n         self._name = name\\n@@ -191,7 +186,7 @@ class Template(Header):\\n            to create the initial version of the object\\n            and its arguments\\n            \\\"\\\"\\\"\\n-        return (self.__class__, (self.name, self.args))\\n+        return (self.__class__, (self.name, self.dtypes))\\n \\n #==============================================================================\\n class FunctionHeader(Header):\\n\",\"diff --git a/pyccel/ast/internals.py b/pyccel/ast/internals.py\\nindex 5c00a7d..dd83839 100644\\n--- a/pyccel/ast/internals.py\\n+++ b/pyccel/ast/internals.py\\n@@ -156,19 +156,6 @@ class Slice(Basic):\\n         \\\"\\\"\\\"\\n         return self._step\\n \\n-    def _sympystr(self, printer):\\n-        \\\"\\\"\\\" sympy equivalent of __str__\\\"\\\"\\\"\\n-        sstr = printer.doprint\\n-        if self.start is None:\\n-            start = ''\\n-        else:\\n-            start = sstr(self.start)\\n-        if self.stop is None:\\n-            stop = ''\\n-        else:\\n-            stop = sstr(self.stop)\\n-        return '{0} : {1}'.format(start, stop)\\n-\\n     def __str__(self):\\n         if self.start is None:\\n             start = ''\\n\",\"diff --git a/pyccel/ast/itertoolsext.py b/pyccel/ast/itertoolsext.py\\nindex 68a52de..5cffcb1 100644\\n--- a/pyccel/ast/itertoolsext.py\\n+++ b/pyccel/ast/itertoolsext.py\\n@@ -17,7 +17,7 @@ class Product(Basic):\\n \\n     arg : list, tuple\\n     \\\"\\\"\\\"\\n-    _attribute_nodes = ('_args',)\\n+    _attribute_nodes = ('_elements',)\\n \\n     def __new__(cls, *args):\\n         if not isinstance(args, (tuple, list)):\\n@@ -25,7 +25,7 @@ class Product(Basic):\\n         elif len(args) < 2:\\n             return args[0]\\n         else:\\n-            return super().__new__(cls, *args)\\n+            return super().__new__(cls)\\n \\n     def __init__(self, *args):\\n         self._elements = args\\n\",\"diff --git a/pyccel/ast/literals.py b/pyccel/ast/literals.py\\nindex 0c37312..6dd638d 100644\\n--- a/pyccel/ast/literals.py\\n+++ b/pyccel/ast/literals.py\\n@@ -4,7 +4,7 @@\\n #------------------------------------------------------------------------------------------#\\n \\\"\\\"\\\" This module contains all literal types\\n \\\"\\\"\\\"\\n-from sympy               import Float as sp_Float\\n+from pyccel.utilities.metaclasses import Singleton, ArgumentSingleton\\n \\n from .basic              import PyccelAstNode, Basic\\n from .datatypes          import (NativeInteger, NativeBool, NativeReal,\\n@@ -47,11 +47,8 @@ class Literal(PyccelAstNode):\\n     def python_value(self):\\n         \\\"\\\"\\\" Get python literal represented by this instance \\\"\\\"\\\"\\n \\n-    def __repr__(self):\\n-        return repr(self.python_value)\\n-\\n-    def _sympystr(self, printer):\\n-        return printer.doprint(self.python_value)\\n+    def __str__(self):\\n+        return str(self.python_value)\\n \\n     def __eq__(self, other):\\n         if isinstance(other, PyccelAstNode):\\n@@ -63,7 +60,7 @@ class Literal(PyccelAstNode):\\n         return hash(self.python_value)\\n \\n #------------------------------------------------------------------------------\\n-class LiteralTrue(Literal):\\n+class LiteralTrue(Literal, metaclass = ArgumentSingleton):\\n     \\\"\\\"\\\"Represents the python value True\\\"\\\"\\\"\\n     _dtype     = NativeBool()\\n \\n@@ -75,7 +72,7 @@ class LiteralTrue(Literal):\\n         return True\\n \\n #------------------------------------------------------------------------------\\n-class LiteralFalse(Literal):\\n+class LiteralFalse(Literal, metaclass = ArgumentSingleton):\\n     \\\"\\\"\\\"Represents the python value False\\\"\\\"\\\"\\n     _dtype     = NativeBool()\\n \\n@@ -105,20 +102,22 @@ class LiteralInteger(Literal):\\n         return self.python_value\\n \\n #------------------------------------------------------------------------------\\n-class LiteralFloat(Literal, sp_Float):\\n+class LiteralFloat(Literal):\\n     \\\"\\\"\\\"Represents a float literal in python\\\"\\\"\\\"\\n     _dtype     = NativeReal()\\n-    def __new__(cls, value, *, precision = default_precision['float']):\\n-        return sp_Float.__new__(cls, value)\\n \\n     def __init__(self, value, *, precision = default_precision['float']):\\n         if not isinstance(value, (int, float, LiteralFloat)):\\n             raise TypeError(\\\"A LiteralFloat can only be created with an integer or a float\\\")\\n         Literal.__init__(self, precision)\\n+        if isinstance(value, LiteralFloat):\\n+            self._value = value.python_value\\n+        else:\\n+            self._value = float(value)\\n \\n     @property\\n     def python_value(self):\\n-        return float(self)\\n+        return self._value\\n \\n \\n #------------------------------------------------------------------------------\\n@@ -128,13 +127,13 @@ class LiteralComplex(Literal):\\n \\n     def __new__(cls, real, imag, precision = default_precision['complex']):\\n         if cls is LiteralImaginaryUnit:\\n-            return super().__new__(cls, real, imag)\\n+            return super().__new__(cls)\\n         real_part = cls._collect_python_val(real)\\n         imag_part = cls._collect_python_val(imag)\\n         if real_part == 0 and imag_part == 1:\\n             return LiteralImaginaryUnit()\\n         else:\\n-            return super().__new__(cls, real, imag)\\n+            return super().__new__(cls)\\n \\n     def __init__(self, real, imag, precision = default_precision['complex']):\\n         super().__init__(precision)\\n@@ -206,7 +205,7 @@ class LiteralString(Literal):\\n \\n #------------------------------------------------------------------------------\\n \\n-class Nil(Basic):\\n+class Nil(Basic, metaclass=Singleton):\\n \\n     \\\"\\\"\\\"\\n     class for None object in the code.\\n@@ -220,8 +219,6 @@ class Nil(Basic):\\n         return False\\n \\n     def __eq__(self, other):\\n-        #TODO [EB 7.2.2021] Make Nil singleton. See https://stackoverflow.com/questions/6760685/creating-a-singleton-in-python method 3\\n-        #                   Blocked by issue 662\\n         return isinstance(other, Nil)\\n \\n #------------------------------------------------------------------------------\\n\",\"diff --git a/pyccel/ast/macros.py b/pyccel/ast/macros.py\\nindex 6f82b32..7b70d37 100644\\n--- a/pyccel/ast/macros.py\\n+++ b/pyccel/ast/macros.py\\n@@ -7,8 +7,6 @@\\n \\\"\\\"\\\"\\n This module contains all classes and functions used for handling macros.\\n \\\"\\\"\\\"\\n-from sympy.core.expr import AtomicExpr\\n-\\n from .basic          import PyccelAstNode\\n from .datatypes      import default_precision\\n from .datatypes      import NativeInteger, NativeGeneric\\n@@ -24,7 +22,7 @@ __all__ = (\\n )\\n \\n #==============================================================================\\n-class Macro(AtomicExpr, PyccelAstNode):\\n+class Macro(PyccelAstNode):\\n     \\\"\\\"\\\".\\\"\\\"\\\"\\n     _name = '__UNDEFINED__'\\n     _attribute_nodes = ()\\n@@ -61,13 +59,12 @@ class MacroShape(Macro):\\n     def index(self):\\n         return self._index\\n \\n-    def _sympystr(self, printer):\\n-        sstr = printer.doprint\\n+    def __str__(self):\\n         if self.index is None:\\n-            return 'MacroShape({})'.format(sstr(self.argument))\\n+            return 'MacroShape({})'.format(str(self.argument))\\n         else:\\n-            return 'MacroShape({}, {})'.format(sstr(self.argument),\\n-                                               sstr(self.index))\\n+            return 'MacroShape({}, {})'.format(str(self.argument),\\n+                                               str(self.index))\\n \\n #==============================================================================\\n class MacroType(Macro):\\n@@ -78,9 +75,8 @@ class MacroType(Macro):\\n     _shape     = ()\\n     _precision = 0\\n \\n-    def _sympystr(self, printer):\\n-        sstr = printer.doprint\\n-        return 'MacroType({})'.format(sstr(self.argument))\\n+    def __str__(self):\\n+        return 'MacroType({})'.format(str(self.argument))\\n \\n #==============================================================================\\n class MacroCount(Macro):\\n@@ -91,9 +87,8 @@ class MacroCount(Macro):\\n     _dtype     = NativeInteger()\\n     _precision = default_precision['integer']\\n \\n-    def _sympystr(self, printer):\\n-        sstr = printer.doprint\\n-        return 'MacroCount({})'.format(sstr(self.argument))\\n+    def __str__(self):\\n+        return 'MacroCount({})'.format(str(self.argument))\\n \\n \\n \\n\",\"diff --git a/pyccel/ast/numpyext.py b/pyccel/ast/numpyext.py\\nindex 61c2802..2ec4e93 100644\\n--- a/pyccel/ast/numpyext.py\\n+++ b/pyccel/ast/numpyext.py\\n@@ -7,8 +7,7 @@\\n \\n import numpy\\n \\n-from sympy           import Expr\\n-\\n+from .basic          import PyccelAstNode\\n from .builtins       import (PythonInt, PythonBool, PythonFloat, PythonTuple,\\n                              PythonComplex, PythonReal, PythonImag, PythonList)\\n \\n@@ -118,7 +117,7 @@ class NumpyInt(PythonInt):\\n     \\\"\\\"\\\" Represents a call to numpy.int() function.\\n     \\\"\\\"\\\"\\n     def __new__(cls, arg=None, base=10):\\n-        return PythonInt.__new__(cls, arg)\\n+        return super().__new__(cls, arg)\\n \\n class NumpyInt32(NumpyInt):\\n     \\\"\\\"\\\" Represents a call to numpy.int32() function.\\n@@ -245,8 +244,8 @@ class NumpyArray(NumpyNewArray):\\n         self._precision = prec\\n         super().__init__()\\n \\n-    def _sympystr(self, printer):\\n-        return self.arg\\n+    def __str__(self):\\n+        return str(self.arg)\\n \\n     @property\\n     def arg(self):\\n@@ -320,8 +319,7 @@ class NumpySum(PyccelInternalFunction):\\n     \\\"\\\"\\\"\\n \\n     def __init__(self, arg):\\n-        if not isinstance(arg, (list, tuple, PythonTuple, PythonList,\\n-                            Variable, Expr)):\\n+        if not isinstance(arg, PyccelAstNode):\\n             raise TypeError('Unknown type of  %s.' % type(arg))\\n         super().__init__(arg)\\n         self._dtype = arg.dtype\\n@@ -341,8 +339,7 @@ class NumpyProduct(PyccelInternalFunction):\\n     \\\"\\\"\\\"\\n \\n     def __init__(self, arg):\\n-        if not isinstance(arg, (list, tuple, PythonTuple, PythonList,\\n-                                Variable, Expr)):\\n+        if not isinstance(arg, PyccelAstNode):\\n             raise TypeError('Unknown type of  %s.' % type(arg))\\n         super().__init__(arg)\\n         self._dtype = arg.dtype\\n@@ -362,11 +359,9 @@ class NumpyMatmul(PyccelInternalFunction):\\n     \\\"\\\"\\\"\\n \\n     def __init__(self, a ,b):\\n-        if not isinstance(a, (list, tuple, PythonTuple, PythonList,\\n-                                Variable, Expr)):\\n+        if not isinstance(a, PyccelAstNode):\\n             raise TypeError('Unknown type of  %s.' % type(a))\\n-        if not isinstance(b, (list, tuple, PythonTuple, PythonList,\\n-                                Variable, Expr)):\\n+        if not isinstance(b, PyccelAstNode):\\n             raise TypeError('Unknown type of  %s.' % type(a))\\n         super().__init__(a, b)\\n \\n@@ -478,11 +473,10 @@ class NumpyLinspace(NumpyNewArray):\\n     def step(self):\\n         return (self.stop - self.start) / (self.size - 1)\\n \\n-    def _sympystr(self, printer):\\n-        sstr = printer.doprint\\n-        code = 'linspace({}, {}, {})',format(sstr(self.start),\\n-                                             sstr(self.stop),\\n-                                             sstr(self.size))\\n+    def __str__(self):\\n+        code = 'linspace({}, {}, {})'.format(str(self.start),\\n+                                             str(self.stop),\\n+                                             str(self.size))\\n         return code\\n \\n #==============================================================================\\n\",\"diff --git a/pyccel/ast/operators.py b/pyccel/ast/operators.py\\nindex 62c7ee7..96a9c79 100644\\n--- a/pyccel/ast/operators.py\\n+++ b/pyccel/ast/operators.py\\n@@ -8,7 +8,6 @@ These operators all have a precision as detailed here:\\n     https://docs.python.org/3/reference/expressions.html#operator-precedence\\n They also have specific rules to determine the dtype, precision, rank, shape\\n \\\"\\\"\\\"\\n-from sympy.core.expr        import Expr\\n \\n from ..errors.errors        import Errors, PyccelSemanticError\\n \\n@@ -94,7 +93,7 @@ def broadcast(shape_1, shape_2):\\n \\n #==============================================================================\\n \\n-class PyccelOperator(Expr, PyccelAstNode):\\n+class PyccelOperator(PyccelAstNode):\\n     \\\"\\\"\\\"\\n     Abstract superclass for all builtin operators.\\n     The __init__ function is common\\n@@ -177,6 +176,12 @@ class PyccelOperator(Expr, PyccelAstNode):\\n         else:\\n             self._order = 'C'\\n \\n+    @property\\n+    def args(self):\\n+        \\\"\\\"\\\" Arguments of the operator\\n+        \\\"\\\"\\\"\\n+        return self._args\\n+\\n #==============================================================================\\n \\n class PyccelUnaryOperator(PyccelOperator):\\n@@ -474,7 +479,7 @@ class PyccelAdd(PyccelArithmeticOperator):\\n            arg1.real == LiteralFloat(0):\\n             return LiteralComplex(arg2, arg1.imag)\\n         else:\\n-            return PyccelArithmeticOperator.__new__(cls, arg1, arg2)\\n+            return super().__new__(cls)\\n \\n     def _handle_str_type(self, strs):\\n         self._dtype = NativeString()\\n@@ -533,7 +538,7 @@ class PyccelMinus(PyccelArithmeticOperator):\\n            arg1.real == LiteralFloat(0):\\n             return LiteralComplex(-arg2.python_value, arg1.imag)\\n         else:\\n-            return PyccelArithmeticOperator.__new__(cls, arg1, arg2)\\n+            return super().__new__(cls)\\n \\n     def __repr__(self):\\n         return '{} - {}'.format(repr(self.args[0]), repr(self.args[1]))\\n@@ -826,9 +831,10 @@ class PyccelIs(PyccelBooleanOperator):\\n \\n     Examples\\n     --------\\n-    >>> from pyccel.ast import PyccelIs\\n-    >>> from pyccel.literals import Nil\\n-    >>> from sympy.abc import x\\n+    >>> from pyccel.ast.operators import PyccelIs\\n+    >>> from pyccel.ast.literals  import Nil\\n+    >>> from pyccel.ast.internals import PyccelSymbol\\n+    >>> x = PyccelSymbol('x')\\n     >>> PyccelIs(x, Nil())\\n     PyccelIs(x, None)\\n     \\\"\\\"\\\"\\n@@ -858,9 +864,10 @@ class PyccelIsNot(PyccelIs):\\n \\n     Examples\\n     --------\\n-    >>> from pyccel.ast import PyccelIsNot\\n-    >>> from pyccel.ast.literals import Nil\\n-    >>> from sympy.abc import x\\n+    >>> from pyccel.ast.operators import PyccelIsNot\\n+    >>> from pyccel.ast.literals  import Nil\\n+    >>> from pyccel.ast.internals import PyccelSymbol\\n+    >>> x = PyccelSymbol('x')\\n     >>> PyccelIsNot(x, Nil())\\n     PyccelIsNot(x, None)\\n     \\\"\\\"\\\"\\n\",\"diff --git a/pyccel/ast/variable.py b/pyccel/ast/variable.py\\nindex 91cd293..172b76d 100644\\n--- a/pyccel/ast/variable.py\\n+++ b/pyccel/ast/variable.py\\n@@ -44,7 +44,7 @@ class Variable(PyccelAstNode):\\n         or a str (bool, int, real).\\n \\n     name : str, list, DottedName\\n-        The sympy object the variable represents. This can be either a string\\n+        The name of the variable represented. This can be either a string\\n         or a dotted name, when using a Class attribute.\\n \\n     rank : int\\n@@ -366,11 +366,6 @@ class Variable(PyccelAstNode):\\n     def __hash__(self):\\n         return hash((type(self).__name__, self._name))\\n \\n-    def _sympystr(self, printer):\\n-        \\\"\\\"\\\" sympy equivalent of __str__\\\"\\\"\\\"\\n-        sstr = printer.doprint\\n-        return '{}'.format(sstr(self.name))\\n-\\n     def inspect(self):\\n         \\\"\\\"\\\"inspects the variable.\\\"\\\"\\\"\\n \\n@@ -459,10 +454,6 @@ class Variable(PyccelAstNode):\\n         out =  (apply, (Variable, args, kwargs))\\n         return out\\n \\n-    def _eval_subs(self, old, new):\\n-        \\\"\\\"\\\" Overrides sympy method to indicate an atom\\\"\\\"\\\"\\n-        return self\\n-\\n     def __getitem__(self, *args):\\n \\n         if len(args) == 1 and isinstance(args[0], (tuple, list)):\\n@@ -507,11 +498,6 @@ class DottedName(Basic):\\n     def __str__(self):\\n         return \\\"\\\"\\\".\\\"\\\"\\\".join(str(n) for n in self.name)\\n \\n-    def _sympystr(self, printer):\\n-        \\\"\\\"\\\" sympy equivalent of __str__\\\"\\\"\\\"\\n-        sstr = printer.doprint\\n-        return \\\"\\\"\\\".\\\"\\\"\\\".join(sstr(n) for n in self.name)\\n-\\n class ValuedVariable(Variable):\\n \\n     \\\"\\\"\\\"Represents a valued variable in the code.\\n@@ -544,12 +530,9 @@ class ValuedVariable(Variable):\\n         \\\"\\\"\\\"\\n         return self._value\\n \\n-    def _sympystr(self, printer):\\n-        \\\"\\\"\\\" sympy equivalent of __str__\\\"\\\"\\\"\\n-        sstr = printer.doprint\\n-\\n-        name = sstr(self.name)\\n-        value = sstr(self.value)\\n+    def __str__(self):\\n+        name = str(self.name)\\n+        value = str(self.value)\\n         return '{0}={1}'.format(name, value)\\n \\n class TupleVariable(Variable):\\n@@ -699,10 +682,10 @@ class IndexedElement(PyccelAstNode):\\n \\n     Examples\\n     --------\\n-    >>> from sympy import symbols, Idx\\n     >>> from pyccel.ast.core import Variable, IndexedElement\\n-    >>> i, j = symbols('i j', cls=Idx)\\n-    >>> A = Variable('A', dtype='int')\\n+    >>> A = Variable('A', dtype='int', shape=(2,3), rank=2)\\n+    >>> i = Variable('i', dtype='int')\\n+    >>> j = Variable('j', dtype='int')\\n     >>> IndexedElement(A, i, j)\\n     IndexedElement(A, i, j)\\n     >>> IndexedElement(A, i, j) == A[i, j]\\n\",\"diff --git a/pyccel/codegen/codegen.py b/pyccel/codegen/codegen.py\\nindex 0e4e7cf..bcd0c71 100644\\n--- a/pyccel/codegen/codegen.py\\n+++ b/pyccel/codegen/codegen.py\\n@@ -173,7 +173,7 @@ class Codegen(object):\\n         errors = Errors()\\n         errors.set_parser_stage('codegen')\\n         # set the code printer\\n-        self._printer = code_printer(self.parser, settings)\\n+        self._printer = code_printer(self.parser, **settings)\\n \\n     def get_printer_imports(self):\\n         \\\"\\\"\\\"return the imports of the current codeprinter\\\"\\\"\\\"\\n\",\"diff --git a/pyccel/codegen/printing/ccode.py b/pyccel/codegen/printing/ccode.py\\nindex 84cd3e3..da6b25e 100644\\n--- a/pyccel/codegen/printing/ccode.py\\n+++ b/pyccel/codegen/printing/ccode.py\\n@@ -252,17 +252,17 @@ class CCodePrinter(CodePrinter):\\n         'dereference': set()\\n     }\\n \\n-    def __init__(self, parser, settings=None):\\n+    def __init__(self, parser, **settings):\\n \\n         if parser.filename:\\n             errors.set_target(parser.filename, 'file')\\n \\n-        prefix_module = None if settings is None else settings.pop('prefix_module', None)\\n+        prefix_module = settings.pop('prefix_module', None)\\n         CodePrinter.__init__(self, settings)\\n         self.known_functions = dict(known_functions)\\n-        userfuncs = {} if settings is None else settings.get('user_functions', {})\\n+        userfuncs = settings.get('user_functions', {})\\n         self.known_functions.update(userfuncs)\\n-        self._dereference = set([] if settings is None else settings.get('dereference', []))\\n+        self._dereference = set(settings.get('dereference', []))\\n         self.prefix_module = prefix_module\\n         self._additional_imports = set(['stdlib'])\\n         self._parser = parser\\n@@ -445,11 +445,8 @@ class CCodePrinter(CodePrinter):\\n         value = self._print(expr.arg)\\n         return '({} != 0)'.format(value)\\n \\n-    def _print_LiteralInteger(self, expr):\\n-        return str(expr.p)\\n-\\n-    def _print_LiteralFloat(self, expr):\\n-        return CodePrinter._print_Float(self, expr)\\n+    def _print_Literal(self, expr):\\n+        return repr(expr.python_value)\\n \\n     def _print_LiteralComplex(self, expr):\\n         if expr.real == LiteralFloat(0):\\n@@ -1559,4 +1556,4 @@ def ccode(expr, parser, assign_to=None, **settings):\\n         For example, if ``dereference=[a]``, the resulting code would print\\n         ``(*a)`` instead of ``a``.\\n     \\\"\\\"\\\"\\n-    return CCodePrinter(parser, settings).doprint(expr, assign_to)\\n+    return CCodePrinter(parser, **settings).doprint(expr, assign_to)\\n\",\"diff --git a/pyccel/codegen/printing/cwrappercode.py b/pyccel/codegen/printing/cwrappercode.py\\nindex 0a7cc37..d11476d 100644\\n--- a/pyccel/codegen/printing/cwrappercode.py\\n+++ b/pyccel/codegen/printing/cwrappercode.py\\n@@ -54,8 +54,8 @@ dtype_registry = {('pyobject'     , 0) : 'PyObject',\\n class CWrapperCodePrinter(CCodePrinter):\\n     \\\"\\\"\\\"A printer to convert a python module to strings of c code creating\\n     an interface between python and an implementation of the module in c\\\"\\\"\\\"\\n-    def __init__(self, parser, target_language, settings=None):\\n-        CCodePrinter.__init__(self, parser,settings)\\n+    def __init__(self, parser, target_language, **settings):\\n+        CCodePrinter.__init__(self, parser, **settings)\\n         self._target_language = target_language\\n         self._cast_functions_dict = OrderedDict()\\n         self._to_free_PyObject_list = []\\n@@ -1020,4 +1020,4 @@ def cwrappercode(expr, parser, target_language, assign_to=None, **settings):\\n         ``(*a)`` instead of ``a``.\\n     \\\"\\\"\\\"\\n \\n-    return CWrapperCodePrinter(parser, target_language, settings).doprint(expr, assign_to)\\n+    return CWrapperCodePrinter(parser, target_language, **settings).doprint(expr, assign_to)\\n\",\"diff --git a/pyccel/codegen/printing/fcode.py b/pyccel/codegen/printing/fcode.py\\nindex 2c8e2b5..f21af2a 100644\\n--- a/pyccel/codegen/printing/fcode.py\\n+++ b/pyccel/codegen/printing/fcode.py\\n@@ -198,7 +198,7 @@ class FCodePrinter(CodePrinter):\\n     }\\n \\n \\n-    def __init__(self, parser, settings={}):\\n+    def __init__(self, parser, **settings):\\n \\n         prefix_module = settings.pop('prefix_module', None)\\n \\n@@ -1404,12 +1404,6 @@ class FCodePrinter(CodePrinter):\\n     def _print_DataType(self, expr):\\n         return self._print(expr.name)\\n \\n-    def _print_LiteralTrue(self, expr):\\n-        return '.True._{}'.format(self.print_kind(expr))\\n-\\n-    def _print_LiteralFalse(self, expr):\\n-        return '.False._{}'.format(self.print_kind(expr))\\n-\\n     def _print_LiteralString(self, expr):\\n         sp_chars = ['\\\\a', '\\\\b', '\\\\f', '\\\\r', '\\\\t', '\\\\v', \\\"'\\\", '\\\\n']\\n         sub_str = ''\\n@@ -1833,7 +1827,7 @@ class FCodePrinter(CodePrinter):\\n                                        prolog, epilog)\\n \\n         elif isinstance(expr.iterable, Product):\\n-            for i, a in zip(expr.target, expr.iterable.args):\\n+            for i, a in zip(expr.target, expr.iterable.elements):\\n                 if isinstance(a, PythonRange):\\n                     itr_ = a\\n                 else:\\n@@ -1842,7 +1836,7 @@ class FCodePrinter(CodePrinter):\\n                                            prolog, epilog)\\n \\n         elif isinstance(expr.iterable, PythonZip):\\n-            itr_ = PythonRange(expr.iterable.element.shape[0])\\n+            itr_ = PythonRange(expr.iterable.length)\\n             prolog, epilog = _do_range(expr.target, itr_, \\\\\\n                                        prolog, epilog)\\n \\n@@ -2595,18 +2589,21 @@ class FCodePrinter(CodePrinter):\\n     def _print_int(self, expr):\\n         return str(expr)\\n \\n-    def _print_LiteralFloat(self, expr):\\n-        printed = CodePrinter._print_Float(self, expr)\\n+    def _print_Literal(self, expr):\\n+        printed = repr(expr.python_value)\\n         return \\\"{}_{}\\\".format(printed, self.print_kind(expr))\\n \\n+    def _print_LiteralTrue(self, expr):\\n+        return \\\".True._{}\\\".format(self.print_kind(expr))\\n+\\n+    def _print_LiteralFalse(self, expr):\\n+        return \\\".False._{}\\\".format(self.print_kind(expr))\\n+\\n     def _print_LiteralComplex(self, expr):\\n         real_str = self._print(expr.real)\\n         imag_str = self._print(expr.imag)\\n         return \\\"({}, {})\\\".format(real_str, imag_str)\\n \\n-    def _print_LiteralInteger(self, expr):\\n-        return \\\"{0}_{1}\\\".format(str(expr.p), self.print_kind(expr))\\n-\\n     def _print_IndexedElement(self, expr):\\n         base = expr.base\\n         if isinstance(base, PyccelInternalFunction) and not isinstance(base, PythonTuple):\\n@@ -2936,4 +2933,4 @@ def fcode(expr, parser, assign_to=None, **settings):\\n         for examples.\\n     \\\"\\\"\\\"\\n \\n-    return FCodePrinter(parser, settings).doprint(expr, assign_to)\\n+    return FCodePrinter(parser, **settings).doprint(expr, assign_to)\\n\",\"diff --git a/pyccel/codegen/printing/pycode.py b/pyccel/codegen/printing/pycode.py\\nindex c4b3115..7097ec1 100644\\n--- a/pyccel/codegen/printing/pycode.py\\n+++ b/pyccel/codegen/printing/pycode.py\\n@@ -8,7 +8,6 @@\\n \\n from itertools import chain\\n \\n-from sympy.printing.pycode import PythonCodePrinter as SympyPythonCodePrinter\\n from sympy.printing.pycode import _known_functions\\n from sympy.printing.pycode import _known_functions_math\\n from sympy.printing.pycode import _known_constants_math\\n@@ -18,6 +17,8 @@ from pyccel.decorators import __all__ as pyccel_decorators\\n from pyccel.ast.utilities  import build_types_decorator\\n from pyccel.ast.core       import CodeBlock, Import, DottedName\\n \\n+from pyccel.codegen.printing.codeprinter import CodePrinter\\n+\\n from pyccel.errors.errors import Errors\\n from pyccel.errors.messages import *\\n \\n@@ -31,19 +32,27 @@ def _construct_header(func_name, args):\\n     return pattern.format(name=func_name, args=args)\\n \\n #==============================================================================\\n-class PythonCodePrinter(SympyPythonCodePrinter):\\n+class PythonCodePrinter(CodePrinter):\\n+    \\\"\\\"\\\"A printer to convert pyccel expressions to strings of Python code\\\"\\\"\\\"\\n+    printmethod = \\\"_pycode\\\"\\n     _kf = dict(chain(\\n         _known_functions.items(),\\n         [(k, '' + v) for k, v in _known_functions_math.items()]\\n     ))\\n     _kc = {k: ''+v for k, v in _known_constants_math.items()}\\n \\n-    def __init__(self, parser=None, settings=None):\\n+    def __init__(self, parser=None, **settings):\\n         self.assert_contiguous = settings.pop('assert_contiguous', False)\\n         self.parser = parser\\n-        SympyPythonCodePrinter.__init__(self, settings=settings)\\n+        super().__init__(settings=settings)\\n         self._additional_imports = set()\\n \\n+    def _indent_codestring(self, lines):\\n+        return '    '+lines.replace('\\\\n','\\\\n    ')\\n+\\n+    def _format_code(self, lines):\\n+        return lines\\n+\\n     def get_additional_imports(self):\\n         \\\"\\\"\\\"return the additional imports collected in printing stage\\\"\\\"\\\"\\n         return self._additional_imports\\n@@ -100,7 +109,7 @@ class PythonCodePrinter(SympyPythonCodePrinter):\\n                 for func in f:\\n                     args = func.args\\n                     if args:\\n-                        args = ', '.join(\\\"{}\\\".format(self._print(i)) for i in args)\\n+                        args = ', '.join(self._print(i) for i in args)\\n                         dec += '@{name}({args})\\\\n'.format(name=n, args=args)\\n \\n                     else:\\n@@ -204,7 +213,7 @@ class PythonCodePrinter(SympyPythonCodePrinter):\\n         op  = self._print(expr.op._symbol)\\n         return'{0} {1}= {2}'.format(lhs,op,rhs)\\n \\n-    def _print_Range(self, expr):\\n+    def _print_PythonRange(self, expr):\\n         start = self._print(expr.start)\\n         stop  = self._print(expr.stop)\\n         step  = self._print(expr.step)\\n@@ -261,8 +270,8 @@ class PythonCodePrinter(SympyPythonCodePrinter):\\n                 lines.append(self._print(e))\\n         return \\\"\\\\n\\\".join(lines)\\n \\n-    def _print_LiteralString(self, expr):\\n-        return '\\\"{}\\\"'.format(self._print(expr.arg))\\n+    def _print_Literal(self, expr):\\n+        return repr(expr.python_value)\\n \\n     def _print_Shape(self, expr):\\n         arg = self._print(expr.arg)\\n@@ -281,10 +290,10 @@ class PythonCodePrinter(SympyPythonCodePrinter):\\n \\n             elif isinstance(f, tuple):\\n                 for i in f:\\n-                    args.append(\\\"{}\\\".format(self._print(i)))\\n+                    args.append(self._print(i))\\n \\n             else:\\n-                args.append(\\\"{}\\\".format(self._print(f)))\\n+                args.append(self._print(f))\\n \\n         fs = ', '.join(i for i in args)\\n \\n@@ -372,7 +381,7 @@ class PythonCodePrinter(SympyPythonCodePrinter):\\n         return expr\\n \\n #==============================================================================\\n-def pycode(expr, **settings):\\n+def pycode(expr, assign_to=None, **settings):\\n     \\\"\\\"\\\" Converts an expr to a string of Python code\\n     Parameters\\n     ==========\\n@@ -389,4 +398,4 @@ def pycode(expr, **settings):\\n     'math.tan(x) + 1'\\n     \\\"\\\"\\\"\\n     settings.pop('parser', None)\\n-    return PythonCodePrinter(settings).doprint(expr)\\n+    return PythonCodePrinter(settings).doprint(expr, assign_to)\\n\",\"diff --git a/pyccel/errors/errors.py b/pyccel/errors/errors.py\\nindex 9a1ea34..f053743 100644\\n--- a/pyccel/errors/errors.py\\n+++ b/pyccel/errors/errors.py\\n@@ -12,7 +12,9 @@ import sys\\n \\n from collections import OrderedDict\\n from os.path import basename\\n+\\n from pyccel.ast.basic import Basic\\n+from pyccel.utilities.metaclasses import Singleton\\n \\n # ...\\n #ERROR = 'error'\\n@@ -126,20 +128,7 @@ class ErrorInfo:\\n         return pattern.format(**info)\\n \\n \\n-def _singleton(cls):\\n-    \\\"\\\"\\\"\\n-    A Class representing a singleton. Python does not offer this pattern.\\n-    \\\"\\\"\\\"\\n-    instances = {}\\n-    def getinstance():\\n-        if cls not in instances:\\n-            instances[cls] = cls() # Line 5\\n-        return instances[cls]\\n-    return getinstance\\n-\\n-\\n-@_singleton\\n-class ErrorsMode:\\n+class ErrorsMode(metaclass = Singleton):\\n     \\\"\\\"\\\"Developper or User mode.\\n     pyccel command line will set it.\\n     \\\"\\\"\\\"\\n@@ -155,8 +144,7 @@ class ErrorsMode:\\n         self._mode = mode\\n \\n \\n-@_singleton\\n-class Errors:\\n+class Errors(metaclass = Singleton):\\n     \\\"\\\"\\\"Container for compile errors.\\n     \\\"\\\"\\\"\\n \\n\",\"diff --git a/pyccel/parser/semantic.py b/pyccel/parser/semantic.py\\nindex 33c36d2..d1e3722 100644\\n--- a/pyccel/parser/semantic.py\\n+++ b/pyccel/parser/semantic.py\\n@@ -46,11 +46,10 @@ from pyccel.ast.variable import ValuedVariable\\n from pyccel.ast.core import ValuedArgument\\n from pyccel.ast.core import Import\\n from pyccel.ast.core import AsName\\n-from pyccel.ast.core import With, Block\\n+from pyccel.ast.core import With\\n from pyccel.ast.builtins import PythonList\\n from pyccel.ast.core import Dlist\\n from pyccel.ast.core import StarredArguments\\n-from pyccel.ast.core import subs\\n from pyccel.ast.core import get_assigned_symbols\\n from pyccel.ast.operators import PyccelIs, PyccelIsNot, IfTernaryOperator\\n from pyccel.ast.itertoolsext import Product\\n@@ -1164,7 +1163,7 @@ class SemanticParser(BasicParser):\\n     def _visit_PyccelOperator(self, expr, **settings):\\n         args     = [self._visit(a, **settings) for a in expr.args]\\n         try:\\n-            expr_new = expr.func(*args)\\n+            expr_new = type(expr)(*args)\\n         except PyccelSemanticError as err:\\n             msg = str(err)\\n             errors.report(msg, symbol=expr,\\n@@ -1199,14 +1198,14 @@ class SemanticParser(BasicParser):\\n     def _visit_Lambda(self, expr, **settings):\\n \\n \\n-        expr_names = set(map(str, expr.expr.atoms(PyccelSymbol, Argument)))\\n+        expr_names = set(map(str, expr.expr.get_attribute_nodes((PyccelSymbol, Argument))))\\n         var_names = map(str, expr.variables)\\n         missing_vars = expr_names.difference(var_names)\\n         if len(missing_vars) > 0:\\n             errors.report(UNDEFINED_LAMBDA_VARIABLE, symbol = missing_vars,\\n                 bounding_box=(self._current_fst_node.lineno, self._current_fst_node.col_offset),\\n                 severity='fatal', blocker=True)\\n-        funcs = expr.expr.atoms(FunctionCall)\\n+        funcs = expr.expr.get_attribute_nodes(FunctionCall)\\n         for func in funcs:\\n             name = _get_name(func)\\n             f = self.get_symbolic_function(name)\\n@@ -1720,22 +1719,6 @@ class SemanticParser(BasicParser):\\n             rhs = self._visit_FunctionDef(rhs, **settings)\\n             return rhs\\n \\n-        elif isinstance(rhs, Block):\\n-            #case of inline\\n-            results = rhs.get_attribute_nodes(rhs.body,Return)\\n-            sub = list(zip(results,[EmptyNode()]*len(results)))\\n-            body = rhs.body\\n-            body = subs(body,sub)\\n-            results = [i.expr for i in results]\\n-            lhs = expr.lhs\\n-            if isinstance(lhs ,(list, tuple, PythonTuple)):\\n-                sub = [list(zip(i,lhs)) for i in results]\\n-            else:\\n-                sub = [(i[0],lhs) for i in results]\\n-            body = subs(body,sub)\\n-            expr = Block(rhs.name, rhs.variables, body)\\n-            return expr\\n-\\n         elif isinstance(rhs, CodeBlock):\\n             if len(rhs.body)>1 and isinstance(rhs.body[1], FunctionalFor):\\n                 return rhs\\n@@ -2028,7 +2011,7 @@ class SemanticParser(BasicParser):\\n         elif isinstance(iterable, PythonEnumerate):\\n             indx   = iterator.args[0]\\n             var    = iterator.args[1]\\n-            assign = Assign(var, IndexedElement(iterable.args[0], indx))\\n+            assign = Assign(var, IndexedElement(iterable.element, indx))\\n             assign.set_fst(expr.fst)\\n             iterator = indx\\n             body     = [assign] + body\\n@@ -2319,8 +2302,10 @@ class SemanticParser(BasicParser):\\n         return If(*args)\\n \\n     def _visit_IfTernaryOperator(self, expr, **settings):\\n-        args = [self._visit(i, **settings) for i in expr.args]\\n-        return expr.func(*args)\\n+        cond        = self._visit(expr.cond, **settings)\\n+        value_true  = self._visit(expr.value_true, **settings)\\n+        value_false = self._visit(expr.value_false, **settings)\\n+        return IfTernaryOperator(cond, value_true, value_false)\\n \\n     def _visit_VariableHeader(self, expr, **settings):\\n \\n@@ -3060,8 +3045,8 @@ class SemanticParser(BasicParser):\\n     def _visit_Dlist(self, expr, **settings):\\n         # Arguments have been treated in PyccelMul\\n \\n-        val = expr.args[0]\\n-        length = expr.args[1]\\n+        val = expr.val\\n+        length = expr.length\\n         if isinstance(val, (TupleVariable, PythonTuple)) and \\\\\\n                 not isinstance(val, PythonList):\\n             if isinstance(length, LiteralInteger):\\n\",\"diff --git a/pyccel/utilities/__init__.py b/pyccel/utilities/__init__.py\\nnew file mode 100644\\nindex 0000000..e69de29\\n--- /dev/null\\n+++ b/pyccel/utilities/__init__.py\\n\",\"diff --git a/pyccel/utilities/metaclasses.py b/pyccel/utilities/metaclasses.py\\nnew file mode 100644\\nindex 0000000..7158429\\n--- /dev/null\\n+++ b/pyccel/utilities/metaclasses.py\\n@@ -0,0 +1,32 @@\\n+#------------------------------------------------------------------------------------------#\\n+# This file is part of Pyccel which is released under MIT License. See the LICENSE file or #\\n+# go to https://github.com/pyccel/pyccel/blob/master/LICENSE for full license details.     #\\n+#------------------------------------------------------------------------------------------#\\n+\\\"\\\"\\\" Module containing metaclasses which are useful for the rest of pyccel\\n+\\\"\\\"\\\"\\n+\\n+\\n+__all__ = (\\n+    'Singleton',\\n+    'ArgumentSingleton',\\n+)\\n+\\n+class Singleton(type):\\n+    \\\"\\\"\\\" Indicates that there is only one instance of the class\\n+    \\\"\\\"\\\"\\n+    _instances = {}\\n+    def __call__(cls, *args, **kwargs):\\n+        if cls not in cls._instances:\\n+            cls._instances[cls] = super().__call__(*args, **kwargs)\\n+        return cls._instances[cls]\\n+\\n+class ArgumentSingleton(type):\\n+    \\\"\\\"\\\" Indicates that there is only one instance of the class\\n+    for any given set of arguments\\n+    \\\"\\\"\\\"\\n+    _instances = {}\\n+    def __call__(cls, *args, **kwargs):\\n+        index = (cls, *args, *sorted(kwargs.items()))\\n+        if index not in cls._instances:\\n+            cls._instances[index] = super().__call__(*args, **kwargs)\\n+        return cls._instances[index]\\n\"]", "test_patch": "[\"diff --git a/pyccel/ast/builtins.py b/pyccel/ast/builtins.py\\nindex a9aec3b..c48a0d9 100644\\n--- a/pyccel/ast/builtins.py\\n+++ b/pyccel/ast/builtins.py\\n@@ -85,7 +85,7 @@ class PythonReal(PythonComplexProperty):\\n         elif not isinstance(arg.dtype, NativeComplex):\\n             return arg\\n         else:\\n-            return super().__new__(cls, arg)\\n+            return super().__new__(cls)\\n \\n #==============================================================================\\n class PythonImag(PythonComplexProperty):\\n@@ -102,7 +102,7 @@ class PythonImag(PythonComplexProperty):\\n         if arg.dtype is not NativeComplex():\\n             return get_default_literal_value(arg.dtype)\\n         else:\\n-            return super().__new__(cls, arg)\\n+            return super().__new__(cls)\\n \\n \\n #==============================================================================\\n@@ -115,11 +115,11 @@ class PythonBool(PyccelAstNode):\\n \\n     def __new__(cls, arg):\\n         if getattr(arg, 'is_optional', None):\\n-            bool_expr = super().__new__(cls, arg)\\n+            bool_expr = super().__new__(cls)\\n             bool_expr.__init__(arg)\\n             return PyccelAnd(PyccelIsNot(arg, Nil()), bool_expr)\\n         else:\\n-            return super().__new__(cls, arg)\\n+            return super().__new__(cls)\\n \\n     def __init__(self, arg):\\n         self._arg = arg\\n@@ -134,9 +134,6 @@ class PythonBool(PyccelAstNode):\\n     def __str__(self):\\n         return 'Bool({})'.format(str(self.arg))\\n \\n-    def _sympystr(self, printer):\\n-        return self.__str__()\\n-\\n #==============================================================================\\n class PythonComplex(PyccelAstNode):\\n     \\\"\\\"\\\" Represents a call to Python's native complex() function.\\n@@ -177,7 +174,7 @@ class PythonComplex(PyccelAstNode):\\n         if arg0.dtype is NativeComplex() and arg1.dtype is NativeComplex():\\n             # both args are complex\\n             return PyccelAdd(arg0, PyccelMul(arg1, LiteralImaginaryUnit()))\\n-        return super().__new__(cls, arg0, arg1)\\n+        return super().__new__(cls)\\n \\n     def __init__(self, arg0, arg1 = LiteralFloat(0)):\\n         self._is_cast = arg0.dtype is NativeComplex() and \\\\\\n@@ -232,7 +229,7 @@ class PythonComplex(PyccelAstNode):\\n         return self._internal_var\\n \\n     def __str__(self):\\n-        return \\\"complex({}, {})\\\".format(str(self._args[0]), str(self._args[1]))\\n+        return \\\"complex({}, {})\\\".format(str(self.real), str(self.imag))\\n \\n #==============================================================================\\n class PythonEnumerate(Basic):\\n@@ -268,7 +265,7 @@ class PythonFloat(PyccelAstNode):\\n         elif isinstance(arg, LiteralInteger):\\n             return LiteralFloat(arg.p, precision = cls._precision)\\n         else:\\n-            return super().__new__(cls, arg)\\n+            return super().__new__(cls)\\n \\n     def __init__(self, arg):\\n         self._arg = arg\\n@@ -283,9 +280,6 @@ class PythonFloat(PyccelAstNode):\\n     def __str__(self):\\n         return 'LiteralFloat({0})'.format(str(self.arg))\\n \\n-    def _sympystr(self, printer):\\n-        return self.__str__()\\n-\\n #==============================================================================\\n class PythonInt(PyccelAstNode):\\n     \\\"\\\"\\\" Represents a call to Python's native int() function.\\n@@ -299,7 +293,7 @@ class PythonInt(PyccelAstNode):\\n         if isinstance(arg, LiteralInteger):\\n             return LiteralInteger(arg.p, precision = cls._precision)\\n         else:\\n-            return super().__new__(cls, arg)\\n+            return super().__new__(cls)\\n \\n     def __init__(self, arg):\\n         self._arg = arg\\n@@ -390,6 +384,12 @@ class PythonTuple(PyccelAstNode):\\n     def inconsistent_shape(self):\\n         return self._inconsistent_shape\\n \\n+    @property\\n+    def args(self):\\n+        \\\"\\\"\\\" Arguments of the tuple\\n+        \\\"\\\"\\\"\\n+        return self._args\\n+\\n #==============================================================================\\n class PythonLen(PyccelInternalFunction):\\n \\n@@ -428,13 +428,19 @@ class PythonMap(Basic):\\n         self._args = args\\n         super().__init__()\\n \\n+    @property\\n+    def args(self):\\n+        \\\"\\\"\\\" Arguments of the map\\n+        \\\"\\\"\\\"\\n+        return self._args\\n+\\n #==============================================================================\\n class PythonPrint(Basic):\\n \\n     \\\"\\\"\\\"Represents a print function in the code.\\n \\n-    expr : sympy expr\\n-        The expression to return.\\n+    expr : PyccelAstNode\\n+        The expression to print\\n \\n     Examples\\n \\n@@ -507,7 +513,7 @@ class PythonRange(Basic):\\n \\n \\n #==============================================================================\\n-class PythonZip(Basic):\\n+class PythonZip(PyccelInternalFunction):\\n \\n     \\\"\\\"\\\"\\n     Represents a zip stmt.\\n@@ -520,12 +526,22 @@ class PythonZip(Basic):\\n             raise TypeError('args must be a list or tuple')\\n         elif len(args) < 2:\\n             raise ValueError('args must be of length > 2')\\n-        self._args = args\\n-        super().__init__()\\n+        super().__init__(*args)\\n+        if PyccelAstNode.stage == 'syntactic':\\n+            self._length = None\\n+            return\\n+        else:\\n+            lengths = [a.shape[0].python_value for a in self.args if isinstance(a.shape[0], LiteralInteger)]\\n+            if lengths:\\n+                self._length = min(lengths)\\n+            else:\\n+                self._length = self.args[0].shape[0]\\n \\n     @property\\n-    def element(self):\\n-        return self._args[0]\\n+    def length(self):\\n+        \\\"\\\"\\\" Length of the shortest zip argument\\n+        \\\"\\\"\\\"\\n+        return self._length\\n \\n #==============================================================================\\n class PythonAbs(PyccelInternalFunction):\\n\",\"diff --git a/pyccel/ast/core.py b/pyccel/ast/core.py\\nindex 86b1dd8..dc043b9 100644\\n--- a/pyccel/ast/core.py\\n+++ b/pyccel/ast/core.py\\n@@ -7,20 +7,15 @@\\n \\n from collections     import OrderedDict\\n \\n-from sympy import preorder_traversal\\n-\\n-from sympy.core.compatibility import with_metaclass\\n-from sympy.core.singleton     import Singleton\\n-from sympy.core.expr          import Expr\\n from sympy.logic.boolalg      import And as sp_And\\n \\n-from sympy.utilities.iterables          import iterable\\n-\\n \\n from pyccel.errors.errors import Errors\\n from pyccel.errors.messages import RECURSIVE_RESULTS_REQUIRED\\n \\n-from .basic     import Basic, PyccelAstNode\\n+from pyccel.utilities.metaclasses import Singleton\\n+\\n+from .basic     import Basic, PyccelAstNode, iterable\\n from .builtins  import (PythonEnumerate, PythonLen, PythonMap, PythonTuple,\\n                         PythonRange, PythonZip, PythonBool, Lambda)\\n from .datatypes import (datatype, DataType, NativeSymbol,\\n@@ -169,45 +164,12 @@ def subs(expr, new_elements):\\n         new_expr = expr.subs(new_elements)\\n         new_expr.set_fst(expr.fst)\\n         return new_expr\\n-    elif isinstance(expr, Expr):\\n+    elif isinstance(expr, PyccelAstNode):\\n         return expr.subs(new_elements)\\n \\n     else:\\n         return expr\\n \\n-\\n-\\n-#def collect_vars(ast):\\n-#    \\\"\\\"\\\" collect variables in order to be declared\\\"\\\"\\\"\\n-#    #TODO use the namespace to get the declared variables\\n-#    variables = {}\\n-#    def collect(stmt):\\n-#\\n-#        if isinstance(stmt, Variable):\\n-#            if not isinstance(stmt.name, DottedName):\\n-#                variables[stmt.name] = stmt\\n-#        elif isinstance(stmt, (tuple, list)):\\n-#            for i in stmt:\\n-#                collect(i)\\n-#        if isinstance(stmt, For):\\n-#            collect(stmt.target)\\n-#            collect(stmt.body)\\n-#        elif isinstance(stmt, FunctionalFor):\\n-#            collect(stmt.lhs)\\n-#            collect(stmt.loops)\\n-#        elif isinstance(stmt, If):\\n-#            collect(stmt.bodies)\\n-#        elif isinstance(stmt, (While, CodeBlock)):\\n-#            collect(stmt.body)\\n-#        elif isinstance(stmt, (Assign, AliasAssign, AugAssign)):\\n-#            collect(stmt.lhs)\\n-#            if isinstance(stmt.rhs, (Linspace, Diag, Where)):\\n-#                collect(stmt.rhs.index)\\n-#\\n-#\\n-#    collect(ast)\\n-#    return variables.values()\\n-\\n def inline(func, args):\\n     local_vars = func.local_vars\\n     body = func.body\\n@@ -322,9 +284,8 @@ class AsName(Basic):\\n     def target(self):\\n         return self._target\\n \\n-    def _sympystr(self, printer):\\n-        sstr = printer.doprint\\n-        return '{0} as {1}'.format(sstr(self.name), sstr(self.target))\\n+    def __str__(self):\\n+        return '{0} as {1}'.format(str(self.name), str(self.target))\\n \\n     def __eq__(self, string):\\n         if isinstance(string, str):\\n@@ -342,8 +303,8 @@ class Dlist(PyccelAstNode):\\n \\n     Parameters\\n     ----------\\n-    value : Expr\\n-           a sympy expression which represents the initilized value of the list\\n+    value : PyccelAstNode\\n+           an expression which represents the initilized value of the list\\n \\n     shape : the shape of the array\\n     \\\"\\\"\\\"\\n@@ -372,7 +333,7 @@ class Assign(Basic):\\n \\n     Parameters\\n     ----------\\n-    lhs : Expr\\n+    lhs : PyccelAstNode\\n         In the syntactic stage:\\n            Object representing the lhs of the expression. These should be\\n            singular objects, such as one would use in writing code. Notable types\\n@@ -381,7 +342,7 @@ class Assign(Basic):\\n         In the semantic stage:\\n            Variable or IndexedElement\\n \\n-    rhs : Expr\\n+    rhs : PyccelAstNode\\n         In the syntactic stage:\\n           Object representing the rhs of the expression\\n         In the semantic stage :\\n@@ -429,9 +390,8 @@ class Assign(Basic):\\n         self._like = like\\n         super().__init__()\\n \\n-    def _sympystr(self, printer):\\n-        sstr = printer.doprint\\n-        return '{0} := {1}'.format(sstr(self.lhs), sstr(self.rhs))\\n+    def __str__(self):\\n+        return '{0} := {1}'.format(str(self.lhs), str(self.rhs))\\n \\n     @property\\n     def lhs(self):\\n@@ -567,10 +527,9 @@ class Allocate(Basic):\\n     def status(self):\\n         return self._status\\n \\n-    def _sympystr(self, printer):\\n-        sstr = printer.doprint\\n+    def __str__(self):\\n         return 'Allocate({}, shape={}, order={}, status={})'.format(\\n-                sstr(self.variable), sstr(self.shape), sstr(self.order), sstr(self.status))\\n+                str(self.variable), str(self.shape), str(self.order), str(self.status))\\n \\n     def __eq__(self, other):\\n         if isinstance(other, Allocate):\\n@@ -666,6 +625,27 @@ class CodeBlock(Basic):\\n     def __str__(self):\\n         return 'CodeBlock({})'.format(self.body)\\n \\n+    def __reduce_ex__(self, i):\\n+        \\\"\\\"\\\" Used by pickle to create an object of this class.\\n+\\n+          Parameters\\n+          ----------\\n+\\n+          i : int\\n+           protocol\\n+\\n+          Results\\n+          -------\\n+\\n+          out : tuple\\n+           A tuple of two elements\\n+           a callable function that can be called\\n+           to create the initial version of the object\\n+           and its arguments.\\n+        \\\"\\\"\\\"\\n+        kwargs = dict(body = self.body)\\n+        return (apply, (self.__class__, (), kwargs))\\n+\\n class AliasAssign(Basic):\\n \\n     \\\"\\\"\\\"Represents aliasing for code generation. An alias is any statement of the\\n@@ -706,9 +686,8 @@ class AliasAssign(Basic):\\n         self._rhs = rhs\\n         super().__init__()\\n \\n-    def _sympystr(self, printer):\\n-        sstr = printer.doprint\\n-        return '{0} := {1}'.format(sstr(self.lhs), sstr(self.rhs))\\n+    def __str__(self):\\n+        return '{0} := {1}'.format(str(self.lhs), str(self.rhs))\\n \\n     @property\\n     def lhs(self):\\n@@ -747,9 +726,8 @@ class SymbolicAssign(Basic):\\n         self._rhs = rhs\\n         super().__init__()\\n \\n-    def _sympystr(self, printer):\\n-        sstr = printer.doprint\\n-        return '{0} := {1}'.format(sstr(self.lhs), sstr(self.rhs))\\n+    def __str__(self):\\n+        return '{0} := {1}'.format(str(self.lhs), str(self.rhs))\\n \\n     @property\\n     def lhs(self):\\n@@ -760,11 +738,11 @@ class SymbolicAssign(Basic):\\n         return self._rhs\\n \\n \\n-# The following are defined to be sympy approved nodes. If there is something\\n+# The following were defined to be sympy approved nodes. If there is something\\n # smaller that could be used, that would be preferable. We only use them as\\n # tokens.\\n \\n-class NativeOp(with_metaclass(Singleton)):\\n+class NativeOp(metaclass=Singleton):\\n \\n     \\\"\\\"\\\"Base type for native operands.\\\"\\\"\\\"\\n \\n@@ -814,7 +792,7 @@ class AugAssign(Assign):\\n \\n     Parameters\\n     ----------\\n-    lhs : Expr\\n+    lhs : PyccelAstNode\\n         In the syntactic stage:\\n            Object representing the lhs of the expression. These should be\\n            singular objects, such as one would use in writing code. Notable types\\n@@ -826,7 +804,7 @@ class AugAssign(Assign):\\n     op : str\\n         Operator (+, -, /, \\\\*, %).\\n \\n-    rhs : Expr\\n+    rhs : PyccelAstNode\\n         In the syntactic stage:\\n           Object representing the rhs of the expression\\n         In the semantic stage :\\n@@ -867,10 +845,9 @@ class AugAssign(Assign):\\n \\n         super().__init__(lhs, rhs, status, like)\\n \\n-    def _sympystr(self, printer):\\n-        sstr = printer.doprint\\n-        return '{0} {1}= {2}'.format(sstr(self.lhs), self.op._symbol,\\n-                sstr(self.rhs))\\n+    def __str__(self):\\n+        return '{0} {1}= {2}'.format(str(self.lhs), self.op._symbol,\\n+                str(self.rhs))\\n \\n     @property\\n     def op(self):\\n@@ -887,9 +864,9 @@ class While(Basic):\\n \\n     Parameters\\n     ----------\\n-    test : expression\\n-        test condition given as a sympy expression\\n-    body : sympy expr\\n+    test : PyccelAstNode\\n+        test condition given as an expression\\n+    body : list of Pyccel objects\\n         list of statements representing the body of the While statement.\\n \\n     Examples\\n@@ -941,9 +918,9 @@ class With(Basic):\\n \\n     Parameters\\n     ----------\\n-    test : expression\\n-        test condition given as a sympy expression\\n-    body : sympy expr\\n+    test : PyccelAstNode\\n+        test condition given as an expression\\n+    body : list of Pyccel objects\\n         list of statements representing the body of the With statement.\\n \\n     Examples\\n@@ -1327,11 +1304,11 @@ class For(Basic):\\n \\n     Parameters\\n     ----------\\n-    target : symbol\\n+    target : symbol / Variable\\n         symbol representing the iterator\\n     iter : iterable\\n         iterable object. for the moment only Range is used\\n-    body : sympy expr\\n+    body : list of pyccel objects\\n         list of statements representing the body of the For statement.\\n \\n     Examples\\n@@ -1488,12 +1465,11 @@ class ConstructorCall(Basic):\\n         self._arguments = arguments\\n         super().__init__()\\n \\n-    def _sympystr(self, printer):\\n-        sstr = printer.doprint\\n-        name = sstr(self.name)\\n+    def __str__(self):\\n+        name = str(self.name)\\n         args = ''\\n         if not self.arguments is None:\\n-            args = ', '.join(sstr(i) for i in self.arguments)\\n+            args = ', '.join(str(i) for i in self.arguments)\\n         return '{0}({1})'.format(name, args)\\n \\n     @property\\n@@ -1601,11 +1577,9 @@ class ValuedArgument(Basic):\\n     def is_kwonly(self):\\n         return self._kwonly\\n \\n-    def _sympystr(self, printer):\\n-        sstr = printer.doprint\\n-\\n-        argument = sstr(self.argument)\\n-        value = sstr(self.value)\\n+    def __str__(self):\\n+        argument = str(self.argument)\\n+        value = str(self.value)\\n         return '{0}={1}'.format(argument, value)\\n \\n class FunctionCall(PyccelAstNode):\\n@@ -1747,7 +1721,7 @@ class Return(Basic):\\n \\n     Parameters\\n     ----------\\n-    expr : sympy expr\\n+    expr : PyccelAstNode\\n         The expression to return.\\n \\n     stmts :represent assign stmts in the case of expression return\\n@@ -1859,11 +1833,6 @@ class FunctionDef(Basic):\\n                  '_interfaces'\\n                  )\\n \\n-    def __new__(cls, *args, **kwargs):\\n-        kwargs.pop('decorators', None)\\n-        kwargs.pop('templates', None)\\n-        return super().__new__(cls, *args, **kwargs)\\n-\\n     def __init__(\\n         self,\\n         name,\\n@@ -2424,10 +2393,6 @@ class ValuedFunctionAddress(FunctionAddress):\\n     \\\"\\\"\\\"\\n     _attribute_nodes = (*FunctionAddress._attribute_nodes, '_value')\\n \\n-    def __new__(cls, *args, **kwargs):\\n-        kwargs.pop('value', Nil())\\n-        return super().__new__(cls, *args, **kwargs)\\n-\\n     def __init__(self, *args, **kwargs):\\n         self._value = kwargs.pop('value', Nil())\\n         super().__init__(*args, **kwargs)\\n@@ -2463,8 +2428,6 @@ class BindCFunctionDef(FunctionDef):\\n         The function from which the c-compatible version was created\\n     \\\"\\\"\\\"\\n     _attribute_nodes = (*FunctionDef._attribute_nodes, '_original_function')\\n-    def __new__(cls, *args, original_function, **kwargs):\\n-        return super().__new__(cls, *args, **kwargs)\\n \\n     def __init__(self, *args, original_function, **kwargs):\\n         self._original_function = original_function\\n@@ -2729,9 +2692,6 @@ class ClassDef(Basic):\\n         else:\\n             return self.is_iterable or self.is_with_construct\\n \\n-    def _eval_subs(self, old , new):\\n-        return self\\n-\\n     @property\\n     def is_unused(self):\\n         return False\\n@@ -2809,13 +2769,12 @@ class Import(Basic):\\n             raise TypeError('to_ignore must be a boolean.')\\n         self._ignore_at_print = to_ignore\\n \\n-    def _sympystr(self, printer):\\n-        sstr = printer.doprint\\n-        source = sstr(self.source)\\n+    def __str__(self):\\n+        source = str(self.source)\\n         if len(self.target) == 0:\\n             return 'import {source}'.format(source=source)\\n         else:\\n-            target = ', '.join([sstr(i) for i in self.target])\\n+            target = ', '.join([str(i) for i in self.target])\\n             return 'from {source} import {target}'.format(source=source,\\n                     target=target)\\n \\n@@ -2843,7 +2802,7 @@ class FuncAddressDeclare(Basic):\\n         An instance of FunctionAddress.\\n     intent: None, str\\n         one among {'in', 'out', 'inout'}\\n-    value: Expr\\n+    value: PyccelAstNode\\n         variable value\\n     static: bool\\n         True for a static declaration of an array.\\n@@ -2922,7 +2881,7 @@ class Declare(Basic):\\n         Variables must be of the same type.\\n     intent: None, str\\n         one among {'in', 'out', 'inout'}\\n-    value: Expr\\n+    value: PyccelAstNode\\n         variable value\\n     static: bool\\n         True for a static declaration of an array.\\n@@ -3026,8 +2985,8 @@ class SymbolicPrint(Basic):\\n \\n     Parameters\\n     ----------\\n-    expr : sympy expr\\n-        The expression to return.\\n+    expr : PyccelAstNode\\n+        The expression to print\\n \\n     Examples\\n     --------\\n@@ -3111,7 +3070,7 @@ class EmptyNode(Basic):\\n     \\\"\\\"\\\"\\n     _attribute_nodes = ()\\n \\n-    def _sympystr(self, printer):\\n+    def __str__(self):\\n         return ''\\n \\n \\n@@ -3140,9 +3099,29 @@ class Comment(Basic):\\n     def text(self):\\n         return self._text\\n \\n-    def _sympystr(self, printer):\\n-        sstr = printer.doprint\\n-        return '# {0}'.format(sstr(self.text))\\n+    def __str__(self):\\n+        return '# {0}'.format(str(self.text))\\n+\\n+    def __reduce_ex__(self, i):\\n+        \\\"\\\"\\\" Used by pickle to create an object of this class.\\n+\\n+          Parameters\\n+          ----------\\n+\\n+          i : int\\n+           protocol\\n+\\n+          Results\\n+          -------\\n+\\n+          out : tuple\\n+           A tuple of two elements\\n+           a callable function that can be called\\n+           to create the initial version of the object\\n+           and its arguments.\\n+        \\\"\\\"\\\"\\n+        kwargs = dict(text = self.text)\\n+        return (apply, (self.__class__, (), kwargs))\\n \\n \\n class SeparatorComment(Comment):\\n@@ -3265,7 +3244,7 @@ class Assert(Basic):\\n \\n     Parameters\\n     ----------\\n-    test: Expr\\n+    test: PyccelAstNode\\n         boolean expression to check\\n \\n     Examples\\n@@ -3602,7 +3581,6 @@ def get_iterable_ranges(it, var_name=None):\\n         cls_base = it.this.cls_base\\n \\n         # arguments[0] is 'self'\\n-        # TODO must be improved in syntax, so that a['value'] is a sympy object\\n \\n         args = []\\n         kwargs = {}\\n\",\"diff --git a/tests/epyccel/test_parallel_epyccel.py b/tests/epyccel/test_parallel_epyccel.py\\nindex 926c797..ee0d047 100644\\n--- a/tests/epyccel/test_parallel_epyccel.py\\n+++ b/tests/epyccel/test_parallel_epyccel.py\\n@@ -5,15 +5,6 @@ import numpy as np\\n \\n from pyccel.epyccel import epyccel\\n \\n-@pytest.fixture(params=[\\n-    pytest.param('fortran', marks = pytest.mark.fortran),\\n-    pytest.param('c'      , marks = [pytest.mark.c,\\n-        pytest.mark.xfail(message='Arrays not implemented in C')])\\n-    ]\\n-)\\n-def language(request):\\n-    return request.param\\n-\\n #==============================================================================\\n @pytest.mark.parallel\\n def test_module_1(language):\\n\",\"diff --git a/tests/pyccel/test_pyccel.py b/tests/pyccel/test_pyccel.py\\nindex cc7ccde..a65ad05 100644\\n--- a/tests/pyccel/test_pyccel.py\\n+++ b/tests/pyccel/test_pyccel.py\\n@@ -458,6 +458,7 @@ def test_hope_benchmarks( test_file ):\\n     pyccel_test(test_file)\\n \\n #------------------------------------------------------------------------------\\n+@pytest.mark.c\\n @pytest.mark.parametrize( \\\"test_file\\\", [\\\"scripts/hope_benchmarks/hope_fib.py\\\",\\n                                         pytest.param(\\\"scripts/hope_benchmarks/quicksort.py\\\",\\n                                             marks = pytest.mark.skip(reason=\\\"len not implemented in c\\\")),\"]", "hints_text": ""}

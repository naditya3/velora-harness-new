{"instance_id": "2204411016742245", "repo": "certcc/ssvc", "base_commit": "a31c6589a307013df83e348f711c71724cd2c0a7", "problem_statement": "Create tool to auto-populate documentation examples for decision point objects:\\nThis is (I think) the last item to cover the changes that were all bunched up in #339.\\r\\n\\r\\nThis issue is to create a tool that can automatically populate example text (markdown), json, and possibly python examples based on python SsvcDecisionPoint objects. The target is to be able to automatically generate these as separate files that can be included into the info box at the top of the page for a decision point, as for example in:\\r\\n\\r\\nhttps://certcc.github.io/SSVC-staging/reference/decision_points/automatable/ \\r\\n\\r\\n(screenshot follows)\\r\\n<img width=\"756\" alt=\"Screenshot 2023-10-30 at 1 01 18 PM\" src=\"https://github.com/CERTCC/SSVC/assets/2594236/d8e2827e-e189-49f8-a5aa-6eff309453e0\">\\r\\n\\r\\nThe resulting output should be clearly delineated as generated content to reduce the chance of misplaced effort in manually editing docs that will be overwritten by a future build process. (I.e., use a specific directory name and/or comments in the files to indicate that they are generated files and should not be edited.)\\r\\n", "FAIL_TO_PASS": ["src/test/test_dp_base.py::MyTestCase::test_ssvc_decision_point_json_roundtrip"], "PASS_TO_PASS": ["src/test/test_csv_analyzer.py::MyTestCase::test_col_norm", "src/test/test_mixins.py::TestMixins::test_keyed_create", "src/test/test_policy_generator.py::MyTestCase::test_validate_paths", "src/test/test_policy_generator.py::MyTestCase::test_add_nodes", "src/test/test_mixins.py::TestMixins::test_asdict_roundtrip", "src/test/test_outcomes.py::MyTestCase::test_outcome_value", "src/test/test_mixins.py::TestMixins::test_versioned_create", "src/test/test_policy_generator.py::MyTestCase::test_assign_weighted_outcomes", "src/test/test_mixins.py::TestMixins::test_json_roundtrip", "src/test/test_dp_groups.py::MyTestCase::test_iter", "src/test/test_policy_generator.py::MyTestCase::test_assign_outcomes", "src/test/test_dp_groups.py::MyTestCase::test_len", "src/test/test_csv_analyzer.py::MyTestCase::test_parse_args", "src/test/test_dp_base.py::MyTestCase::test_ssvc_decision_point", "src/test/test_csv_analyzer.py::MyTestCase::test_perm_feat_imp", "src/test/test_policy_generator.py::MyTestCase::test_emit_policy", "src/test/test_csv_analyzer.py::MyTestCase::test_create_dt_classifier", "src/test/test_dp_base.py::MyTestCase::test_ssvc_value", "src/test/test_dp_base.py::MyTestCase::test_ssvc_value_json_roundtrip", "src/test/test_schema.py::MyTestCase::test_decision_point_validation", "src/test/test_mixins.py::TestMixins::test_mixin_combos", "src/test/test_outcomes.py::MyTestCase::test_outcome_group", "src/test/test_policy_generator.py::MyTestCase::test_add_edges", "src/test/test_policy_generator.py::MyTestCase::test_create_policy", "src/test/test_mixins.py::TestMixins::test_ssvc_base_create", "src/test/test_policy_generator.py::MyTestCase::test_pg_init", "src/test/test_dp_base.py::MyTestCase::test_registry", "src/test/test_csv_analyzer.py::MyTestCase::test_drop_col_feat_imp", "src/test/test_csv_analyzer.py::MyTestCase::test_clean_table", "src/test/test_dp_groups.py::MyTestCase::test_json_roundtrip", "src/test/test_schema.py::MyTestCase::test_decision_point_group_validation", "src/test/test_policy_generator.py::MyTestCase::test_pg_context", "src/test/test_csv_analyzer.py::MyTestCase::test_imp_df", "src/test/test_mixins.py::TestMixins::test_namespaced_create", "src/test/test_policy_generator.py::MyTestCase::test_enumerate_dp_values", "src/test/test_schema.py::MyTestCase::test_confirm_registered_decision_points", "src/test/test_csv_analyzer.py::MyTestCase::test_split_data"], "language": "python", "test_command": "source /saved/ENV || source /saved/*/ENV && pytest --no-header -rA --tb=no -p no:cacheprovider --continue-on-collection-errors", "test_output_parser": "python/parse_log_pytest_v3", "image_storage_uri": "vmvm-registry.fbinfra.net/repomate_image_activ_pytest/certcc_ssvc:a31c6589a307013df83e348f711c71724cd2c0a7", "patch": "", "test_patch": "[\"diff --git a/data/json/decision_points/exploitation_1_0_0.json b/data/json/decision_points/exploitation_1_0_0.json\\nnew file mode 100644\\nindex 0000000..9f28731\\n--- /dev/null\\n+++ b/data/json/decision_points/exploitation_1_0_0.json\\n@@ -0,0 +1,24 @@\\n+{\\n+  \\\"namespace\\\": \\\"ssvc\\\",\\n+  \\\"version\\\": \\\"1.0.0\\\",\\n+  \\\"key\\\": \\\"E\\\",\\n+  \\\"name\\\": \\\"Exploitation\\\",\\n+  \\\"description\\\": \\\"The present state of exploitation of the vulnerability.\\\",\\n+  \\\"values\\\": [\\n+    {\\n+      \\\"key\\\": \\\"N\\\",\\n+      \\\"name\\\": \\\"None\\\",\\n+      \\\"description\\\": \\\"There is no evidence of active exploitation and no public proof of concept (PoC) of how to exploit the vulnerability.\\\"\\n+    },\\n+    {\\n+      \\\"key\\\": \\\"P\\\",\\n+      \\\"name\\\": \\\"PoC\\\",\\n+      \\\"description\\\": \\\"One of the following cases is true: (1) private evidence of exploitation is attested but not shared; (2) widespread hearsay attests to exploitation; (3) typical public PoC in places such as Metasploit or ExploitDB; or (4) the vulnerability has a well-known method of exploitation.\\\"\\n+    },\\n+    {\\n+      \\\"key\\\": \\\"A\\\",\\n+      \\\"name\\\": \\\"Active\\\",\\n+      \\\"description\\\": \\\"Shared, observable, reliable evidence that the exploit is being used in the wild by real attackers; there is credible public reporting.\\\"\\n+    }\\n+  ]\\n+}\\n\\\\ No newline at end of file\\n\",\"diff --git a/docs/_generated/decision_points/exploitation_1_0_0.md b/docs/_generated/decision_points/exploitation_1_0_0.md\\nnew file mode 100644\\nindex 0000000..1b07d38\\n--- /dev/null\\n+++ b/docs/_generated/decision_points/exploitation_1_0_0.md\\n@@ -0,0 +1,18 @@\\n+<!-- This content is autogenerated by doctools.py. Do not Edit. -->\\n+!!! note \\\"Exploitation v1.0.0\\\"\\n+\\n+    === \\\"Text\\\" \\n+    \\n+        The present state of exploitation of the vulnerability.\\n+\\n+        | Value | Definition |\\n+        |:-----|:-----------|\\n+        | None | There is no evidence of active exploitation and no public proof of concept (PoC) of how to exploit the vulnerability. |\\n+        | PoC | One of the following cases is true: (1) private evidence of exploitation is attested but not shared; (2) widespread hearsay attests to exploitation; (3) typical public PoC in places such as Metasploit or ExploitDB; or (4) the vulnerability has a well-known method of exploitation. |\\n+        | Active | Shared, observable, reliable evidence that the exploit is being used in the wild by real attackers; there is credible public reporting. |\\n+        \\n+    === \\\"JSON\\\"\\n+    \\n+        ```json\\n+        {% include \\\"../../../data/json/decision_points/exploitation_1_0_0.json\\\" %}\\n+        ```\\n\",\"diff --git a/src/test/test_doctools.py b/src/test/test_doctools.py\\nnew file mode 100644\\nindex 0000000..a41095c\\n--- /dev/null\\n+++ b/src/test/test_doctools.py\\n@@ -0,0 +1,221 @@\\n+#  Copyright (c) 2023 Carnegie Mellon University and Contributors.\\n+#  - see Contributors.md for a full list of Contributors\\n+#  - see ContributionInstructions.md for information on how you can Contribute to this project\\n+#  Stakeholder Specific Vulnerability Categorization (SSVC) is\\n+#  licensed under a MIT (SEI)-style license, please see LICENSE.md distributed\\n+#  with this Software or contact permission@sei.cmu.edu for full terms.\\n+#  Created, in part, with funding and support from the United States Government\\n+#  (see Acknowledgments file). This program may include and/or can make use of\\n+#  certain third party source code, object code, documentation and other files\\n+#  (“Third Party Software”). See LICENSE.md for more details.\\n+#  Carnegie Mellon®, CERT® and CERT Coordination Center® are registered in the\\n+#  U.S. Patent and Trademark Office by Carnegie Mellon University\\n+import json\\n+import logging\\n+import os\\n+import tempfile\\n+import unittest\\n+\\n+from ssvc.decision_points import SsvcDecisionPoint\\n+from ssvc.doctools import (\\n+    EnsureDirExists,\\n+    _filename_friendly,\\n+    dump_decision_point,\\n+    dump_json,\\n+    dump_markdown,\\n+    remove_if_exists,\\n+    to_markdown_table,\\n+)\\n+\\n+_dp_dict = {\\n+    \\\"namespace\\\": \\\"ssvc\\\",\\n+    \\\"version\\\": \\\"1.0.0\\\",\\n+    \\\"key\\\": \\\"DPT\\\",\\n+    \\\"name\\\": \\\"Decision Point Test\\\",\\n+    \\\"description\\\": \\\"This is a test decision point.\\\",\\n+    \\\"values\\\": [\\n+        {\\\"key\\\": \\\"N\\\", \\\"name\\\": \\\"No\\\", \\\"description\\\": \\\"No means no\\\"},\\n+        {\\\"key\\\": \\\"Y\\\", \\\"name\\\": \\\"Yes\\\", \\\"description\\\": \\\"Yes means yes\\\"},\\n+    ],\\n+}\\n+\\n+\\n+class MyTestCase(unittest.TestCase):\\n+    def setUp(self) -> None:\\n+        self.dp = SsvcDecisionPoint.from_dict(_dp_dict)\\n+\\n+        # create a temp working dir\\n+        self.tempdir = tempfile.TemporaryDirectory()\\n+\\n+    def tearDown(self) -> None:\\n+        # remove the temp working dir\\n+        self.tempdir.cleanup()\\n+        self.assertFalse(os.path.exists(self.tempdir.name))\\n+\\n+    def test__filename_friendly(self):\\n+        # replace spaces with underscores\\n+        self.assertEqual(\\\"foo_bar\\\", _filename_friendly(\\\"foo bar\\\"))\\n+        # replace periods with underscores\\n+        self.assertEqual(\\\"foo_bar\\\", _filename_friendly(\\\"foo.bar\\\"))\\n+        # lowercase the string\\n+        self.assertEqual(\\\"foo_bar\\\", _filename_friendly(\\\"Foo.Bar\\\"))\\n+\\n+    def test_to_markdown_table(self):\\n+        dp = self.dp\\n+\\n+        table = to_markdown_table(dp)\\n+        self.assertIn(dp.description, table)\\n+        # self.assertIn(dp.name, table)\\n+        # self.assertIn(dp.version, table)\\n+        for value in dp.values:\\n+            self.assertIn(value.name, table)\\n+            self.assertIn(value.description, table)\\n+            self.assertIn(value.key, table)\\n+\\n+    def test_ensure_dir_exists(self):\\n+        path = os.path.join(self.tempdir.name, \\\"foo\\\")\\n+        self.assertFalse(os.path.exists(path))\\n+\\n+        with EnsureDirExists(path):\\n+            self.assertTrue(os.path.exists(path))\\n+\\n+    def test_remove_if_exists(self):\\n+        path = os.path.join(self.tempdir.name, \\\"foo\\\")\\n+        self.assertFalse(os.path.exists(path))\\n+\\n+        # should work without error\\n+        self.assertIsNone(remove_if_exists(path))\\n+\\n+        # create the file\\n+        open(path, \\\"w\\\").close()\\n+        self.assertTrue(os.path.exists(path))\\n+\\n+        # should work without error\\n+        self.assertIsNone(remove_if_exists(path))\\n+\\n+        # should have removed the file\\n+        self.assertFalse(os.path.exists(path))\\n+\\n+    def test_dump_decision_point(self):\\n+        jsondir = os.path.join(self.tempdir.name, \\\"json\\\")\\n+        outdir = os.path.join(self.tempdir.name, \\\"out\\\")\\n+        dp = self.dp\\n+        overwrite = False\\n+\\n+        self.assertEqual(0, len(os.listdir(self.tempdir.name)))\\n+\\n+        # should create the files in the expected places\\n+        r = dump_decision_point(jsondir, outdir, dp, overwrite)\\n+        self.assertTrue(os.path.exists(r[\\\"include_file\\\"]))\\n+        self.assertTrue(os.path.exists(r[\\\"symlink\\\"]))\\n+        self.assertTrue(os.path.exists(r[\\\"json_file\\\"]))\\n+\\n+        # not checking these thoroughly, just making sure they are there\\n+        # because they are tested elsewhere in dump_markdown and dump_json\\n+\\n+    def test_dump_markdown(self):\\n+        # dump_markdown should create a file, write to it, and then create a generic symlink\\n+        basename = \\\"foo\\\"\\n+        dp = self.dp\\n+        json_file = os.path.join(self.tempdir.name, f\\\"{basename}.json\\\")\\n+        outdir = self.tempdir.name\\n+        overwrite = False\\n+\\n+        # should create the file in the expected place\\n+        include_file = os.path.join(outdir, f\\\"{basename}.md\\\")\\n+        symlink = os.path.join(outdir, f\\\"{_filename_friendly(dp.name)}.md\\\")\\n+\\n+        self.assertFalse(os.path.exists(include_file))\\n+        self.assertFalse(os.path.exists(symlink))\\n+        r = dump_markdown(basename, dp, json_file, outdir, overwrite)\\n+        self.assertTrue(os.path.exists(include_file))\\n+\\n+        self.assertEqual(include_file, r[\\\"include_file\\\"])\\n+        self.assertEqual(symlink, r[\\\"symlink\\\"])\\n+\\n+        # the file contains text based on the dp\\n+        with open(include_file, \\\"r\\\") as f:\\n+            text = f.read()\\n+\\n+        self.assertIn(dp.description, text)\\n+        self.assertIn(dp.name, text)\\n+        self.assertIn(dp.version, text)\\n+        for value in dp.values:\\n+            self.assertIn(value.name, text)\\n+            self.assertIn(value.description, text)\\n+            self.assertIn(value.key, text)\\n+\\n+        # should create the symlink in the expected place\\n+        self.assertTrue(os.path.exists(symlink), symlink)\\n+        # should be a symlink\\n+        self.assertTrue(os.path.islink(symlink))\\n+        # should point to the include file\\n+        self.assertEqual(os.path.realpath(symlink), os.path.realpath(include_file))\\n+\\n+        # should not overwrite the file\\n+        overwrite = False\\n+        # capture logger output\\n+        with self.assertLogs() as cm:\\n+            dump_markdown(basename, dp, json_file, outdir, overwrite)\\n+        # logger warns that the file exists\\n+        self.assertIn(\\\"already exists\\\", cm.output[0])\\n+\\n+        # should overwrite the file\\n+        overwrite = True\\n+        dp.name = \\\"Different Decision Point\\\"\\n+        # capture logger output\\n+        with self.assertLogs(level=logging.DEBUG) as cm:\\n+            dump_markdown(basename, dp, json_file, outdir, overwrite)\\n+        # logger warns that the file was removed\\n+        self.assertIn(\\\"Removed\\\", cm.output[0])\\n+\\n+    def test_dump_json(self):\\n+        basename = \\\"foo\\\"\\n+        dp = self.dp\\n+        jsondir = self.tempdir.name\\n+        overwrite = False\\n+\\n+        _jsonfile = os.path.join(jsondir, f\\\"{basename}.json\\\")\\n+        self.assertFalse(os.path.exists(_jsonfile))\\n+\\n+        # should create the file in the expected place\\n+        json_file = dump_json(basename, dp, jsondir, overwrite)\\n+        self.assertEqual(_jsonfile, json_file)\\n+        self.assertTrue(os.path.exists(json_file))\\n+\\n+        # file is loadable json\\n+        d = json.load(open(json_file))\\n+        for k, v in dp.to_dict().items():\\n+            self.assertEqual(v, d[k])\\n+\\n+        # should not overwrite the file\\n+        overwrite = False\\n+        # capture logger output\\n+        with self.assertLogs() as cm:\\n+            json_file = dump_json(basename, dp, jsondir, overwrite)\\n+        self.assertEqual(_jsonfile, json_file)\\n+        # logger warns that the file exists\\n+        self.assertIn(\\\"already exists\\\", cm.output[0])\\n+\\n+        # should overwrite the file\\n+        overwrite = True\\n+\\n+        dp.name = \\\"Different Decision Point\\\"\\n+        # capture logger output\\n+        with self.assertLogs(level=logging.DEBUG) as cm:\\n+            json_file = dump_json(basename, dp, jsondir, overwrite)\\n+\\n+        self.assertEqual(_jsonfile, json_file)\\n+        # logger warns that the file was removed\\n+        self.assertIn(\\\"Removed\\\", cm.output[0])\\n+\\n+        # the file was overwritten\\n+        d = json.load(open(json_file))\\n+        self.assertEqual(dp.name, d[\\\"name\\\"])\\n+\\n+    def test_main(self):\\n+        pass\\n+\\n+\\n+if __name__ == \\\"__main__\\\":\\n+    unittest.main()\\n\",\"diff --git a/src/test/test_dp_base.py b/src/test/test_dp_base.py\\nindex 969ef03..4fcd701 100644\\n--- a/src/test/test_dp_base.py\\n+++ b/src/test/test_dp_base.py\\n@@ -20,9 +20,14 @@ class MyTestCase(unittest.TestCase):\\n     def setUp(self) -> None:\\n         self.original_registry = base.REGISTERED_DECISION_POINTS.copy()\\n \\n-        self.value = base.SsvcDecisionPointValue(\\n-            name=\\\"foo\\\", key=\\\"bar\\\", description=\\\"baz\\\"\\n-        )\\n+        # add multiple values\\n+        self.values = []\\n+        for i in range(3):\\n+            self.values.append(\\n+                base.SsvcDecisionPointValue(\\n+                    name=f\\\"foo{i}\\\", key=f\\\"bar{i}\\\", description=f\\\"baz{i}\\\"\\n+                )\\n+            )\\n \\n         self.dp = base.SsvcDecisionPoint(\\n             name=\\\"foo\\\",\\n@@ -30,7 +35,7 @@ class MyTestCase(unittest.TestCase):\\n             description=\\\"baz\\\",\\n             version=\\\"1.0.0\\\",\\n             namespace=\\\"ns\\\",\\n-            values=(self.value,),\\n+            values=tuple(self.values),\\n         )\\n \\n     def tearDown(self) -> None:\\n@@ -47,10 +52,24 @@ class MyTestCase(unittest.TestCase):\\n             description=\\\"asdfasdf\\\",\\n             version=\\\"1.33.1\\\",\\n             namespace=\\\"asdfasdf\\\",\\n-            values=(\\n-                self.value,\\n-                self.value,\\n-            ),\\n+            values=tuple(self.values),\\n+        )\\n+\\n+    def tearDown(self) -> None:\\n+        # restore the original registry\\n+        base.REGISTERED_DECISION_POINTS = self.original_registry\\n+\\n+    def test_registry(self):\\n+        # just by creating the objects, they should be registered\\n+        self.assertIn(self.dp, base.REGISTERED_DECISION_POINTS)\\n+\\n+        dp2 = base.SsvcDecisionPoint(\\n+            name=\\\"asdfad\\\",\\n+            key=\\\"asdfasdf\\\",\\n+            description=\\\"asdfasdf\\\",\\n+            version=\\\"1.33.1\\\",\\n+            namespace=\\\"asdfasdf\\\",\\n+            values=self.values,\\n         )\\n \\n         dp2._comment = \\\"asdfasdfasdf\\\"\\n@@ -58,15 +77,15 @@ class MyTestCase(unittest.TestCase):\\n         self.assertIn(dp2, base.REGISTERED_DECISION_POINTS)\\n \\n     def test_ssvc_value(self):\\n-        obj = self.value\\n-        # should have name, key, description\\n-        self.assertEqual(obj.name, \\\"foo\\\")\\n-        self.assertEqual(obj.key, \\\"bar\\\")\\n-        self.assertEqual(obj.description, \\\"baz\\\")\\n+        for i, obj in enumerate(self.values):\\n+            # should have name, key, description\\n+            self.assertEqual(obj.name, f\\\"foo{i}\\\")\\n+            self.assertEqual(obj.key, f\\\"bar{i}\\\")\\n+            self.assertEqual(obj.description, f\\\"baz{i}\\\")\\n \\n-        # should not have namespace, version\\n-        self.assertFalse(hasattr(obj, \\\"namespace\\\"))\\n-        self.assertFalse(hasattr(obj, \\\"version\\\"))\\n+            # should not have namespace, version\\n+            self.assertFalse(hasattr(obj, \\\"namespace\\\"))\\n+            self.assertFalse(hasattr(obj, \\\"version\\\"))\\n \\n     def test_ssvc_decision_point(self):\\n         obj = self.dp\\n@@ -76,17 +95,16 @@ class MyTestCase(unittest.TestCase):\\n         self.assertEqual(obj.description, \\\"baz\\\")\\n         self.assertEqual(obj.version, \\\"1.0.0\\\")\\n         self.assertEqual(obj.namespace, \\\"ns\\\")\\n-        self.assertEqual(len(obj.values), 1)\\n+        self.assertEqual(len(self.values), len(obj.values))\\n \\n     def test_ssvc_value_json_roundtrip(self):\\n-        obj = self.value\\n+        for i, obj in enumerate(self.values):\\n+            json = obj.to_json()\\n+            self.assertIsInstance(json, str)\\n+            self.assertGreater(len(json), 0)\\n \\n-        json = obj.to_json()\\n-        self.assertIsInstance(json, str)\\n-        self.assertGreater(len(json), 0)\\n-\\n-        obj2 = base.SsvcDecisionPointValue.from_json(json)\\n-        self.assertEqual(obj, obj2)\\n+            obj2 = base.SsvcDecisionPointValue.from_json(json)\\n+            self.assertEqual(obj, obj2)\\n \\n     def test_ssvc_decision_point_json_roundtrip(self):\\n         obj = self.dp\\n@@ -96,19 +114,10 @@ class MyTestCase(unittest.TestCase):\\n         self.assertGreater(len(json), 0)\\n \\n         obj2 = base.SsvcDecisionPoint.from_json(json)\\n-        self.assertEqual(obj.to_dict(), obj2.to_dict())\\n-\\n-    def test_dp_to_table(self):\\n-        obj = self.dp\\n \\n-        table = base.dp_to_table(obj)\\n-\\n-        self.assertIn(obj.description, table)\\n-        self.assertIn(\\\"Value\\\", table)\\n-        self.assertIn(\\\"Key\\\", table)\\n-        self.assertIn(\\\"Description\\\", table)\\n-        self.assertIn(obj.name, table)\\n-        self.assertIn(obj.key, table)\\n+        # the objects should be equal\\n+        self.assertEqual(obj, obj2)\\n+        self.assertEqual(obj.to_dict(), obj2.to_dict())\\n \\n \\n if __name__ == \\\"__main__\\\":\\n\",\"diff --git a/src/test/test_schema.py b/src/test/test_schema.py\\nindex cec9b46..f4c830c 100644\\n--- a/src/test/test_schema.py\\n+++ b/src/test/test_schema.py\\n@@ -24,12 +24,11 @@ from ssvc.decision_points.base import REGISTERED_DECISION_POINTS\\n from ssvc.decision_points.critical_software import CRITICAL_SOFTWARE_1  # noqa\\n from ssvc.decision_points.high_value_asset import HIGH_VALUE_ASSET_1  # noqa\\n from ssvc.decision_points.in_kev import IN_KEV_1\\n+# importing these causes the decision points to register themselves\\n+from ssvc.dp_groups.ssvc.collections import SSVCv1, SSVCv2, SSVCv2_1 # noqa\\n from ssvc.dp_groups.cvss.v1 import CVSSv1  # noqa\\n from ssvc.dp_groups.cvss.v2 import CVSSv2  # noqa\\n from ssvc.dp_groups.cvss.v3 import CVSSv3  # noqa\\n-from ssvc.dp_groups.v1 import SSVCv1  # noqa\\n-from ssvc.dp_groups.v2 import SSVCv2  # noqa\\n-from ssvc.dp_groups.v2_1 import SSVCv2_1  # noqa\\n \\n \\n def find_schema(basepath: str) -> str:\"]", "hints_text": ""}

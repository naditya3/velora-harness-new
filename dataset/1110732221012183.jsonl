{"instance_id": "1110732221012183", "repo": "codezonediitj/pydatastructs", "base_commit": "64bb29b221bac453f5efd667e546796b22de3aa9", "problem_statement": "Add a `backend` option to all the APIs in PyDataStructs and default to `pydatastructs.Backend.Python`. :\\nOther than the title - An error should be raised if any other input is provided for this parameter as of now. It's an easy to do ask.", "FAIL_TO_PASS": ["pydatastructs/utils/tests/test_code_quality.py::test_backend_argument_message"], "PASS_TO_PASS": ["pydatastructs/linear_data_structures/tests/test_algorithms.py::test_quick_sort", "pydatastructs/utils/tests/test_code_quality.py::test_final_new_lines", "pydatastructs/miscellaneous_data_structures/tests/test_disjoint_set.py::test_DisjointSetForest", "pydatastructs/linear_data_structures/tests/test_algorithms.py::test_merge_sort_parallel", "pydatastructs/linear_data_structures/tests/test_algorithms.py::test_lower_bound", "pydatastructs/graphs/tests/test_algorithms.py::test_strongly_connected_components", "pydatastructs/utils/tests/test_misc_util.py::test_AdjacencyListGraphNode", "pydatastructs/linear_data_structures/tests/test_algorithms.py::test_matrix_multiply_parallel", "pydatastructs/linear_data_structures/tests/test_algorithms.py::test_longest_increasing_subsequence", "pydatastructs/trees/tests/test_heaps.py::test_BinomialHeap", "pydatastructs/utils/tests/test_code_quality.py::test_trailing_white_spaces", "pydatastructs/miscellaneous_data_structures/tests/test_stack.py::test_ArrayStack", "pydatastructs/utils/tests/test_misc_util.py::test_GraphEdge", "pydatastructs/graphs/tests/test_algorithms.py::test_shortest_paths", "pydatastructs/utils/tests/test_misc_util.py::test_AdjacencyMatrixGraphNode", "pydatastructs/strings/tests/test_algorithms.py::test_kmp", "pydatastructs/utils/tests/test_misc_util.py::test_CartesianTreeNode", "pydatastructs/trees/tests/test_binary_trees.py::test_Treap", "pydatastructs/trees/tests/test_binary_trees.py::test_SplayTree", "pydatastructs/trees/tests/test_m_ary_trees.py::test_MAryTree", "pydatastructs/utils/tests/test_code_quality.py::test_public_api", "pydatastructs/miscellaneous_data_structures/tests/test_range_query_static.py::test_RangeQueryStatic_summation", "pydatastructs/miscellaneous_data_structures/tests/test_range_query_static.py::test_RangeQueryStatic_greatest_common_divisor", "pydatastructs/linear_data_structures/tests/test_algorithms.py::test_counting_sort", "pydatastructs/graphs/tests/test_algorithms.py::test_breadth_first_search_parallel", "pydatastructs/linear_data_structures/tests/test_linked_lists.py::test_SinglyLinkedList", "pydatastructs/trees/tests/test_heaps.py::test_TernaryHeap", "pydatastructs/miscellaneous_data_structures/tests/test_range_query_static.py::test_RangeQueryStatic_minimum", "pydatastructs/utils/tests/test_misc_util.py::test_MAryTreeNode", "pydatastructs/strings/tests/test_trie.py::test_Trie", "pydatastructs/utils/tests/test_code_quality.py::test_comparison_True_False_None", "pydatastructs/linear_data_structures/tests/test_algorithms.py::test_bucket_sort", "pydatastructs/linear_data_structures/tests/test_algorithms.py::test_brick_sort_parallel", "pydatastructs/linear_data_structures/tests/test_linked_lists.py::test_DoublyCircularLinkedList", "pydatastructs/linear_data_structures/tests/test_linked_lists.py::test_SkipList", "pydatastructs/miscellaneous_data_structures/tests/test_stack.py::test_LinkedListStack", "pydatastructs/strings/tests/test_algorithms.py::test_rka", "pydatastructs/miscellaneous_data_structures/tests/test_binomial_trees.py::test_BinomialTree", "pydatastructs/miscellaneous_data_structures/tests/test_queue.py::test_LinkedListQueue", "pydatastructs/graphs/tests/test_algorithms.py::test_minimum_spanning_tree", "pydatastructs/utils/tests/test_misc_util.py::test_BinomialTreeNode", "pydatastructs/trees/tests/test_binary_trees.py::test_CartesianTree", "pydatastructs/miscellaneous_data_structures/tests/test_queue.py::test_ImplementationPriorityQueue", "pydatastructs/linear_data_structures/tests/test_linked_lists.py::test_DoublyLinkedList", "pydatastructs/utils/tests/test_misc_util.py::test_SkipNode", "pydatastructs/miscellaneous_data_structures/tests/test_queue.py::test_ArrayQueue", "pydatastructs/graphs/tests/test_algorithms.py::test_topological_sort", "pydatastructs/trees/tests/test_binary_trees.py::test_AVLTree", "pydatastructs/linear_data_structures/tests/test_linked_lists.py::test_SinglyCircularLinkedList", "pydatastructs/trees/tests/test_binary_trees.py::test_BinaryTreeTraversal", "pydatastructs/utils/tests/test_misc_util.py::test_RedBlackTreeNode", "pydatastructs/trees/tests/test_space_partitioning_tree.py::test_OneDimensionalSegmentTree", "pydatastructs/miscellaneous_data_structures/tests/test_queue.py::test_PriorityQueue", "pydatastructs/miscellaneous_data_structures/tests/test_stack.py::test_Stack", "pydatastructs/linear_data_structures/tests/test_algorithms.py::test_brick_sort", "pydatastructs/trees/tests/test_binary_trees.py::test_BinaryIndexedTree", "pydatastructs/linear_data_structures/tests/test_algorithms.py::test_cocktail_shaker_sort", "pydatastructs/linear_data_structures/tests/test_arrays.py::test_OneDimensionalArray", "pydatastructs/graphs/tests/test_adjacency_matrix.py::test_AdjacencyMatrix", "pydatastructs/trees/tests/test_binary_trees.py::test_BinarySearchTree", "pydatastructs/trees/tests/test_binary_trees.py::test_RedBlackTree", "pydatastructs/linear_data_structures/tests/test_algorithms.py::test_next_prev_permutation", "pydatastructs/linear_data_structures/tests/test_algorithms.py::test_next_permutation", "pydatastructs/graphs/tests/test_algorithms.py::test_depth_first_search", "pydatastructs/trees/tests/test_heaps.py::test_DHeap", "pydatastructs/linear_data_structures/tests/test_algorithms.py::test_prev_permutation", "pydatastructs/linear_data_structures/tests/test_algorithms.py::test_longest_common_sequence", "pydatastructs/graphs/tests/test_adjacency_list.py::test_adjacency_list", "pydatastructs/graphs/tests/test_algorithms.py::test_all_pair_shortest_paths", "pydatastructs/linear_data_structures/tests/test_arrays.py::test_MultiDimensionalArray", "pydatastructs/miscellaneous_data_structures/tests/test_queue.py::test_Queue", "pydatastructs/trees/tests/test_heaps.py::test_BinaryHeap", "pydatastructs/linear_data_structures/tests/test_algorithms.py::test_upper_bound", "pydatastructs/linear_data_structures/tests/test_algorithms.py::test_heapsort", "pydatastructs/graphs/tests/test_algorithms.py::test_breadth_first_search", "pydatastructs/utils/tests/test_code_quality.py::test_presence_of_tabs", "pydatastructs/trees/tests/test_binary_trees.py::test_issue_234", "pydatastructs/linear_data_structures/tests/test_algorithms.py::test_is_ordered", "pydatastructs/linear_data_structures/tests/test_arrays.py::test_DynamicOneDimensionalArray"], "language": "python", "test_command": "source /saved/ENV || source /saved/*/ENV && pytest --no-header -rA --tb=no -p no:cacheprovider --continue-on-collection-errors", "test_output_parser": "python/parse_log_pytest_v3", "image_storage_uri": "vmvm-registry.fbinfra.net/repomate_image_activ_pytest/codezonediitj_pydatastructs:64bb29b221bac453f5efd667e546796b22de3aa9", "patch": "", "test_patch": "[\"diff --git a/pydatastructs/graphs/algorithms.py b/pydatastructs/graphs/algorithms.py\\nindex 4997245ac..234255008 100644\\n--- a/pydatastructs/graphs/algorithms.py\\n+++ b/pydatastructs/graphs/algorithms.py\\n@@ -4,8 +4,8 @@\\n \\\"\\\"\\\"\\n from collections import deque\\n from concurrent.futures import ThreadPoolExecutor\\n-from pydatastructs.utils import GraphEdge\\n-from pydatastructs.utils.misc_util import _comp\\n+from pydatastructs.utils.misc_util import (\\n+    _comp, raise_if_backend_is_not_python, Backend)\\n from pydatastructs.miscellaneous_data_structures import (\\n     DisjointSetForest, PriorityQueue)\\n from pydatastructs.graphs.graph import Graph\\n@@ -51,6 +51,10 @@ def breadth_first_search(\\n         current node and the node next to current node.\\n         The rest of the arguments are optional and you can\\n         provide your own stuff there.\\n+    backend: pydatastructs.Backend\\n+        The backend to be used.\\n+        Optional, by default, the best available\\n+        backend is used.\\n \\n     Note\\n     ====\\n@@ -75,6 +79,8 @@ def breadth_first_search(\\n     >>> G.add_edge(V2.name, V3.name)\\n     >>> breadth_first_search(G, V1.name, f, V3.name)\\n     \\\"\\\"\\\"\\n+    raise_if_backend_is_not_python(\\n+        breadth_first_search, kwargs.get('backend', Backend.PYTHON))\\n     import pydatastructs.graphs.algorithms as algorithms\\n     func = \\\"_breadth_first_search_\\\" + graph._impl\\n     if not hasattr(algorithms, func):\\n@@ -133,6 +139,10 @@ def breadth_first_search_parallel(\\n         current node and the node next to current node.\\n         The rest of the arguments are optional and you can\\n         provide your own stuff there.\\n+    backend: pydatastructs.Backend\\n+        The backend to be used.\\n+        Optional, by default, the best available\\n+        backend is used.\\n \\n     Note\\n     ====\\n@@ -157,6 +167,8 @@ def breadth_first_search_parallel(\\n     >>> G.add_edge(V2.name, V3.name)\\n     >>> breadth_first_search_parallel(G, V1.name, 3, f, V3.name)\\n     \\\"\\\"\\\"\\n+    raise_if_backend_is_not_python(\\n+        breadth_first_search_parallel, kwargs.get('backend', Backend.PYTHON))\\n     import pydatastructs.graphs.algorithms as algorithms\\n     func = \\\"_breadth_first_search_parallel_\\\" + graph._impl\\n     if not hasattr(algorithms, func):\\n@@ -256,7 +268,7 @@ def _minimum_spanning_tree_prim_adjacency_list(graph):\\n                     e[w] = vw\\n     return mst\\n \\n-def minimum_spanning_tree(graph, algorithm):\\n+def minimum_spanning_tree(graph, algorithm, **kwargs):\\n     \\\"\\\"\\\"\\n     Computes a minimum spanning tree for the given\\n     graph and algorithm.\\n@@ -276,6 +288,10 @@ def minimum_spanning_tree(graph, algorithm):\\n         'kruskal' -> Kruskal's algorithm as given in [1].\\n \\n         'prim' -> Prim's algorithm as given in [2].\\n+    backend: pydatastructs.Backend\\n+        The backend to be used.\\n+        Optional, by default, the best available\\n+        backend is used.\\n \\n     Returns\\n     =======\\n@@ -312,6 +328,8 @@ def minimum_spanning_tree(graph, algorithm):\\n     should be used only for such graphs. Using with other\\n     types of graphs may lead to unwanted results.\\n     \\\"\\\"\\\"\\n+    raise_if_backend_is_not_python(\\n+        minimum_spanning_tree, kwargs.get('backend', Backend.PYTHON))\\n     import pydatastructs.graphs.algorithms as algorithms\\n     func = \\\"_minimum_spanning_tree_\\\" + algorithm + \\\"_\\\" + graph._impl\\n     if not hasattr(algorithms, func):\\n@@ -390,7 +408,7 @@ def _minimum_spanning_tree_parallel_prim_adjacency_list(graph, num_threads):\\n \\n     return mst\\n \\n-def minimum_spanning_tree_parallel(graph, algorithm, num_threads):\\n+def minimum_spanning_tree_parallel(graph, algorithm, num_threads, **kwargs):\\n     \\\"\\\"\\\"\\n     Computes a minimum spanning tree for the given\\n     graph and algorithm using the given number of threads.\\n@@ -412,6 +430,10 @@ def minimum_spanning_tree_parallel(graph, algorithm, num_threads):\\n         'prim' -> Prim's algorithm as given in [2].\\n     num_threads: int\\n         The number of threads to be used.\\n+    backend: pydatastructs.Backend\\n+        The backend to be used.\\n+        Optional, by default, the best available\\n+        backend is used.\\n \\n     Returns\\n     =======\\n@@ -448,6 +470,8 @@ def minimum_spanning_tree_parallel(graph, algorithm, num_threads):\\n     should be used only for such graphs. Using with other\\n     types of graphs will lead to unwanted results.\\n     \\\"\\\"\\\"\\n+    raise_if_backend_is_not_python(\\n+        minimum_spanning_tree_parallel, kwargs.get('backend', Backend.PYTHON))\\n     import pydatastructs.graphs.algorithms as algorithms\\n     func = \\\"_minimum_spanning_tree_parallel_\\\" + algorithm + \\\"_\\\" + graph._impl\\n     if not hasattr(algorithms, func):\\n@@ -505,7 +529,7 @@ def _strongly_connected_components_kosaraju_adjacency_list(graph):\\n _strongly_connected_components_kosaraju_adjacency_matrix = \\\\\\n     _strongly_connected_components_kosaraju_adjacency_list\\n \\n-def strongly_connected_components(graph, algorithm):\\n+def strongly_connected_components(graph, algorithm, **kwargs):\\n     \\\"\\\"\\\"\\n     Computes strongly connected components for the given\\n     graph and algorithm.\\n@@ -523,6 +547,10 @@ def strongly_connected_components(graph, algorithm):\\n         supported,\\n \\n         'kosaraju' -> Kosaraju's algorithm as given in [1].\\n+    backend: pydatastructs.Backend\\n+        The backend to be used.\\n+        Optional, by default, the best available\\n+        backend is used.\\n \\n     Returns\\n     =======\\n@@ -550,6 +578,8 @@ def strongly_connected_components(graph, algorithm):\\n     .. [1] https://en.wikipedia.org/wiki/Kosaraju%27s_algorithm\\n \\n     \\\"\\\"\\\"\\n+    raise_if_backend_is_not_python(\\n+        strongly_connected_components, kwargs.get('backend', Backend.PYTHON))\\n     import pydatastructs.graphs.algorithms as algorithms\\n     func = \\\"_strongly_connected_components_\\\" + algorithm + \\\"_\\\" + graph._impl\\n     if not hasattr(algorithms, func):\\n@@ -583,6 +613,10 @@ def depth_first_search(\\n         current node and the node next to current node.\\n         The rest of the arguments are optional and you can\\n         provide your own stuff there.\\n+    backend: pydatastructs.Backend\\n+        The backend to be used.\\n+        Optional, by default, the best available\\n+        backend is used.\\n \\n     Note\\n     ====\\n@@ -612,6 +646,8 @@ def depth_first_search(\\n \\n     .. [1] https://en.wikipedia.org/wiki/Depth-first_search\\n     \\\"\\\"\\\"\\n+    raise_if_backend_is_not_python(\\n+        depth_first_search, kwargs.get('backend', Backend.PYTHON))\\n     import pydatastructs.graphs.algorithms as algorithms\\n     func = \\\"_depth_first_search_\\\" + graph._impl\\n     if not hasattr(algorithms, func):\\n@@ -646,7 +682,8 @@ def _depth_first_search_adjacency_list(\\n _depth_first_search_adjacency_matrix = _depth_first_search_adjacency_list\\n \\n def shortest_paths(graph: Graph, algorithm: str,\\n-                   source: str, target: str=\\\"\\\") -> tuple:\\n+                   source: str, target: str=\\\"\\\",\\n+                   **kwargs) -> tuple:\\n     \\\"\\\"\\\"\\n     Finds shortest paths in the given graph from a given source.\\n \\n@@ -668,6 +705,10 @@ def shortest_paths(graph: Graph, algorithm: str,\\n         The name of the target node.\\n         Optional, by default, all pair shortest paths\\n         are returned.\\n+    backend: pydatastructs.Backend\\n+        The backend to be used.\\n+        Optional, by default, the best available\\n+        backend is used.\\n \\n     Returns\\n     =======\\n@@ -701,6 +742,8 @@ def shortest_paths(graph: Graph, algorithm: str,\\n     .. [1] https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm\\n     .. [2] https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\\n     \\\"\\\"\\\"\\n+    raise_if_backend_is_not_python(\\n+        shortest_paths, kwargs.get('backend', Backend.PYTHON))\\n     import pydatastructs.graphs.algorithms as algorithms\\n     func = \\\"_\\\" + algorithm + \\\"_\\\" + graph._impl\\n     if not hasattr(algorithms, func):\\n@@ -767,7 +810,8 @@ def _dijkstra_adjacency_list(graph: Graph, start: str, target: str):\\n \\n _dijkstra_adjacency_matrix = _dijkstra_adjacency_list\\n \\n-def all_pair_shortest_paths(graph: Graph, algorithm: str) -> tuple:\\n+def all_pair_shortest_paths(graph: Graph, algorithm: str,\\n+                            **kwargs) -> tuple:\\n     \\\"\\\"\\\"\\n     Finds shortest paths between all pairs of vertices in the given graph.\\n \\n@@ -781,6 +825,10 @@ def all_pair_shortest_paths(graph: Graph, algorithm: str) -> tuple:\\n         are implemented,\\n \\n         'floyd_warshall' -> Floyd Warshall algorithm as given in [1].\\n+    backend: pydatastructs.Backend\\n+        The backend to be used.\\n+        Optional, by default, the best available\\n+        backend is used.\\n \\n     Returns\\n     =======\\n@@ -810,6 +858,8 @@ def all_pair_shortest_paths(graph: Graph, algorithm: str) -> tuple:\\n \\n     .. [1] https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm\\n     \\\"\\\"\\\"\\n+    raise_if_backend_is_not_python(\\n+        all_pair_shortest_paths, kwargs.get('backend', Backend.PYTHON))\\n     import pydatastructs.graphs.algorithms as algorithms\\n     func = \\\"_\\\" + algorithm + \\\"_\\\" + graph._impl\\n     if not hasattr(algorithms, func):\\n@@ -849,7 +899,8 @@ def _floyd_warshall_adjacency_list(graph: Graph):\\n \\n _floyd_warshall_adjacency_matrix = _floyd_warshall_adjacency_list\\n \\n-def topological_sort(graph: Graph, algorithm: str) -> list:\\n+def topological_sort(graph: Graph, algorithm: str,\\n+                     **kwargs) -> list:\\n     \\\"\\\"\\\"\\n     Performs topological sort on the given graph using given algorithm.\\n \\n@@ -863,6 +914,10 @@ def topological_sort(graph: Graph, algorithm: str) -> list:\\n         Currently, following are supported,\\n \\n         'kahn' -> Kahn's algorithm as given in [1].\\n+    backend: pydatastructs.Backend\\n+        The backend to be used.\\n+        Optional, by default, the best available\\n+        backend is used.\\n \\n     Returns\\n     =======\\n@@ -886,6 +941,8 @@ def topological_sort(graph: Graph, algorithm: str) -> list:\\n \\n     .. [1] https://en.wikipedia.org/wiki/Topological_sorting#Kahn's_algorithm\\n     \\\"\\\"\\\"\\n+    raise_if_backend_is_not_python(\\n+        topological_sort, kwargs.get('backend', Backend.PYTHON))\\n     import pydatastructs.graphs.algorithms as algorithms\\n     func = \\\"_\\\" + algorithm + \\\"_\\\" + graph._impl\\n     if not hasattr(algorithms, func):\\n@@ -920,7 +977,8 @@ def _kahn_adjacency_list(graph: Graph) -> list:\\n         raise ValueError(\\\"Graph is not acyclic.\\\")\\n     return L\\n \\n-def topological_sort_parallel(graph: Graph, algorithm: str, num_threads: int) -> list:\\n+def topological_sort_parallel(graph: Graph, algorithm: str, num_threads: int,\\n+                              **kwargs) -> list:\\n     \\\"\\\"\\\"\\n     Performs topological sort on the given graph using given algorithm using\\n     given number of threads.\\n@@ -937,6 +995,10 @@ def topological_sort_parallel(graph: Graph, algorithm: str, num_threads: int) ->\\n         'kahn' -> Kahn's algorithm as given in [1].\\n     num_threads: int\\n         The maximum number of threads to be used.\\n+    backend: pydatastructs.Backend\\n+        The backend to be used.\\n+        Optional, by default, the best available\\n+        backend is used.\\n \\n     Returns\\n     =======\\n@@ -960,6 +1022,8 @@ def topological_sort_parallel(graph: Graph, algorithm: str, num_threads: int) ->\\n \\n     .. [1] https://en.wikipedia.org/wiki/Topological_sorting#Kahn's_algorithm\\n     \\\"\\\"\\\"\\n+    raise_if_backend_is_not_python(\\n+        topological_sort_parallel, kwargs.get('backend', Backend.PYTHON))\\n     import pydatastructs.graphs.algorithms as algorithms\\n     func = \\\"_\\\" + algorithm + \\\"_\\\" + graph._impl + '_parallel'\\n     if not hasattr(algorithms, func):\\n\",\"diff --git a/pydatastructs/utils/__init__.py b/pydatastructs/utils/__init__.py\\nindex e0b6067cf..9f2fee894 100644\\n--- a/pydatastructs/utils/__init__.py\\n+++ b/pydatastructs/utils/__init__.py\\n@@ -16,6 +16,7 @@\\n     SkipNode,\\n     summation,\\n     greatest_common_divisor,\\n-    minimum\\n+    minimum,\\n+    Backend\\n )\\n __all__.extend(misc_util.__all__)\\n\",\"diff --git a/pydatastructs/utils/misc_util.py b/pydatastructs/utils/misc_util.py\\nindex 845b02db6..8c6d9dc5c 100644\\n--- a/pydatastructs/utils/misc_util.py\\n+++ b/pydatastructs/utils/misc_util.py\\n@@ -1,3 +1,6 @@\\n+import math, pydatastructs\\n+from enum import Enum\\n+\\n __all__ = [\\n     'TreeNode',\\n     'MAryTreeNode',\\n@@ -13,11 +16,22 @@\\n     'SkipNode',\\n     'minimum',\\n     'summation',\\n-    'greatest_common_divisor'\\n+    'greatest_common_divisor',\\n+    'Backend'\\n ]\\n \\n-import math\\n \\n+class Backend(Enum):\\n+\\n+    PYTHON = 'Python'\\n+\\n+    def __str__(self):\\n+        return self.value\\n+\\n+def raise_if_backend_is_not_python(api, backend):\\n+    if backend != Backend.PYTHON:\\n+        raise ValueError(\\\"As of {} version, only {} backend is supported for {} API\\\".format(\\n+                            pydatastructs.__version__, str(Backend.PYTHON), api))\\n \\n _check_type = lambda a, t: isinstance(a, t)\\n NoneType = type(None)\\n@@ -43,6 +57,10 @@ class TreeNode(Node):\\n         Optional, index of the left child node.\\n     right: int\\n         Optional, index of the right child node.\\n+    backend: pydatastructs.Backend\\n+        The backend to be used.\\n+        Optional, by default, the best available\\n+        backend is used.\\n     \\\"\\\"\\\"\\n \\n     __slots__ = ['key', 'data', 'left', 'right', 'is_root',\\n@@ -52,7 +70,9 @@ class TreeNode(Node):\\n     def methods(cls):\\n         return ['__new__', '__str__']\\n \\n-    def __new__(cls, key, data=None):\\n+    def __new__(cls, key, data=None, **kwargs):\\n+        raise_if_backend_is_not_python(\\n+            cls, kwargs.get('backend', Backend.PYTHON))\\n         obj = Node.__new__(cls)\\n         obj.data, obj.key = data, key\\n         obj.left, obj.right, obj.parent, obj.height, obj.size = \\\\\\n@@ -79,11 +99,16 @@ class CartesianTreeNode(TreeNode):\\n         Any valid data to be stored in the node.\\n     priority: int\\n         An integer value for heap property.\\n-\\n+    backend: pydatastructs.Backend\\n+        The backend to be used.\\n+        Optional, by default, the best available\\n+        backend is used.\\n     \\\"\\\"\\\"\\n     __slots__ = ['key', 'data', 'priority']\\n \\n-    def __new__(cls, key, priority, data=None):\\n+    def __new__(cls, key, priority, data=None, **kwargs):\\n+        raise_if_backend_is_not_python(\\n+            cls, kwargs.get('backend', Backend.PYTHON))\\n         obj = TreeNode.__new__(cls, key, data)\\n         obj.priority = priority\\n         return obj\\n@@ -107,7 +132,10 @@ class RedBlackTreeNode(TreeNode):\\n         Any valid data to be stored in the node.\\n     color\\n         0 for black and 1 for red.\\n-\\n+    backend: pydatastructs.Backend\\n+        The backend to be used.\\n+        Optional, by default, the best available\\n+        backend is used.\\n     \\\"\\\"\\\"\\n     __slots__ = ['key', 'data', 'color']\\n \\n@@ -115,7 +143,9 @@ class RedBlackTreeNode(TreeNode):\\n     def methods(cls):\\n         return ['__new__']\\n \\n-    def __new__(cls, key, data=None):\\n+    def __new__(cls, key, data=None, **kwargs):\\n+        raise_if_backend_is_not_python(\\n+            cls, kwargs.get('backend', Backend.PYTHON))\\n         obj = TreeNode.__new__(cls, key, data)\\n         obj.color = 1\\n         return obj\\n@@ -131,6 +161,10 @@ class BinomialTreeNode(TreeNode):\\n         Required for comparison operations.\\n     data\\n         Any valid data to be stored in the node.\\n+    backend: pydatastructs.Backend\\n+        The backend to be used.\\n+        Optional, by default, the best available\\n+        backend is used.\\n \\n     Note\\n     ====\\n@@ -146,6 +180,10 @@ class BinomialTreeNode(TreeNode):\\n     is_root: bool, by default, False\\n         If the current node is a root of the tree then\\n         set it to True otherwise False.\\n+    backend: pydatastructs.Backend\\n+        The backend to be used.\\n+        Optional, by default, the best available\\n+        backend is used.\\n     \\\"\\\"\\\"\\n     __slots__ = ['parent', 'key', 'children', 'data', 'is_root']\\n \\n@@ -153,7 +191,9 @@ class BinomialTreeNode(TreeNode):\\n     def methods(cls):\\n         return ['__new__', 'add_children', '__str__']\\n \\n-    def __new__(cls, key, data=None):\\n+    def __new__(cls, key, data=None, **kwargs):\\n+        raise_if_backend_is_not_python(\\n+            cls, kwargs.get('backend', Backend.PYTHON))\\n         from pydatastructs.linear_data_structures.arrays import DynamicOneDimensionalArray\\n         obj = Node.__new__(cls)\\n         obj.data, obj.key = data, key\\n@@ -189,6 +229,10 @@ class MAryTreeNode(TreeNode):\\n         Required for comparison operations.\\n     data\\n         Any valid data to be stored in the node.\\n+    backend: pydatastructs.Backend\\n+        The backend to be used.\\n+        Optional, by default, the best available\\n+        backend is used.\\n \\n     Note\\n     ====\\n@@ -208,7 +252,9 @@ class MAryTreeNode(TreeNode):\\n     def methods(cls):\\n         return ['__new__', 'add_children', '__str__']\\n \\n-    def __new__(cls, key, data=None):\\n+    def __new__(cls, key, data=None, **kwargs):\\n+        raise_if_backend_is_not_python(\\n+            cls, kwargs.get('backend', Backend.PYTHON))\\n         from pydatastructs.linear_data_structures.arrays import DynamicOneDimensionalArray\\n         obj = Node.__new__(cls)\\n         obj.data = data\\n@@ -241,15 +287,24 @@ class LinkedListNode(Node):\\n     data\\n         Any valid data to be stored in the node.\\n     links\\n-        List of names of attributes which should be used as links to other nodes.\\n+        List of names of attributes which should\\n+        be used as links to other nodes.\\n     addrs\\n-        List of address of nodes to be assigned to each of the attributes in links.\\n+        List of address of nodes to be assigned to\\n+        each of the attributes in links.\\n+    backend: pydatastructs.Backend\\n+        The backend to be used.\\n+        Optional, by default, the best available\\n+        backend is used.\\n     \\\"\\\"\\\"\\n     @classmethod\\n     def methods(cls):\\n         return ['__new__', '__str__']\\n \\n-    def __new__(cls, key, data=None, links=None, addrs=None):\\n+    def __new__(cls, key, data=None, links=None, addrs=None,\\n+                **kwargs):\\n+        raise_if_backend_is_not_python(\\n+            cls, kwargs.get('backend', Backend.PYTHON))\\n         if links is None:\\n             links = ['next']\\n         if addrs is None:\\n@@ -278,16 +333,25 @@ class SkipNode(Node):\\n     data\\n         Any valid data to be stored in the node.\\n     next\\n-        Reference to the node lying just forward to the current node.\\n+        Reference to the node lying just forward\\n+        to the current node.\\n         Optional, by default, None.\\n     down\\n-        Reference to the node lying just below the current node.\\n+        Reference to the node lying just below the\\n+        current node.\\n         Optional, by default, None.\\n+    backend: pydatastructs.Backend\\n+        The backend to be used.\\n+        Optional, by default, the best available\\n+        backend is used.\\n     \\\"\\\"\\\"\\n \\n     __slots__ = ['key', 'data', 'next', 'down']\\n \\n-    def __new__(cls, key, data=None, next=None, down=None):\\n+    def __new__(cls, key, data=None, next=None, down=None,\\n+                **kwargs):\\n+        raise_if_backend_is_not_python(\\n+            cls, kwargs.get('backend', Backend.PYTHON))\\n         obj = Node.__new__(cls)\\n         obj.key, obj.data = key, data\\n         obj.next, obj.down = next, down\\n@@ -320,13 +384,20 @@ class AdjacencyListGraphNode(GraphNode):\\n         Any valid iterator to initialize the adjacent\\n         nodes of the current node.\\n         Optional, by default, None\\n+    backend: pydatastructs.Backend\\n+        The backend to be used.\\n+        Optional, by default, the best available\\n+        backend is used.\\n     \\\"\\\"\\\"\\n     @classmethod\\n     def methods(cls):\\n         return ['__new__', 'add_adjacent_node',\\n                 'remove_adjacent_node']\\n \\n-    def __new__(cls, name, data=None, adjacency_list=None):\\n+    def __new__(cls, name, data=None, adjacency_list=None,\\n+                **kwargs):\\n+        raise_if_backend_is_not_python(\\n+            cls, kwargs.get('backend', Backend.PYTHON))\\n         obj = GraphNode.__new__(cls)\\n         obj.name, obj.data = str(name), data\\n         obj._impl = 'adjacency_list'\\n@@ -371,6 +442,10 @@ class AdjacencyMatrixGraphNode(GraphNode):\\n         The index of the node in the AdjacencyMatrix.\\n     data\\n         The data to be stored at each graph node.\\n+    backend: pydatastructs.Backend\\n+        The backend to be used.\\n+        Optional, by default, the best available\\n+        backend is used.\\n     \\\"\\\"\\\"\\n     __slots__ = ['name', 'data']\\n \\n@@ -378,7 +453,10 @@ class AdjacencyMatrixGraphNode(GraphNode):\\n     def methods(cls):\\n         return ['__new__']\\n \\n-    def __new__(cls, name, data=None):\\n+    def __new__(cls, name, data=None,\\n+                **kwargs):\\n+        raise_if_backend_is_not_python(\\n+            cls, kwargs.get('backend', Backend.PYTHON))\\n         obj = GraphNode.__new__(cls)\\n         obj.name, obj.data, obj.is_connected = \\\\\\n             str(name), data, None\\n@@ -396,12 +474,19 @@ class GraphEdge(object):\\n         The source node of the edge.\\n     node2: GraphNode or it's child classes\\n         The target node of the edge.\\n+    backend: pydatastructs.Backend\\n+        The backend to be used.\\n+        Optional, by default, the best available\\n+        backend is used.\\n     \\\"\\\"\\\"\\n     @classmethod\\n     def methods(cls):\\n         return ['__new__', '__str__']\\n \\n-    def __new__(cls, node1, node2, value=None):\\n+    def __new__(cls, node1, node2, value=None,\\n+                **kwargs):\\n+        raise_if_backend_is_not_python(\\n+            cls, kwargs.get('backend', Backend.PYTHON))\\n         obj = object.__new__(cls)\\n         obj.source, obj.target = node1, node2\\n         obj.value = value\\n@@ -422,6 +507,10 @@ class Set(object):\\n         the set.\\n     data: Python object\\n         The data to be stored in the set.\\n+    backend: pydatastructs.Backend\\n+        The backend to be used.\\n+        Optional, by default, the best available\\n+        backend is used.\\n     \\\"\\\"\\\"\\n \\n     __slots__ = ['parent', 'size', 'key', 'data']\\n@@ -430,7 +519,10 @@ class Set(object):\\n     def methods(cls):\\n         return ['__new__']\\n \\n-    def __new__(cls, key, data=None):\\n+    def __new__(cls, key, data=None,\\n+                **kwargs):\\n+        raise_if_backend_is_not_python(\\n+            cls, kwargs.get('backend', Backend.PYTHON))\\n         obj = object.__new__(cls)\\n         obj.key = key\\n         obj.data = data\\n@@ -446,6 +538,10 @@ class TrieNode(Node):\\n \\n     char: The character stored in the current node.\\n           Optional, by default None.\\n+    backend: pydatastructs.Backend\\n+        The backend to be used.\\n+        Optional, by default, the best available\\n+        backend is used.\\n     \\\"\\\"\\\"\\n \\n     __slots__ = ['char', '_children', 'is_terminal']\\n@@ -454,7 +550,9 @@ class TrieNode(Node):\\n     def methods(cls):\\n         return ['__new__', 'add_child', 'get_child', 'remove_child']\\n \\n-    def __new__(cls, char=None):\\n+    def __new__(cls, char=None, **kwargs):\\n+        raise_if_backend_is_not_python(\\n+            cls, kwargs.get('backend', Backend.PYTHON))\\n         obj = Node.__new__(cls)\\n         obj.char = char\\n         obj._children = {}\\n\",\"diff --git a/pydatastructs/utils/tests/test_code_quality.py b/pydatastructs/utils/tests/test_code_quality.py\\nindex 138a0750f..9a5ee418b 100644\\n--- a/pydatastructs/utils/tests/test_code_quality.py\\n+++ b/pydatastructs/utils/tests/test_code_quality.py\\n@@ -1,4 +1,5 @@\\n import os, re, sys, pydatastructs, inspect\\n+from typing import Type\\n \\n def _list_files():\\n     root_path = os.path.abspath(\\n@@ -128,3 +129,26 @@ def test_public_api():\\n                                 \\\"have %s method implemented.\\\"%(\\n                                     _class, method\\n                                 ))\\n+\\n+def test_backend_argument_message():\\n+\\n+    def call_and_raise(api, pos_args_count=0):\\n+        try:\\n+            if pos_args_count == 0:\\n+                api(backend=None)\\n+            elif pos_args_count == 1:\\n+                api(None, backend=None)\\n+            elif pos_args_count == 2:\\n+                api(None, None, backend=None)\\n+        except ValueError as value_error:\\n+            assert str(api) in value_error.args[0]\\n+        except TypeError as type_error:\\n+            max_pos_args_count = 2\\n+            if pos_args_count <= max_pos_args_count:\\n+                call_and_raise(api, pos_args_count + 1)\\n+            else:\\n+                raise type_error\\n+\\n+    apis = _apis()\\n+    for api in apis:\\n+        call_and_raise(api, 0)\"]", "hints_text": ""}

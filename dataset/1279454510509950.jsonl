{"instance_id": "1279454510509950", "repo": "seperman/deepdiff", "base_commit": "89c5cc227c48b63be4a0e1ad4af59d3c1b0272d7", "problem_statement": "Wrong diff on list of strings:\\n**Describe the bug**\\r\\nWith certain specific data, DeepDiff gives a wrong result (see below for more details).\\r\\nThe issue seems to be related to repeated elements in the input, because even just small changes from the sequences below won't trigger the bug.\\r\\n\\r\\n**To Reproduce**\\r\\n```python\\r\\nfrom pprint import pprint\\r\\nfrom deepdiff import DeepDiff\\r\\n\\r\\nl1 = \"A B C D E F G D H\".split()\\r\\nl2 = \"B C X D H Y Z\".split()\\r\\npprint(DeepDiff(l1, l2))\\r\\n```\\r\\nResult:\\r\\n```\\r\\n{'iterable_item_removed': {'root[0]': 'A', 'root[4]': 'E'},\\r\\n 'values_changed': {'root[2]': {'new_value': 'X', 'old_value': 'D'},\\r\\n                    'root[5]': {'new_value': 'Y', 'old_value': 'F'},\\r\\n                    'root[6]': {'new_value': 'Z', 'old_value': 'G'}}}\\r\\n```\\r\\nProblems with this:\\r\\n- indexes in the `values_changed` key are not consistent: `root[2]` old value is not `D`, unless you take it _after_ removing, but `root[5]` old value is `F` only if you take it _before_ removing.\\r\\n- Applying the diff (with some \"interpretation\" of the indexes) does not transform l1 into l2. We obtain `B C X Y Z D H` instead of `B C X D H Y Z`\\r\\n\\r\\n**Expected behavior**\\r\\nIndexes in the `values_changed` section should be consistent, and applying the diff on l1 should produce l2\\r\\n\\r\\n**OS, DeepDiff version and Python version (please complete the following information):**\\r\\n - OS: Any\\r\\n - Python Version: 3.10.7\\r\\n - DeepDiff Version: 6.7.1\\r\\n\\r\\n**Additional context**\\r\\nNote that changes to l1 or l2 will most probably produce a correct result.\\r\\nThis was the smallest example I could find that was reproducing the error.\\nError when subtracting Delta from a dictionary:\\nPlease checkout the [F.A.Q](https://zepworks.com/deepdiff/current/faq.html) page before creating a bug ticket to make sure it is not already addressed.\\r\\n\\r\\n**Describe the bug**\\r\\nAn upstream provider sends us a JSON event with 3 sections: beforeImage, updates, allAfterImage.  In the near future they will send us only the **updates** and **allAfterImage** to save on payload size.  We will then attempt to generate the **beforeImage** on our own by using the allAfterImage and subtracting a Delta created from the updates.  _Note: we are taking a cautious approach and have chosen to specify the argument raise_errors=True on our Delta._  However, in this one circumstance, we see that when we try to generate a beforeImage, the Delta throws an error.  Likewise, if we change raise_errors=False then we see that our generated beforeImage does not match what was expected(provided).\\r\\n\\r\\n**To Reproduce**\\r\\nThe below code can be used to demonstrate the problem using a Unit Test.\\r\\n\\r\\n```\\r\\nimport deepdiff.serialization\\r\\nimport pytest\\r\\nimport json\\r\\nimport copy\\r\\nfrom deepdiff import DeepDiff, Delta, serialization\\r\\nfrom conv_deep_diff import write_dictionary_to_json\\r\\n\\r\\n\"\"\"\\r\\nSample code (Unit Test) to demonstrate DeepDiff errors when trying\\r\\nto generate a result dict from a AFTER dict - Delta\\r\\n    \\r\\n    execute:\\r\\n    pytest -vv demo_deepdiff_fail.py\\r\\n\"\"\"\\r\\n\\r\\ndef test_delta_failure():\\r\\n\\r\\n    false = False   # Helps to translate between true JSON and Python Dictionary\\r\\n    true = True     # Helps to translate between true JSON and Python Dictionary\\r\\n    null = None     # Helps to translate between true JSON and Python Dictionary\\r\\n\\r\\n    event = {\\r\\n        \"beforeImage\": {\\r\\n            \"postalAddresses\": [\\r\\n                {\\r\\n                    \"country\": \"UNITED STATES\",\\r\\n                    \"city\": \"BLUFFS\",\\r\\n                    \"addressType\": \"US\",\\r\\n                    \"postalCode\": \"626218032\",\\r\\n                    \"usage\": \"Mailing\",\\r\\n                    \"specialHandling\": null,\\r\\n                    \"standardization\": \"YES\",\\r\\n                    \"stateProvince\": \"IL\",\\r\\n                    \"primaryIndicator\": true,\\r\\n                    \"addressIdentifier\": \"Z8PDWBG42YC\",\\r\\n                    \"addressLines\": [\\r\\n                        \"871 PHILLIPS FERRY RD\"\\r\\n                    ],\\r\\n                    \"specialHandlingType\": null\\r\\n                },\\r\\n                {\\r\\n                    \"country\": \"UNITED STATES\",\\r\\n                    \"city\": \"BLUFFS\",\\r\\n                    \"addressType\": \"US\",\\r\\n                    \"postalCode\": \"626218032\",\\r\\n                    \"usage\": \"Residence\",\\r\\n                    \"specialHandling\": null,\\r\\n                    \"standardization\": \"YES\",\\r\\n                    \"stateProvince\": \"IL\",\\r\\n                    \"primaryIndicator\": false,\\r\\n                    \"addressIdentifier\": \"Z8PDWBG42YC\",\\r\\n                    \"addressLines\": [\\r\\n                        \"871 PHILLIPS FERRY RD\"\\r\\n                    ],\\r\\n                    \"specialHandlingType\": null\\r\\n                },\\r\\n                {\\r\\n                    \"country\": \"UNITED STATES\",\\r\\n                    \"city\": \"BLUFFS\",\\r\\n                    \"addressType\": \"US\",\\r\\n                    \"postalCode\": \"626218032\",\\r\\n                    \"usage\": \"Mailing\",\\r\\n                    \"specialHandling\": null,\\r\\n                    \"standardization\": null,\\r\\n                    \"stateProvince\": \"IL\",\\r\\n                    \"primaryIndicator\": false,\\r\\n                    \"addressIdentifier\": \"MHPP3BY0BYC\",\\r\\n                    \"addressLines\": [\\r\\n                        \"871 PHILLIPS FERRY RD\",\\r\\n                        \"APT RV92\"\\r\\n                    ],\\r\\n                    \"specialHandlingType\": null\\r\\n                }\\r\\n            ]\\r\\n        },\\r\\n        \"allAfterImage\": {\\r\\n            \"postalAddresses\": [\\r\\n                {\\r\\n                    \"country\": \"UNITED STATES\",\\r\\n                    \"city\": \"BLUFFS\",\\r\\n                    \"addressType\": \"US\",\\r\\n                    \"postalCode\": \"626218032\",\\r\\n                    \"usage\": \"Residence\",\\r\\n                    \"specialHandling\": null,\\r\\n                    \"standardization\": \"NO\",\\r\\n                    \"stateProvince\": \"IL\",\\r\\n                    \"primaryIndicator\": false,\\r\\n                    \"addressIdentifier\": \"Z8PDWBG42YC\",\\r\\n                    \"addressLines\": [\\r\\n                        \"871 PHILLIPS FERRY RD\"\\r\\n                    ],\\r\\n                    \"specialHandlingType\": null\\r\\n                },\\r\\n                {\\r\\n                    \"country\": \"UNITED STATES\",\\r\\n                    \"city\": \"BLUFFS\",\\r\\n                    \"addressType\": \"US\",\\r\\n                    \"postalCode\": \"626218032\",\\r\\n                    \"usage\": \"Mailing\",\\r\\n                    \"specialHandling\": null,\\r\\n                    \"standardization\": null,\\r\\n                    \"stateProvince\": \"IL\",\\r\\n                    \"primaryIndicator\": false,\\r\\n                    \"addressIdentifier\": \"MHPP3BY0BYC\",\\r\\n                    \"addressLines\": [\\r\\n                        \"871 PHILLIPS FERRY RD\",\\r\\n                        \"APT RV92\"\\r\\n                    ],\\r\\n                    \"specialHandlingType\": null\\r\\n                },\\r\\n                {\\r\\n                    \"country\": \"UNITED STATES\",\\r\\n                    \"city\": \"BLUFFS\",\\r\\n                    \"addressType\": \"US\",\\r\\n                    \"postalCode\": \"626218032\",\\r\\n                    \"usage\": \"Mailing\",\\r\\n                    \"specialHandling\": null,\\r\\n                    \"standardization\": \"NO\",\\r\\n                    \"stateProvince\": \"IL\",\\r\\n                    \"primaryIndicator\": true,\\r\\n                    \"addressIdentifier\": \"Z8PDWBG42YC\",\\r\\n                    \"addressLines\": [\\r\\n                        \"871 PHILLIPS FERRY RD\"\\r\\n                    ],\\r\\n                    \"specialHandlingType\": null\\r\\n                }\\r\\n            ]\\r\\n        },\\r\\n        \"updates\": [\\r\\n            {\\r\\n                \"path\": [\\r\\n                    \"postalAddresses\",\\r\\n                    1,\\r\\n                    \"standardization\"\\r\\n                ],\\r\\n                \"action\": \"values_changed\",\\r\\n                \"value\": \"NO\",\\r\\n                \"old_value\": \"YES\"\\r\\n            },\\r\\n            {\\r\\n                \"path\": [\\r\\n                    \"postalAddresses\",\\r\\n                    0,\\r\\n                    \"standardization\"\\r\\n                ],\\r\\n                \"action\": \"values_changed\",\\r\\n                \"value\": \"NO\",\\r\\n                \"old_value\": \"YES\"\\r\\n            }\\r\\n        ]\\r\\n    }\\r\\n\\r\\n    # Sanity Check, make sure a calculated_updates matches what was provided on the event.\\r\\n    temp_diff = DeepDiff(event.get('beforeImage'), event.get('allAfterImage'), ignore_order=True, report_repetition=True)\\r\\n    temp_delta = Delta(temp_diff, always_include_values=True, bidirectional=True, raise_errors=True)\\r\\n    calculated_updates = temp_delta.to_flat_dicts()\\r\\n\\r\\n    double_check = DeepDiff(calculated_updates, event.get('updates'))\\r\\n    assert {} == double_check\\r\\n\\r\\n    # If we get to here, then our event details were accurate, including the 'updates'\\r\\n    # Now see if we could generate a beforeImage by subtracting a Delta from our 'allAfterImage'\\r\\n\\r\\n    delta = Delta(flat_dict_list=event.get('updates'),\\r\\n                  always_include_values=True, bidirectional=True, raise_errors=True)\\r\\n\\r\\n    generated_before_image = event.get('allAfterImage') - delta\\r\\n\\r\\n    \"\"\"\\r\\n    Errors on line above with:\\r\\n    msg = \"Expected the old value for root['postalAddresses'][1]['standardization'] to be NO but it is None. Error found on: You have applied the delta to an object that has different values than the original object the delta was made from.\"\\r\\nlevel = 'error'\\r\\n\\r\\n    def _raise_or_log(self, msg, level='error'):\\r\\n        if self.log_errors:\\r\\n            getattr(logger, level)(msg)\\r\\n        if self.raise_errors:\\r\\n>           raise DeltaError(msg)\\r\\nE           deepdiff.delta.DeltaError: Expected the old value for root['postalAddresses'][1]['standardization'] to be NO but it is None. Error found on: You have applied the delta to an object that has different values than the original object the delta was made from.\\r\\n\\r\\n\\r\\nC:\\DEV\\Tools\\Python\\Python38\\lib\\site-packages\\deepdiff\\delta.py:190: DeltaError\\r\\n    \"\"\"\\r\\n\\r\\n    double_check = DeepDiff(generated_before_image, event.get('beforeImage'), ignore_order=True, report_repetition=True)\\r\\n    assert {} == double_check\\r\\n```\\r\\n\\r\\n\\r\\n**Expected behavior**\\r\\nWe would expect to be able to be able to generate a new beforeImage which exactly matches the provided event beforeImage.\\r\\n\\r\\n**OS, DeepDiff version and Python version (please complete the following information):**\\r\\n - OS: Win10\\r\\n - Version [e.g. 20LTS]\\r\\n - Python Version [e.g. 3.9.12]: Python 3.8.8\\r\\n - DeepDiff Version [e.g. 5.8.0]:  6.7.0\\r\\n\\r\\n**Additional context**\\r\\nAdd any other context about the problem here.\\r\\n\\nInstantiating a Delta with a flat_dict_list unexpectedly mutates the flat_dict_list:\\nPlease checkout the [F.A.Q](https://zepworks.com/deepdiff/current/faq.html) page before creating a bug ticket to make sure it is not already addressed.\\r\\n\\r\\n**Describe the bug**\\r\\nWe recently discovered some unexpected behaviour which we are considering as a bug.  When instantiating a new Delta with a flat_dict_list, which contains indexed list items as being added and removed, we see that the list item path index is getting removed from the flat_dict_list from the perspective of the calling module.\\r\\n\\r\\n**To Reproduce**\\r\\n```\\r\\n\\r\\nflat_dict_list = [{'path': ['individualNames', 1],\\r\\n                                   'value': {'firstName': 'Johnny',\\r\\n                                             'lastName': 'Doe',\\r\\n                                             'prefix': '',\\r\\n                                             'middleName': 'A',\\r\\n                                             'primaryIndicator': False,\\r\\n                                             'professionalDesignation': '',\\r\\n                                             'suffix': 'SR',\\r\\n                                             'nameIdentifier': '00003'},\\r\\n                                   'action': 'unordered_iterable_item_added'},\\r\\n                                  {'path': ['individualNames', 1],\\r\\n                                   'value': {'firstName': 'John',\\r\\n                                             'lastName': 'Doe',\\r\\n                                             'prefix': '',\\r\\n                                             'middleName': '',\\r\\n                                             'primaryIndicator': False,\\r\\n                                             'professionalDesignation': '',\\r\\n                                             'suffix': 'SR',\\r\\n                                             'nameIdentifier': '00002'},\\r\\n                                   'action': 'unordered_iterable_item_removed'}]\\r\\n\\r\\n\\r\\n        # Note: the list index is provided on the path value...\\r\\n\\r\\n        # Now use the flat_dict_list to instantiate a new delta...\\r\\n        delta = Delta(flat_dict_list=flat_dict_list,\\r\\n                      always_include_values=True, bidirectional=True, raise_errors=True)\\r\\n\\r\\n        # if the flat_dict_list is (unexpectedly) mutated, it will be missing the list index number on the path value.\\r\\n        # our flat_dict_list will now look like this:\\r\\n        mutated_list_missing_indexes_on_path = [{'path': ['individualNames'],\\r\\n                                         'value': {'firstName': 'Johnny',\\r\\n                                                   'lastName': 'Doe',\\r\\n                                                   'prefix': '',\\r\\n                                                   'middleName': 'A',\\r\\n                                                   'primaryIndicator': False,\\r\\n                                                   'professionalDesignation': '',\\r\\n                                                   'suffix': 'SR',\\r\\n                                                   'nameIdentifier': '00003'},\\r\\n                                         'action': 'unordered_iterable_item_added'},\\r\\n                                        {'path': ['individualNames'],\\r\\n                                         'value': {'firstName': 'John',\\r\\n                                                   'lastName': 'Doe',\\r\\n                                                   'prefix': '',\\r\\n                                                   'middleName': '',\\r\\n                                                   'primaryIndicator': False,\\r\\n                                                   'professionalDesignation': '',\\r\\n                                                   'suffix': 'SR',\\r\\n                                                   'nameIdentifier': '00002'},\\r\\n                                         'action': 'unordered_iterable_item_removed'}]\\r\\n\\r\\n```\\r\\n\\r\\n\\r\\n\\r\\n**Expected behavior**\\r\\nA clear and concise description of what you expected to happen.\\r\\nWe expect that the flat_dict_list will be used but not changed/mutated in any way.  Think of this as pass by COPY rather than pass by REFERENCE.\\r\\n\\r\\n**OS, DeepDiff version and Python version (please complete the following information):**\\r\\n - OS: [e.g. Ubuntu] Win10 and/or Linux\\r\\n - Version [e.g. 20LTS]\\r\\n - Python Version [e.g. 3.9.12] 3.9.12\\r\\n - DeepDiff Version [e.g. 5.8.0] 6.7.1 **(but using code from dev branch from 3/12/2024)**\\r\\n\\r\\n**Additional context**\\r\\nAdd any other context about the problem here.\\r\\n**We will submit a Pull Request to fix this issue.**\\r\\n\\nError after comparing: Can not produce a hash (type datetime.date doesn't define __round__ method):\\nDeepDiff has crashing comparing on the stage of hashes creating.\\r\\n\\r\\nCompare two lists of dictionaries with type `date` and `True` for parameters `ignore_order` and `ignore_numeric_type_changes`:\\r\\n\\r\\n> import datetime\\r\\n> \\r\\n> DeepDiff(\\r\\n>     [{'due_date': datetime.date(2024, 2, 1)}], \\r\\n>     [{'due_date': datetime.date(2024, 2, 2)}], \\r\\n>     ignore_order=True, \\r\\n>     ignore_numeric_type_changes=True\\r\\n> )\\r\\n\\r\\n\\r\\n**Actual result:**\\r\\nCan not produce a hash for root.Not counting this object.\\r\\n type datetime.date doesn't define __round__ method\\r\\nCan not produce a hash for iterable root. type datetime.date doesn't define __round__ method\\r\\nCan not produce a hash for root.Not counting this object.\\r\\n type datetime.date doesn't define __round__ method\\r\\nCan not produce a hash for iterable root. type datetime.date doesn't define __round__ method\\r\\n{}\\r\\n\\r\\n![image](https://github.com/seperman/deepdiff/assets/13105138/302ca0dd-e309-409d-ae7f-cf8cf64b85e2)\\r\\n\\r\\n\\r\\n**Expected result:**\\r\\n{'values_changed': {\"root[0]['due_date']\": {'new_value': datetime.date(2024, 2, 1), 'old_value': datetime.date(2024, 2, 2)}}}\\r\\n\\r\\n\\r\\n**Environment:**\\r\\n - OS: Ubuntu\\r\\n - Version 22.04\\r\\n - Python Version 3.10.12\\r\\n - DeepDiff Version 6.7.1\\r\\n\\nError when comparing two nested dicts with 2 added fields:\\n**Describe the bug**\\r\\n`DeepDiff` fails when 2 new fields are added in `t2` in different nested dictionary fields. The library identifies correctly the name of the new fields, but it is unable to retrieve the correct dictionary levels or paths to them.\\r\\n`DeepDiff` works as expected when just a new field is added, but it breaks when 2 new fields are added in different levels.\\r\\n\\r\\n**To Reproduce**\\r\\nCreate two dictionaries to compare:\\r\\n```\\r\\ns1 = {\\r\\n    \"type\": \"struct\",\\r\\n    \"fields\": [\\r\\n        {\"name\": \"Competition\", \"metadata\": {}, \"nullable\": True, \"type\": \"string\"},\\r\\n        {\"name\": \"TeamName\", \"metadata\": {}, \"nullable\": True, \"type\": \"string\"},\\r\\n        {\\r\\n            \"name\": \"Contents\",\\r\\n            \"metadata\": {},\\r\\n            \"nullable\": True,\\r\\n            \"type\": {\\r\\n                \"type\": \"struct\",\\r\\n                \"fields\": [\\r\\n                    {\"name\": \"Date\", \"metadata\": {}, \"nullable\": True, \"type\": \"string\"},\\r\\n                    {\"name\": \"Player1\", \"metadata\": {}, \"nullable\": True, \"type\": \"string\"}\\r\\n                ]\\r\\n            }\\r\\n        }\\r\\n    ]\\r\\n}\\r\\n\\r\\ns2 = {\\r\\n    \"type\": \"struct\",\\r\\n    \"fields\": [\\r\\n        {\"name\": \"Competition\", \"metadata\": {}, \"nullable\": True, \"type\": \"string\"},\\r\\n        {\"name\": \"GlobalId\", \"metadata\": {}, \"nullable\": True, \"type\": \"string\"},\\r\\n        {\"name\": \"TeamName\", \"metadata\": {}, \"nullable\": True, \"type\": \"string\"},\\r\\n        {\\r\\n            \"name\": \"Contents\",\\r\\n            \"metadata\": {},\\r\\n            \"nullable\": True,\\r\\n            \"type\": {\\r\\n                \"type\": \"struct\",\\r\\n                \"fields\": [\\r\\n                    {\"name\": \"Date\", \"metadata\": {}, \"nullable\": True, \"type\": \"string\"},\\r\\n                    {\"name\": \"Player1\", \"metadata\": {}, \"nullable\": True, \"type\": \"string\"},\\r\\n                    {\"name\": \"Player2\", \"metadata\": {}, \"nullable\": True, \"type\": \"string\"}\\r\\n                ]\\r\\n            }\\r\\n        }\\r\\n    ]\\r\\n}\\r\\n```\\r\\nThe `s2` dictionary contains two new fields `GlobalId` at `root['fields'][1]` and `Player2` at `root['fields'][3]['type']['fields'][2]`, but if I run\\r\\n```\\r\\ndd = DeepDiff(t1=s1, t2=s2, ignore_order=True, verbose_level=2)\\r\\n```\\r\\nI get:\\r\\n```\\r\\n{\\r\\n    'iterable_item_added': {\\r\\n        \"root['fields'][1]\": {'name': 'GlobalId', 'metadata': {}, 'nullable': True, 'type': 'string'},\\r\\n        \"root['fields'][2]['type']['fields'][2]\": {'name': 'Player2', 'metadata': {}, 'nullable': True, 'type': 'string'}\\r\\n    }\\r\\n}\\r\\n```\\r\\nWhich is wrong for the second added field: the new field name is correctly identified, but the path within the dictionary is wrong, the path `root['fields'][2]['type']['fields'][2]` does not exist.\\r\\n\\r\\n**Expected behavior**\\r\\nIt should return the right dictionary path for the second added field, that is `root['fields'][3]['type']['fields'][2]`, i.e., the full correct output should be:\\r\\n```\\r\\n{\\r\\n    'iterable_item_added': {\\r\\n        \"root['fields'][1]\": {'name': 'GlobalId', 'metadata': {}, 'nullable': True, 'type': 'string'},\\r\\n        \"root['fields'][3]['type']['fields'][2]\": {'name': 'Player2', 'metadata': {}, 'nullable': True, 'type': 'string'}\\r\\n    }\\r\\n}\\r\\n```\\r\\n\\r\\n**OS, DeepDiff version and Python version (please complete the following information):**\\r\\n - OS: Linux\\r\\n - Version: Any\\r\\n - Python Version 3.8\\r\\n - DeepDiff Version > 6.5.0 (tested with 6.5.1 and 6.7.1).\\r\\n\\r\\n**Additional context**\\r\\nNone.\\r\\n", "FAIL_TO_PASS": ["tests/test_diff_numpy.py::TestNumpy::test_numpy[numpy_array3_ignore_number_type_changes]", "tests/test_diff_numpy.py::TestNumpy::test_numpy[numpy_array5_ignore_number_type_changes_and_ignore_order]", "tests/test_ignore_order.py::TestIgnoreOrder::test_type_change_numeric_ignored[10-10.0-5-False-result0]", "tests/test_diff_text.py::TestDeepDiffText::test_ignore_type_in_groups_numbers_and_strings", "tests/test_diff_text.py::TestDeepDiffText::test_decimal_digits[t16-10.0-10-expected_result6]", "tests/test_ignore_order.py::TestIgnoreOrder::test_type_change_numeric_when_ignore_order[t13-t23-expected_result3]", "tests/test_diff_text.py::TestDeepDiffText::test_decimal_digits[t112-10.01-3-expected_result12]", "tests/test_diff_text.py::TestDeepDiffText::test_ignore_type_in_groups_none_and_objects", "tests/test_hash.py::TestDeepHashPrep::test_objects_with_same_content[4-t13-t23-ignore_type_in_groups3-False-True]", "tests/test_diff_text.py::TestDeepDiffText::test_decimal_digits[t14-10-10-expected_result4]", "tests/test_delta.py::TestNumpyDelta::test_numpy_delta_cases[delta_numpy4_type_change_ignore_numeric_type_changes]", "tests/test_diff_text.py::TestDeepDiffText::test_decimal_digits[t111-10.01-8-expected_result11]", "tests/test_serialization.py::TestDeepDiffPretty::test_json_dumps_and_loads[9-value8-array]", "tests/test_ignore_order.py::TestIgnoreOrder::test_ignore_order_max_passes[1-expected1]", "tests/test_ignore_order.py::TestIgnoreOrder::test_type_change_numeric_when_ignore_order[10-10.2-expected_result1]", "tests/test_delta.py::TestDeltaCompareFunc::test_flat_dict_and_deeply_nested_dict", "tests/test_diff_text.py::TestDeepDiffText::test_ignore_numeric_type_changes_numbers_when_decimal[t11-t21-5-result1]", "tests/test_diff_text.py::TestDeepDiffText::test_decimal_digits[t110-10.01-5-expected_result10]", "tests/test_ignore_order.py::TestIgnoreOrder::test_type_change_numeric_when_ignore_order[t12-10.0-expected_result2]", "tests/test_ignore_order.py::TestIgnoreOrder::test_ignore_order_max_diffs[80-expected2]", "tests/test_ignore_order.py::TestIgnoreOrder::test_ignore_order_max_passes[22-expected2]", "tests/test_diff_text.py::TestDeepDiffText::test_item_type_change_for_strings_ignored_by_default", "tests/test_delta.py::TestIgnoreOrderDelta::test_ignore_order_delta_cases[delta_ignore_order_case4]", "tests/test_diff_text.py::TestDeepDiffText::test_custom_object_changes_when_ignore_type_in_groups", "tests/test_diff_text.py::TestDeepDiffText::test_ignore_numeric_type_changes_numbers_when_decimal[t12-t22-5-result2]", "tests/test_diff_text.py::TestDeepDiffText::test_ignore_type_in_groups2", "tests/test_diff_text.py::TestDeepDiffText::test_decimal_digits[t15-10.0-0-expected_result5]", "tests/test_diff_text.py::TestDeepDiffText::test_decimal_digits[t19-10.01-2-expected_result9]", "tests/test_diff_text.py::TestDeepDiffText::test_decimal_digits[t113-100000.1-0-expected_result13]", "tests/test_diff_other.py::TestDiffOther::test_multi_processing3_deephash", "tests/test_ignore_order.py::TestIgnoreOrder::test_ignore_type_in_groups_numbers_and_strings_when_ignore_order", "tests/test_diff_text.py::TestDeepDiffText::test_ignore_numeric_type_changes_numbers_when_decimal[t14-t24-3-result4]", "tests/test_delta.py::TestDeltaCompareFunc::test_list_of_alphabet_and_its_delta", "tests/test_diff_text.py::TestDeepDiffText::test_decimal_digits[123.93420232-123.93420232-0-expected_result18]", "tests/test_diff_text.py::TestDeepDiffText::test_decimal_digits[t116-100000.1-0-expected_result16]", "tests/test_diff_text.py::TestDeepDiffText::test_decimal_digits[10-10.2-0-expected_result2]", "tests/test_diff_text.py::TestDeepDiffText::test_enum_ignore_type_change", "tests/test_diff_text.py::TestDeepDiffText::test_decimal_digits[10-10.0-5-expected_result0]", "tests/test_hash.py::TestDeepHashPrep::test_named_tuples", "tests/test_diff_numpy.py::TestNumpy::test_numpy[numpy_array4_ignore_number_type_changes_and_ignore_order]", "tests/test_diff_text.py::TestDeepDiffText::test_decimal_digits[t114-100000.1-1-expected_result14]", "tests/test_ignore_order.py::TestIgnoreOrder::test_type_change_numeric_when_ignore_order[10-10.0-expected_result0]", "tests/test_diff_text.py::TestDeepDiffText::test_significant_digits_and_notation[6-t15-t25-True-4-e-result5]", "tests/test_ignore_order.py::TestIgnoreOrder::test_ignore_order_max_diffs[65-expected1]", "tests/test_serialization.py::TestDeepDiffPretty::test_namedtuple_seriazliation", "tests/test_diff_text.py::TestDeepDiffText::test_decimal_digits[t17-10.0-5-expected_result7]", "tests/test_diff_text.py::TestDeepDiffText::test_decimal_digits[t115-100000.1-5-expected_result15]", "tests/test_diff_other.py::TestDiffOther::test_bool_str2", "tests/test_delta.py::TestIgnoreOrderDelta::test_ignore_order_delta_cases[delta_ignore_order_case5]", "tests/test_diff_text.py::TestDeepDiffText::test_ignore_numeric_type_changes_numbers_when_decimal[t10-t20-55-result0]", "tests/test_diff_text.py::TestDeepDiffText::test_decimal_digits[t13-10-0-expected_result3]", "tests/test_diff_text.py::TestDeepDiffText::test_decimal_digits[t18-10.01-1-expected_result8]", "tests/test_diff_text.py::TestDeepDiffText::test_decimal_digits[t117-100000.1-1-expected_result17]", "tests/test_delta.py::TestIgnoreOrderDelta::test_ignore_order_delta_cases[delta_ignore_order_case3]", "tests/test_diff_text.py::TestDeepDiffText::test_decimal_digits[10-10.2-5-expected_result1]", "tests/test_diff_text.py::TestDeepDiffText::test_ignore_type_in_groups_float_vs_decimal", "tests/test_diff_text.py::TestDeepDiffText::test_ignore_type_in_groups_str_and_datetime", "tests/test_diff_other.py::TestDiffOther::test_bool_str1", "tests/test_delta.py::TestIgnoreOrderDelta::test_ignore_order_delta_cases[delta_ignore_order_case2]", "tests/test_diff_text.py::TestDeepDiffText::test_custom_class_changes_with_slot_change_when_ignore_type", "tests/test_delta.py::TestIgnoreOrderDelta::test_ignore_order_delta_cases[delta_ignore_order_case_reverse2]", "tests/test_hash.py::TestDeepHashPrep::test_objects_with_same_content[2-t11-t21-ignore_type_in_groups1-False-True]", "tests/test_diff_text.py::TestDeepDiffText::test_ignore_type_in_groups_just_numbers", "tests/test_hash.py::TestDeepHashPrep::test_objects_with_same_content[3-t12-t22-ignore_type_in_groups2-False-True]"], "PASS_TO_PASS": [], "language": "python", "test_command": "source /saved/ENV || source /saved/*/ENV && pytest --no-header -rA --tb=no -p no:cacheprovider --continue-on-collection-errors", "test_output_parser": "python/parse_log_pytest_v3", "image_storage_uri": "vmvm-registry.fbinfra.net/repomate_image_activ_pytest/seperman_deepdiff:89c5cc227c48b63be4a0e1ad4af59d3c1b0272d7", "patch": "[\"diff --git a/CITATION.cff b/CITATION.cff\\nnew file mode 100644\\nindex 00000000..20de7532\\n--- /dev/null\\n+++ b/CITATION.cff\\n@@ -0,0 +1,10 @@\\n+cff-version: 1.2.0\\n+message: \\\"If you use this software, please cite it as below.\\\"\\n+authors:\\n+- family-names: \\\"Dehpour\\\"\\n+  given-names: \\\"Sep\\\"\\n+  orcid: \\\"https://orcid.org/0009-0009-5828-4345\\\"\\n+title: \\\"DeepDiff\\\"\\n+version: 7.0.0\\n+date-released: 2024\\n+url: \\\"https://github.com/seperman/deepdiff\\\"\\n\",\"diff --git a/deepdiff/__init__.py b/deepdiff/__init__.py\\nindex e15f3476..2f321a7f 100644\\n--- a/deepdiff/__init__.py\\n+++ b/deepdiff/__init__.py\\n@@ -1,6 +1,6 @@\\n \\\"\\\"\\\"This module offers the DeepDiff, DeepSearch, grep, Delta and DeepHash classes.\\\"\\\"\\\"\\n # flake8: noqa\\n-__version__ = '6.7.1'\\n+__version__ = '7.0.0'\\n import logging\\n \\n if __name__ == '__main__':\\n\",\"diff --git a/deepdiff/base.py b/deepdiff/base.py\\nindex 3c812e5c..3de7e9f3 100644\\n--- a/deepdiff/base.py\\n+++ b/deepdiff/base.py\\n@@ -44,7 +44,8 @@ def get_ignore_types_in_groups(self, ignore_type_in_groups,\\n         if ignore_numeric_type_changes and self.numbers not in ignore_type_in_groups:\\n             ignore_type_in_groups.append(OrderedSet(self.numbers))\\n \\n-        if ignore_type_subclasses:\\n+        if not ignore_type_subclasses:\\n+            # is_instance method needs tuples. When we look for subclasses, we need them to be tuples\\n             ignore_type_in_groups = list(map(tuple, ignore_type_in_groups))\\n \\n         return ignore_type_in_groups\\n\",\"diff --git a/deepdiff/distance.py b/deepdiff/distance.py\\nindex fb572d6b..731fa814 100644\\n--- a/deepdiff/distance.py\\n+++ b/deepdiff/distance.py\\n@@ -156,7 +156,7 @@ def _get_item_length(item, parents_ids=frozenset([])):\\n                 subitem = new_subitem\\n \\n             # internal keys such as _numpy_paths should not count towards the distance\\n-            if isinstance(key, strings) and (key.startswith('_') or key == 'deep_distance'):\\n+            if isinstance(key, strings) and (key.startswith('_') or key == 'deep_distance' or key == 'new_path'):\\n                 continue\\n \\n             item_id = id(subitem)\\n\",\"diff --git a/deepdiff/model.py b/deepdiff/model.py\\nindex 8fe9b444..f375fcde 100644\\n--- a/deepdiff/model.py\\n+++ b/deepdiff/model.py\\n@@ -152,9 +152,17 @@ def _from_tree_results(self, tree):\\n         self._from_tree_deep_distance(tree)\\n         self._from_tree_custom_results(tree)\\n \\n-    def _from_tree_default(self, tree, report_type):\\n+    def _from_tree_default(self, tree, report_type, ignore_if_in_iterable_opcodes=False):\\n         if report_type in tree:\\n+                \\n             for change in tree[report_type]:  # report each change\\n+                # When we convert from diff to delta result, we care more about opcodes than iterable_item_added or removed\\n+                if (\\n+                    ignore_if_in_iterable_opcodes\\n+                    and report_type in {\\\"iterable_item_added\\\", \\\"iterable_item_removed\\\"}\\n+                    and change.up.path(force=FORCE_DEFAULT) in self[\\\"_iterable_opcodes\\\"]\\n+                ):\\n+                    continue\\n                 # determine change direction (added or removed)\\n                 # Report t2 (the new one) whenever possible.\\n                 # In cases where t2 doesn't exist (i.e. stuff removed), report t1.\\n@@ -180,6 +188,7 @@ def _from_tree_default(self, tree, report_type):\\n     def _from_tree_type_changes(self, tree):\\n         if 'type_changes' in tree:\\n             for change in tree['type_changes']:\\n+                path = change.path(force=FORCE_DEFAULT)\\n                 if type(change.t1) is type:\\n                     include_values = False\\n                     old_type = change.t1\\n@@ -190,19 +199,26 @@ def _from_tree_type_changes(self, tree):\\n                     new_type = get_type(change.t2)\\n                 remap_dict = RemapDict({\\n                     'old_type': old_type,\\n-                    'new_type': new_type\\n+                    'new_type': new_type,\\n                 })\\n-                self['type_changes'][change.path(\\n-                    force=FORCE_DEFAULT)] = remap_dict\\n+                if self.verbose_level > 1:\\n+                    new_path = change.path(use_t2=True, force=FORCE_DEFAULT)\\n+                    if path != new_path:\\n+                        remap_dict['new_path'] = new_path\\n+                self['type_changes'][path] = remap_dict\\n                 if self.verbose_level and include_values:\\n                     remap_dict.update(old_value=change.t1, new_value=change.t2)\\n \\n     def _from_tree_value_changed(self, tree):\\n         if 'values_changed' in tree and self.verbose_level > 0:\\n             for change in tree['values_changed']:\\n+                path = change.path(force=FORCE_DEFAULT)\\n                 the_changed = {'new_value': change.t2, 'old_value': change.t1}\\n-                self['values_changed'][change.path(\\n-                    force=FORCE_DEFAULT)] = the_changed\\n+                if self.verbose_level > 1:\\n+                    new_path = change.path(use_t2=True, force=FORCE_DEFAULT)\\n+                    if path != new_path:\\n+                        the_changed['new_path'] = new_path\\n+                self['values_changed'][path] = the_changed\\n                 if 'diff' in change.additional:\\n                     the_changed.update({'diff': change.additional['diff']})\\n \\n@@ -279,7 +295,7 @@ def _from_tree_custom_results(self, tree):\\n class DeltaResult(TextResult):\\n     ADD_QUOTES_TO_STRINGS = False\\n \\n-    def __init__(self, tree_results=None, ignore_order=None, always_include_values=False):\\n+    def __init__(self, tree_results=None, ignore_order=None, always_include_values=False, _iterable_opcodes=None):\\n         self.ignore_order = ignore_order\\n         self.always_include_values = always_include_values\\n \\n@@ -297,6 +313,7 @@ def __init__(self, tree_results=None, ignore_order=None, always_include_values=F\\n             \\\"set_item_added\\\": dict_(),\\n             \\\"iterable_items_added_at_indexes\\\": dict_(),\\n             \\\"iterable_items_removed_at_indexes\\\": dict_(),\\n+            \\\"_iterable_opcodes\\\": _iterable_opcodes or {},\\n         })\\n \\n         if tree_results:\\n@@ -318,8 +335,8 @@ def _from_tree_results(self, tree):\\n             self._from_tree_iterable_item_added_or_removed(\\n                 tree, 'iterable_item_removed', delta_report_key='iterable_items_removed_at_indexes')\\n         else:\\n-            self._from_tree_default(tree, 'iterable_item_added')\\n-            self._from_tree_default(tree, 'iterable_item_removed')\\n+            self._from_tree_default(tree, 'iterable_item_added', ignore_if_in_iterable_opcodes=True)\\n+            self._from_tree_default(tree, 'iterable_item_removed', ignore_if_in_iterable_opcodes=True)\\n             self._from_tree_iterable_item_moved(tree)\\n         self._from_tree_default(tree, 'attribute_added')\\n         self._from_tree_default(tree, 'attribute_removed')\\n@@ -370,21 +387,27 @@ def _from_tree_type_changes(self, tree):\\n                     except Exception:\\n                         pass\\n \\n+                path = change.path(force=FORCE_DEFAULT)\\n+                new_path = change.path(use_t2=True, force=FORCE_DEFAULT)\\n                 remap_dict = RemapDict({\\n                     'old_type': old_type,\\n-                    'new_type': new_type\\n+                    'new_type': new_type,\\n                 })\\n-                self['type_changes'][change.path(\\n-                    force=FORCE_DEFAULT)] = remap_dict\\n+                if path != new_path:\\n+                    remap_dict['new_path'] = new_path\\n+                self['type_changes'][path] = remap_dict\\n                 if include_values or self.always_include_values:\\n                     remap_dict.update(old_value=change.t1, new_value=change.t2)\\n \\n     def _from_tree_value_changed(self, tree):\\n         if 'values_changed' in tree:\\n             for change in tree['values_changed']:\\n+                path = change.path(force=FORCE_DEFAULT)\\n+                new_path = change.path(use_t2=True, force=FORCE_DEFAULT)\\n                 the_changed = {'new_value': change.t2, 'old_value': change.t1}\\n-                self['values_changed'][change.path(\\n-                    force=FORCE_DEFAULT)] = the_changed\\n+                if path != new_path:\\n+                    the_changed['new_path'] = new_path\\n+                self['values_changed'][path] = the_changed\\n                 # If we ever want to store the difflib results instead of the new_value\\n                 # these lines need to be uncommented and the Delta object needs to be able\\n                 # to use them.\\n@@ -407,9 +430,12 @@ def _from_tree_repetition_change(self, tree):\\n     def _from_tree_iterable_item_moved(self, tree):\\n         if 'iterable_item_moved' in tree:\\n             for change in tree['iterable_item_moved']:\\n-                the_changed = {'new_path': change.path(use_t2=True), 'value': change.t2}\\n-                self['iterable_item_moved'][change.path(\\n-                    force=FORCE_DEFAULT)] = the_changed\\n+                if (\\n+                    change.up.path(force=FORCE_DEFAULT) not in self[\\\"_iterable_opcodes\\\"]\\n+                ):\\n+                    the_changed = {'new_path': change.path(use_t2=True), 'value': change.t2}\\n+                    self['iterable_item_moved'][change.path(\\n+                        force=FORCE_DEFAULT)] = the_changed\\n \\n \\n class DiffLevel:\\n@@ -693,8 +719,8 @@ def path(self, root=\\\"root\\\", force=None, get_parent_too=False, use_t2=False, outp\\n         # traverse all levels of this relationship\\n         while level and level is not self:\\n             # get this level's relationship object\\n-            if(use_t2):\\n-                next_rel = level.t2_child_rel\\n+            if use_t2:\\n+                next_rel = level.t2_child_rel or level.t1_child_rel\\n             else:\\n                 next_rel = level.t1_child_rel or level.t2_child_rel  # next relationship object to get a formatted param from\\n \\n\",\"diff --git a/deepdiff/serialization.py b/deepdiff/serialization.py\\nindex d2e85370..f13a33e7 100644\\n--- a/deepdiff/serialization.py\\n+++ b/deepdiff/serialization.py\\n@@ -45,7 +45,7 @@\\n from functools import partial\\n from collections.abc import Mapping\\n from deepdiff.helper import (\\n-    strings, get_type, TEXT_VIEW, np_float32, np_float64, np_int32, np_int64\\n+    strings, get_type, TEXT_VIEW, np_float32, np_float64, np_int32, np_int64, np_ndarray, Opcode, py_current_version\\n )\\n from deepdiff.model import DeltaResult\\n \\n@@ -96,6 +96,7 @@ class UnsupportedFormatErr(TypeError):\\n     'collections.namedtuple',\\n     'collections.OrderedDict',\\n     're.Pattern',\\n+    'deepdiff.helper.Opcode',\\n }\\n \\n \\n@@ -241,7 +242,29 @@ def _to_delta_dict(self, directed=True, report_repetition_required=True, always_\\n         if self.group_by is not None:\\n             raise ValueError(DELTA_ERROR_WHEN_GROUP_BY)\\n \\n-        result = DeltaResult(tree_results=self.tree, ignore_order=self.ignore_order, always_include_values=always_include_values)\\n+        if directed and not always_include_values:\\n+            _iterable_opcodes = {}\\n+            for path, op_codes in self._iterable_opcodes.items():\\n+                _iterable_opcodes[path] = []\\n+                for op_code in op_codes:\\n+                    new_op_code = Opcode(\\n+                        tag=op_code.tag,\\n+                        t1_from_index=op_code.t1_from_index,\\n+                        t1_to_index=op_code.t1_to_index,\\n+                        t2_from_index=op_code.t2_from_index,\\n+                        t2_to_index=op_code.t2_to_index,\\n+                        new_values=op_code.new_values,\\n+                    )\\n+                    _iterable_opcodes[path].append(new_op_code)\\n+        else:\\n+            _iterable_opcodes = self._iterable_opcodes\\n+\\n+        result = DeltaResult(\\n+            tree_results=self.tree,\\n+            ignore_order=self.ignore_order,\\n+            always_include_values=always_include_values,\\n+            _iterable_opcodes=_iterable_opcodes,\\n+        )\\n         result.remove_empty_keys()\\n         if report_repetition_required and self.ignore_order and not self.report_repetition:\\n             raise ValueError(DELTA_IGNORE_ORDER_NEEDS_REPETITION_REPORT)\\n@@ -537,6 +560,12 @@ def _serialize_decimal(value):\\n         return float(value)\\n \\n \\n+def _serialize_tuple(value):\\n+    if hasattr(value, '_asdict'):  # namedtuple\\n+        return value._asdict()\\n+    return value\\n+\\n+\\n JSON_CONVERTOR = {\\n     decimal.Decimal: _serialize_decimal,\\n     ordered_set.OrderedSet: list,\\n@@ -548,7 +577,10 @@ def _serialize_decimal(value):\\n     np_float32: float,\\n     np_float64: float,\\n     np_int32: int,\\n-    np_int64: int\\n+    np_int64: int,\\n+    np_ndarray: lambda x: x.tolist(),\\n+    tuple: _serialize_tuple,\\n+    Mapping: dict,\\n }\\n \\n if PydanticBaseModel:\\n\",\"diff --git a/docs/conf.py b/docs/conf.py\\nindex 03fcdf5d..d971afe5 100644\\n--- a/docs/conf.py\\n+++ b/docs/conf.py\\n@@ -61,9 +61,9 @@\\n # built documents.\\n #\\n # The short X.Y version.\\n-version = '6.7.1'\\n+version = '7.0.0'\\n # The full version, including alpha/beta/rc tags.\\n-release = '6.7.1'\\n+release = '7.0.0'\\n \\n load_dotenv(override=True)\\n DOC_VERSION = os.environ.get('DOC_VERSION', version)\\n\",\"diff --git a/docs/delta.rst b/docs/delta.rst\\nindex 751dfba3..fed718c5 100644\\n--- a/docs/delta.rst\\n+++ b/docs/delta.rst\\n@@ -181,6 +181,13 @@ Flat Dict List\\n \\n You can create a delta object from the list of flat dictionaries that are produced via :ref:`to_flat_dicts_label`. Read more on :ref:`delta_from_flat_dicts_label`.\\n \\n+.. _flat_rows_list_label:\\n+\\n+Flat Rows List\\n+--------------\\n+\\n+You can create a delta object from the list of flat dictionaries that are produced via :ref:`to_flat_rows_label`. Read more on :ref:`delta_from_flat_rows_label`.\\n+\\n \\n .. _delta_deserializer_label:\\n \\n\",\"diff --git a/docs/diff_doc.rst b/docs/diff_doc.rst\\nindex 106dd023..9c33d822 100644\\n--- a/docs/diff_doc.rst\\n+++ b/docs/diff_doc.rst\\n@@ -114,6 +114,10 @@ ignore_type_subclasses: Boolean, default = False\\n     :ref:`ignore_type_subclasses_label`\\n     ignore type (class) changes when dealing with the subclasses of classes that were marked to be ignored.\\n \\n+.. Note::\\n+    ignore_type_subclasses was incorrectly doing the reverse of its job up until DeepDiff 6.7.1\\n+    Please make sure to flip it in your use cases, when upgrading from older versions to 7.0.0 or above.\\n+\\n ignore_string_case: Boolean, default = False\\n     :ref:`ignore_string_case_label`\\n     Whether to be case-sensitive or not when comparing strings. By settings ignore_string_case=False, strings will be compared case-insensitively.\\n\",\"diff --git a/docs/ignore_types_or_values.rst b/docs/ignore_types_or_values.rst\\nindex 7d55b9cb..105ec1ac 100644\\n--- a/docs/ignore_types_or_values.rst\\n+++ b/docs/ignore_types_or_values.rst\\n@@ -108,6 +108,19 @@ ignore_type_in_groups: Tuple or List of Tuples, default = None\\n     2. or ignore_type_in_groups=[(str, bytes), (typeA, typeB)]\\n \\n \\n+Example: Ignore Enum to string comparison\\n+    >>> from deepdiff import DeepDiff\\n+    >>> from enum import Enum\\n+    >>> class MyEnum1(Enum):\\n+    ...     book = \\\"book\\\"\\n+    ...     cake = \\\"cake\\\"\\n+    ...\\n+    >>> DeepDiff(\\\"book\\\", MyEnum1.book)\\n+    {'type_changes': {'root': {'old_type': <class 'str'>, 'new_type': <enum 'MyEnum1'>, 'old_value': 'book', 'new_value': <MyEnum1.book: 'book'>}}}\\n+    >>> DeepDiff(\\\"book\\\", MyEnum1.book, ignore_type_in_groups=[(Enum, str)])\\n+    {}\\n+\\n+\\n Example: Ignore Type Number - Dictionary that contains float and integer. Note that this is exactly the same as passing ignore_numeric_type_changes=True.\\n     >>> from deepdiff import DeepDiff\\n     >>> from pprint import pprint\\n@@ -201,6 +214,10 @@ Ignore Type Subclasses\\n ignore_type_subclasses: Boolean, default = False\\n     Use ignore_type_subclasses=True so when ignoring type (class), the subclasses of that class are ignored too.\\n \\n+.. Note::\\n+    ignore_type_subclasses was incorrectly doing the reverse of its job up until DeepDiff 6.7.1\\n+    Please make sure to flip it in your use cases, when upgrading from older versions to 7.0.0 or above.\\n+\\n     >>> from deepdiff import DeepDiff\\n     >>> class ClassA:\\n     ...     def __init__(self, x, y):\\n@@ -217,10 +234,10 @@ ignore_type_subclasses: Boolean, default = False\\n     >>> obj_a = ClassA(1, 2)\\n     >>> obj_c = ClassC(3)\\n     >>>\\n-    >>> DeepDiff(obj_a, obj_c, ignore_type_in_groups=[(ClassA, ClassB)], ignore_type_subclasses=False)\\n+    >>> DeepDiff(obj_a, obj_c, ignore_type_in_groups=[(ClassA, ClassB)], ignore_type_subclasses=True)\\n     {'type_changes': {'root': {'old_type': <class '__main__.ClassA'>, 'new_type': <class '__main__.ClassC'>, 'old_value': <__main__.ClassA object at 0x10076a2e8>, 'new_value': <__main__.ClassC object at 0x10082f630>}}}\\n     >>>\\n-    >>> DeepDiff(obj_a, obj_c, ignore_type_in_groups=[(ClassA, ClassB)], ignore_type_subclasses=True)\\n+    >>> DeepDiff(obj_a, obj_c, ignore_type_in_groups=[(ClassA, ClassB)], ignore_type_subclasses=False)\\n     {'values_changed': {'root.x': {'new_value': 3, 'old_value': 1}}, 'attribute_removed': [root.y]}\\n \\n \\n\",\"diff --git a/docs/index.rst b/docs/index.rst\\nindex b337d0c6..e520c144 100644\\n--- a/docs/index.rst\\n+++ b/docs/index.rst\\n@@ -4,7 +4,7 @@\\n    contain the root `toctree` directive.\\n \\n \\n-DeepDiff 6.7.1 documentation!\\n+DeepDiff 7.0.0 documentation!\\n =============================\\n \\n *******\\n\",\"diff --git a/docs/serialization.rst b/docs/serialization.rst\\nindex 2ed67a4a..0f63428a 100644\\n--- a/docs/serialization.rst\\n+++ b/docs/serialization.rst\\n@@ -106,6 +106,98 @@ Load the diff object from the json pickle dump.\\n Take a look at the above :ref:`to_json_pickle_label` for an example.\\n \\n \\n+.. _delta_to_flat_rows_label:\\n+\\n+Delta Serialize To Flat Rows\\n+----------------------------\\n+\\n+Sometimes, it is desired to serialize a :ref:`delta_label` object to a list of flat rows. For example, to store them in relation databases. In that case, you can use the Delta.to_flat_rows to achieve the desired outcome. The rows are named tuples and can be converted to dictionaries using `._asdict()`\\n+\\n+    >>> from pprint import pprint\\n+    >>> from deepdiff import DeepDiff, Delta\\n+    >>> t1 = {\\\"key1\\\": \\\"value1\\\"}\\n+    >>> t2 = {\\\"field2\\\": {\\\"key2\\\": \\\"value2\\\"}}\\n+    >>> diff = DeepDiff(t1, t2, verbose_level=2)\\n+    >>> pprint(diff, indent=2)\\n+    { 'dictionary_item_added': {\\\"root['field2']\\\": {'key2': 'value2'}},\\n+      'dictionary_item_removed': {\\\"root['key1']\\\": 'value1'}}\\n+    >>> delta = Delta(diff, bidirectional=True)\\n+    >>> flat_rows = delta.to_flat_rows()\\n+    >>> pprint(flat_rows, indent=2)\\n+    [ FlatDeltaRow(path=['field2', 'key2'], action='dictionary_item_added', value='value2'),\\n+      FlatDeltaRow(path=['key1'], action='dictionary_item_removed', value='value1')]\\n+\\n+.. note::\\n+    When converting a delta to flat rows, nested dictionaries that have single keys in them are flattened too.\\n+    Notice that the diff object says\\n+\\n+        { 'dictionary_item_added': {\\\"root['field2']\\\": {'key2': 'value2'}}\\n+\\n+    but the flat row is:\\n+\\n+        FlatDeltaRow(path=['field2', 'key2'], action='dictionary_item_added', value='value2')\\n+\\n+    That means, when you recreate the delta from the flat rows, you need to set force=True to apply the delta:\\n+\\n+        >>> t1 + delta == t2\\n+        True\\n+        >>> t2 - delta == t1\\n+        True\\n+        >>> delta2 = Delta(flat_rows_list=flat_rows, bidirectional=True)\\n+        >>> t1 + delta2 == t2\\n+        Expected the old value for root['field2']['key2'] to be None but it is not found. Error found on: 'field2'\\n+        False. You may want to set force=True, especially if this delta is created by passing flat_rows_list or flat_dict_list\\n+        >>> t1 + delta\\n+        {'field2': {'key2': 'value2'}}\\n+        >>> t1 + delta2\\n+        {}\\n+        >>> delta2 = Delta(flat_rows_list=flat_rows, bidirectional=True, force=True)  # We need to set force=True\\n+        >>> t1 + delta2\\n+        {'field2': {'key2': 'value2'}}\\n+        >>>\\n+\\n+\\n+\\n+Flat Row Specs:\\n+\\n+\\n+    class FlatDataAction(str, enum.Enum):\\n+        values_changed = 'values_changed'\\n+        type_changes = 'type_changes'\\n+        set_item_added = 'set_item_added'\\n+        set_item_removed = 'set_item_removed'\\n+        dictionary_item_added = 'dictionary_item_added'\\n+        dictionary_item_removed = 'dictionary_item_removed'\\n+        iterable_item_added = 'iterable_item_added'\\n+        iterable_item_removed = 'iterable_item_removed'\\n+        iterable_item_moved = 'iterable_item_moved'\\n+        iterable_items_inserted = 'iterable_items_inserted'  # opcode\\n+        iterable_items_deleted = 'iterable_items_deleted'  # opcode\\n+        iterable_items_replaced = 'iterable_items_replaced'  # opcode\\n+        iterable_items_equal = 'iterable_items_equal'  # opcode\\n+        attribute_removed = 'attribute_removed'\\n+        attribute_added = 'attribute_added'\\n+        unordered_iterable_item_added = 'unordered_iterable_item_added'\\n+        unordered_iterable_item_removed = 'unordered_iterable_item_removed'\\n+\\n+\\n+    UnkownValueCode = '*-UNKNOWN-*'\\n+\\n+\\n+    class FlatDeltaRow(NamedTuple):\\n+        path: List\\n+        action: FlatDataAction\\n+        value: Optional[Any] = UnkownValueCode\\n+        old_value: Optional[Any] = UnkownValueCode\\n+        type: Optional[Any] = UnkownValueCode\\n+        old_type: Optional[Any] = UnkownValueCode\\n+        new_path: Optional[List] = None\\n+        t1_from_index: Optional[int] = None\\n+        t1_to_index: Optional[int] = None\\n+        t2_from_index: Optional[int] = None\\n+        t2_to_index: Optional[int] = None\\n+\\n+\\n .. _delta_to_flat_dicts_label:\\n \\n Delta Serialize To Flat Dictionaries\\n@@ -113,6 +205,12 @@ Delta Serialize To Flat Dictionaries\\n \\n Sometimes, it is desired to serialize a :ref:`delta_label` object to a list of flat dictionaries. For example, to store them in relation databases. In that case, you can use the Delta.to_flat_dicts to achieve the desired outcome.\\n \\n+Since None is a valid value, we use a special hard-coded string to signify \\\"unkown\\\": '*-UNKNOWN-*'\\n+\\n+.. note::\\n+    Many new keys are added to the flat dicts in DeepDiff 7.0.0\\n+    You may want to use :ref:`delta_to_flat_rows_label` instead of flat dicts.\\n+\\n For example:\\n \\n     >>> from pprint import pprint\\n@@ -123,14 +221,31 @@ For example:\\n     >>> pprint(diff, indent=2)\\n     { 'dictionary_item_added': {\\\"root['field2']\\\": {'key2': 'value2'}},\\n       'dictionary_item_removed': {\\\"root['key1']\\\": 'value1'}}\\n-    >>>\\n-    >>> delta = Delta(diff, verify_symmetry=True)\\n+    >>> delta = Delta(diff, bidirectional=True)\\n     >>> flat_dicts = delta.to_flat_dicts()\\n     >>> pprint(flat_dicts, indent=2)\\n     [ { 'action': 'dictionary_item_added',\\n+        'new_path': None,\\n+        'old_type': '*-UNKNOWN-*',\\n+        'old_value': '*-UNKNOWN-*',\\n         'path': ['field2', 'key2'],\\n+        't1_from_index': None,\\n+        't1_to_index': None,\\n+        't2_from_index': None,\\n+        't2_to_index': None,\\n+        'type': '*-UNKNOWN-*',\\n         'value': 'value2'},\\n-      {'action': 'dictionary_item_removed', 'path': ['key1'], 'value': 'value1'}]\\n+      { 'action': 'dictionary_item_removed',\\n+        'new_path': None,\\n+        'old_type': '*-UNKNOWN-*',\\n+        'old_value': '*-UNKNOWN-*',\\n+        'path': ['key1'],\\n+        't1_from_index': None,\\n+        't1_to_index': None,\\n+        't2_from_index': None,\\n+        't2_to_index': None,\\n+        'type': '*-UNKNOWN-*',\\n+        'value': 'value1'}]\\n \\n \\n Example 2:\\n@@ -141,11 +256,31 @@ Example 2:\\n     >>> pprint(diff, indent=2)\\n     {'iterable_item_added': {'root[2]': 'C', 'root[3]': 'D'}}\\n     >>>\\n-    >>> delta = Delta(diff, verify_symmetry=True)\\n+    >>> delta = Delta(diff, bidirectional=True)\\n     >>> flat_dicts = delta.to_flat_dicts()\\n     >>> pprint(flat_dicts, indent=2)\\n-    [ {'action': 'iterable_item_added', 'path': [2], 'value': 'C'},\\n-      {'action': 'iterable_item_added', 'path': [3], 'value': 'D'}]\\n+    [ { 'action': 'iterable_item_added',\\n+        'new_path': None,\\n+        'old_type': '*-UNKNOWN-*',\\n+        'old_value': '*-UNKNOWN-*',\\n+        'path': [2],\\n+        't1_from_index': None,\\n+        't1_to_index': None,\\n+        't2_from_index': None,\\n+        't2_to_index': None,\\n+        'type': '*-UNKNOWN-*',\\n+        'value': 'C'},\\n+      { 'action': 'iterable_item_added',\\n+        'new_path': None,\\n+        'old_type': '*-UNKNOWN-*',\\n+        'old_value': '*-UNKNOWN-*',\\n+        'path': [3],\\n+        't1_from_index': None,\\n+        't1_to_index': None,\\n+        't2_from_index': None,\\n+        't2_to_index': None,\\n+        'type': '*-UNKNOWN-*',\\n+        'value': 'D'}]\\n \\n \\n .. _delta_from_flat_dicts_label:\\n@@ -157,8 +292,7 @@ Delta Load From Flat Dictionaries\\n     >>> t3 = [\\\"A\\\", \\\"B\\\"]\\n     >>> t4 = [\\\"A\\\", \\\"B\\\", \\\"C\\\", \\\"D\\\"]\\n     >>> diff = DeepDiff(t3, t4, verbose_level=2)\\n-    >>> delta = Delta(diff, verify_symmetry=True)\\n-    DeepDiff Deprecation: use bidirectional instead of verify_symmetry parameter.\\n+    >>> delta = Delta(diff, bidirectional=True)\\n     >>> flat_dicts = delta.to_flat_dicts()\\n     >>>\\n     >>> delta2 = Delta(flat_dict_list=flat_dicts)\\n\",\"diff --git a/requirements-cli.txt b/requirements-cli.txt\\nindex f487dc50..0ba0c7e6 100644\\n--- a/requirements-cli.txt\\n+++ b/requirements-cli.txt\\n@@ -1,2 +1,2 @@\\n-click==8.1.3\\n+click==8.1.7\\n pyyaml==6.0.1\\n\",\"diff --git a/requirements.txt b/requirements.txt\\nindex c8de6a12..6bfbf09f 100644\\n--- a/requirements.txt\\n+++ b/requirements.txt\\n@@ -1 +1 @@\\n-ordered-set>=4.0.2,<4.2.0\\n+ordered-set>=4.1.0,<4.2.0\\n\",\"diff --git a/setup.cfg b/setup.cfg\\nindex 5630d3ad..518ad74b 100644\\n--- a/setup.cfg\\n+++ b/setup.cfg\\n@@ -1,5 +1,5 @@\\n [bumpversion]\\n-current_version = 6.7.1\\n+current_version = 7.0.0\\n commit = True\\n tag = True\\n tag_name = {new_version}\\n@@ -15,6 +15,8 @@ exclude = ./data,./src,.svn,CVS,.bzr,.hg,.git,__pycache__\\n \\n [bumpversion:file:README.md]\\n \\n+[bumpversion:file:CITATION.cff]\\n+\\n [bumpversion:file:docs/index.rst]\\n \\n [bumpversion:file:docs/conf.py]\\n\",\"diff --git a/setup.py b/setup.py\\nindex 2660a668..dd90d576 100755\\n--- a/setup.py\\n+++ b/setup.py\\n@@ -10,7 +10,7 @@\\n if os.environ.get('USER', '') == 'vagrant':\\n     del os.link\\n \\n-version = '6.7.1'\\n+version = '7.0.0'\\n \\n \\n def get_reqs(filename):\\n@@ -43,7 +43,7 @@ def get_reqs(filename):\\n       long_description=long_description,\\n       long_description_content_type='text/markdown',\\n       install_requires=reqs,\\n-      python_requires='>=3.7',\\n+      python_requires='>=3.8',\\n       extras_require={\\n           \\\"cli\\\": cli_reqs,\\n           \\\"optimize\\\": optimize_reqs,\\n@@ -52,11 +52,11 @@ def get_reqs(filename):\\n           \\\"Intended Audience :: Developers\\\",\\n           \\\"Operating System :: OS Independent\\\",\\n           \\\"Topic :: Software Development\\\",\\n-          \\\"Programming Language :: Python :: 3.7\\\",\\n           \\\"Programming Language :: Python :: 3.8\\\",\\n           \\\"Programming Language :: Python :: 3.9\\\",\\n           \\\"Programming Language :: Python :: 3.10\\\",\\n           \\\"Programming Language :: Python :: 3.11\\\",\\n+          \\\"Programming Language :: Python :: 3.12\\\",\\n           \\\"Programming Language :: Python :: Implementation :: PyPy\\\",\\n           \\\"Development Status :: 5 - Production/Stable\\\",\\n           \\\"License :: OSI Approved :: MIT License\\\"\\n\"]", "test_patch": "", "hints_text": ""}

{"instance_id": "1465953211411294", "repo": "pyscaffold/configupdater", "base_commit": "43ddeeace488db59907442cea10cfaf0bd7f0328", "problem_statement": "Allowing sections/options to be copied from one document to the other:\\nRight now it is not possible to simply copy a section or option object from one container to another.\\r\\nWhen we try to add the copied object to the other container a `AlreadyAttechedError` is raised.\\r\\n\\r\\nThis is a symptom of the fact that every block contains a reference to their containers and when they are copied, the copy reference keeps pointing to the previous container.\\r\\n\\r\\nI think copies should always be created in a \"detached\" mode, i.e., the reference to the parent container should be `None`.\\r\\nTo solve this problem we also have to rely on `deepcopy`, because when copying a section, the references inside its options should also be clear (in my understanding it makes very little sense to implement shallow copies in ConfigUpdater).\\r\\n", "FAIL_TO_PASS": ["tests/test_section.py::test_deepcopy", "tests/test_section.py::test_clear_error_message", "tests/test_option.py::test_deepcopy", "tests/test_configupdater.py::test_transfering_sections_and_manipulating_options_with_deepcopy", "tests/test_configupdater.py::test_set_option", "tests/test_configupdater.py::test_setitem_detached_option"], "PASS_TO_PASS": ["tests/test_configupdater.py::test_del_option", "tests/test_configupdater.py::test_add_before_then_add_after_option", "tests/test_configupdater.py::test_inline_comments", "tests/test_configupdater.py::test_no_space_around_delim", "tests/test_configupdater.py::test_comments_in_multiline_options", "tests/test_configupdater.py::test_add_before_after_option", "tests/test_configupdater.py::test_assure_no_duplicate_options", "tests/test_configupdater.py::test_section_comment", "tests/test_configupdater.py::test_get_section", "tests/test_configupdater.py::test_read_file_like", "tests/test_configupdater.py::test_update_mixed_case_options", "tests/test_configupdater.py::test_has_section", "tests/test_configupdater.py::test_read_mixed_case_options", "tests/test_configupdater.py::test_iter_items_section", "tests/test_configupdater.py::test_len_updater", "tests/test_configupdater.py::test_transferring_blocks_between_elements", "tests/test_configupdater.py::test_update_no_changes", "tests/test_configupdater.py::test_indented_comment", "tests/test_configupdater.py::test_constructor", "tests/test_configupdater.py::test_add_detached_section_option_objects", "tests/test_configupdater.py::test_handle_error", "tests/test_configupdater.py::test_reade_write_no_changes", "tests/test_configupdater.py::test_add_section", "tests/test_configupdater.py::test_missing_section_error", "tests/test_configupdater.py::test_contains_section", "tests/test_configupdater.py::test_get_method", "tests/test_configupdater.py::test_has_option", "tests/test_configupdater.py::test_empty_lines_in_values_support", "tests/test_configupdater.py::test_get_options", "tests/test_configupdater.py::test_rename_option_key", "tests/test_configupdater.py::test_duplicate_section_error", "tests/test_configupdater.py::test_read_file_with_string", "tests/test_configupdater.py::test_validate_format", "tests/test_configupdater.py::test_transfering_sections_and_manipulating_options", "tests/test_configupdater.py::test_del_section", "tests/test_configupdater.py::test_str", "tests/test_configupdater.py::test_eq", "tests/test_configupdater.py::test_set_item_section", "tests/test_configupdater.py::test_sections", "tests/test_configupdater.py::test_update_no_cfg", "tests/test_configupdater.py::test_value_change", "tests/test_configupdater.py::test_iter_section", "tests/test_configupdater.py::test_contains_options", "tests/test_configupdater.py::test_iter_option", "tests/test_configupdater.py::test_remove_option", "tests/test_configupdater.py::test_set_optionxform", "tests/test_configupdater.py::test_len_section", "tests/test_configupdater.py::test_add_before_after_space", "tests/test_configupdater.py::test_add_before_after_comment", "tests/test_configupdater.py::test_navigation_and_remove", "tests/test_configupdater.py::test_add_before_after_section", "tests/test_configupdater.py::test_duplicate_option_error", "tests/test_configupdater.py::test_get_option", "tests/test_configupdater.py::test_no_value", "tests/test_configupdater.py::test_items", "tests/test_configupdater.py::test_insert_at", "tests/test_configupdater.py::test_section_set_option", "tests/test_configupdater.py::test_no_duplicate_blocks_with_blockbuilder", "tests/test_configupdater.py::test_len_option", "tests/test_configupdater.py::test_iter_consistency_with_configparser", "tests/test_configupdater.py::test_updater_to_dict", "tests/test_configupdater.py::test_section_to_dict"], "language": "python", "test_command": "source /saved/ENV || source /saved/*/ENV && tox -- --no-header -rA --tb=no -p no:cacheprovider --continue-on-collection-errors", "test_output_parser": "python/parse_log_pytest_v3", "image_storage_uri": "vmvm-registry.fbinfra.net/repomate_image_activ_pytest/pyscaffold_configupdater:43ddeeace488db59907442cea10cfaf0bd7f0328", "patch": "[\"diff --git a/src/configupdater/section.py b/src/configupdater/section.py\\nindex 2f5ddd4..7c87f41 100644\\n--- a/src/configupdater/section.py\\n+++ b/src/configupdater/section.py\\n@@ -121,15 +121,20 @@ def __str__(self) -> str:\\n     def __repr__(self) -> str:\\n         return f\\\"<Section: {self.name!r} {super()._repr_blocks()}>\\\"\\n \\n+    def optionxform(self, optionstr: str) -> str:\\n+        if self.has_container():\\n+            return self.document.optionxform(optionstr)\\n+        return optionstr.lower()\\n+\\n     def __getitem__(self, key: str) -> \\\"Option\\\":\\n-        key = self.document.optionxform(key)\\n+        key = self.optionxform(key)\\n         try:\\n             return next(o for o in self.iter_options() if o.key == key)\\n         except StopIteration as ex:\\n             raise KeyError(f\\\"No option `{key}` found\\\", {\\\"key\\\": key}) from ex\\n \\n     def __setitem__(self, key: str, value: Optional[Value] = None):\\n-        if self.document.optionxform(key) in self:\\n+        if self.optionxform(key) in self:\\n             if isinstance(value, Option):\\n                 if value.key != key:\\n                     raise ValueError(\\n@@ -241,7 +246,7 @@ def set(self: S, option: str, value: Optional[str] = None) -> S:\\n             option (str): option name\\n             value (str): value, default None\\n         \\\"\\\"\\\"\\n-        option = self.document.optionxform(option)\\n+        option = self.optionxform(option)\\n         if option in self.options():\\n             self.__getitem__(option).value = value\\n         else:\\n\",\"diff --git a/src/configupdater/option.py b/src/configupdater/option.py\\nindex 932c65d..b3fcdac 100644\\n--- a/src/configupdater/option.py\\n+++ b/src/configupdater/option.py\\n@@ -95,10 +95,15 @@ def __str__(self) -> str:\\n     def __repr__(self) -> str:\\n         return f\\\"<Option: {self._key} = {self.value!r}>\\\"\\n \\n+    def optionxform(self, optionstr: str) -> str:\\n+        if self.has_container():\\n+            section = cast(\\\"Section\\\", self.container)\\n+            return section.optionxform(optionstr)\\n+        return optionstr.lower()\\n+\\n     @property\\n     def key(self) -> str:\\n-        section = cast(\\\"Section\\\", self.container)\\n-        return section.document.optionxform(self._key)\\n+        return self.optionxform(self._key)\\n \\n     @key.setter\\n     def key(self, value: str):\\n\",\"diff --git a/src/configupdater/block.py b/src/configupdater/block.py\\nindex bbfca0d..2afd2b2 100644\\n--- a/src/configupdater/block.py\\n+++ b/src/configupdater/block.py\\n@@ -6,6 +6,7 @@\\n \\\"\\\"\\\"\\n import sys\\n from abc import ABC\\n+from copy import deepcopy\\n from typing import TYPE_CHECKING, Optional, TypeVar\\n \\n if sys.version_info[:2] >= (3, 9):  # pragma: no cover\\n@@ -62,6 +63,18 @@ def __eq__(self, other) -> bool:\\n         else:\\n             return False\\n \\n+    def __deepcopy__(self: B, memo: dict) -> B:\\n+        clone = self._intantiate_copy()\\n+        clone._lines = deepcopy(self._lines, memo)\\n+        clone._updated = self._updated\\n+        memo[id(self)] = clone\\n+        return clone\\n+\\n+    def _intantiate_copy(self: B) -> B:\\n+        \\\"\\\"\\\"Auxiliary method that allows subclasses calling ``__deepcopy__``\\\"\\\"\\\"\\n+        return self.__class__(container=None)  # allow overwrite for different init args\\n+        # ^  A fresh copy should always be made detached from any container\\n+\\n     def add_line(self: B, line: str) -> B:\\n         \\\"\\\"\\\"PRIVATE: this function is not part of the public API of Block.\\n         It is only used internally by other classes of the package during parsing.\\n\",\"diff --git a/src/configupdater/option.py b/src/configupdater/option.py\\nindex b3fcdac..481b1bd 100644\\n--- a/src/configupdater/option.py\\n+++ b/src/configupdater/option.py\\n@@ -11,7 +11,7 @@\\n :meth:`~Option.set_values` method.\\n \\\"\\\"\\\"\\n import sys\\n-from typing import TYPE_CHECKING, Optional, Union, cast\\n+from typing import TYPE_CHECKING, Optional, TypeVar, Union, cast\\n \\n if sys.version_info[:2] >= (3, 9):  # pragma: no cover\\n     List = list\\n@@ -25,6 +25,7 @@\\n from .block import Block\\n \\n Value = Union[\\\"Option\\\", str]\\n+T = TypeVar(\\\"T\\\", bound=\\\"Option\\\")\\n \\n \\n class Option(Block):\\n@@ -95,6 +96,17 @@ def __str__(self) -> str:\\n     def __repr__(self) -> str:\\n         return f\\\"<Option: {self._key} = {self.value!r}>\\\"\\n \\n+    def _intantiate_copy(self: T) -> T:\\n+        \\\"\\\"\\\"Will be called by :meth:`Block.__deepcopy__`\\\"\\\"\\\"\\n+        self._join_multiline_value()\\n+        return self.__class__(\\n+            self._key,\\n+            self._value,\\n+            container=None,\\n+            delimiter=self._delimiter,\\n+            space_around_delimiters=self._space_around_delimiters,\\n+        )\\n+\\n     def optionxform(self, optionstr: str) -> str:\\n         if self.has_container():\\n             section = cast(\\\"Section\\\", self.container)\\n\",\"diff --git a/src/configupdater/block.py b/src/configupdater/block.py\\nindex 2afd2b2..69cf8a1 100644\\n--- a/src/configupdater/block.py\\n+++ b/src/configupdater/block.py\\n@@ -64,13 +64,13 @@ def __eq__(self, other) -> bool:\\n             return False\\n \\n     def __deepcopy__(self: B, memo: dict) -> B:\\n-        clone = self._intantiate_copy()\\n+        clone = self._instantiate_copy()\\n         clone._lines = deepcopy(self._lines, memo)\\n         clone._updated = self._updated\\n         memo[id(self)] = clone\\n         return clone\\n \\n-    def _intantiate_copy(self: B) -> B:\\n+    def _instantiate_copy(self: B) -> B:\\n         \\\"\\\"\\\"Auxiliary method that allows subclasses calling ``__deepcopy__``\\\"\\\"\\\"\\n         return self.__class__(container=None)  # allow overwrite for different init args\\n         # ^  A fresh copy should always be made detached from any container\\n\",\"diff --git a/src/configupdater/option.py b/src/configupdater/option.py\\nindex 481b1bd..9e17e91 100644\\n--- a/src/configupdater/option.py\\n+++ b/src/configupdater/option.py\\n@@ -96,7 +96,7 @@ def __str__(self) -> str:\\n     def __repr__(self) -> str:\\n         return f\\\"<Option: {self._key} = {self.value!r}>\\\"\\n \\n-    def _intantiate_copy(self: T) -> T:\\n+    def _instantiate_copy(self: T) -> T:\\n         \\\"\\\"\\\"Will be called by :meth:`Block.__deepcopy__`\\\"\\\"\\\"\\n         self._join_multiline_value()\\n         return self.__class__(\\n\",\"diff --git a/src/configupdater/container.py b/src/configupdater/container.py\\nindex c753914..406485a 100644\\n--- a/src/configupdater/container.py\\n+++ b/src/configupdater/container.py\\n@@ -6,8 +6,9 @@\\n \\\"\\\"\\\"\\n import sys\\n from abc import ABC\\n+from copy import deepcopy\\n from textwrap import indent\\n-from typing import Generic, Optional, TypeVar\\n+from typing import TYPE_CHECKING, Generic, Optional, TypeVar\\n \\n if sys.version_info[:2] >= (3, 9):  # pragma: no cover\\n     from collections.abc import Iterator\\n@@ -16,7 +17,10 @@\\n else:  # pragma: no cover\\n     from typing import Iterator, List\\n \\n-T = TypeVar(\\\"T\\\")\\n+if TYPE_CHECKING:\\n+    from .block import Block  # noqa\\n+\\n+T = TypeVar(\\\"T\\\", bound=\\\"Block\\\")\\n C = TypeVar(\\\"C\\\", bound=\\\"Container\\\")\\n \\n \\n@@ -34,6 +38,19 @@ def _repr_blocks(self) -> str:\\n     def __repr__(self) -> str:\\n         return f\\\"<{self.__class__.__name__} {self._repr_blocks()}>\\\"\\n \\n+    def __deepcopy__(self: C, memo: dict) -> C:\\n+        copy = self._intantiate_copy()\\n+        return copy._copy_structure(self._structure, memo)\\n+\\n+    def _copy_structure(self: C, structure: List[T], memo: dict) -> C:\\n+        \\\"\\\"\\\"``__deepcopy__`` auxiliary method also useful with multi-inheritance\\\"\\\"\\\"\\n+        self._structure = [b.attach(self) for b in deepcopy(structure, memo)]\\n+        return self\\n+\\n+    def _intantiate_copy(self: C) -> C:\\n+        \\\"\\\"\\\"Auxiliary method that allows subclasses calling ``__deepcopy__``\\\"\\\"\\\"\\n+        return self.__class__()  # allow overwrite for different init args\\n+\\n     @property\\n     def structure(self) -> List[T]:\\n         return self._structure\\n\",\"diff --git a/src/configupdater/section.py b/src/configupdater/section.py\\nindex 7c87f41..ab0b84c 100644\\n--- a/src/configupdater/section.py\\n+++ b/src/configupdater/section.py\\n@@ -121,6 +121,17 @@ def __str__(self) -> str:\\n     def __repr__(self) -> str:\\n         return f\\\"<Section: {self.name!r} {super()._repr_blocks()}>\\\"\\n \\n+    def _intantiate_copy(self: S) -> S:\\n+        \\\"\\\"\\\"Will be called by :meth:`Block.__deepcopy__`\\\"\\\"\\\"\\n+        clone = self.__class__(self._name, container=None)\\n+        # ^  A fresh copy should always be made detached from any container\\n+        clone._raw_comment = self._raw_comment\\n+        return clone\\n+\\n+    def __deepcopy__(self: S, memo: dict) -> S:\\n+        clone = Block.__deepcopy__(self, memo)  # specific due to multi-inheritance\\n+        return clone._copy_structure(self._structure, memo)\\n+\\n     def optionxform(self, optionstr: str) -> str:\\n         if self.has_container():\\n             return self.document.optionxform(optionstr)\\n\",\"diff --git a/src/configupdater/container.py b/src/configupdater/container.py\\nindex 406485a..1bc3416 100644\\n--- a/src/configupdater/container.py\\n+++ b/src/configupdater/container.py\\n@@ -39,8 +39,9 @@ def __repr__(self) -> str:\\n         return f\\\"<{self.__class__.__name__} {self._repr_blocks()}>\\\"\\n \\n     def __deepcopy__(self: C, memo: dict) -> C:\\n-        copy = self._intantiate_copy()\\n-        return copy._copy_structure(self._structure, memo)\\n+        clone = self._intantiate_copy()\\n+        memo[id(self)] = clone\\n+        return clone._copy_structure(self._structure, memo)\\n \\n     def _copy_structure(self: C, structure: List[T], memo: dict) -> C:\\n         \\\"\\\"\\\"``__deepcopy__`` auxiliary method also useful with multi-inheritance\\\"\\\"\\\"\\n\",\"diff --git a/src/configupdater/container.py b/src/configupdater/container.py\\nindex 1bc3416..96f5f7e 100644\\n--- a/src/configupdater/container.py\\n+++ b/src/configupdater/container.py\\n@@ -39,7 +39,7 @@ def __repr__(self) -> str:\\n         return f\\\"<{self.__class__.__name__} {self._repr_blocks()}>\\\"\\n \\n     def __deepcopy__(self: C, memo: dict) -> C:\\n-        clone = self._intantiate_copy()\\n+        clone = self._instantiate_copy()\\n         memo[id(self)] = clone\\n         return clone._copy_structure(self._structure, memo)\\n \\n@@ -48,7 +48,7 @@ def _copy_structure(self: C, structure: List[T], memo: dict) -> C:\\n         self._structure = [b.attach(self) for b in deepcopy(structure, memo)]\\n         return self\\n \\n-    def _intantiate_copy(self: C) -> C:\\n+    def _instantiate_copy(self: C) -> C:\\n         \\\"\\\"\\\"Auxiliary method that allows subclasses calling ``__deepcopy__``\\\"\\\"\\\"\\n         return self.__class__()  # allow overwrite for different init args\\n \\n\",\"diff --git a/src/configupdater/section.py b/src/configupdater/section.py\\nindex ab0b84c..6613148 100644\\n--- a/src/configupdater/section.py\\n+++ b/src/configupdater/section.py\\n@@ -121,7 +121,7 @@ def __str__(self) -> str:\\n     def __repr__(self) -> str:\\n         return f\\\"<Section: {self.name!r} {super()._repr_blocks()}>\\\"\\n \\n-    def _intantiate_copy(self: S) -> S:\\n+    def _instantiate_copy(self: S) -> S:\\n         \\\"\\\"\\\"Will be called by :meth:`Block.__deepcopy__`\\\"\\\"\\\"\\n         clone = self.__class__(self._name, container=None)\\n         # ^  A fresh copy should always be made detached from any container\\n\",\"diff --git a/src/configupdater/configupdater.py b/src/configupdater/configupdater.py\\nindex f279801..446e880 100644\\n--- a/src/configupdater/configupdater.py\\n+++ b/src/configupdater/configupdater.py\\n@@ -100,6 +100,12 @@ def __init__(\\n         self._filename: Optional[str] = None\\n         super().__init__()\\n \\n+    def _intantiate_copy(self: T) -> T:\\n+        \\\"\\\"\\\"Will be called by ``Container.__deepcopy__``\\\"\\\"\\\"\\n+        clone = self.__class__(**self._parser_opts)\\n+        clone._filename = self._filename\\n+        return clone\\n+\\n     def _parser(self, **kwargs):\\n         opts = {\\\"optionxform\\\": self.optionxform, **self._parser_opts, **kwargs}\\n         return Parser(**opts)\\n\",\"diff --git a/src/configupdater/configupdater.py b/src/configupdater/configupdater.py\\nindex 446e880..c02c506 100644\\n--- a/src/configupdater/configupdater.py\\n+++ b/src/configupdater/configupdater.py\\n@@ -100,7 +100,7 @@ def __init__(\\n         self._filename: Optional[str] = None\\n         super().__init__()\\n \\n-    def _intantiate_copy(self: T) -> T:\\n+    def _instantiate_copy(self: T) -> T:\\n         \\\"\\\"\\\"Will be called by ``Container.__deepcopy__``\\\"\\\"\\\"\\n         clone = self.__class__(**self._parser_opts)\\n         clone._filename = self._filename\\n\",\"diff --git a/src/configupdater/block.py b/src/configupdater/block.py\\nindex 69cf8a1..c4b9b5e 100644\\n--- a/src/configupdater/block.py\\n+++ b/src/configupdater/block.py\\n@@ -30,7 +30,10 @@ def __init__(self):\\n \\n \\n class AlreadyAttachedError(Exception):\\n-    \\\"\\\"\\\"The block has been already attached to a container. Try to remove it first.\\\"\\\"\\\"\\n+    \\\"\\\"\\\"The block has been already attached to a container.\\n+    Try to remove it first using ``detach`` or create a copy using stdlib's\\n+    ``copy.deepcopy``.\\n+    \\\"\\\"\\\"\\n \\n     def __init__(self):\\n         super().__init__(self.__class__.__doc__)\\n\",\"diff --git a/src/configupdater/document.py b/src/configupdater/document.py\\nindex 592e895..91bce8a 100644\\n--- a/src/configupdater/document.py\\n+++ b/src/configupdater/document.py\\n@@ -69,8 +69,14 @@ def _get_section_idx(self, name: str) -> int:\\n             if isinstance(entry, Section) and entry.name == name\\n         )\\n \\n-    def optionxform(self, optionstr: str) -> str:\\n-        \\\"\\\"\\\"Converts an option key to lower case for unification\\n+    def optionxform(self, optionstr) -> str:\\n+        \\\"\\\"\\\"Converts an option key for unification\\n+\\n+        By default it uses :meth:`str.lower`, which means that ConfigUpdater will\\n+        compare options in a case insensitive way.\\n+\\n+        This implementation mimics ConfigParser API, and can be configured as described\\n+        in :meth:`configparser.ConfigParser.optionxform`.\\n \\n         Args:\\n              optionstr (str): key name\\n\",\"diff --git a/src/configupdater/option.py b/src/configupdater/option.py\\nindex 9e17e91..5b82142 100644\\n--- a/src/configupdater/option.py\\n+++ b/src/configupdater/option.py\\n@@ -108,10 +108,17 @@ def _instantiate_copy(self: T) -> T:\\n         )\\n \\n     def optionxform(self, optionstr: str) -> str:\\n+        \\\"\\\"\\\"Delegates :meth:`~configupdater.document.Document.optionxform`\\n+        to its parent container.\\n+\\n+        Please notice that when the option object is :obj:`detached\\n+        <configupdater.block.Block.detach>`, this method will simply return\\n+        ``optionstr`` as it is, without any changes.\\n+        \\\"\\\"\\\"\\n         if self.has_container():\\n             section = cast(\\\"Section\\\", self.container)\\n             return section.optionxform(optionstr)\\n-        return optionstr.lower()\\n+        return optionstr\\n \\n     @property\\n     def key(self) -> str:\\n@@ -123,6 +130,11 @@ def key(self, value: str):\\n         self._key = value\\n         self._updated = True\\n \\n+    @property\\n+    def raw_key(self) -> str:\\n+        \\\"\\\"\\\"Equivalent to :obj:`key`, but before applying :meth:`optionxform`.\\\"\\\"\\\"\\n+        return self._key\\n+\\n     @property\\n     def value(self) -> Optional[str]:\\n         self._join_multiline_value()\\n\",\"diff --git a/src/configupdater/section.py b/src/configupdater/section.py\\nindex 6613148..4eee0f1 100644\\n--- a/src/configupdater/section.py\\n+++ b/src/configupdater/section.py\\n@@ -133,6 +133,13 @@ def __deepcopy__(self: S, memo: dict) -> S:\\n         return clone._copy_structure(self._structure, memo)\\n \\n     def optionxform(self, optionstr: str) -> str:\\n+        \\\"\\\"\\\"Delegates :meth:`~configupdater.document.Document.optionxform`\\n+        to its parent container.\\n+\\n+        Please notice that when the option object is :obj:`detached\\n+        <configupdater.block.Block.detach>`, this method will simply return\\n+        ``optionstr`` as it is, without any changes.\\n+        \\\"\\\"\\\"\\n         if self.has_container():\\n             return self.document.optionxform(optionstr)\\n         return optionstr.lower()\\n@@ -145,19 +152,32 @@ def __getitem__(self, key: str) -> \\\"Option\\\":\\n             raise KeyError(f\\\"No option `{key}` found\\\", {\\\"key\\\": key}) from ex\\n \\n     def __setitem__(self, key: str, value: Optional[Value] = None):\\n-        if self.optionxform(key) in self:\\n+        \\\"\\\"\\\"Set the value of an option.\\n+\\n+        Please notice that this method used :meth:`optionxform` to verify if the given\\n+        option already exists inside the section object. Therefore, calling it when the\\n+        section is :obj:`detached <configupdater.block.Block.detach>`, might result in\\n+        inconsistent behavior, especially if the configuration document uses mixed cases\\n+        for the option keys strings.\\n+        \\\"\\\"\\\"\\n+        given_key = self.optionxform(key)\\n+        if given_key in self:\\n             if isinstance(value, Option):\\n-                if value.key != key:\\n+                value_key = self.optionxform(value.raw_key)\\n+                # ^ Calculate value_key according to the optionxform of the current\\n+                #   document, in the case the option is imported from a document with a\\n+                #   different optionxform\\n+                if value_key != given_key:\\n                     raise ValueError(\\n-                        f\\\"Set key `{key}` does not equal option key `{value.key}`\\\"\\n+                        f\\\"Set key `{given_key}` does not equal option key `{value_key}`\\\"\\n                     )\\n-                curr_value = self.__getitem__(key)\\n+                curr_value = self.__getitem__(given_key)\\n                 idx = curr_value.container_idx\\n                 curr_value.detach()\\n                 value.attach(self)\\n                 self.structure.insert(idx, value)\\n             else:\\n-                option = self.__getitem__(key)\\n+                option = self.__getitem__(given_key)\\n                 option.value = value\\n         else:\\n             if isinstance(value, Option):\\n\",\"diff --git a/src/configupdater/section.py b/src/configupdater/section.py\\nindex 4eee0f1..e72e3d1 100644\\n--- a/src/configupdater/section.py\\n+++ b/src/configupdater/section.py\\n@@ -142,7 +142,7 @@ def optionxform(self, optionstr: str) -> str:\\n         \\\"\\\"\\\"\\n         if self.has_container():\\n             return self.document.optionxform(optionstr)\\n-        return optionstr.lower()\\n+        return optionstr\\n \\n     def __getitem__(self, key: str) -> \\\"Option\\\":\\n         key = self.optionxform(key)\\n\",\"diff --git a/src/configupdater/option.py b/src/configupdater/option.py\\nindex 5b82142..0bb9e60 100644\\n--- a/src/configupdater/option.py\\n+++ b/src/configupdater/option.py\\n@@ -107,22 +107,22 @@ def _instantiate_copy(self: T) -> T:\\n             space_around_delimiters=self._space_around_delimiters,\\n         )\\n \\n-    def optionxform(self, optionstr: str) -> str:\\n-        \\\"\\\"\\\"Delegates :meth:`~configupdater.document.Document.optionxform`\\n-        to its parent container.\\n-\\n-        Please notice that when the option object is :obj:`detached\\n-        <configupdater.block.Block.detach>`, this method will simply return\\n-        ``optionstr`` as it is, without any changes.\\n-        \\\"\\\"\\\"\\n-        if self.has_container():\\n-            section = cast(\\\"Section\\\", self.container)\\n-            return section.optionxform(optionstr)\\n-        return optionstr\\n+    @property\\n+    def section(self) -> \\\"Section\\\":\\n+        return cast(\\\"Section\\\", self.container)\\n \\n     @property\\n     def key(self) -> str:\\n-        return self.optionxform(self._key)\\n+        \\\"\\\"\\\"Key string associated with the option.\\n+\\n+        Please notice that usually, the option key is normalized with\\n+        :meth:`~configupdater.document.Document.optionxform`, however,\\n+        when the option object is :obj:`detached <configupdater.block.Block.detach>`,\\n+        this method will simply return the key as it is, without any changes.\\n+        \\\"\\\"\\\"\\n+        if self.has_container():\\n+            return self.section.document.optionxform(self._key)\\n+        return self._key\\n \\n     @key.setter\\n     def key(self, value: str):\\n\",\"diff --git a/src/configupdater/section.py b/src/configupdater/section.py\\nindex e72e3d1..5d3267a 100644\\n--- a/src/configupdater/section.py\\n+++ b/src/configupdater/section.py\\n@@ -53,7 +53,7 @@ def __init__(self, name: str, container: Optional[\\\"Document\\\"] = None):\\n         super().__init__(container=container)\\n \\n     @property\\n-    def document(self):\\n+    def document(self) -> \\\"Document\\\":\\n         return cast(\\\"Document\\\", self.container)\\n \\n     def add_option(self: S, entry: \\\"Option\\\") -> S:\\n@@ -132,20 +132,8 @@ def __deepcopy__(self: S, memo: dict) -> S:\\n         clone = Block.__deepcopy__(self, memo)  # specific due to multi-inheritance\\n         return clone._copy_structure(self._structure, memo)\\n \\n-    def optionxform(self, optionstr: str) -> str:\\n-        \\\"\\\"\\\"Delegates :meth:`~configupdater.document.Document.optionxform`\\n-        to its parent container.\\n-\\n-        Please notice that when the option object is :obj:`detached\\n-        <configupdater.block.Block.detach>`, this method will simply return\\n-        ``optionstr`` as it is, without any changes.\\n-        \\\"\\\"\\\"\\n-        if self.has_container():\\n-            return self.document.optionxform(optionstr)\\n-        return optionstr\\n-\\n     def __getitem__(self, key: str) -> \\\"Option\\\":\\n-        key = self.optionxform(key)\\n+        key = self.document.optionxform(key)\\n         try:\\n             return next(o for o in self.iter_options() if o.key == key)\\n         except StopIteration as ex:\\n@@ -154,16 +142,14 @@ def __getitem__(self, key: str) -> \\\"Option\\\":\\n     def __setitem__(self, key: str, value: Optional[Value] = None):\\n         \\\"\\\"\\\"Set the value of an option.\\n \\n-        Please notice that this method used :meth:`optionxform` to verify if the given\\n-        option already exists inside the section object. Therefore, calling it when the\\n-        section is :obj:`detached <configupdater.block.Block.detach>`, might result in\\n-        inconsistent behavior, especially if the configuration document uses mixed cases\\n-        for the option keys strings.\\n+        Please notice that this method used\\n+        :meth:`~configupdater.document.Document.optionxform` to verify if the given\\n+        option already exists inside the section object.\\n         \\\"\\\"\\\"\\n-        given_key = self.optionxform(key)\\n+        given_key = self.document.optionxform(key)\\n         if given_key in self:\\n             if isinstance(value, Option):\\n-                value_key = self.optionxform(value.raw_key)\\n+                value_key = self.document.optionxform(value.raw_key)\\n                 # ^ Calculate value_key according to the optionxform of the current\\n                 #   document, in the case the option is imported from a document with a\\n                 #   different optionxform\\n@@ -277,7 +263,7 @@ def set(self: S, option: str, value: Optional[str] = None) -> S:\\n             option (str): option name\\n             value (str): value, default None\\n         \\\"\\\"\\\"\\n-        option = self.optionxform(option)\\n+        option = self.document.optionxform(option)\\n         if option in self.options():\\n             self.__getitem__(option).value = value\\n         else:\\n\",\"diff --git a/src/configupdater/option.py b/src/configupdater/option.py\\nindex 0bb9e60..26ef529 100644\\n--- a/src/configupdater/option.py\\n+++ b/src/configupdater/option.py\\n@@ -120,9 +120,7 @@ def key(self) -> str:\\n         when the option object is :obj:`detached <configupdater.block.Block.detach>`,\\n         this method will simply return the key as it is, without any changes.\\n         \\\"\\\"\\\"\\n-        if self.has_container():\\n-            return self.section.document.optionxform(self._key)\\n-        return self._key\\n+        return self.section.document.optionxform(self._key)\\n \\n     @key.setter\\n     def key(self, value: str):\\n\",\"diff --git a/src/configupdater/option.py b/src/configupdater/option.py\\nindex 26ef529..1989cd3 100644\\n--- a/src/configupdater/option.py\\n+++ b/src/configupdater/option.py\\n@@ -115,10 +115,11 @@ def section(self) -> \\\"Section\\\":\\n     def key(self) -> str:\\n         \\\"\\\"\\\"Key string associated with the option.\\n \\n-        Please notice that usually, the option key is normalized with\\n-        :meth:`~configupdater.document.Document.optionxform`, however,\\n-        when the option object is :obj:`detached <configupdater.block.Block.detach>`,\\n-        this method will simply return the key as it is, without any changes.\\n+        Please notice that the option key is normalized with\\n+        :meth:`~configupdater.document.Document.optionxform`.\\n+\\n+        When the option object is :obj:`detached <configupdater.block.Block.detach>`,\\n+        this method will raise a :obj:`NotAttachedError`.\\n         \\\"\\\"\\\"\\n         return self.section.document.optionxform(self._key)\\n \\n\",\"diff --git a/src/configupdater/block.py b/src/configupdater/block.py\\nindex c4b9b5e..9c82be8 100644\\n--- a/src/configupdater/block.py\\n+++ b/src/configupdater/block.py\\n@@ -7,7 +7,7 @@\\n import sys\\n from abc import ABC\\n from copy import deepcopy\\n-from typing import TYPE_CHECKING, Optional, TypeVar\\n+from typing import TYPE_CHECKING, Optional, TypeVar, Union, cast\\n \\n if sys.version_info[:2] >= (3, 9):  # pragma: no cover\\n     List = list\\n@@ -22,21 +22,31 @@\\n B = TypeVar(\\\"B\\\", bound=\\\"Block\\\")\\n \\n \\n+def _block_short_repr(block) -> str:\\n+    if isinstance(block, str):\\n+        return block\\n+    name = getattr(block, \\\"key\\\", None) or getattr(block, \\\"name\\\", None)\\n+    name = f\\\" {name!r}\\\" if name else \\\"\\\"\\n+    return f\\\"<{block.__class__.__name__}{name}>\\\"\\n+\\n+\\n class NotAttachedError(Exception):\\n-    \\\"\\\"\\\"The block is not attached to a container yet. Try to insert it first.\\\"\\\"\\\"\\n+    \\\"\\\"\\\"{block} is not attached to a container yet. Try to insert it first.\\\"\\\"\\\"\\n \\n-    def __init__(self):\\n-        super().__init__(self.__class__.__doc__)\\n+    def __init__(self, block: Union[str, \\\"Block\\\"] = \\\"The block\\\"):\\n+        msg = cast(str, self.__class__.__doc__).format(_block_short_repr(block))\\n+        super().__init__(msg)\\n \\n \\n class AlreadyAttachedError(Exception):\\n-    \\\"\\\"\\\"The block has been already attached to a container.\\n+    \\\"\\\"\\\"{block} has been already attached to a container.\\n     Try to remove it first using ``detach`` or create a copy using stdlib's\\n     ``copy.deepcopy``.\\n     \\\"\\\"\\\"\\n \\n-    def __init__(self):\\n-        super().__init__(self.__class__.__doc__)\\n+    def __init__(self, block: Union[str, \\\"Block\\\"] = \\\"The block\\\"):\\n+        msg = cast(str, self.__class__.__doc__).format(_block_short_repr(block))\\n+        super().__init__(msg)\\n \\n \\n class Block(ABC):\\n@@ -98,7 +108,7 @@ def lines(self) -> List[str]:\\n     def container(self) -> \\\"Container\\\":\\n         \\\"\\\"\\\"Container holding the block\\\"\\\"\\\"\\n         if self._container is None:\\n-            raise NotAttachedError\\n+            raise NotAttachedError(self)\\n         return self._container\\n \\n     @property\\n@@ -161,7 +171,7 @@ def attach(self: B, container: \\\"Container\\\") -> B:\\n         Rather use `add_*` or the bracket notation\\n         \\\"\\\"\\\"\\n         if self._container is not None and self._container is not container:\\n-            raise AlreadyAttachedError\\n+            raise AlreadyAttachedError(self)\\n         self._container = container\\n         return self\\n \\n\",\"diff --git a/src/configupdater/block.py b/src/configupdater/block.py\\nindex 9c82be8..1132b31 100644\\n--- a/src/configupdater/block.py\\n+++ b/src/configupdater/block.py\\n@@ -22,10 +22,10 @@\\n B = TypeVar(\\\"B\\\", bound=\\\"Block\\\")\\n \\n \\n-def _block_short_repr(block) -> str:\\n+def _short_repr(block) -> str:\\n     if isinstance(block, str):\\n         return block\\n-    name = getattr(block, \\\"key\\\", None) or getattr(block, \\\"name\\\", None)\\n+    name = getattr(block, \\\"raw_key\\\", None) or getattr(block, \\\"name\\\", None)\\n     name = f\\\" {name!r}\\\" if name else \\\"\\\"\\n     return f\\\"<{block.__class__.__name__}{name}>\\\"\\n \\n@@ -34,7 +34,7 @@ class NotAttachedError(Exception):\\n     \\\"\\\"\\\"{block} is not attached to a container yet. Try to insert it first.\\\"\\\"\\\"\\n \\n     def __init__(self, block: Union[str, \\\"Block\\\"] = \\\"The block\\\"):\\n-        msg = cast(str, self.__class__.__doc__).format(_block_short_repr(block))\\n+        msg = cast(str, self.__class__.__doc__).format(block=_short_repr(block))\\n         super().__init__(msg)\\n \\n \\n@@ -45,7 +45,7 @@ class AlreadyAttachedError(Exception):\\n     \\\"\\\"\\\"\\n \\n     def __init__(self, block: Union[str, \\\"Block\\\"] = \\\"The block\\\"):\\n-        msg = cast(str, self.__class__.__doc__).format(_block_short_repr(block))\\n+        msg = cast(str, self.__class__.__doc__).format(block=_short_repr(block))\\n         super().__init__(msg)\\n \\n \\n\"]", "test_patch": "[\"diff --git a/tests/test_option.py b/tests/test_option.py\\nnew file mode 100644\\nindex 0000000..10ed1c7\\n--- /dev/null\\n+++ b/tests/test_option.py\\n@@ -0,0 +1,32 @@\\n+from copy import deepcopy\\n+from textwrap import dedent\\n+\\n+import pytest\\n+\\n+from configupdater.block import NotAttachedError\\n+from configupdater.parser import Parser\\n+\\n+\\n+def test_deepcopy():\\n+    example = \\\"\\\"\\\"\\\\\\n+    [options.extras_require]\\n+    testing =   # Add here test requirements (used by tox)\\n+        sphinx  # required for system tests\\n+        flake8  # required for system tests\\n+    \\\"\\\"\\\"\\n+    doc = Parser().read_string(dedent(example))\\n+    section = doc[\\\"options.extras_require\\\"]\\n+    option = section[\\\"testing\\\"]\\n+    assert option.container is section\\n+\\n+    clone = deepcopy(option)\\n+\\n+    assert str(clone) == str(option)\\n+    assert option.container is section\\n+    with pytest.raises(NotAttachedError):\\n+        assert clone.container is None  # copies should always be created detached\\n+\\n+    # Make sure no side effects are felt by the original when the copy is modified\\n+    clone.value = \\\"\\\"\\n+    assert str(clone) != str(option)\\n+    assert str(doc) == dedent(example)\\n\",\"diff --git a/tests/test_section.py b/tests/test_section.py\\nnew file mode 100644\\nindex 0000000..4a66281\\n--- /dev/null\\n+++ b/tests/test_section.py\\n@@ -0,0 +1,49 @@\\n+from copy import deepcopy\\n+from textwrap import dedent\\n+\\n+import pytest\\n+\\n+from configupdater.block import NotAttachedError\\n+from configupdater.parser import Parser\\n+\\n+\\n+def test_deepcopy():\\n+    example = \\\"\\\"\\\"\\\\\\n+    [options.extras_require]\\n+    testing =   # Add here test requirements (used by tox)\\n+        sphinx  # required for system tests\\n+        flake8  # required for system tests\\n+    \\\"\\\"\\\"\\n+    doc = Parser().read_string(dedent(example))\\n+    section = doc[\\\"options.extras_require\\\"]\\n+    option = section[\\\"testing\\\"]\\n+    assert option.container is section\\n+\\n+    clone = deepcopy(section)\\n+\\n+    assert str(clone) == str(section)\\n+    assert section.container is doc\\n+    with pytest.raises(NotAttachedError):\\n+        assert clone.container is None  # copies should always be created detached\\n+\\n+    # Make sure no side effects are felt by the original when the copy is modified\\n+    # and vice-versa\\n+    clone[\\\"testing\\\"] = \\\"\\\"\\n+    assert str(clone) != str(section)\\n+    assert str(doc) == dedent(example)\\n+    clone[\\\"testing\\\"].add_before.option(\\\"extra_option\\\", \\\"extra_value\\\")\\n+    assert \\\"extra_option\\\" in clone\\n+    assert \\\"extra_option\\\" not in section\\n+    assert clone[\\\"extra_option\\\"].container is clone\\n+\\n+    section[\\\"testing\\\"].add_before.option(\\\"other_extra_option\\\", \\\"other_extra_value\\\")\\n+    assert \\\"other_extra_option\\\" in section\\n+    assert \\\"other_extra_option\\\" not in clone\\n+    assert section[\\\"other_extra_option\\\"].container is section\\n+\\n+    section.add_after.comment(\\\"# new comment\\\")\\n+    assert \\\"# new comment\\\" in str(doc)\\n+    assert \\\"# new comment\\\" not in str(clone)\\n+\\n+    with pytest.raises(NotAttachedError):\\n+        clone.add_before.comment(\\\"# new comment\\\")\\n\",\"diff --git a/tests/test_configupdater.py b/tests/test_configupdater.py\\nindex 74706c7..e04fb46 100644\\n--- a/tests/test_configupdater.py\\n+++ b/tests/test_configupdater.py\\n@@ -347,10 +347,10 @@ def test_set_option():\\n     assert values == [\\\"param1\\\", \\\"param2\\\"]  # non destructive operation\\n     with pytest.raises(NoSectionError):\\n         updater.set(\\\"wrong_section\\\", \\\"key\\\", \\\"1\\\")\\n-    new_option = copy.copy(updater[\\\"default\\\"][\\\"key\\\"])\\n+    new_option = copy.deepcopy(updater[\\\"default\\\"][\\\"key\\\"])\\n     updater[\\\"default\\\"][\\\"key\\\"] = new_option\\n     assert updater[\\\"default\\\"][\\\"key\\\"] is new_option\\n-    new_option = copy.copy(updater[\\\"default\\\"][\\\"key\\\"])\\n+    new_option = copy.deepcopy(updater[\\\"default\\\"][\\\"key\\\"])\\n     new_option.key = \\\"wrong_key\\\"\\n     with pytest.raises(ValueError):\\n         updater[\\\"default\\\"][\\\"key\\\"] = new_option\\n@@ -1145,6 +1145,63 @@ def test_transfering_sections_and_manipulating_options():\\n     assert \\\"option2\\\" in str(target)\\n \\n \\n+def test_transfering_sections_and_manipulating_options_with_deepcopy():\\n+    existing = \\\"\\\"\\\"\\\\\\n+    [section0]\\n+    option0 = 0\\n+    \\\"\\\"\\\"\\n+\\n+    template1 = \\\"\\\"\\\"\\\\\\n+    [section1]\\n+    option1 = 1\\n+    \\\"\\\"\\\"\\n+\\n+    template2 = \\\"\\\"\\\"\\\\\\n+    [section2]\\n+    option2 = 2\\n+    # comment\\n+    \\\"\\\"\\\"\\n+\\n+    target = ConfigUpdater()\\n+    target.read_string(dedent(existing))\\n+\\n+    source1 = ConfigUpdater()\\n+    source1.read_string(dedent(template1))\\n+\\n+    source2 = ConfigUpdater()\\n+    source2.read_string(dedent(template2))\\n+\\n+    target[\\\"section1\\\"] = copy.deepcopy(source1[\\\"section1\\\"])\\n+    assert \\\"section1\\\" in target\\n+    assert \\\"section1\\\" in source1\\n+\\n+    target[\\\"section1\\\"].add_after.section(copy.deepcopy(source2[\\\"section2\\\"]))\\n+    target[\\\"section2\\\"][\\\"option2\\\"] = \\\"value\\\"\\n+    assert \\\"option2 = value\\\" in str(target)\\n+    assert \\\"option2\\\" not in str(source1)\\n+    assert \\\"value\\\" not in str(source2)\\n+\\n+\\n+def test_deepcopy():\\n+    example = \\\"\\\"\\\"\\\\\\n+    [options]\\n+    testing =   # Add here test requirements (used by tox)\\n+        sphinx  # required for system tests\\n+        flake8  # required for system tests\\n+    \\\"\\\"\\\"\\n+    updater = ConfigUpdater().read_string(dedent(example))\\n+    clone = copy.deepcopy(updater)\\n+    assert clone[\\\"options\\\"].container is clone\\n+    assert clone[\\\"options\\\"][\\\"testing\\\"].container is not updater[\\\"options\\\"]\\n+    clone[\\\"options\\\"][\\\"testing\\\"].detach()\\n+    assert \\\"testing\\\" not in str(clone)\\n+    assert \\\"testing\\\" in str(updater)\\n+    clone.add_section(\\\"other\\\")\\n+    assert \\\"other\\\" in clone\\n+    assert \\\"other\\\" not in updater\\n+    assert str(updater) == dedent(example)\\n+\\n+\\n def test_section_comment():\\n     section = \\\"\\\"\\\"\\\\\\n     [section0] # section comment\\n\",\"diff --git a/README.rst b/README.rst\\nindex f6d6518..97d14c3 100644\\n--- a/README.rst\\n+++ b/README.rst\\n@@ -196,9 +196,10 @@ With the help of two ConfigUpdater objects we can easily inject this section int\\n \\n     (updater[\\\"metadata\\\"].add_after\\n                         .space()\\n-                        .section(sphinx_sect))\\n+                        .section(sphinx_sect.detach()))\\n \\n-This results in::\\n+The ``detach`` method will remove the ``build_sphinx`` section from the first object\\n+and add it to the second object. This results in::\\n \\n     [metadata]\\n     author = Ada Lovelace\\n@@ -208,6 +209,25 @@ This results in::\\n     source_dir = docs\\n     build_dir = docs/_build\\n \\n+Alternatively, if you want to preserve ``build_sphinx`` in both\\n+``ConfigUpdater`` objects (i.e., prevent it from being removed from the first\\n+while still adding a copy to the second), you call also rely on stdlib's\\n+``copy.deepcopy`` function instead of ``detach``::\\n+\\n+    from copy import deepcopy\\n+\\n+    (updater[\\\"metadata\\\"].add_after\\n+                        .space()\\n+                        .section(deepcopy(sphinx_sect)))\\n+\\n+This technique can be used for all objects inside ConfigUpdater: sections,\\n+options, comments and blank spaces.\\n+\\n+Shallow copies are discouraged in the context of ConfigUpdater because each\\n+configuration block keeps a reference to its container to allow easy document\\n+editing. When doing editions (such as adding or changing options and comments)\\n+based on a shallow copy, the results can be unreliable and unexpected.\\n+\\n For more examples on how the API of ConfigUpdater works it's best to take a look into the\\n `unit tests`_ and read the references.\\n \\n\",\"diff --git a/docs/usage.rst b/docs/usage.rst\\nindex 10775de..03842e2 100644\\n--- a/docs/usage.rst\\n+++ b/docs/usage.rst\\n@@ -82,7 +82,7 @@ Using ``add_after`` would give the same result and looks like::\\n                                   .comment(\\\"Ada would have loved MIT\\\")\\n                                   .option(\\\"license\\\", \\\"MIT\\\"))\\n \\n-Let's say we want to rename `summary` to the more common `description`::\\n+Let's say we want to rename ``summary`` to the more common ``description``::\\n \\n     updater = ConfigUpdater()\\n     updater.read_string(cfg)\\n@@ -139,9 +139,10 @@ With the help of two ConfigUpdater objects we can easily inject this section int\\n \\n     (updater[\\\"metadata\\\"].add_after\\n                         .space()\\n-                        .section(sphinx_sect))\\n+                        .section(sphinx_sect.detach()))\\n \\n-This results in::\\n+The :meth:`~configupdater.block.Block.detach` method will remove the ``build_sphinx``\\n+section from the first object and add it to the second object. This results in::\\n \\n     [metadata]\\n     author = Ada Lovelace\\n@@ -151,6 +152,26 @@ This results in::\\n     source_dir = docs\\n     build_dir = docs/_build\\n \\n+Alternatively, if you want to preserve ``build_sphinx`` in both\\n+:class:`~configupdater.ConfigUpdater` objects (i.e., prevent it from being\\n+removed from the first while still adding a copy to the second), you call also\\n+rely on stdlib's :func:`copy.deepcopy` function instead of\\n+:meth:`~configupdater.block.Block.detach`::\\n+\\n+    from copy import deepcopy\\n+\\n+    (updater[\\\"metadata\\\"].add_after\\n+                        .space()\\n+                        .section(deepcopy(sphinx_sect)))\\n+\\n+This technique can be used for all objects inside ConfigUpdater: sections,\\n+options, comments and blank spaces.\\n+\\n+Shallow copies are discouraged in the context of ConfigUpdater because each\\n+configuration block keeps a reference to its container to allow easy document\\n+editing. When doing editions (such as adding or changing options and comments)\\n+based on a shallow copy, the results can be unreliable and unexpected.\\n+\\n For more examples on how the API of ConfigUpdater works it's best to take a look into the\\n `unit tests`_ and read the references.\\n \\n\",\"diff --git a/tests/test_configupdater.py b/tests/test_configupdater.py\\nindex e04fb46..1f8b512 100644\\n--- a/tests/test_configupdater.py\\n+++ b/tests/test_configupdater.py\\n@@ -1226,3 +1226,26 @@ def test_section_comment():\\n     key = value\\n     \\\"\\\"\\\"\\n     assert str(updater) == dedent(expected)\\n+\\n+\\n+def test_setitem_detached_option():\\n+    existing = \\\"\\\"\\\"\\\\\\n+    [section0]\\n+    option0 = 0\\n+    option1 = # No value\\n+    \\\"\\\"\\\"\\n+\\n+    template1 = \\\"\\\"\\\"\\\\\\n+    [section1]\\n+    option1 = 1\\n+    \\\"\\\"\\\"\\n+\\n+    target = ConfigUpdater()\\n+    target.read_string(dedent(existing))\\n+\\n+    source1 = ConfigUpdater()\\n+    source1.read_string(dedent(template1))\\n+\\n+    option1 = source1[\\\"section1\\\"][\\\"option1\\\"].detach()\\n+    target[\\\"section0\\\"][\\\"option1\\\"] = option1\\n+    assert target[\\\"section0\\\"][\\\"option1\\\"] == \\\"1\\\"\\n\",\"diff --git a/tests/test_configupdater.py b/tests/test_configupdater.py\\nindex 1f8b512..6cef2fb 100644\\n--- a/tests/test_configupdater.py\\n+++ b/tests/test_configupdater.py\\n@@ -1248,4 +1248,4 @@ def test_setitem_detached_option():\\n \\n     option1 = source1[\\\"section1\\\"][\\\"option1\\\"].detach()\\n     target[\\\"section0\\\"][\\\"option1\\\"] = option1\\n-    assert target[\\\"section0\\\"][\\\"option1\\\"] == \\\"1\\\"\\n+    assert target[\\\"section0\\\"][\\\"option1\\\"].value == \\\"1\\\"\\n\",\"diff --git a/tests/test_section.py b/tests/test_section.py\\nindex 4a66281..4b0b6ba 100644\\n--- a/tests/test_section.py\\n+++ b/tests/test_section.py\\n@@ -15,16 +15,20 @@ def test_deepcopy():\\n         flake8  # required for system tests\\n     \\\"\\\"\\\"\\n     doc = Parser().read_string(dedent(example))\\n+    other = Parser().read_string(\\\"\\\")\\n     section = doc[\\\"options.extras_require\\\"]\\n     option = section[\\\"testing\\\"]\\n     assert option.container is section\\n \\n     clone = deepcopy(section)\\n+    with pytest.raises(NotAttachedError):  # copies should always be created detached\\n+        assert clone.container is None\\n+\\n+    other.add_section(clone)  # needed to be able to modify section\\n+    assert clone.container is other\\n \\n     assert str(clone) == str(section)\\n     assert section.container is doc\\n-    with pytest.raises(NotAttachedError):\\n-        assert clone.container is None  # copies should always be created detached\\n \\n     # Make sure no side effects are felt by the original when the copy is modified\\n     # and vice-versa\\n@@ -43,7 +47,8 @@ def test_deepcopy():\\n \\n     section.add_after.comment(\\\"# new comment\\\")\\n     assert \\\"# new comment\\\" in str(doc)\\n-    assert \\\"# new comment\\\" not in str(clone)\\n+    assert \\\"# new comment\\\" not in str(other)\\n \\n-    with pytest.raises(NotAttachedError):\\n-        clone.add_before.comment(\\\"# new comment\\\")\\n+    clone.add_before.comment(\\\"# other comment\\\")\\n+    assert \\\"# other comment\\\" in str(other)\\n+    assert \\\"# other comment\\\" not in str(doc)\\n\",\"diff --git a/tests/test_section.py b/tests/test_section.py\\nindex 4b0b6ba..6cf5f75 100644\\n--- a/tests/test_section.py\\n+++ b/tests/test_section.py\\n@@ -3,7 +3,7 @@\\n \\n import pytest\\n \\n-from configupdater.block import NotAttachedError\\n+from configupdater.block import AlreadyAttachedError, NotAttachedError\\n from configupdater.parser import Parser\\n \\n \\n@@ -52,3 +52,23 @@ def test_deepcopy():\\n     clone.add_before.comment(\\\"# other comment\\\")\\n     assert \\\"# other comment\\\" in str(other)\\n     assert \\\"# other comment\\\" not in str(doc)\\n+\\n+\\n+def test_clear_error_message():\\n+    # Make sure the error messages specify the exact object\\n+    example = \\\"\\\"\\\"\\\\\\n+    [options.extras_require]\\n+    testing =   # Add here test requirements (used by tox)\\n+        sphinx  # required for system tests\\n+        flake8  # required for system tests\\n+    \\\"\\\"\\\"\\n+    doc = Parser().read_string(dedent(example))\\n+    section = doc[\\\"options.extras_require\\\"]\\n+    clone = deepcopy(section)\\n+    with pytest.raises(NotAttachedError) as ex:\\n+        clone[\\\"testing\\\"] = \\\"\\\"\\n+    assert \\\"<Section 'option.extras_require'>\\\" in ex.value\\n+\\n+    with pytest.raises(AlreadyAttachedError) as ex:\\n+        section[\\\"testing\\\"] = clone[\\\"testing\\\"]\\n+    assert \\\"<Option 'testing'>\\\" in ex.value\\n\",\"diff --git a/tests/test_configupdater.py b/tests/test_configupdater.py\\nindex 6cef2fb..394aec5 100644\\n--- a/tests/test_configupdater.py\\n+++ b/tests/test_configupdater.py\\n@@ -1063,9 +1063,9 @@ def test_add_detached_section_option_objects():\\n     new_sec2 = Section(\\\"new-sec2\\\")\\n     new_opt = Option(key=\\\"new-key\\\", value=\\\"new-value\\\")\\n     new_sec2.add_option(new_opt)\\n+    updater.add_section(new_sec2)\\n     with pytest.raises(AlreadyAttachedError):\\n         sec1.add_option(new_opt)\\n-    updater.add_section(new_sec2)\\n     assert updater.has_section(\\\"new-sec2\\\")\\n     assert updater[\\\"new-sec2\\\"][\\\"new-key\\\"].value == \\\"new-value\\\"\\n \\n\",\"diff --git a/tests/test_section.py b/tests/test_section.py\\nindex 6cf5f75..4f8c1c8 100644\\n--- a/tests/test_section.py\\n+++ b/tests/test_section.py\\n@@ -67,8 +67,8 @@ def test_clear_error_message():\\n     clone = deepcopy(section)\\n     with pytest.raises(NotAttachedError) as ex:\\n         clone[\\\"testing\\\"] = \\\"\\\"\\n-    assert \\\"<Section 'option.extras_require'>\\\" in ex.value\\n+    assert \\\"<Section 'options.extras_require'>\\\" in str(ex.value)\\n \\n     with pytest.raises(AlreadyAttachedError) as ex:\\n-        section[\\\"testing\\\"] = clone[\\\"testing\\\"]\\n-    assert \\\"<Option 'testing'>\\\" in ex.value\\n+        section[\\\"testing\\\"] = next(clone.iter_options())\\n+    assert \\\"<Option 'testing'>\\\" in str(ex.value)\\n\",\"diff --git a/tests/test_configupdater.py b/tests/test_configupdater.py\\nindex 394aec5..6cef2fb 100644\\n--- a/tests/test_configupdater.py\\n+++ b/tests/test_configupdater.py\\n@@ -1063,9 +1063,9 @@ def test_add_detached_section_option_objects():\\n     new_sec2 = Section(\\\"new-sec2\\\")\\n     new_opt = Option(key=\\\"new-key\\\", value=\\\"new-value\\\")\\n     new_sec2.add_option(new_opt)\\n-    updater.add_section(new_sec2)\\n     with pytest.raises(AlreadyAttachedError):\\n         sec1.add_option(new_opt)\\n+    updater.add_section(new_sec2)\\n     assert updater.has_section(\\\"new-sec2\\\")\\n     assert updater[\\\"new-sec2\\\"][\\\"new-key\\\"].value == \\\"new-value\\\"\\n \"]", "hints_text": ""}

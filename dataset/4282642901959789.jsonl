{"instance_id": "4282642901959789", "repo": "kit-iai/pywatts", "base_commit": "71961293aca113740f27133fab12e7d71bac9233", "problem_statement": "Performance problems in online learning:\\n**Describe the bug**\\r\\nOnline learning is currently slow - taking large amounts of time to process one step. It seems that a single processor is busy. This could be due to:\\r\\n- Merging and copying of xarray.datasets.\\r\\n- Predict/Transform of single datapoints by sklearn.\\r\\n- Internal calls of pyWATTS\\r\\n\\r\\n**Expected behavior**\\r\\nThe online learning should run smoothly. Posisble solutions:\\r\\n- Reduce copying and merging of datasets.\\r\\n- Multiprocessing.\\r\\n", "FAIL_TO_PASS": ["tests/unit/core/test_inverse_step.py::TestInverseTransform::test_get_result_stop", "tests/unit/core/test_probabilistic_step.py::TestProbabilisticStep::test_get_result_stop", "tests/unit/core/test_start_step.py::TestStartStep::test_get_result_copying"], "PASS_TO_PASS": ["tests/unit/core/test_pipeline.py::TestPipeline::test_module_naming_conflict", "tests/unit/modules/test_rolling_rmse.py::TestRollingRMSE::test_transform_without_predictions", "tests/unit/summaries/test_mean_absolute_error.py::TestMAE::test_transform_with_filter", "tests/unit/wrapper/test_keras_wrapper.py::TestKerasWrapper::test_load", "tests/unit/wrapper/test_sklearn_wrapper.py::TestSklearnWrapper::test_DensityMixin", "tests/unit/core/test_pipeline.py::TestPipeline::test__collect_batch_results_naming_conflict", "tests/unit/modules/test_differentiate.py::TestResampler::test_wrong_parameter", "tests/unit/wrapper/test_function_module.py::TestFunctionModule::test_load", "tests/unit/summaries/test_mean_abs_percentage_error.py::TestMAE::test_get_params", "tests/unit/modules/test_rolling_kurtosis.py::TestRollingKurtosis::test_transform_groupbyNo", "tests/unit/modules/test_rolling_skewness.py::TestRollingSkewness::test_get_params", "tests/unit/modules/test_trend_extraction.py::TestTrendExtraction::test_transform", "tests/unit/wrapper/test_function_module.py::TestFunctionModule::test_save", "tests/unit/modules/test_root_mean_squared_error.py::TestRMSECalculator::test_set_params", "tests/unit/modules/test_sample_module.py::TestSampler::test_transform_exception", "tests/unit/core/test_step.py::TestStep::test_further_elements_target_false", "tests/unit/modules/test_profile_neural_network.py::TestPNN::test_load_if_not_fitted", "tests/unit/modules/test_profile_neural_network.py::TestPNN::test_fit", "tests/unit/wrapper/test_sklearn_wrapper.py::TestSklearnWrapper::test_fit_TransformerMixin", "tests/unit/modules/test_profile_neural_network.py::TestPNN::test_get_params", "tests/unit/core/test_pipeline.py::TestPipeline::test_set_params", "tests/unit/modules/test_rolling_mae.py::TestRollingMAE::test_set_params", "tests/unit/summaries/test_max_error.py::TestMaxErr::test_set_params", "tests/unit/modules/test_missing_value_detection.py::TestMissingValueDetector::test_set_params", "tests/unit/core/test_pipeline.py::TestPipeline::test_test", "tests/unit/core/test_pipeline.py::TestPipeline::test_train", "tests/unit/core/test_pipeline.py::TestPipeline::test_batch_1_transform", "tests/unit/modules/test_profile_neural_network.py::TestPNN::test_set_params", "tests/unit/modules/test_rolling_variance.py::TestRollingVariance::test_get_params", "tests/unit/core/test_step.py::TestStep::test_store_load_of_step_with_condition", "tests/unit/modules/test_differentiate.py::TestResampler::test_two_dimensional", "tests/unit/core/test_pipeline.py::TestPipeline::test_add_input_as_positional", "tests/unit/wrapper/test_statsmodels_wrapper.py::TestSmTimeSeriesModelWrapper::test_save", "tests/unit/modules/test_rolling_skewness.py::TestRollingSkewness::test_set_params", "tests/unit/core/test_filemanager.py::TestFilemanager::test_get_path_filename_with_path", "tests/unit/wrapper/test_sklearn_wrapper.py::TestSklearnWrapper::test_fit_BiClusterMixin", "tests/unit/summaries/test_min_error.py::TestMinErr::test_save", "tests/unit/modules/test_rolling_variance.py::TestRollingVariance::test_transform_groupbyWeekend", "tests/unit/modules/test_rolling_rmse.py::TestRollingRMSE::test_transform", "tests/integration/test_simple_pipeline.py::TestSimplePipeline::test_run_reloaded_simple_pipeline", "tests/unit/modules/test_mean_absolute_error.py::TestMaeCalculator::test_get_params", "tests/unit/modules/test_rolling_mae.py::TestRollingMAE::test_transform", "tests/unit/core/test_pipeline.py::TestPipeline::test_save", "tests/unit/modules/test_change_direction.py::TestChangeDirection::test_transform", "tests/unit/summaries/test_max_error.py::TestMaxErr::test_load", "tests/unit/core/test_filemanager.py::TestFilemanager::test_get_path", "tests/unit/core/test_step.py::TestStep::test_set_computation_mode_specified", "tests/unit/modules/test_rolling_variance.py::TestRollingVariance::test_transform_groupbyWeekendHoliday", "tests/unit/summaries/test_min_error.py::TestMinErr::test_load", "tests/unit/wrapper/test_sklearn_wrapper.py::TestSklearnWrapper::test_transform_multiple_output", "tests/unit/modules/test_differentiate.py::TestResampler::test_set_get_params", "tests/unit/modules/test_sample_module.py::TestSampler::test_get_params", "tests/unit/summaries/test_min_error.py::TestMinErr::test_set_params", "tests/unit/modules/test_rolling_kurtosis.py::TestRollingKurtosis::test_get_params", "tests/unit/modules/test_profile_neural_network.py::TestPNN::test_load_if_fitted", "tests/unit/summaries/test_max_error.py::TestMaxErr::test_save", "tests/unit/summaries/test_mean_absolute_error.py::TestMAE::test_transform_without_predictions", "tests/unit/core/test_step.py::TestStep::test_further_elements_input_false", "tests/unit/wrapper/test_statsmodels_wrapper.py::TestSmTimeSeriesModelWrapper::test_set_params", "tests/unit/core/test_pipeline.py::TestPipeline::test_transform_pipeline", "tests/unit/core/test_step.py::TestStep::test_input_finished", "tests/unit/core/test_step.py::TestStep::test_transform", "tests/unit/core/test_pipeline.py::TestPipeline::test_add_pipeline_to_pipeline_and_test", "tests/unit/modules/test_sample_module.py::TestSampler::test_set_params", "tests/unit/core/test_start_step.py::TestStartStep::test_load", "tests/unit/core/test_pipeline.py::TestPipeline::test_add_module_which_is_not_in_a_list", "tests/unit/core/test_pipeline.py::TestPipeline::test_batched_pipeline", "tests/unit/modules/test_rolling_mae.py::TestRollingMAE::test_get_params", "tests/unit/modules/test_clock_shift.py::TestClockShift::test_transform", "tests/unit/modules/test_resample.py::TestResampler::test_downscaling_median", "tests/unit/core/test_pipeline.py::TestPipeline::test_add_module_with_one_input_without_a_list", "tests/unit/core/test_step.py::TestStep::test_get_json", "tests/unit/modules/test_rolling_rmse.py::TestRollingRMSE::test_get_params", "tests/unit/core/test_pipeline.py::TestPipeline::test__collect_batch_results", "tests/unit/core/test_step.py::TestStep::test_set_computation_mode", "tests/unit/wrapper/test_keras_wrapper.py::TestKerasWrapper::test_transform_single_output", "tests/unit/modules/test_clock_shift.py::TestClockShift::test_transform_exception", "tests/unit/summaries/test_mean_absolute_error.py::TestMAE::test_save", "tests/unit/summaries/test_max_error.py::TestMaxErr::test_transform_without_predictions", "tests/unit/summaries/test_root_mean_squared_error.py::TestRMSE::test_load", "tests/unit/modules/test_rolling_mean.py::TestRollingMean::test_set_params", "tests/unit/wrapper/test_keras_wrapper.py::TestKerasWrapper::test_fit", "tests/unit/summaries/test_root_mean_squared_error.py::TestRMSE::test_transform_without_predictions", "tests/unit/modules/test_missing_value_detection.py::TestMissingValueDetector::test_transform", "tests/unit/modules/test_profile_neural_network.py::TestPNN::test_save_if_fitted", "tests/unit/modules/test_resample.py::TestResampler::test_downscaling_mean", "tests/unit/core/test_probabilistic_step.py::TestProbabilisticStep::test_transform_no_prob_method", "tests/unit/core/test_summary_step.py::TestSummaryStep::test_store", "tests/unit/modules/test_differentiate.py::TestResampler::test_target_index_none", "tests/unit/modules/test_profile_neural_network.py::TestPNN::test_transform", "tests/unit/summaries/test_mean_absolute_error.py::TestMAE::test_get_params", "tests/unit/modules/test_rolling_rmse.py::TestRollingRMSE::test_set_params", "tests/unit/modules/test_change_direction.py::TestChangeDirection::test_get_params", "tests/unit/core/test_summary_step.py::TestSummaryStep::test_load", "tests/unit/core/test_either_or_step.py::TestEitherOrStep::test_load", "tests/unit/modules/test_mean_absolute_error.py::TestMaeCalculator::test_transform_rolling", "tests/unit/summaries/test_mean_abs_percentage_error.py::TestMAE::test_save", "tests/unit/summaries/test_mean_absolute_error.py::TestMAE::test_transform", "tests/unit/wrapper/test_statsmodels_wrapper.py::TestSmTimeSeriesModelWrapper::test_load", "tests/unit/summaries/test_mean_abs_percentage_error.py::TestMAE::test_load", "tests/unit/wrapper/test_sklearn_wrapper.py::TestSklearnWrapper::test_fit_RegressorMixin", "tests/unit/modules/test_root_mean_squared_error.py::TestRMSECalculator::test_transform_without_predictions", "tests/unit/modules/test_linear_interpolation.py::TestLinearInterpolater::test_get_params", "tests/unit/core/test_step.py::TestStep::test_fit", "tests/unit/summaries/test_min_error.py::TestMinErr::test_get_params", "tests/unit/modules/test_rolling_mean.py::TestRollingMean::test_transform_groupbyWeekendWeekdayAndHoliday", "tests/unit/modules/test_missing_value_detection.py::TestMissingValueDetector::test_get_params", "tests/unit/modules/test_rolling_variance.py::TestRollingVariance::test_transform_groupbyNo", "tests/unit/core/test_pipeline.py::TestPipeline::test_from_folder", "tests/unit/modules/test_rolling_mean.py::TestRollingMean::test_transform_groupbyNo", "tests/unit/wrapper/test_statsmodels_wrapper.py::TestSmTimeSeriesModelWrapper::test_get_params", "tests/unit/summaries/test_root_mean_squared_error.py::TestRMSE::test_save", "tests/unit/wrapper/test_keras_wrapper.py::TestKerasWrapper::test_set_params", "tests/unit/core/test_inverse_step.py::TestInverseTransform::test_transform_no_inverse_method", "tests/unit/modules/test_resample.py::TestResampler::test_upscaling_interpolation", "tests/unit/modules/test_root_mean_squared_error.py::TestRMSECalculator::test_transform_rolling", "tests/unit/modules/test_profile_neural_network.py::TestPNN::test_save_if_not_fitted", "tests/unit/modules/test_root_mean_squared_error.py::TestRMSECalculator::test_get_params", "tests/unit/summaries/test_mean_abs_percentage_error.py::TestMAE::test_transform", "tests/unit/wrapper/test_statsmodels_wrapper.py::TestSmTimeSeriesModelWrapper::test_fit", "tests/unit/wrapper/test_pytorch_wrapper.py::TestPyTorchWrapper::test_set_params", "tests/unit/core/test_step.py::TestStep::test_load", "tests/unit/wrapper/test_statsmodels_wrapper.py::TestSmTimeSeriesModelWrapper::test_transform", "tests/unit/core/test_step.py::TestStep::test_fit_with_targets", "tests/unit/core/test_summary_step.py::TestSummaryStep::test_get_summary", "tests/unit/core/test_pipeline.py::TestPipeline::test_add_pipeline_to_pipeline_and_save", "tests/unit/modules/test_clock_shift.py::TestClockShift::test_get_params", "tests/unit/modules/test_rolling_kurtosis.py::TestRollingKurtosis::test_set_params", "tests/unit/wrapper/test_sklearn_wrapper.py::TestSklearnWrapper::test_set_params", "tests/unit/summaries/test_root_mean_squared_error.py::TestRMSE::test_transform_with_filter", "tests/unit/modules/test_sample_module.py::TestSampler::test_transform", "tests/unit/modules/test_rolling_variance.py::TestRollingVariance::test_set_params", "tests/unit/modules/test_rolling_mean.py::TestRollingMean::test_get_params", "tests/unit/summaries/test_root_mean_squared_error.py::TestRMSE::test_transform", "tests/unit/wrapper/test_sklearn_wrapper.py::TestSklearnWrapper::test_fit_ClusterMixin", "tests/unit/wrapper/test_keras_wrapper.py::TestKerasWrapper::test_transform_multiple_output", "tests/unit/wrapper/test_pytorch_wrapper.py::TestPyTorchWrapper::test_fit_transform_PyTorchModel", "tests/unit/modules/test_calendar_extraction.py::TestCalendarExtraction::test_invalid_input", "tests/unit/modules/test_linear_interpolation.py::TestLinearInterpolater::test_set_params", "tests/unit/summaries/test_min_error.py::TestMinErr::test_transform_with_filter", "tests/unit/summaries/test_min_error.py::TestMinErr::test_transform", "tests/unit/modules/test_trend_extraction.py::TestTrendExtraction::test_set_params", "tests/unit/core/test_filemanager.py::TestFilemanager::test_duplicate_filename", "tests/integration/test_simple_pipeline.py::TestSimplePipeline::test_create_and_run_simple_pipeline", "tests/unit/modules/test_rolling_skewness.py::TestRollingSkewness::test_transform_groupbyNo", "tests/unit/wrapper/test_pytorch_wrapper.py::TestPyTorchWrapper::test_fit_PyTorchModel", "tests/unit/summaries/test_root_mean_squared_error.py::TestRMSE::test_get_params", "tests/unit/core/test_pipeline.py::TestPipeline::test_add_pipeline_to_pipeline_and_train", "tests/unit/modules/test_root_mean_squared_error.py::TestRMSECalculator::test_transform", "tests/unit/modules/test_mean_absolute_error.py::TestMaeCalculator::test_transform_without_predictions", "tests/unit/core/test_step.py::TestStep::test_get_result", "tests/unit/core/test_pipeline.py::TestPipeline::test_add_only_module", "tests/unit/wrapper/test_sklearn_wrapper.py::TestSklearnWrapper::test_get_params", "tests/unit/wrapper/test_function_module.py::TestFunctionModule::test_transform", "tests/unit/modules/test_mean_absolute_error.py::TestMaeCalculator::test_set_params", "tests/unit/modules/test_resample.py::TestResampler::test_get_set_params", "tests/unit/core/test_step.py::TestStep::test_reset", "tests/unit/core/test_step.py::TestStep::test_transform_batch_with_existing_buffer", "tests/unit/summaries/test_mean_abs_percentage_error.py::TestMAE::test_set_params", "tests/unit/wrapper/test_sklearn_wrapper.py::TestSklearnWrapper::test_fit_ClassifierMixin", "tests/unit/core/test_pipeline.py::TestPipeline::test_get_params", "tests/unit/summaries/test_max_error.py::TestMaxErr::test_transform_with_filter", "tests/unit/core/test_step.py::TestStep::test_store_load_of_step_with_train_if", "tests/unit/wrapper/test_function_module.py::TestFunctionModule::test_fit_transform", "tests/unit/wrapper/test_keras_wrapper.py::TestKerasWrapper::test_save", "tests/unit/core/test_pipeline.py::TestPipeline::test_horizon_greater_one_regression_inclusive_summary_file", "tests/unit/summaries/test_max_error.py::TestMaxErr::test_get_params", "tests/unit/modules/test_differentiate.py::TestResampler::test_one_dimensional", "tests/unit/modules/test_differentiate.py::TestResampler::test_linear_diff", "tests/unit/wrapper/test_sklearn_wrapper.py::TestSklearnWrapper::test_fit_regression_multiple_datavariables", "tests/unit/core/test_pipeline.py::TestPipeline::test_load", "tests/unit/modules/test_mean_absolute_error.py::TestMaeCalculator::test_transform", "tests/unit/modules/test_rolling_mean.py::TestRollingMean::test_transform_groupbyWeekendWeekday", "tests/unit/summaries/test_root_mean_squared_error.py::TestRMSE::test_set_params", "tests/unit/summaries/test_min_error.py::TestMinErr::test_transform_without_predictions", "tests/unit/modules/test_linear_interpolation.py::TestLinearInterpolater::test_transform", "tests/unit/wrapper/test_keras_wrapper.py::TestKerasWrapper::test_get_params", "tests/unit/modules/test_rolling_mae.py::TestRollingMAE::test_transform_without_predictions", "tests/unit/core/test_pipeline.py::TestPipeline::test_add_pipeline_without_index", "tests/unit/core/test_pipeline.py::TestPipeline::test_batch_2H_transform", "tests/unit/summaries/test_mean_absolute_error.py::TestMAE::test_load", "tests/unit/core/test_inverse_step.py::TestInverseTransform::test_get_result", "tests/unit/core/test_pipeline.py::TestPipeline::test_add_with_target", "tests/unit/core/test_either_or_step.py::TestEitherOrStep::test_transform", "tests/unit/summaries/test_mean_abs_percentage_error.py::TestMAE::test_transform_with_filter", "tests/unit/summaries/test_mean_absolute_error.py::TestMAE::test_set_params", "tests/unit/modules/test_differentiate.py::TestResampler::test_three_dimensional", "tests/unit/modules/test_trend_extraction.py::TestTrendExtraction::test_get_params", "tests/unit/summaries/test_mean_abs_percentage_error.py::TestMAE::test_transform_without_predictions", "tests/unit/modules/test_clock_shift.py::TestClockShift::test_set_params", "tests/unit/core/test_probabilistic_step.py::TestProbabilisticStep::test_transform", "tests/unit/core/test_pipeline.py::TestPipeline::test_add_module_with_inputs", "tests/unit/modules/test_calendar_extraction.py::TestCalendarExtraction::test_get_set_params", "tests/unit/core/test_filemanager.py::TestFilemanager::test_not_allowed_filetype", "tests/unit/wrapper/test_sklearn_wrapper.py::TestSklearnWrapper::test_transform_RegressorMixin", "tests/unit/summaries/test_max_error.py::TestMaxErr::test_transform", "tests/unit/core/test_pipeline.py::TestPipeline::test_multiple_same_module", "tests/unit/core/test_step.py::TestStep::test_further_elements_already_buffered", "tests/unit/modules/test_calendar_extraction.py::TestCalendarExtraction::test_encoding"], "language": "python", "test_command": "source /saved/ENV || source /saved/*/ENV && pytest --no-header -rA --tb=no -p no:cacheprovider --continue-on-collection-errors", "test_output_parser": "python/parse_log_pytest_v3", "image_storage_uri": "vmvm-registry.fbinfra.net/repomate_image_activ_pytest/kit-iai_pywatts:71961293aca113740f27133fab12e7d71bac9233", "patch": "[\"diff --git a/pywatts/core/base_step.py b/pywatts/core/base_step.py\\nindex 4a09c388..69ad2546 100644\\n--- a/pywatts/core/base_step.py\\n+++ b/pywatts/core/base_step.py\\n@@ -43,8 +43,7 @@ def __init__(self,  input_steps: Optional[Dict[str, \\\"BaseStep\\\"]]=None,\\n         self.buffer: Dict[str, xr.DataArray] = {}\\n         self.training_time = None\\n \\n-    def get_result(self, start: pd.Timestamp, end: Optional[pd.Timestamp], buffer_element: str = None,\\n-                   return_all=False):\\n+    def get_result(self, start: pd.Timestamp, end: Optional[pd.Timestamp], buffer_element: str = None,                  return_all=False):\\n         \\\"\\\"\\\"\\n         This method is responsible for providing the result of this step.\\n         Therefore,\\n\",\"diff --git a/pywatts/core/base_step.py b/pywatts/core/base_step.py\\nindex 69ad2546..4a09c388 100644\\n--- a/pywatts/core/base_step.py\\n+++ b/pywatts/core/base_step.py\\n@@ -43,7 +43,8 @@ def __init__(self,  input_steps: Optional[Dict[str, \\\"BaseStep\\\"]]=None,\\n         self.buffer: Dict[str, xr.DataArray] = {}\\n         self.training_time = None\\n \\n-    def get_result(self, start: pd.Timestamp, end: Optional[pd.Timestamp], buffer_element: str = None,                  return_all=False):\\n+    def get_result(self, start: pd.Timestamp, end: Optional[pd.Timestamp], buffer_element: str = None,\\n+                   return_all=False):\\n         \\\"\\\"\\\"\\n         This method is responsible for providing the result of this step.\\n         Therefore,\\n\",\"diff --git a/CHANGELOG.md b/CHANGELOG.md\\nindex e52e5daa..f3d107ee 100644\\n--- a/CHANGELOG.md\\n+++ b/CHANGELOG.md\\n@@ -35,6 +35,11 @@\\n * Fix save and load of keras Wrapper  ([#91](https://github.com/KIT-IAI/pyWATTS/issues/91))\\n * Import of pytorchWrapper via wrapper.__init__\\n * Fix the mask for weekends and public holidays in rolling_base  ([#107](https://github.com/KIT-IAI/pyWATTS/issues/107))\\n+* Improved Online Learning Performance  ([#18](https://github.com/KIT-IAI/pyWATTS/issues/18))\\n+  * Add a cache for the most recent value, since this value is often requested by successing modules.\\n+  * Remove unecessary copies\\n+  * Avoid uncessary execution in should_stop \\n+  * Improve performance in sample_module\\n * Fix the extracted time index in rolling RMSE  ([#124](https://github.com/KIT-IAI/pyWATTS/issues/124))\\n * Use raise from if an exception is raise because an other is raised before for retaining the original stack trace  ([#107](https://github.com/KIT-IAI/pyWATTS/issues/123))\\n \\n\",\"diff --git a/pywatts/core/base_step.py b/pywatts/core/base_step.py\\nindex 4a09c388..9771fce2 100644\\n--- a/pywatts/core/base_step.py\\n+++ b/pywatts/core/base_step.py\\n@@ -25,7 +25,7 @@ class BaseStep(ABC):\\n     :type computation_mode: ComputationMode\\n     \\\"\\\"\\\"\\n \\n-    def __init__(self,  input_steps: Optional[Dict[str, \\\"BaseStep\\\"]]=None,\\n+    def __init__(self, input_steps: Optional[Dict[str, \\\"BaseStep\\\"]] = None,\\n                  targets: Optional[Dict[str, \\\"BaseStep\\\"]] = None, condition=None,\\n                  computation_mode=ComputationMode.Default):\\n         self._original_compuation_mode = computation_mode\\n@@ -33,6 +33,7 @@ def __init__(self,  input_steps: Optional[Dict[str, \\\"BaseStep\\\"]]=None,\\n         self.input_steps: Dict[str, \\\"BaseStep\\\"] = dict() if input_steps is None else input_steps\\n         self.targets: Dict[str, \\\"BaseStep\\\"] = dict() if targets is None else targets\\n         self.condition = condition\\n+        self.cached_result = None\\n \\n         self.name = \\\"BaseStep\\\"\\n \\n@@ -62,7 +63,6 @@ def get_result(self, start: pd.Timestamp, end: Optional[pd.Timestamp], buffer_el\\n         :type return_all: bool\\n         :return: The resulting data or None if no data are calculated\\n         \\\"\\\"\\\"\\n-\\n         # Check if step should be executed.\\n         if self._should_stop(start, end):\\n             return None\\n@@ -70,7 +70,7 @@ def get_result(self, start: pd.Timestamp, end: Optional[pd.Timestamp], buffer_el\\n         # Trigger fit and transform if necessary\\n         if not self.finished:\\n             if not self.buffer or not self._current_end or end > self._current_end:\\n-                self._compute(start, end)\\n+                self.cached_result = self._compute(start, end), start, end\\n                 self._current_end = end\\n             if not end:\\n                 self.finished = True\\n@@ -78,6 +78,9 @@ def get_result(self, start: pd.Timestamp, end: Optional[pd.Timestamp], buffer_el\\n                 self.finished = not self.further_elements(end)\\n             self._callbacks()\\n \\n+        if self.cached_result and (self.cached_result[1] == start and self.cached_result[2] == end):\\n+            return self.cached_result[0] if return_all else self.cached_result[0][\\n+                buffer_element] if buffer_element is not None else list(self.cached_result[0].values())[0]\\n         return self._pack_data(start, end, buffer_element, return_all=return_all)\\n \\n     def _compute(self, start, end):\\n@@ -109,14 +112,15 @@ def _pack_data(self, start, end, buffer_element=None, return_all=False):\\n         if end and start and end > start:\\n             index = list(self.buffer.values())[0].indexes[time_index[0]]\\n             start = max(index[0], start.to_numpy())\\n+            # After sel copy is not needed, since it returns a new array.\\n             if buffer_element is not None:\\n-                return self.buffer.copy()[buffer_element].sel(\\n+                return self.buffer[buffer_element].sel(\\n                     **{time_index[0]: index[(index >= start) & (index < end.to_numpy())]})\\n             elif return_all:\\n-                return {key: b.copy().sel(**{time_index[0]: index[(index >= start) & (index < end.to_numpy())]}) for\\n+                return {key: b.sel(**{time_index[0]: index[(index >= start) & (index < end.to_numpy())]}) for\\n                         key, b in self.buffer.items()}\\n             else:\\n-                return list(self.buffer.copy().values())[0].sel(\\n+                return list(self.buffer.values())[0].sel(\\n                     **{time_index[0]: index[(index >= start) & (index < end.to_numpy())]})\\n         else:\\n             self.finished = True\\n@@ -149,6 +153,7 @@ def _post_transform(self, result):\\n             dim = _get_time_indeces(result)[0]\\n             for key in self.buffer.keys():\\n                 self.buffer[key] = xr.concat([self.buffer[key], result[key]], dim=dim)\\n+        return result\\n \\n     def get_json(self, fm: FileManager) -> Dict:\\n         \\\"\\\"\\\"\\n@@ -192,6 +197,8 @@ def _get_target(self, start, batch):\\n \\n     def _should_stop(self, start, end) -> bool:\\n         # Fetch input and target data\\n+        if end is not None and self._current_end is not None and end <= self._current_end:\\n+            return False\\n         input_step = self._get_input(start, end)\\n         target_step = self._get_target(start, end)\\n \\n\",\"diff --git a/pywatts/modules/sample_module.py b/pywatts/modules/sample_module.py\\nindex 481cdf1c..7b218369 100644\\n--- a/pywatts/modules/sample_module.py\\n+++ b/pywatts/modules/sample_module.py\\n@@ -55,7 +55,6 @@ def set_params(self, sample_size: int = None, indexes: List[str] = None):\\n             # Do not use if indexes here, since this would be false if indexes is empty.\\n             self.indexes = indexes\\n \\n-\\n     def transform(self, x: xr.DataArray) -> xr.DataArray:\\n         \\\"\\\"\\\"\\n         Sample the given time series x by the lag.\\n@@ -69,9 +68,9 @@ def transform(self, x: xr.DataArray) -> xr.DataArray:\\n         if not indexes:\\n             indexes = _get_time_indeces(x)\\n         try:\\n-            result = x\\n-            for i in range(1, self.sample_size):\\n-                result = xr.concat([result, x.shift({index: i for index in indexes}, fill_value=0)], dim=\\\"horizon\\\")\\n+            result = xr.concat(\\n+                [x.shift({index: i for index in indexes}, fill_value=0) for i in range(0, self.sample_size)],\\n+                dim=\\\"horizon\\\")\\n         except ValueError as exc:\\n             raise WrongParameterException(\\n                 f\\\"Not all indexes ({indexes}) are in the indexes of x ({list(x.indexes.keys())}).\\\",\\n\",\"diff --git a/CHANGELOG.md b/CHANGELOG.md\\nindex f3d107ee..73f8604a 100644\\n--- a/CHANGELOG.md\\n+++ b/CHANGELOG.md\\n@@ -40,6 +40,8 @@\\n   * Remove unecessary copies\\n   * Avoid uncessary execution in should_stop \\n   * Improve performance in sample_module\\n+  * Improve performance in trend_extraction\\n+  * Callbacks are only executed if the step is finished. No intermediate results are plotted.\\n * Fix the extracted time index in rolling RMSE  ([#124](https://github.com/KIT-IAI/pyWATTS/issues/124))\\n * Use raise from if an exception is raise because an other is raised before for retaining the original stack trace  ([#107](https://github.com/KIT-IAI/pyWATTS/issues/123))\\n \\n\",\"diff --git a/pywatts/core/base_step.py b/pywatts/core/base_step.py\\nindex 9771fce2..4f587394 100644\\n--- a/pywatts/core/base_step.py\\n+++ b/pywatts/core/base_step.py\\n@@ -33,7 +33,7 @@ def __init__(self, input_steps: Optional[Dict[str, \\\"BaseStep\\\"]] = None,\\n         self.input_steps: Dict[str, \\\"BaseStep\\\"] = dict() if input_steps is None else input_steps\\n         self.targets: Dict[str, \\\"BaseStep\\\"] = dict() if targets is None else targets\\n         self.condition = condition\\n-        self.cached_result = None\\n+        self.cached_result = None, None, None\\n \\n         self.name = \\\"BaseStep\\\"\\n \\n@@ -68,7 +68,7 @@ def get_result(self, start: pd.Timestamp, end: Optional[pd.Timestamp], buffer_el\\n             return None\\n \\n         # Trigger fit and transform if necessary\\n-        if not self.finished:\\n+        if not self.finished and not (end is not None and self._current_end is not None and end <= self._current_end):\\n             if not self.buffer or not self._current_end or end > self._current_end:\\n                 self.cached_result = self._compute(start, end), start, end\\n                 self._current_end = end\\n@@ -76,14 +76,16 @@ def get_result(self, start: pd.Timestamp, end: Optional[pd.Timestamp], buffer_el\\n                 self.finished = True\\n             else:\\n                 self.finished = not self.further_elements(end)\\n-            self._callbacks()\\n+            # Only call callbacks if the step is finished\\n+            if self.finished:\\n+                self._callbacks()\\n \\n-        if self.cached_result and (self.cached_result[1] == start and self.cached_result[2] == end):\\n+        if self.cached_result[0] is not None and self.cached_result[1] == start and self.cached_result[2] == end:\\n             return self.cached_result[0] if return_all else self.cached_result[0][\\n                 buffer_element] if buffer_element is not None else list(self.cached_result[0].values())[0]\\n         return self._pack_data(start, end, buffer_element, return_all=return_all)\\n \\n-    def _compute(self, start, end):\\n+    def _compute(self, start, end) -> Dict[str, xr.DataArray]:\\n         pass\\n \\n     def further_elements(self, counter: pd.Timestamp) -> bool:\\n@@ -197,15 +199,13 @@ def _get_target(self, start, batch):\\n \\n     def _should_stop(self, start, end) -> bool:\\n         # Fetch input and target data\\n-        if end is not None and self._current_end is not None and end <= self._current_end:\\n-            return False\\n-        input_step = self._get_input(start, end)\\n-        target_step = self._get_target(start, end)\\n-\\n-        return (self.condition is not None and not self.condition(input_step, target_step)) or \\\\\\n-               (len(self.input_steps) > 0 and\\n-                any(map(lambda x: x._should_stop(start, end), self.input_steps.values()))) or \\\\\\n-               (len(self.targets) > 0 and any(map(lambda x: x._should_stop(start, end), self.targets.values())))\\n+        input_result = self._get_input(start, end)\\n+        target_result = self._get_target(start, end)\\n+\\n+        return (self.condition is not None and not self.condition(input_result, target_result)) or \\\\\\n+               (input_result is not None and len(input_result) > 0 and\\n+                any(map(lambda x: x is None, input_result.values()))) or \\\\\\n+               (target_result is not None and len(target_result) > 0 and any(map(lambda x: x is None, target_result.values())))\\n \\n     def reset(self):\\n         \\\"\\\"\\\"\\n\",\"diff --git a/pywatts/core/either_or_step.py b/pywatts/core/either_or_step.py\\nindex 821965de..c7e0c6ef 100644\\n--- a/pywatts/core/either_or_step.py\\n+++ b/pywatts/core/either_or_step.py\\n@@ -30,8 +30,7 @@ def _transform(self, input_step):\\n         for in_step in input_step:\\n             if in_step is not None:\\n                 # This buffer is never changed in this step. Consequently, no copy is necessary..\\n-                self._post_transform(in_step)\\n-                return\\n+                return self._post_transform(in_step)\\n \\n     @classmethod\\n     def load(cls, stored_step: dict, inputs, targets, module, file_manager):\\n\",\"diff --git a/pywatts/core/inverse_step.py b/pywatts/core/inverse_step.py\\nindex c29c5afe..af4b2a21 100644\\n--- a/pywatts/core/inverse_step.py\\n+++ b/pywatts/core/inverse_step.py\\n@@ -30,4 +30,4 @@ def _transform(self, input_step):\\n             raise KindOfTransformDoesNotExistException(f\\\"The module {self.module.name} has no inverse transform\\\",\\n                                                        KindOfTransform.INVERSE_TRANSFORM)\\n \\n-        self._post_transform(self.module.inverse_transform(**input_step))\\n+        return self._post_transform(self.module.inverse_transform(**input_step))\\n\",\"diff --git a/pywatts/core/step.py b/pywatts/core/step.py\\nindex 4e43f8f6..04a0b743 100644\\n--- a/pywatts/core/step.py\\n+++ b/pywatts/core/step.py\\n@@ -78,8 +78,7 @@ def _transform(self, input_step):\\n             logger.error(message)\\n             raise NotFittedException(message, self.name, self.module.name)\\n         result = self.module.transform(**input_step)\\n-        self._post_transform(result)\\n-        return result\\n+        return self._post_transform(result)\\n \\n     @classmethod\\n     def load(cls, stored_step: Dict, inputs, targets, module, file_manager):\\n@@ -135,7 +134,7 @@ def _compute(self, start, end):\\n         elif self.module is BaseEstimator:\\n             logger.info(\\\"%s not fitted in Step %s\\\", self.module.name, self.name)\\n \\n-        self._transform(input_data)\\n+        return self._transform(input_data)\\n \\n     def _get_target(self, start, batch):\\n         return {\\n\",\"diff --git a/pywatts/modules/sample_module.py b/pywatts/modules/sample_module.py\\nindex 7b218369..f80d6cdb 100644\\n--- a/pywatts/modules/sample_module.py\\n+++ b/pywatts/modules/sample_module.py\\n@@ -5,6 +5,7 @@\\n from pywatts.core.base import BaseTransformer\\n from pywatts.core.exceptions.wrong_parameter_exception import WrongParameterException\\n from pywatts.utils._xarray_time_series_utils import _get_time_indeces\\n+import numpy as np\\n \\n \\n class Sampler(BaseTransformer):\\n@@ -68,14 +69,11 @@ def transform(self, x: xr.DataArray) -> xr.DataArray:\\n         if not indexes:\\n             indexes = _get_time_indeces(x)\\n         try:\\n-            result = xr.concat(\\n-                [x.shift({index: i for index in indexes}, fill_value=0) for i in range(0, self.sample_size)],\\n-                dim=\\\"horizon\\\")\\n+            r = [x.shift({index: i for index in indexes}, fill_value=0) for i in range(0, self.sample_size)]\\n         except ValueError as exc:\\n             raise WrongParameterException(\\n                 f\\\"Not all indexes ({indexes}) are in the indexes of x ({list(x.indexes.keys())}).\\\",\\n                 \\\"Perhaps you set the wrong indexes with set_params or during the initialization of the Sampler.\\\",\\n                 module=self.name) from exc\\n-        result = result.transpose(_get_time_indeces(x)[0], \\\"horizon\\\", ...)\\n-\\n-        return result\\n+        result = xr.DataArray(np.stack(r, axis=-1), dims=(*x.dims, \\\"horizon\\\"), coords=x.coords)\\n+        return result.transpose(_get_time_indeces(x)[0], \\\"horizon\\\", ...)\\n\",\"diff --git a/pywatts/modules/trend_extraction.py b/pywatts/modules/trend_extraction.py\\nindex 181bbebd..f343ca7f 100644\\n--- a/pywatts/modules/trend_extraction.py\\n+++ b/pywatts/modules/trend_extraction.py\\n@@ -8,6 +8,7 @@\\n \\n from pywatts.core.base import BaseTransformer\\n from pywatts.utils._xarray_time_series_utils import _get_time_indeces\\n+import numpy as np\\n \\n \\n class TrendExtraction(BaseTransformer):\\n@@ -79,8 +80,7 @@ def transform(self, x: xr.DataArray) -> xr.DataArray:\\n         indexes = self.indexes\\n         if not indexes:\\n             indexes = _get_time_indeces(x)\\n-        trend = x.shift({index: self.period for index in indexes}, fill_value=0)\\n-        for i in range(2, self.length + 1):\\n-            trend = xr.concat([trend,\\n-                               x.shift({index: self.period * i for index in indexes}, fill_value=0)], dim=\\\"length\\\")\\n+        trends = [x.shift({index: self.period * i for index in indexes}, fill_value=0) for i in\\n+                  range(1, self.length + 1)]\\n+        trend = xr.DataArray(np.stack(trends, axis=-1), dims=(*x.dims, \\\"length\\\"), coords=x.coords)\\n         return trend.transpose(_get_time_indeces(x)[0], \\\"length\\\", ...)\\n\",\"diff --git a/pywatts/core/probabilistic_step.py b/pywatts/core/probabilistic_step.py\\nindex 92fec55d..faf4ad61 100644\\n--- a/pywatts/core/probabilistic_step.py\\n+++ b/pywatts/core/probabilistic_step.py\\n@@ -34,4 +34,4 @@ def _transform(self, input_step):\\n             raise KindOfTransformDoesNotExistException(f\\\"The module {self.module.name} has no probablisitic transform\\\",\\n                                                        KindOfTransform.PROBABILISTIC_TRANSFORM)\\n \\n-        self._post_transform(self.module.predict_proba(input_step))\\n+        return self._post_transform(self.module.predict_proba(input_step))\\n\",\"diff --git a/pywatts/core/base_step.py b/pywatts/core/base_step.py\\nindex 4f587394..6a7b11ca 100644\\n--- a/pywatts/core/base_step.py\\n+++ b/pywatts/core/base_step.py\\n@@ -67,7 +67,7 @@ def get_result(self, start: pd.Timestamp, end: Optional[pd.Timestamp], buffer_el\\n         if self._should_stop(start, end):\\n             return None\\n \\n-        # Trigger fit and transform if necessary\\n+        # Only execute the module if the step is not finished and the results are not yet calculated\\n         if not self.finished and not (end is not None and self._current_end is not None and end <= self._current_end):\\n             if not self.buffer or not self._current_end or end > self._current_end:\\n                 self.cached_result = self._compute(start, end), start, end\\n@@ -76,10 +76,12 @@ def get_result(self, start: pd.Timestamp, end: Optional[pd.Timestamp], buffer_el\\n                 self.finished = True\\n             else:\\n                 self.finished = not self.further_elements(end)\\n+\\n             # Only call callbacks if the step is finished\\n             if self.finished:\\n                 self._callbacks()\\n \\n+        # Check if the cached results fits to the request, if yes return it.\\n         if self.cached_result[0] is not None and self.cached_result[1] == start and self.cached_result[2] == end:\\n             return self.cached_result[0] if return_all else self.cached_result[0][\\n                 buffer_element] if buffer_element is not None else list(self.cached_result[0].values())[0]\\n@@ -202,10 +204,13 @@ def _should_stop(self, start, end) -> bool:\\n         input_result = self._get_input(start, end)\\n         target_result = self._get_target(start, end)\\n \\n+        # Check if either the condition is True or some of the previous steps stopped (return_value is None)\\n         return (self.condition is not None and not self.condition(input_result, target_result)) or \\\\\\n-               (input_result is not None and len(input_result) > 0 and\\n-                any(map(lambda x: x is None, input_result.values()))) or \\\\\\n-               (target_result is not None and len(target_result) > 0 and any(map(lambda x: x is None, target_result.values())))\\n+                self._input_stopped(input_result) or self._input_stopped(target_result)\\n+\\n+    @staticmethod\\n+    def _input_stopped(input_data):\\n+        return (input_data is not None and len(input_data) > 0 and any(map(lambda x: x is None, input_data.values())))\\n \\n     def reset(self):\\n         \\\"\\\"\\\"\\n\",\"diff --git a/pywatts/core/step.py b/pywatts/core/step.py\\nindex 04a0b743..278c6d0c 100644\\n--- a/pywatts/core/step.py\\n+++ b/pywatts/core/step.py\\n@@ -102,7 +102,7 @@ def load(cls, stored_step: Dict, inputs, targets, module, file_manager):\\n         else:\\n             train_if = None\\n         callbacks = []\\n-        for callback_path in  stored_step[\\\"callbacks\\\"]:\\n+        for callback_path in stored_step[\\\"callbacks\\\"]:\\n             with open(callback_path, 'rb') as pickle_file:\\n                 callback = cloudpickle.load(pickle_file)\\n             callback.set_filemanager(file_manager)\\n\",\"diff --git a/pywatts/core/base_step.py b/pywatts/core/base_step.py\\nindex 6a7b11ca..e35be31a 100644\\n--- a/pywatts/core/base_step.py\\n+++ b/pywatts/core/base_step.py\\n@@ -1,6 +1,7 @@\\n import logging\\n from abc import ABC, abstractmethod\\n from typing import Optional, Dict\\n+import copy\\n \\n import pandas as pd\\n import xarray as xr\\n@@ -33,7 +34,7 @@ def __init__(self, input_steps: Optional[Dict[str, \\\"BaseStep\\\"]] = None,\\n         self.input_steps: Dict[str, \\\"BaseStep\\\"] = dict() if input_steps is None else input_steps\\n         self.targets: Dict[str, \\\"BaseStep\\\"] = dict() if targets is None else targets\\n         self.condition = condition\\n-        self.cached_result = None, None, None\\n+        self.cached_result = {\\\"cached\\\": None, \\\"start\\\": None, \\\"end\\\": None}\\n \\n         self.name = \\\"BaseStep\\\"\\n \\n@@ -70,7 +71,9 @@ def get_result(self, start: pd.Timestamp, end: Optional[pd.Timestamp], buffer_el\\n         # Only execute the module if the step is not finished and the results are not yet calculated\\n         if not self.finished and not (end is not None and self._current_end is not None and end <= self._current_end):\\n             if not self.buffer or not self._current_end or end > self._current_end:\\n-                self.cached_result = self._compute(start, end), start, end\\n+                self.cached_result[\\\"cached\\\"] = self._compute(start, end)\\n+                self.cached_result[\\\"start\\\"] = start\\n+                self.cached_result[\\\"end\\\"] = end\\n                 self._current_end = end\\n             if not end:\\n                 self.finished = True\\n@@ -82,9 +85,11 @@ def get_result(self, start: pd.Timestamp, end: Optional[pd.Timestamp], buffer_el\\n                 self._callbacks()\\n \\n         # Check if the cached results fits to the request, if yes return it.\\n-        if self.cached_result[0] is not None and self.cached_result[1] == start and self.cached_result[2] == end:\\n-            return self.cached_result[0] if return_all else self.cached_result[0][\\n-                buffer_element] if buffer_element is not None else list(self.cached_result[0].values())[0]\\n+        if self.cached_result[\\\"cached\\\"] is not None and self.cached_result[\\\"start\\\"] == start and self.cached_result[\\n+            \\\"end\\\"] == end:\\n+            return copy.deepcopy(self.cached_result[\\\"cached\\\"]) if return_all else copy.deepcopy(self.cached_result[\\\"cached\\\"][\\n+                buffer_element]) if buffer_element is not None else copy.deepcopy(list(self.cached_result[\\\"cached\\\"].values())[\\n+                0])\\n         return self._pack_data(start, end, buffer_element, return_all=return_all)\\n \\n     def _compute(self, start, end) -> Dict[str, xr.DataArray]:\\n@@ -131,9 +136,9 @@ def _pack_data(self, start, end, buffer_element=None, return_all=False):\\n             if buffer_element is not None:\\n                 return self.buffer[buffer_element].copy()\\n             elif return_all:\\n-                return self.buffer.copy()\\n+                return copy.deepcopy(self.buffer)\\n             else:\\n-                return list(self.buffer.copy().values())[0]\\n+                return list(self.buffer.values())[0].copy()\\n \\n     def _transform(self, input_step):\\n         pass\\n@@ -206,7 +211,7 @@ def _should_stop(self, start, end) -> bool:\\n \\n         # Check if either the condition is True or some of the previous steps stopped (return_value is None)\\n         return (self.condition is not None and not self.condition(input_result, target_result)) or \\\\\\n-                self._input_stopped(input_result) or self._input_stopped(target_result)\\n+               self._input_stopped(input_result) or self._input_stopped(target_result)\\n \\n     @staticmethod\\n     def _input_stopped(input_data):\\n\"]", "test_patch": "[\"diff --git a/tests/unit/core/test_inverse_step.py b/tests/unit/core/test_inverse_step.py\\nindex 1872d64a..ef4a67f4 100644\\n--- a/tests/unit/core/test_inverse_step.py\\n+++ b/tests/unit/core/test_inverse_step.py\\n@@ -36,7 +36,7 @@ def test_get_result(self):\\n         self.inverse_module.inverse_transform.assert_called_once_with(input=self.input_step.get_result())\\n \\n     def test_get_result_stop(self):\\n-        self.input_step._should_stop.return_value = True\\n+        self.input_step.get_result.return_value = None\\n         self.inverse_step.get_result(None, None)\\n \\n         self.inverse_module.inverse_transform.assert_not_called()\\n\",\"diff --git a/tests/unit/core/test_probabilistic_step.py b/tests/unit/core/test_probabilistic_step.py\\nindex 3639a28a..c4bcb4c9 100644\\n--- a/tests/unit/core/test_probabilistic_step.py\\n+++ b/tests/unit/core/test_probabilistic_step.py\\n@@ -29,7 +29,7 @@ def test_transform(self):\\n         self.probabilistic_module.predict_proba.assert_called_once_with(input_mock)\\n \\n     def test_get_result_stop(self):\\n-        self.input_step._should_stop.return_value = True\\n+        self.input_step.get_result.return_value = None\\n \\n         self.probabilistic_step.get_result(pd.Timestamp(\\\"2000.01.01\\\"), pd.Timestamp(\\\"2000.01.02\\\"))\\n \\n\",\"diff --git a/tests/unit/core/test_start_step.py b/tests/unit/core/test_start_step.py\\nindex 102a5218..a44813f4 100644\\n--- a/tests/unit/core/test_start_step.py\\n+++ b/tests/unit/core/test_start_step.py\\n@@ -1,4 +1,8 @@\\n import unittest\\n+import pandas as pd\\n+import xarray as xr\\n+\\n+from unittest.mock import MagicMock\\n \\n from pywatts.core.start_step import StartStep\\n \\n@@ -15,8 +19,28 @@ def test_load(self):\\n             \\\"module\\\": \\\"pywatts.core.start_step\\\",\\n             \\\"class\\\": \\\"StartStep\\\",\\n             \\\"name\\\": \\\"StartStep\\\",\\n-            \\\"last\\\":False\\n+            \\\"last\\\": False\\n         }\\n         step = StartStep(None).load(params, None, None, None, None)\\n         json = step.get_json(\\\"file\\\")\\n         self.assertEqual(params, json)\\n+\\n+    def test_get_result_copying(self):\\n+        # Tests if the get_result method calls correctly the previous step and the module\\n+\\n+        input_step = MagicMock()\\n+        input_step_result_mock = MagicMock()\\n+        input_step.get_result.return_value = input_step_result_mock\\n+        input_step._should_stop.return_value = False\\n+\\n+        time = pd.date_range('2000-01-01', freq='1H', periods=7)\\n+        step = StartStep(\\\"x\\\")\\n+        step.buffer = {\\\"x\\\": xr.DataArray([2, 3, 4, 3, 3, 1, 2], dims=[\\\"time\\\"],\\n+                                         coords={'time': time})}\\n+        result1 = step.get_result(None, None)\\n+        result2 = step.get_result(None, None)\\n+\\n+        # result1 and result2 has to be different objects\\n+        result1[1] = 20\\n+\\n+        self.assertNotEqual(result1[1], result2[1])\"]", "hints_text": ""}

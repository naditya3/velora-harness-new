{"instance_id": "1559745158727974", "repo": "tobymao/sqlglot", "base_commit": "2dd8cba03fea94b811ec6bf2c6ce0a60bc48744f", "problem_statement": "Can not convert '||' from redshift to presto/trino when the arguments are not string typed:\\n```\\r\\nsql = \"\"\"\\r\\nselect 'a' || 1 || 1.1\\r\\n\"\"\"\\r\\nconverted_sql = sqlglot.transpile(sql, read=\"redshift\", write=\"trino\")[0]\\r\\nprint(converted_sql)\\r\\n```\\r\\n```\\r\\nSELECT 'a' || 1 || 1.1\\r\\n\\r\\n```\\r\\n\\r\\nTrino would throw error `Unexpected parameters (varchar(1), integer) for function concat. Expected: concat(char(x), char(y)), concat(array(E), E) E, concat(E, array(E)) E, concat(array(E)) E, concat(varchar), concat(varbinary)'` when executing the output SQL, as Trino doesn't covert the type implicitly like Redshift does.", "FAIL_TO_PASS": ["dataframe.unit.test_functions.TestFunctions.test_concat"], "PASS_TO_PASS": ["dataframe.unit.test_functions.TestFunctions.test_atan2", "dataframe.unit.test_functions.TestFunctions.test_base64", "dataframe.unit.test_functions.TestFunctions.test_substring", "dataframe.unit.test_types.TestDataframeTypes.test_byte", "dataframe.unit.test_column.TestDataframeColumn.test_eq", "dataframe.unit.test_functions.TestFunctions.test_unix_timestamp", "test_transpile.TestTranspile.test_unary", "test_expressions.TestExpressions.test_transform_simple", "dataframe.unit.test_functions.TestFunctions.test_acos", "dataframe.unit.test_window.TestDataframeWindow.test_window_rows_between", "dataframe.unit.test_column.TestDataframeColumn.test_rmul", "dialects.test_hive.TestHive.test_regex", "test_expressions.TestExpressions.test_identifier", "test_executor.TestExecutor.test_static_queries", "test_expressions.TestExpressions.test_to_interval", "test_transpile.TestTranspile.test_pretty", "dialects.test_snowflake.TestSnowflake.test_describe_table", "dialects.test_teradata.TestTeradata.test_create", "test_optimizer.TestOptimizer.test_unnest_subqueries", "test_expressions.TestExpressions.test_replace_placeholders", "dataframe.unit.test_functions.TestFunctions.test_bitwise_not", "dataframe.unit.test_functions.TestFunctions.test_stddev", "test_parser.TestParser.test_parse_errors", "test_parser.TestParser.test_missing_by", "dataframe.unit.test_functions.TestFunctions.test_expm1", "dataframe.unit.test_functions.TestFunctions.test_make_date", "dataframe.unit.test_functions.TestFunctions.test_sum", "test_diff.TestDiff.test_simple", "dialects.test_dialect.TestDialect.test_nullsafe_neq", "dialects.test_presto.TestPresto.test_interval_plural_to_singular", "dataframe.unit.test_functions.TestFunctions.test_month", "dataframe.unit.test_functions.TestFunctions.test_cot", "dataframe.unit.test_types.TestDataframeTypes.test_binary", "dialects.test_redshift.TestRedshift.test_varchar_max", "dataframe.unit.test_column.TestDataframeColumn.test_like", "dataframe.unit.test_functions.TestFunctions.test_tanh", "test_transpile.TestTranspile.test_some", "test_expressions.TestExpressions.test_union", "test_lineage.TestLineage.test_lineage_cte_name_appears_in_schema", "dialects.test_snowflake.TestSnowflake.test_table_literal", "test_diff.TestDiff.test_window_functions", "dataframe.unit.test_functions.TestFunctions.test_array_repeat", "dialects.test_teradata.TestTeradata.test_insert", "dialects.test_hive.TestHive.test_hive", "test_transpile.TestTranspile.test_alias", "dataframe.unit.test_functions.TestFunctions.test_stddev_samp", "dialects.test_dialect.TestDialect.test_transactions", "dataframe.unit.test_functions.TestFunctions.test_expr", "dataframe.unit.test_session.TestDataframeSession.test_typed_schema_nested", "dataframe.unit.test_functions.TestFunctions.test_last", "dataframe.unit.test_functions.TestFunctions.test_ceil", "dataframe.unit.test_functions.TestFunctions.test_to_json", "dataframe.unit.test_window.TestDataframeWindow.test_window_order_by", "test_helper.TestHelper.test_compare_dialects", "dataframe.unit.test_functions.TestFunctions.test_signum", "dataframe.unit.test_functions.TestFunctions.test_hypot", "dataframe.unit.test_functions.TestFunctions.test_isnan", "dataframe.unit.test_functions.TestFunctions.test_quarter", "dataframe.unit.test_functions.TestFunctions.test_flatten", "dialects.test_teradata.TestTeradata.test_datatype", "test_time.TestTime.test_format_time", "dialects.test_databricks.TestDatabricks.test_add_date", "dataframe.unit.test_functions.TestFunctions.test_transform", "dataframe.unit.test_types.TestDataframeTypes.test_struct_field", "dataframe.unit.test_functions.TestFunctions.test_from_json", "dataframe.unit.test_functions.TestFunctions.test_dense_rank", "dataframe.unit.test_functions.TestFunctions.test_instr", "dialects.test_mysql.TestMySQL.test_show_name", "dataframe.unit.test_functions.TestFunctions.test_desc", "dialects.test_presto.TestPresto.test_presto", "dataframe.unit.test_session.TestDataframeSession.test_sql_create", "test_schema.TestSchema.test_schema_catalog", "test_parser.TestParser.test_comment_error_n", "dialects.test_dialect.TestDialect.test_logarithm", "test_optimizer.TestOptimizer.test_scope", "dataframe.unit.test_functions.TestFunctions.test_asc_nulls_last", "dataframe.unit.test_column.TestDataframeColumn.test_radd", "dataframe.unit.test_functions.TestFunctions.test_hash", "dialects.test_snowflake.TestSnowflake.test_stored_procedures", "dataframe.unit.test_dataframe_writer.TestDataFrameWriter.test_saveAsTable_ignore", "dataframe.unit.test_functions.TestFunctions.test_shiftrightunsigned", "dialects.test_tsql.TestTSQL.test_udf", "dialects.test_mysql.TestMySQL.test_show_replica_status", "dataframe.unit.test_session.TestDataframeSession.test_session_create_builder_patterns", "dataframe.unit.test_types.TestDataframeTypes.test_varchar", "dialects.test_hive.TestHive.test_order_by", "dialects.test_redshift.TestRedshift.test_no_schema_binding", "dataframe.unit.test_dataframe.TestDataframe.test_persist_storagelevel", "dialects.test_redshift.TestRedshift.test_redshift", "dataframe.unit.test_functions.TestFunctions.test_months_between", "dataframe.unit.test_column.TestDataframeColumn.test_desc_nulls_last", "dataframe.unit.test_functions.TestFunctions.test_asinh", "test_expressions.TestExpressions.test_selects", "dataframe.unit.test_functions.TestFunctions.test_decode", "dataframe.unit.test_types.TestDataframeTypes.test_struct_type", "test_optimizer.TestOptimizer.test_concat_annotation", "dataframe.unit.test_functions.TestFunctions.test_filter", "dataframe.unit.test_column.TestDataframeColumn.test_mul", "test_optimizer.TestOptimizer.test_pushdown_predicates", "dialects.test_dialect.TestDialect.test_lateral_subquery", "dialects.test_tsql.TestTSQL.test_openjson", "dialects.test_sqlite.TestSQLite.test_ddl", "dataframe.unit.test_functions.TestFunctions.test_shiftright", "dataframe.unit.test_functions.TestFunctions.test_rtrim", "dialects.test_duckdb.TestDuckDB.test_rename_table", "test_optimizer.TestOptimizer.test_optimize", "test_optimizer.TestOptimizer.test_literal_type_annotation", "dataframe.unit.test_column.TestDataframeColumn.test_asc", "dataframe.unit.test_functions.TestFunctions.test_var_pop", "dataframe.unit.test_functions.TestFunctions.test_radians", "dataframe.unit.test_functions.TestFunctions.test_element_at", "dialects.test_tsql.TestTSQL.test_datename", "dataframe.unit.test_functions.TestFunctions.test_input_file_name", "dataframe.unit.test_functions.TestFunctions.test_cbrt", "dialects.test_mysql.TestMySQL.test_show_like_or_where", "test_parser.TestParser.test_column", "test_optimizer.TestOptimizer.test_cache_annotation", "dialects.test_tsql.TestTSQL.test_datepart", "dialects.test_mysql.TestMySQL.test_show_profile", "dataframe.unit.test_functions.TestFunctions.test_covar_samp", "dataframe.unit.test_window.TestDataframeWindow.test_window_range_between", "test_optimizer.TestOptimizer.test_normalize_identifiers", "dialects.test_tableau.TestTableau.test_tableau", "dialects.test_spark.TestSpark.test_current_user", "dialects.test_dialect.TestDialect.test_limit", "dataframe.unit.test_functions.TestFunctions.test_row_number", "dataframe.unit.test_column.TestDataframeColumn.test_rlike", "dataframe.unit.test_functions.TestFunctions.test_map_zip_with", "dataframe.unit.test_window.TestDataframeWindow.test_window_rows_unbounded", "dataframe.unit.test_dataframe_writer.TestDataFrameWriter.test_mode_override", "test_tokens.TestTokens.test_token_line_col", "dataframe.unit.test_functions.TestFunctions.test_kurtosis", "dataframe.unit.test_column.TestDataframeColumn.test_gt", "dataframe.unit.test_functions.TestFunctions.test_rand", "dialects.test_tsql.TestTSQL.test_top", "dataframe.unit.test_functions.TestFunctions.test_overlay", "dialects.test_clickhouse.TestClickhouse.test_ternary", "dialects.test_dialect.TestDialect.test_order_by", "dataframe.unit.test_functions.TestFunctions.test_array_intersect", "dataframe.unit.test_functions.TestFunctions.test_corr", "dataframe.unit.test_functions.TestFunctions.test_raise_error", "dialects.test_dialect.TestDialect.test_cast", "dataframe.unit.test_functions.TestFunctions.test_regexp_replace", "dataframe.unit.test_column.TestDataframeColumn.test_between", "dataframe.unit.test_functions.TestFunctions.test_array_join", "dataframe.unit.test_functions.TestFunctions.test_weekofyear", "test_expressions.TestExpressions.test_alias_or_name", "dataframe.unit.test_functions.TestFunctions.test_json_tuple", "dataframe.unit.test_functions.TestFunctions.test_aggregate", "dataframe.unit.test_functions.TestFunctions.test_map_from_entries", "test_optimizer.TestOptimizer.test_eliminate_joins", "test_expressions.TestExpressions.test_to_dot", "dataframe.unit.test_types.TestDataframeTypes.test_string", "test_expressions.TestExpressions.test_rename_table", "dialects.test_hive.TestHive.test_bits", "dataframe.unit.test_functions.TestFunctions.test_abs", "dataframe.unit.test_column.TestDataframeColumn.test_is_null", "test_optimizer.TestOptimizer.test_derived_tables_column_annotation", "test_executor.TestExecutor.test_execute_tables", "dataframe.unit.test_functions.TestFunctions.test_atan", "dataframe.unit.test_functions.TestFunctions.test_to_utc_timestamp", "test_expressions.TestExpressions.test_unit", "test_transpile.TestTranspile.test_leading_comma", "dialects.test_mysql.TestMySQL.test_show_columns", "dialects.test_dialect.TestDialect.test_substring", "test_generator.TestGenerator.test_identify", "dataframe.unit.test_dataframe_writer.TestDataFrameWriter.test_mode_standalone", "test_optimizer.TestOptimizer.test_lateral_annotation", "dialects.test_snowflake.TestSnowflake.test_user_defined_functions", "dataframe.unit.test_functions.TestFunctions.test_current_timestamp", "test_transpile.TestTranspile.test_space", "dialects.test_starrocks.TestMySQL.test_regex", "dataframe.unit.test_dataframe_writer.TestDataFrameWriter.test_saveAsTable_append", "dataframe.unit.test_column.TestDataframeColumn.test_desc_nulls_first", "dataframe.unit.test_functions.TestFunctions.test_randn", "dataframe.unit.test_column.TestDataframeColumn.test_ilike", "test_parser.TestParser.test_rename_table", "dataframe.unit.test_functions.TestFunctions.test_crc32", "dialects.test_tsql.TestTSQL.test_jsonvalue", "dataframe.unit.test_functions.TestFunctions.test_translate", "dataframe.unit.test_column.TestDataframeColumn.test_and", "test_transforms.TestTransforms.test_unalias_group", "dataframe.unit.test_functions.TestFunctions.test_array_max", "dataframe.unit.test_functions.TestFunctions.test_collect_set", "dataframe.unit.test_functions.TestFunctions.test_from_csv", "dataframe.unit.test_functions.TestFunctions.test_to_date", "dialects.test_snowflake.TestSnowflake.test_null_treatment", "test_transpile.TestTranspile.test_comments", "dialects.test_clickhouse.TestClickhouse.test_ddl", "test_executor.TestExecutor.test_execute_catalog_db_table", "test_expressions.TestExpressions.test_pop", "test_transpile.TestTranspile.test_types", "dataframe.unit.test_functions.TestFunctions.test_dayofyear", "test_expressions.TestExpressions.test_to_column", "dataframe.unit.test_functions.TestFunctions.test_upper", "test_parser.TestParser.test_multi", "dataframe.unit.test_dataframe_writer.TestDataFrameWriter.test_saveAsTable_error", "dataframe.unit.test_column.TestDataframeColumn.test_asc_nulls_last", "dataframe.unit.test_functions.TestFunctions.test_trim", "test_expressions.TestExpressions.test_comment_alias", "dataframe.unit.test_functions.TestFunctions.test_log", "dialects.test_bigquery.TestBigQuery.test_remove_precision_parameterized_types", "test_optimizer.TestOptimizer.test_qualify_columns", "dataframe.unit.test_functions.TestFunctions.test_array_union", "dialects.test_presto.TestPresto.test_time", "dialects.test_redshift.TestRedshift.test_rename_table", "dialects.test_mysql.TestMySQL.test_show_events", "test_expressions.TestExpressions.test_values", "test_optimizer.TestOptimizer.test_schema_with_spaces", "dialects.test_mysql.TestMySQL.test_show_errors", "test_optimizer.TestOptimizer.test_tpch", "dataframe.unit.test_functions.TestFunctions.test_second", "dataframe.unit.test_functions.TestFunctions.test_map_keys", "test_parser.TestParser.test_set_expression", "dataframe.unit.test_functions.TestFunctions.test_sha1", "test_parser.TestParser.test_transactions", "test_transpile.TestTranspile.test_asc", "test_executor.TestExecutor.test_correlated_count", "dataframe.unit.test_functions.TestFunctions.test_current_date", "dialects.test_sqlite.TestSQLite.test_datediff", "test_expressions.TestExpressions.test_transform_multiple_children", "dialects.test_dialect.TestDialect.test_array", "test_optimizer.TestOptimizer.test_cast_type_annotation", "dialects.test_tsql.TestTSQL.test_types", "dataframe.unit.test_functions.TestFunctions.test_md5", "dataframe.unit.test_functions.TestFunctions.test_conv", "dataframe.unit.test_functions.TestFunctions.test_min", "dataframe.unit.test_functions.TestFunctions.test_desc_nulls_first", "dataframe.unit.test_functions.TestFunctions.test_map_filter", "test_parser.TestParser.test_comment_error_r", "dialects.test_presto.TestPresto.test_json", "dialects.test_snowflake.TestSnowflake.test_timestamps", "test_parser.TestParser.test_type_literals", "dataframe.unit.test_window.TestDataframeWindow.test_window_spec_partition_by", "test_build.TestBuild.test_build", "dataframe.unit.test_functions.TestFunctions.test_sec", "dialects.test_mysql.TestMySQL.test_set_variable", "dataframe.unit.test_column.TestDataframeColumn.test_asc_nulls_first", "dataframe.unit.test_functions.TestFunctions.test_array", "dataframe.unit.test_functions.TestFunctions.test_xxhash64", "dataframe.unit.test_functions.TestFunctions.test_lower", "test_lineage.TestLineage.test_lineage_sql_with_cte", "test_executor.TestExecutor.test_set_operations", "dialects.test_starrocks.TestMySQL.test_identity", "dataframe.unit.test_column.TestDataframeColumn.test_neq", "dialects.test_tsql.TestTSQL.test_lateral_table_valued_function", "dataframe.unit.test_functions.TestFunctions.test_exp", "dataframe.unit.test_functions.TestFunctions.test_degrees", "dialects.test_tsql.TestTSQL.test_eomonth", "dataframe.unit.test_functions.TestFunctions.test_max", "dialects.test_clickhouse.TestClickhouse.test_clickhouse", "test_transpile.TestTranspile.test_identity", "dataframe.unit.test_functions.TestFunctions.test_lit", "test_parser.TestParser.test_identify", "test_transforms.TestTransforms.test_eliminate_distinct_on", "test_optimizer.TestOptimizer.test_qualify_tables", "dataframe.unit.test_column.TestDataframeColumn.test_mod", "dataframe.unit.test_types.TestDataframeTypes.test_float", "dialects.test_clickhouse.TestClickhouse.test_parameterization", "dataframe.unit.test_functions.TestFunctions.test_asin", "test_optimizer.TestOptimizer.test_merge_subqueries", "dataframe.unit.test_functions.TestFunctions.test_pos_explode", "dataframe.unit.test_functions.TestFunctions.test_sum_distinct", "dataframe.unit.test_functions.TestFunctions.test_year", "dataframe.unit.test_functions.TestFunctions.test_from_unixtime", "dataframe.unit.test_session.TestDataframeSession.test_sql_with_aggs", "test_parser.TestParser.test_parse_properties", "dialects.test_tsql.TestTSQL.test_add_date", "dataframe.unit.test_functions.TestFunctions.test_min_by", "dataframe.unit.test_session.TestDataframeSession.test_select_quoted", "dataframe.unit.test_functions.TestFunctions.test_length", "dialects.test_mysql.TestMySQL.test_mysql", "dataframe.unit.test_dataframe.TestDataframe.test_hash_select_expression", "dialects.test_snowflake.TestSnowflake.test_parse_like_any", "test_executor.TestExecutor.test_scalar_functions", "dataframe.unit.test_window.TestDataframeWindow.test_window_spec_range_between", "dataframe.unit.test_types.TestDataframeTypes.test_double", "dialects.test_dialect.TestDialect.test_get_or_raise", "test_expressions.TestExpressions.test_find_ancestor", "dialects.test_snowflake.TestSnowflake.test_flatten", "dialects.test_presto.TestPresto.test_encode_decode", "test_transpile.TestTranspile.test_partial", "test_executor.TestExecutor.test_case_sensitivity", "test_tokens.TestTokens.test_command", "dialects.test_spark.TestSpark.test_to_date", "test_executor.TestExecutor.test_optimized_tpch", "dialects.test_bigquery.TestBigQuery.test_group_concat", "dataframe.unit.test_functions.TestFunctions.test_invoke_anonymous", "dataframe.unit.test_functions.TestFunctions.test_octet_length", "test_expressions.TestExpressions.test_functions", "dialects.test_tsql.TestTSQL.test_identifier_prefixes", "dataframe.unit.test_functions.TestFunctions.test_rint", "test_expressions.TestExpressions.test_function_building", "dialects.test_presto.TestPresto.test_cast", "test_optimizer.TestOptimizer.test_recursive_cte", "dataframe.unit.test_functions.TestFunctions.test_log1p", "dataframe.unit.test_column.TestDataframeColumn.test_isin", "test_optimizer.TestOptimizer.test_binary_annotation", "dataframe.unit.test_functions.TestFunctions.test_size", "dialects.test_tsql.TestTSQL.test_iif", "dialects.test_tsql.TestTSQL.test_lateral_subquery", "dialects.test_tsql.TestTSQL.test_system_time", "dataframe.unit.test_column.TestDataframeColumn.test_substring", "test_parser.TestParser.test_parse_floats", "dataframe.unit.test_functions.TestFunctions.test_assert_true", "dataframe.unit.test_functions.TestFunctions.test_dayofmonth", "dialects.test_mysql.TestMySQL.test_ddl", "dialects.test_mysql.TestMySQL.test_introducers", "dataframe.unit.test_functions.TestFunctions.test_repeat", "test_expressions.TestExpressions.test_set_metadata", "dataframe.unit.test_functions.TestFunctions.test_percent_rank", "test_expressions.TestExpressions.test_root", "test_generator.TestGenerator.test_fallback_function_var_args_sql", "dataframe.unit.test_types.TestDataframeTypes.test_array", "dataframe.unit.test_functions.TestFunctions.test_ascii", "dataframe.unit.test_functions.TestFunctions.test_lead", "test_serde.TestSerDe.test_custom_expression", "dialects.test_bigquery.TestBigQuery.test_merge", "test_optimizer.TestOptimizer.test_boolean_type_annotation", "dataframe.unit.test_functions.TestFunctions.test_percentile_approx", "dataframe.unit.test_functions.TestFunctions.test_tan", "dialects.test_mysql.TestMySQL.test_escape", "dataframe.unit.test_functions.TestFunctions.test_add_months", "dataframe.unit.test_functions.TestFunctions.test_cume_dist", "dialects.test_tsql.TestTSQL.test_replicate", "test_transpile.TestTranspile.test_error_level", "dialects.test_mysql.TestMySQL.test_show_grants", "dialects.test_presto.TestPresto.test_regex", "test_serde.TestSerDe.test_serde", "dataframe.unit.test_types.TestDataframeTypes.test_boolean", "dialects.test_spark.TestSpark.test_ddl", "dialects.test_oracle.TestOracle.test_hints", "dialects.test_spark.TestSpark.test_bool_or", "dialects.test_dialect.TestDialect.test_hash_comments", "dataframe.unit.test_functions.TestFunctions.test_first", "dataframe.unit.test_window.TestDataframeWindow.test_window_spec_rows_between", "dialects.test_clickhouse.TestClickhouse.test_cte", "dataframe.unit.test_column.TestDataframeColumn.test_startswith", "dataframe.unit.test_functions.TestFunctions.test_schema_of_json", "test_expressions.TestExpressions.test_convert", "test_transpile.TestTranspile.test_index_offset", "dataframe.unit.test_functions.TestFunctions.test_soundex", "dialects.test_databricks.TestDatabricks.test_databricks", "dataframe.unit.test_dataframe_writer.TestDataFrameWriter.test_quotes", "test_expressions.TestExpressions.test_find", "dataframe.unit.test_functions.TestFunctions.test_get_json_object", "dataframe.unit.test_functions.TestFunctions.test_sha2", "test_expressions.TestExpressions.test_sql", "test_expressions.TestExpressions.test_eq", "test_schema.TestSchema.test_schema_db", "dataframe.unit.test_functions.TestFunctions.test_avg", "test_lineage.TestLineage.test_lineage_source_with_cte", "test_expressions.TestExpressions.test_column", "test_optimizer.TestOptimizer.test_predicate_annotation", "dataframe.unit.test_functions.TestFunctions.test_format_string", "dataframe.unit.test_functions.TestFunctions.test_last_day", "test_optimizer.TestOptimizer.test_optimize_joins", "test_executor.TestExecutor.test_execute_callable", "dataframe.unit.test_dataframe_writer.TestDataFrameWriter.test_insertInto_byName", "dataframe.unit.test_functions.TestFunctions.test_acosh", "test_diff.TestDiff.test_identifier", "dataframe.unit.test_functions.TestFunctions.test_shiftleft", "dialects.test_tsql.TestTSQL.test_isnull", "dataframe.unit.test_column.TestDataframeColumn.test_rdiv", "dialects.test_mysql.TestMySQL.test_mysql_time", "dataframe.unit.test_functions.TestFunctions.test_skewness", "dialects.test_mysql.TestMySQL.test_canonical_functions", "test_diff.TestDiff.test_pre_matchings", "dialects.test_dialect.TestDialect.test_merge", "dialects.test_mysql.TestMySQL.test_convert", "dataframe.unit.test_functions.TestFunctions.test_arrays_overlap", "dataframe.unit.test_functions.TestFunctions.test_transform_values", "dataframe.unit.test_functions.TestFunctions.test_product", "dialects.test_tsql.TestTSQL.test_datefromparts", "dataframe.unit.test_functions.TestFunctions.test_sequence", "test_expressions.TestExpressions.test_arg_key", "dataframe.unit.test_session.TestDataframeSession.test_cdf_str_schema", "dataframe.unit.test_functions.TestFunctions.test_ltrim", "dataframe.unit.test_column.TestDataframeColumn.test_le", "dialects.test_bigquery.TestBigQuery.test_rename_table", "test_expressions.TestExpressions.test_ctes", "dataframe.unit.test_functions.TestFunctions.test_lag", "dataframe.unit.test_functions.TestFunctions.test_floor", "dialects.test_mysql.TestMySQL.test_string_literals", "dataframe.unit.test_functions.TestFunctions.test_array_remove", "test_transpile.TestTranspile.test_normalize_name", "test_transpile.TestTranspile.test_pretty_line_breaks", "test_parser.TestParser.test_pivot_columns", "dataframe.unit.test_functions.TestFunctions.test_date_add", "dialects.test_tsql.TestTSQL.test_format", "test_parser.TestParser.test_unary_plus", "dialects.test_spark.TestSpark.test_hint", "dataframe.unit.test_functions.TestFunctions.test_concat_ws", "dataframe.unit.test_functions.TestFunctions.test_substring_index", "dataframe.unit.test_column.TestDataframeColumn.test_ge", "dataframe.unit.test_session.TestDataframeSession.test_typed_schema_basic", "dialects.test_databricks.TestDatabricks.test_without_as", "dataframe.unit.test_functions.TestFunctions.test_levenshtein", "dataframe.unit.test_column.TestDataframeColumn.test_or", "dataframe.unit.test_functions.TestFunctions.test_session_window", "test_optimizer.TestOptimizer.test_quotes", "dataframe.unit.test_functions.TestFunctions.test_asc", "dialects.test_snowflake.TestSnowflake.test_sample", "test_serde.TestSerDe.test_meta", "dialects.test_mysql.TestMySQL.test_show_engine", "test_expressions.TestExpressions.test_replace", "dialects.test_presto.TestPresto.test_ddl", "test_expressions.TestExpressions.test_transform_with_arguments", "dialects.test_drill.TestDrill.test_string_literals", "test_transpile.TestTranspile.test_unsupported_level", "dataframe.unit.test_types.TestDataframeTypes.test_integer", "dataframe.unit.test_column.TestDataframeColumn.test_cast", "dataframe.unit.test_functions.TestFunctions.test_unhex", "dialects.test_tsql.TestTSQL.test_current_user", "dialects.test_postgres.TestPostgres.test_ddl", "dialects.test_oracle.TestOracle.test_match_recognize", "test_expressions.TestExpressions.test_find_all", "dialects.test_hive.TestHive.test_escapes", "test_transpile.TestTranspile.test_paren", "dataframe.unit.test_session.TestDataframeSession.test_cdf_row_mixed_primitives", "test_transpile.TestTranspile.test_identify_lambda", "dialects.test_clickhouse.TestClickhouse.test_signed_and_unsigned_types", "dataframe.unit.test_functions.TestFunctions.test_least", "test_parser.TestParser.test_lambda_struct", "test_optimizer.TestOptimizer.test_eliminate_ctes", "dataframe.unit.test_functions.TestFunctions.test_reverse", "dataframe.unit.test_dataframe_writer.TestDataFrameWriter.test_saveAsTable_overwrite", "test_transforms.TestTransforms.test_eliminate_qualify", "test_transpile.TestTranspile.test_extract", "dataframe.unit.test_window.TestDataframeWindow.test_window_partition_by", "dialects.test_redshift.TestRedshift.test_create_table_like", "dataframe.unit.test_functions.TestFunctions.test_greatest", "dataframe.unit.test_dataframe_writer.TestDataFrameWriter.test_insertInto_overwrite", "dataframe.unit.test_functions.TestFunctions.test_max_by", "dataframe.unit.test_functions.TestFunctions.test_mean", "dialects.test_dialect.TestDialect.test_alias", "dataframe.unit.test_functions.TestFunctions.test_rpad", "dialects.test_hive.TestHive.test_quotes", "dataframe.unit.test_functions.TestFunctions.test_to_csv", "dataframe.unit.test_functions.TestFunctions.test_coalesce", "test_helper.TestHelper.test_tsort", "dialects.test_databricks.TestDatabricks.test_datediff", "dialects.test_mysql.TestMySQL.test_show_db_like_or_where_sql", "test_parser.TestParser.test_parse_into_errors", "dataframe.unit.test_functions.TestFunctions.test_nanvl", "test_schema.TestSchema.test_schema_add_table_with_and_without_mapping", "test_parser.TestParser.test_create_table_error", "dialects.test_presto.TestPresto.test_hex_unhex", "test_optimizer.TestOptimizer.test_unknown_annotation", "dataframe.unit.test_functions.TestFunctions.test_array_sort", "dialects.test_redshift.TestRedshift.test_values", "dataframe.unit.test_session.TestDataframeSession.test_sql_insert", "test_expressions.TestExpressions.test_is_star", "dialects.test_mysql.TestMySQL.test_show_simple", "dataframe.unit.test_functions.TestFunctions.test_next_day", "dataframe.unit.test_functions.TestFunctions.test_round", "dialects.test_duckdb.TestDuckDB.test_cast", "test_expressions.TestExpressions.test_alias", "dataframe.unit.test_functions.TestFunctions.test_array_zip", "dataframe.unit.test_functions.TestFunctions.test_from_utc_timestamp", "dataframe.unit.test_functions.TestFunctions.test_split", "dataframe.unit.test_column.TestDataframeColumn.test_rpow", "dataframe.unit.test_column.TestDataframeColumn.test_lt", "dialects.test_mysql.TestMySQL.test_show_index", "dataframe.unit.test_functions.TestFunctions.test_date_diff", "dataframe.unit.test_functions.TestFunctions.test_approx_count_distinct", "dataframe.unit.test_types.TestDataframeTypes.test_char", "dialects.test_bigquery.TestBigQuery.test_user_defined_functions", "dialects.test_duckdb.TestDuckDB.test_sample", "dialects.test_snowflake.TestSnowflake.test_ddl", "dialects.test_tsql.TestTSQL.test_date_diff", "dialects.test_mysql.TestMySQL.test_show_processlist", "test_optimizer.TestOptimizer.test_simplify", "dialects.test_spark.TestSpark.test_spark", "test_executor.TestExecutor.test_execute_subqueries", "test_expressions.TestExpressions.test_depth", "dataframe.unit.test_window.TestDataframeWindow.test_window_spec_order_by", "dataframe.unit.test_functions.TestFunctions.test_initcap", "dialects.test_sqlite.TestSQLite.test_longvarchar_dtype", "dialects.test_dialect.TestDialect.test_operators", "dataframe.unit.test_functions.TestFunctions.test_nth_value", "dataframe.unit.test_functions.TestFunctions.test_sort_array", "dialects.test_tsql.TestTSQL.test_hints", "test_lineage.TestLineage.test_lineage", "test_tokens.TestTokens.test_comment_attachment", "dataframe.unit.test_functions.TestFunctions.test_bround", "test_tokens.TestTokens.test_jinja", "dialects.test_dialect.TestDialect.test_set_operators", "test_parser.TestParser.test_parameter", "dataframe.unit.test_functions.TestFunctions.test_minute", "test_transpile.TestTranspile.test_if", "dataframe.unit.test_functions.TestFunctions.test_map_values", "dataframe.unit.test_dataframe.TestDataframe.test_columns", "test_lineage.TestLineage.test_lineage_source_with_star", "dataframe.unit.test_types.TestDataframeTypes.test_long", "dialects.test_drill.TestDrill.test_table_function", "dataframe.unit.test_functions.TestFunctions.test_grouping_id", "test_executor.TestExecutor.test_table_depth_mismatch", "test_expressions.TestExpressions.test_hash", "test_parser.TestParser.test_parse_empty", "test_generator.TestGenerator.test_fallback_function_sql", "dialects.test_mysql.TestMySQL.test_match_against", "dataframe.unit.test_functions.TestFunctions.test_sentences", "dataframe.unit.test_functions.TestFunctions.test_map_entries", "dataframe.unit.test_functions.TestFunctions.test_stddev_pop", "test_diff.TestDiff.test_cte", "test_optimizer.TestOptimizer.test_isolate_table_selects", "dataframe.unit.test_functions.TestFunctions.test_encode", "dataframe.unit.test_functions.TestFunctions.test_sinh", "test_tokens.TestTokens.test_error_msg", "dataframe.unit.test_types.TestDataframeTypes.test_short", "dataframe.unit.test_column.TestDataframeColumn.test_add", "test_schema.TestSchema.test_schema", "dataframe.unit.test_functions.TestFunctions.test_lpad", "test_expressions.TestExpressions.test_replace_tables", "dataframe.unit.test_session.TestDataframeSession.test_cdf_one_row", "dialects.test_dialect.TestDialect.test_decode", "dialects.test_snowflake.TestSnowflake.test_minus", "dialects.test_teradata.TestTeradata.test_translate", "dataframe.unit.test_functions.TestFunctions.test_log2", "dataframe.unit.test_functions.TestFunctions.test_collect_list", "dataframe.unit.test_functions.TestFunctions.test_zip_with", "test_optimizer.TestOptimizer.test_eliminate_subqueries", "dataframe.unit.test_column.TestDataframeColumn.test_invert", "dialects.test_tsql.TestTSQL.test_convert_date_format", "dataframe.unit.test_functions.TestFunctions.test_trunc", "test_expressions.TestExpressions.test_table_name", "dialects.test_hive.TestHive.test_time", "dataframe.unit.test_column.TestDataframeColumn.test_endswith", "test_optimizer.TestOptimizer.test_cte_column_annotation", "dataframe.unit.test_functions.TestFunctions.test_posexplode_outer", "dataframe.unit.test_column.TestDataframeColumn.test_sub", "dataframe.unit.test_functions.TestFunctions.test_bin", "dialects.test_dialect.TestDialect.test_nullsafe_eq", "dialects.test_redshift.TestRedshift.test_identity", "dataframe.unit.test_functions.TestFunctions.test_cos", "dataframe.unit.test_dataframe_writer.TestDataFrameWriter.test_insertInto_cache", "dataframe.unit.test_session.TestDataframeSession.test_cdf_no_schema", "dataframe.unit.test_session.TestDataframeSession.test_sql_select_only", "dataframe.unit.test_functions.TestFunctions.test_atanh", "test_parser.TestParser.test_expression", "dataframe.unit.test_types.TestDataframeTypes.test_map", "dataframe.unit.test_functions.TestFunctions.test_cosh", "dataframe.unit.test_functions.TestFunctions.test_factorial", "dialects.test_duckdb.TestDuckDB.test_duckdb", "dataframe.unit.test_types.TestDataframeTypes.test_timestamp", "test_parser.TestParser.test_var", "dataframe.unit.test_functions.TestFunctions.test_asc_nulls_first", "dataframe.unit.test_dataframe_writer.TestDataFrameWriter.test_saveAsTable_cache", "dataframe.unit.test_functions.TestFunctions.test_explode_outer", "dataframe.unit.test_window.TestDataframeWindow.test_window_range_unbounded", "dialects.test_sqlite.TestSQLite.test_window_null_treatment", "dataframe.unit.test_functions.TestFunctions.test_isnull", "test_optimizer.TestOptimizer.test_canonicalize", "dataframe.unit.test_session.TestDataframeSession.test_cdf_dict_rows", "dataframe.unit.test_column.TestDataframeColumn.test_over", "dataframe.unit.test_types.TestDataframeTypes.test_decimal", "dataframe.unit.test_functions.TestFunctions.test_count_distinct", "dialects.test_snowflake.TestSnowflake.test_match_recognize", "test_expressions.TestExpressions.test_text", "dialects.test_snowflake.TestSnowflake.test_values", "dialects.test_teradata.TestTeradata.test_update", "dataframe.unit.test_functions.TestFunctions.test_rank", "dataframe.unit.test_functions.TestFunctions.test_array_contains", "dataframe.unit.test_functions.TestFunctions.test_monotonically_increasing_id", "dialects.test_mysql.TestMySQL.test_show_tables", "dialects.test_oracle.TestOracle.test_join_marker", "test_expressions.TestExpressions.test_transform_no_infinite_recursion", "dataframe.unit.test_functions.TestFunctions.test_count", "dataframe.unit.test_dataframe_writer.TestDataFrameWriter.test_insertInto_db_table", "dataframe.unit.test_functions.TestFunctions.test_ntile", "dialects.test_drill.TestDrill.test_drill", "test_lineage.TestLineage.test_lineage_values", "dialects.test_presto.TestPresto.test_unnest", "dataframe.unit.test_functions.TestFunctions.test_csc", "dialects.test_sqlite.TestSQLite.test_hexadecimal_literal", "dataframe.unit.test_functions.TestFunctions.test_hour", "dialects.test_sqlite.TestSQLite.test_sqlite", "dataframe.unit.test_functions.TestFunctions.test_unbase64", "dialects.test_drill.TestDrill.test_quotes", "dataframe.unit.test_functions.TestFunctions.test_col", "test_executor.TestExecutor.test_tables", "dataframe.unit.test_functions.TestFunctions.test_forall", "dialects.test_mysql.TestMySQL.test_bits_literal", "dialects.test_duckdb.TestDuckDB.test_time", "test_expressions.TestExpressions.test_walk", "dialects.test_starrocks.TestMySQL.test_time", "test_parser.TestParser.test_comments", "test_parser.TestParser.test_select", "test_executor.TestExecutor.test_nested_table_reference", "dataframe.unit.test_functions.TestFunctions.test_window", "dataframe.unit.test_functions.TestFunctions.test_hex", "test_optimizer.TestOptimizer.test_null_annotation", "dialects.test_hive.TestHive.test_lateral_view", "dialects.test_presto.TestPresto.test_explode_to_unnest", "dataframe.unit.test_column.TestDataframeColumn.test_when_otherwise", "dialects.test_teradata.TestTeradata.test_cast", "dialects.test_mysql.TestMySQL.test_date_format", "dataframe.unit.test_dataframe.TestDataframe.test_cache", "dataframe.unit.test_functions.TestFunctions.test_transform_keys", "dataframe.unit.test_functions.TestFunctions.test_exists", "dialects.test_oracle.TestOracle.test_xml_table", "dataframe.unit.test_functions.TestFunctions.test_locate", "dataframe.unit.test_functions.TestFunctions.test_array_min", "test_diff.TestDiff.test_node_position_changed", "test_expressions.TestExpressions.test_to_table", "dataframe.unit.test_functions.TestFunctions.test_var_samp", "dataframe.unit.test_functions.TestFunctions.test_log10", "dataframe.unit.test_column.TestDataframeColumn.test_rsub", "dataframe.unit.test_column.TestDataframeColumn.test_desc", "dataframe.unit.test_dataframe_writer.TestDataFrameWriter.test_insertInto_table", "test_parser.TestParser.test_command", "dialects.test_duckdb.TestDuckDB.test_array", "dialects.test_mysql.TestMySQL.test_identity", "test_parser.TestParser.test_pretty_config_override", "test_transforms.TestTransforms.test_remove_precision_parameterized_types", "dataframe.unit.test_functions.TestFunctions.test_map_from_arrays", "test_optimizer.TestOptimizer.test_file_schema", "dataframe.unit.test_functions.TestFunctions.test_covar_pop", "dialects.test_tsql.TestTSQL.test_len", "dialects.test_tsql.TestTSQL.test_charindex", "dialects.test_hive.TestHive.test_data_type", "dialects.test_spark.TestSpark.test_iif", "test_parser.TestParser.test_float", "test_expressions.TestExpressions.test_properties_from_dict", "dataframe.unit.test_functions.TestFunctions.test_to_timestamp", "dialects.test_postgres.TestPostgres.test_postgres", "dialects.test_presto.TestPresto.test_match_recognize", "test_parser.TestParser.test_parse_into", "test_parser.TestParser.test_space", "test_parser.TestParser.test_parse_into_error", "dataframe.unit.test_functions.TestFunctions.test_desc_nulls_last", "test_executor.TestExecutor.test_aggregate_without_group_by", "dataframe.unit.test_functions.TestFunctions.test_regexp_extract", "dataframe.unit.test_column.TestDataframeColumn.test_div", "dataframe.unit.test_functions.TestFunctions.test_date_sub", "test_optimizer.TestOptimizer.test_tpcds", "dataframe.unit.test_functions.TestFunctions.test_struct", "dialects.test_dialect.TestDialect.test_count_if", "test_optimizer.TestOptimizer.test_nullable_annotation", "dialects.test_mysql.TestMySQL.test_hexadecimal_literal", "dialects.test_dialect.TestDialect.test_time", "dialects.test_snowflake.TestSnowflake.test_snowflake", "dataframe.unit.test_column.TestDataframeColumn.test_alias", "test_optimizer.TestOptimizer.test_qualify_columns__with_invisible", "test_expressions.TestExpressions.test_alias_column_names", "test_expressions.TestExpressions.test_data_type_builder", "dataframe.unit.test_functions.TestFunctions.test_variance", "test_optimizer.TestOptimizer.test_pushdown_projection", "dataframe.unit.test_functions.TestFunctions.test_create_map", "dataframe.unit.test_functions.TestFunctions.test_slice", "dialects.test_hive.TestHive.test_cast", "test_schema.TestSchema.test_schema_normalization", "dataframe.unit.test_column.TestDataframeColumn.test_is_not_null", "dataframe.unit.test_functions.TestFunctions.test_map_concat", "test_expressions.TestExpressions.test_transform_node_removal", "test_helper.TestHelper.test_name_sequence", "test_schema.TestSchema.test_schema_get_column_type", "test_transpile.TestTranspile.test_with", "test_optimizer.TestOptimizer.test_aggfunc_annotation", "dataframe.unit.test_functions.TestFunctions.test_array_position", "test_optimizer.TestOptimizer.test_function_annotation", "dialects.test_mysql.TestMySQL.test_types", "dataframe.unit.test_functions.TestFunctions.test_explode", "dialects.test_teradata.TestTeradata.test_abbrev", "dataframe.unit.test_column.TestDataframeColumn.test_pow", "dataframe.unit.test_functions.TestFunctions.test_format_number", "dialects.test_tsql.TestTSQL.test_string", "dialects.test_databricks.TestDatabricks.test_json", "dataframe.unit.test_session.TestDataframeSession.test_cdf_multiple_rows", "dataframe.unit.test_functions.TestFunctions.test_schema_of_csv", "dataframe.unit.test_functions.TestFunctions.test_timestamp_seconds", "dataframe.unit.test_functions.TestFunctions.test_date_format", "dataframe.unit.test_dataframe.TestDataframe.test_persist_default", "test_parser.TestParser.test_table", "dataframe.unit.test_functions.TestFunctions.test_array_distinct", "test_optimizer.TestOptimizer.test_root_subquery_annotation", "test_parser.TestParser.test_union_order", "dataframe.unit.test_functions.TestFunctions.test_array_except", "test_transpile.TestTranspile.test_time", "test_optimizer.TestOptimizer.test_expand_alias_refs", "dataframe.unit.test_functions.TestFunctions.test_pow", "test_serde.TestSerDe.test_type_annotations", "dialects.test_snowflake.TestSnowflake.test_semi_structured_types", "test_transpile.TestTranspile.test_not_range", "dataframe.unit.test_functions.TestFunctions.test_bit_length", "dialects.test_oracle.TestOracle.test_oracle", "dataframe.unit.test_functions.TestFunctions.test_date_trunc", "test_expressions.TestExpressions.test_named_selects", "dataframe.unit.test_dataframe_writer.TestDataFrameWriter.test_saveAsTable_format", "dataframe.unit.test_functions.TestFunctions.test_when", "dialects.test_tsql.TestTSQL.test_tsql", "dialects.test_teradata.TestTeradata.test_mod", "dataframe.unit.test_functions.TestFunctions.test_dayofweek", "dialects.test_presto.TestPresto.test_quotes", "dataframe.unit.test_types.TestDataframeTypes.test_date", "dialects.test_drill.TestDrill.test_validate_pivot", "dataframe.unit.test_functions.TestFunctions.test_sin", "dataframe.unit.test_types.TestDataframeTypes.test_timestamp_ntz", "dialects.test_duckdb.TestDuckDB.test_bool_or", "dataframe.unit.test_dataframe_writer.TestDataFrameWriter.test_insertInto_full_path", "dialects.test_postgres.TestPostgres.test_bool_or", "dialects.test_bigquery.TestBigQuery.test_bigquery", "dialects.test_dialect.TestDialect.test_if_null", "test_transpile.TestTranspile.test_alter", "dialects.test_dialect.TestDialect.test_json", "test_expressions.TestExpressions.test_table", "test_lineage.TestLineage.test_lineage_external_col", "test_diff.TestDiff.test_join", "dialects.test_hive.TestHive.test_ddl", "dataframe.unit.test_functions.TestFunctions.test_sqrt", "test_expressions.TestExpressions.test_function_normalizer", "dialects.test_dialect.TestDialect.test_cross_join", "dialects.test_dialect.TestDialect.test_enum"], "language": "python", "test_command": "source /saved/ENV || source /saved/*/ENV && /opt/hostedtoolcache/Python/3.10.18/x64/bin/python3 /app/repo/unittest_loader_no_traceback.py ./tests ;", "test_output_parser": "python/parse_log_unittest", "image_storage_uri": "vmvm-registry.fbinfra.net/repomate_image_activ_python_unittest/tobymao_sqlglot:2dd8cba03fea94b811ec6bf2c6ce0a60bc48744f", "patch": "[\"diff --git a/sqlglot/dialects/clickhouse.py b/sqlglot/dialects/clickhouse.py\\nindex 1509a09..5daa68e 100644\\n--- a/sqlglot/dialects/clickhouse.py\\n+++ b/sqlglot/dialects/clickhouse.py\\n@@ -23,6 +23,7 @@ def _lower_func(sql: str) -> str:\\n class ClickHouse(Dialect):\\n     NORMALIZE_FUNCTIONS: bool | str = False\\n     NULL_ORDERING = \\\"nulls_are_last\\\"\\n+    STRICT_STRING_CONCAT = True\\n \\n     class Tokenizer(tokens.Tokenizer):\\n         COMMENTS = [\\\"--\\\", \\\"#\\\", \\\"#!\\\", (\\\"/*\\\", \\\"*/\\\")]\\n@@ -333,6 +334,16 @@ class ClickHouse(Dialect):\\n             \\\"NAMED COLLECTION\\\",\\n         }\\n \\n+        def safeconcat_sql(self, expression: exp.SafeConcat) -> str:\\n+            # Clickhouse errors out if we try to cast a NULL value to TEXT\\n+            return self.func(\\n+                \\\"CONCAT\\\",\\n+                *[\\n+                    exp.func(\\\"if\\\", e.is_(exp.null()), e, exp.cast(e, \\\"text\\\"))\\n+                    for e in expression.expressions\\n+                ],\\n+            )\\n+\\n         def cte_sql(self, expression: exp.CTE) -> str:\\n             if isinstance(expression.this, exp.Alias):\\n                 return self.sql(expression, \\\"this\\\")\\n\",\"diff --git a/sqlglot/dialects/dialect.py b/sqlglot/dialects/dialect.py\\nindex 036d20e..1565286 100644\\n--- a/sqlglot/dialects/dialect.py\\n+++ b/sqlglot/dialects/dialect.py\\n@@ -122,6 +122,9 @@ class _Dialect(type):\\n                 if hasattr(subclass, name):\\n                     setattr(subclass, name, value)\\n \\n+        if not klass.STRICT_STRING_CONCAT:\\n+            klass.parser_class.BITWISE[TokenType.DPIPE] = exp.SafeDPipe\\n+\\n         return klass\\n \\n \\n@@ -138,6 +141,9 @@ class Dialect(metaclass=_Dialect):\\n     # Determines whether or not an unquoted identifier can start with a digit\\n     IDENTIFIERS_CAN_START_WITH_DIGIT = False\\n \\n+    # Determines whether or not CONCAT's arguments must be strings\\n+    STRICT_STRING_CONCAT = False\\n+\\n     # Determines how function names are going to be normalized\\n     NORMALIZE_FUNCTIONS: bool | str = \\\"upper\\\"\\n \\n@@ -535,6 +541,14 @@ def ts_or_ds_to_date_sql(dialect: str) -> t.Callable:\\n     return _ts_or_ds_to_date_sql\\n \\n \\n+def concat_to_dpipe_sql(self: Generator, expression: exp.Concat | exp.SafeConcat) -> str:\\n+    this, *rest_args = expression.expressions\\n+    for arg in rest_args:\\n+        this = exp.DPipe(this=this, expression=arg)\\n+\\n+    return self.sql(this)\\n+\\n+\\n # Spark, DuckDB use (almost) the same naming scheme for the output columns of the PIVOT operator\\n def pivot_column_names(aggregations: t.List[exp.Expression], dialect: DialectType) -> t.List[str]:\\n     names = []\\n\",\"diff --git a/sqlglot/dialects/drill.py b/sqlglot/dialects/drill.py\\nindex 01c3b18..3cca986 100644\\n--- a/sqlglot/dialects/drill.py\\n+++ b/sqlglot/dialects/drill.py\\n@@ -82,6 +82,7 @@ class Drill(Dialect):\\n \\n     class Parser(parser.Parser):\\n         STRICT_CAST = False\\n+        CONCAT_NULL_OUTPUTS_STRING = True\\n \\n         FUNCTIONS = {\\n             **parser.Parser.FUNCTIONS,\\n\",\"diff --git a/sqlglot/dialects/duckdb.py b/sqlglot/dialects/duckdb.py\\nindex fe5ff80..9c8c51c 100644\\n--- a/sqlglot/dialects/duckdb.py\\n+++ b/sqlglot/dialects/duckdb.py\\n@@ -114,6 +114,8 @@ class DuckDB(Dialect):\\n         }\\n \\n     class Parser(parser.Parser):\\n+        CONCAT_NULL_OUTPUTS_STRING = True\\n+\\n         FUNCTIONS = {\\n             **parser.Parser.FUNCTIONS,\\n             \\\"ARRAY_LENGTH\\\": exp.ArraySize.from_arg_list,\\n\",\"diff --git a/sqlglot/dialects/postgres.py b/sqlglot/dialects/postgres.py\\nindex f69010a..67a84e1 100644\\n--- a/sqlglot/dialects/postgres.py\\n+++ b/sqlglot/dialects/postgres.py\\n@@ -258,6 +258,7 @@ class Postgres(Dialect):\\n \\n     class Parser(parser.Parser):\\n         STRICT_CAST = False\\n+        CONCAT_NULL_OUTPUTS_STRING = True\\n \\n         FUNCTIONS = {\\n             **parser.Parser.FUNCTIONS,\\n\",\"diff --git a/sqlglot/dialects/presto.py b/sqlglot/dialects/presto.py\\nindex 345dbef..a8a9884 100644\\n--- a/sqlglot/dialects/presto.py\\n+++ b/sqlglot/dialects/presto.py\\n@@ -179,6 +179,7 @@ class Presto(Dialect):\\n     NULL_ORDERING = \\\"nulls_are_last\\\"\\n     TIME_FORMAT = MySQL.TIME_FORMAT\\n     TIME_MAPPING = MySQL.TIME_MAPPING\\n+    STRICT_STRING_CONCAT = True\\n \\n     class Tokenizer(tokens.Tokenizer):\\n         KEYWORDS = {\\n\",\"diff --git a/sqlglot/dialects/redshift.py b/sqlglot/dialects/redshift.py\\nindex 68a64a1..a7e25fa 100644\\n--- a/sqlglot/dialects/redshift.py\\n+++ b/sqlglot/dialects/redshift.py\\n@@ -3,7 +3,7 @@ from __future__ import annotations\\n import typing as t\\n \\n from sqlglot import exp, transforms\\n-from sqlglot.dialects.dialect import rename_func\\n+from sqlglot.dialects.dialect import concat_to_dpipe_sql, rename_func\\n from sqlglot.dialects.postgres import Postgres\\n from sqlglot.helper import seq_get\\n from sqlglot.tokens import TokenType\\n@@ -94,6 +94,7 @@ class Redshift(Postgres):\\n \\n         TRANSFORMS = {\\n             **Postgres.Generator.TRANSFORMS,\\n+            exp.Concat: concat_to_dpipe_sql,\\n             exp.CurrentTimestamp: lambda self, e: \\\"SYSDATE\\\",\\n             exp.DateAdd: lambda self, e: self.func(\\n                 \\\"DATEADD\\\", exp.var(e.text(\\\"unit\\\") or \\\"day\\\"), e.expression, e.this\\n@@ -106,6 +107,7 @@ class Redshift(Postgres):\\n             exp.FromBase: rename_func(\\\"STRTOL\\\"),\\n             exp.JSONExtract: _json_sql,\\n             exp.JSONExtractScalar: _json_sql,\\n+            exp.SafeConcat: concat_to_dpipe_sql,\\n             exp.Select: transforms.preprocess([transforms.eliminate_distinct_on]),\\n             exp.SortKeyProperty: lambda self, e: f\\\"{'COMPOUND ' if e.args['compound'] else ''}SORTKEY({self.format_args(*e.this)})\\\",\\n             exp.TsOrDsToDate: lambda self, e: self.sql(e.this),\\n\",\"diff --git a/sqlglot/dialects/sqlite.py b/sqlglot/dialects/sqlite.py\\nindex 8931b97..3b837ea 100644\\n--- a/sqlglot/dialects/sqlite.py\\n+++ b/sqlglot/dialects/sqlite.py\\n@@ -5,6 +5,7 @@ from sqlglot.dialects.dialect import (\\n     Dialect,\\n     arrow_json_extract_scalar_sql,\\n     arrow_json_extract_sql,\\n+    concat_to_dpipe_sql,\\n     count_if_to_sum,\\n     no_ilike_sql,\\n     no_pivot_sql,\\n@@ -96,6 +97,7 @@ class SQLite(Dialect):\\n \\n         TRANSFORMS = {\\n             **generator.Generator.TRANSFORMS,\\n+            exp.Concat: concat_to_dpipe_sql,\\n             exp.CountIf: count_if_to_sum,\\n             exp.Create: transforms.preprocess([_transform_create]),\\n             exp.CurrentDate: lambda *_: \\\"CURRENT_DATE\\\",\\n@@ -112,6 +114,7 @@ class SQLite(Dialect):\\n             exp.LogicalOr: rename_func(\\\"MAX\\\"),\\n             exp.LogicalAnd: rename_func(\\\"MIN\\\"),\\n             exp.Pivot: no_pivot_sql,\\n+            exp.SafeConcat: concat_to_dpipe_sql,\\n             exp.Select: transforms.preprocess(\\n                 [transforms.eliminate_distinct_on, transforms.eliminate_qualify]\\n             ),\\n\",\"diff --git a/sqlglot/dialects/tsql.py b/sqlglot/dialects/tsql.py\\nindex ebaa826..6d674f5 100644\\n--- a/sqlglot/dialects/tsql.py\\n+++ b/sqlglot/dialects/tsql.py\\n@@ -361,6 +361,8 @@ class TSQL(Dialect):\\n         LOG_BASE_FIRST = False\\n         LOG_DEFAULTS_TO_LN = True\\n \\n+        CONCAT_NULL_OUTPUTS_STRING = True\\n+\\n         def _parse_system_time(self) -> t.Optional[exp.Expression]:\\n             if not self._match_text_seq(\\\"FOR\\\", \\\"SYSTEM_TIME\\\"):\\n                 return None\\n\",\"diff --git a/sqlglot/executor/env.py b/sqlglot/executor/env.py\\nindex e76402b..d2c4e72 100644\\n--- a/sqlglot/executor/env.py\\n+++ b/sqlglot/executor/env.py\\n@@ -151,6 +151,7 @@ ENV = {\\n     \\\"CAST\\\": cast,\\n     \\\"COALESCE\\\": lambda *args: next((a for a in args if a is not None), None),\\n     \\\"CONCAT\\\": null_if_any(lambda *args: \\\"\\\".join(args)),\\n+    \\\"SAFECONCAT\\\": null_if_any(lambda *args: \\\"\\\".join(str(arg) for arg in args)),\\n     \\\"CONCATWS\\\": null_if_any(lambda this, *args: this.join(args)),\\n     \\\"DATESTRTODATE\\\": null_if_any(lambda arg: datetime.date.fromisoformat(arg)),\\n     \\\"DIV\\\": null_if_any(lambda e, this: e / this),\\n\",\"diff --git a/sqlglot/expressions.py b/sqlglot/expressions.py\\nindex 141d43f..749c3da 100644\\n--- a/sqlglot/expressions.py\\n+++ b/sqlglot/expressions.py\\n@@ -3507,6 +3507,10 @@ class DPipe(Binary):\\n     pass\\n \\n \\n+class SafeDPipe(DPipe):\\n+    pass\\n+\\n+\\n class EQ(Binary, Predicate):\\n     pass\\n \\n@@ -3921,6 +3925,10 @@ class Concat(Func):\\n     is_var_len_args = True\\n \\n \\n+class SafeConcat(Concat):\\n+    pass\\n+\\n+\\n class ConcatWs(Concat):\\n     _sql_names = [\\\"CONCAT_WS\\\"]\\n \\n\",\"diff --git a/sqlglot/generator.py b/sqlglot/generator.py\\nindex 1ba1eec..4d78031 100644\\n--- a/sqlglot/generator.py\\n+++ b/sqlglot/generator.py\\n@@ -247,6 +247,7 @@ class Generator:\\n     UNNEST_COLUMN_ONLY = False\\n     ALIAS_POST_TABLESAMPLE = False\\n     IDENTIFIERS_CAN_START_WITH_DIGIT = False\\n+    STRICT_STRING_CONCAT = False\\n     NORMALIZE_FUNCTIONS: bool | str = \\\"upper\\\"\\n     NULL_ORDERING = \\\"nulls_are_small\\\"\\n \\n@@ -1740,10 +1741,11 @@ class Generator:\\n         else:\\n             return self.func(\\\"TRIM\\\", expression.this, expression.expression)\\n \\n-    def concat_sql(self, expression: exp.Concat) -> str:\\n-        if len(expression.expressions) == 1:\\n-            return self.sql(expression.expressions[0])\\n-        return self.function_fallback_sql(expression)\\n+    def safeconcat_sql(self, expression: exp.SafeConcat) -> str:\\n+        expressions = expression.expressions\\n+        if self.STRICT_STRING_CONCAT:\\n+            expressions = (exp.cast(e, \\\"text\\\") for e in expressions)\\n+        return self.func(\\\"CONCAT\\\", *expressions)\\n \\n     def check_sql(self, expression: exp.Check) -> str:\\n         this = self.sql(expression, key=\\\"this\\\")\\n@@ -1766,9 +1768,7 @@ class Generator:\\n         return f\\\"PRIMARY KEY ({expressions}){options}\\\"\\n \\n     def if_sql(self, expression: exp.If) -> str:\\n-        return self.case_sql(\\n-            exp.Case(ifs=[expression.copy()], default=expression.args.get(\\\"false\\\"))\\n-        )\\n+        return self.case_sql(exp.Case(ifs=[expression], default=expression.args.get(\\\"false\\\")))\\n \\n     def matchagainst_sql(self, expression: exp.MatchAgainst) -> str:\\n         modifier = expression.args.get(\\\"modifier\\\")\\n@@ -2074,6 +2074,11 @@ class Generator:\\n     def dpipe_sql(self, expression: exp.DPipe) -> str:\\n         return self.binary(expression, \\\"||\\\")\\n \\n+    def safedpipe_sql(self, expression: exp.SafeDPipe) -> str:\\n+        if self.STRICT_STRING_CONCAT:\\n+            return self.func(\\\"CONCAT\\\", *(exp.cast(e, \\\"text\\\") for e in expression.flatten()))\\n+        return self.dpipe_sql(expression)\\n+\\n     def div_sql(self, expression: exp.Div) -> str:\\n         return self.binary(expression, \\\"/\\\")\\n \\n\",\"diff --git a/sqlglot/optimizer/annotate_types.py b/sqlglot/optimizer/annotate_types.py\\nindex dc80790..9c8dfdb 100644\\n--- a/sqlglot/optimizer/annotate_types.py\\n+++ b/sqlglot/optimizer/annotate_types.py\\n@@ -108,6 +108,9 @@ class TypeAnnotator:\\n         exp.If: lambda self, expr: self._annotate_by_args(expr, \\\"true\\\", \\\"false\\\"),\\n         exp.Coalesce: lambda self, expr: self._annotate_by_args(expr, \\\"this\\\", \\\"expressions\\\"),\\n         exp.Concat: lambda self, expr: self._annotate_with_type(expr, exp.DataType.Type.VARCHAR),\\n+        exp.SafeConcat: lambda self, expr: self._annotate_with_type(\\n+            expr, exp.DataType.Type.VARCHAR\\n+        ),\\n         exp.ConcatWs: lambda self, expr: self._annotate_with_type(expr, exp.DataType.Type.VARCHAR),\\n         exp.GroupConcat: lambda self, expr: self._annotate_with_type(\\n             expr, exp.DataType.Type.VARCHAR\\n\",\"diff --git a/sqlglot/optimizer/canonicalize.py b/sqlglot/optimizer/canonicalize.py\\nindex da2fce8..015b06a 100644\\n--- a/sqlglot/optimizer/canonicalize.py\\n+++ b/sqlglot/optimizer/canonicalize.py\\n@@ -26,7 +26,7 @@ def canonicalize(expression: exp.Expression) -> exp.Expression:\\n \\n def add_text_to_concat(node: exp.Expression) -> exp.Expression:\\n     if isinstance(node, exp.Add) and node.type and node.type.this in exp.DataType.TEXT_TYPES:\\n-        node = exp.Concat(this=node.this, expression=node.expression)\\n+        node = exp.Concat(expressions=[node.left, node.right])\\n     return node\\n \\n \\n\",\"diff --git a/sqlglot/parser.py b/sqlglot/parser.py\\nindex 8b475fa..1480693 100644\\n--- a/sqlglot/parser.py\\n+++ b/sqlglot/parser.py\\n@@ -708,6 +708,7 @@ class Parser(metaclass=_Parser):\\n \\n     FUNCTION_PARSERS: t.Dict[str, t.Callable] = {\\n         \\\"CAST\\\": lambda self: self._parse_cast(self.STRICT_CAST),\\n+        \\\"CONCAT\\\": lambda self: self._parse_concat(),\\n         \\\"CONVERT\\\": lambda self: self._parse_convert(self.STRICT_CAST),\\n         \\\"DECODE\\\": lambda self: self._parse_decode(),\\n         \\\"EXTRACT\\\": lambda self: self._parse_extract(),\\n@@ -779,6 +780,8 @@ class Parser(metaclass=_Parser):\\n \\n     STRICT_CAST = True\\n \\n+    CONCAT_NULL_OUTPUTS_STRING = False  # A NULL arg in CONCAT yields NULL by default\\n+\\n     CONVERT_TYPE_FIRST = False\\n \\n     PREFIXED_PIVOT_COLUMNS = False\\n@@ -805,6 +808,7 @@ class Parser(metaclass=_Parser):\\n     INDEX_OFFSET: int = 0\\n     UNNEST_COLUMN_ONLY: bool = False\\n     ALIAS_POST_TABLESAMPLE: bool = False\\n+    STRICT_STRING_CONCAT = False\\n     NULL_ORDERING: str = \\\"nulls_are_small\\\"\\n     SHOW_TRIE: t.Dict = {}\\n     SET_TRIE: t.Dict = {}\\n@@ -3609,7 +3613,21 @@ class Parser(metaclass=_Parser):\\n \\n         return self.expression(exp.Cast if strict else exp.TryCast, this=this, to=to)\\n \\n-    def _parse_string_agg(self) -> exp.GroupConcat:\\n+    def _parse_concat(self) -> t.Optional[exp.Expression]:\\n+        args = self._parse_csv(self._parse_conjunction)\\n+        if self.CONCAT_NULL_OUTPUTS_STRING:\\n+            args = [exp.func(\\\"COALESCE\\\", arg, exp.Literal.string(\\\"\\\")) for arg in args]\\n+\\n+        # Some dialects (e.g. Trino) don't allow a single-argument CONCAT call, so when\\n+        # we find such a call we replace it with its argument.\\n+        if len(args) == 1:\\n+            return args[0]\\n+\\n+        return self.expression(\\n+            exp.Concat if self.STRICT_STRING_CONCAT else exp.SafeConcat, expressions=args\\n+        )\\n+\\n+    def _parse_string_agg(self) -> exp.Expression:\\n         expression: t.Optional[exp.Expression]\\n \\n         if self._match(TokenType.DISTINCT):\\n\",\"diff --git a/sqlglot/tokens.py b/sqlglot/tokens.py\\nindex 67252fe..c89592a 100644\\n--- a/sqlglot/tokens.py\\n+++ b/sqlglot/tokens.py\\n@@ -346,6 +346,7 @@ class Token:\\n             col: The column that the token ends on.\\n             start: The start index of the token.\\n             end: The ending index of the token.\\n+            comments: The comments to attach to the token.\\n         \\\"\\\"\\\"\\n         self.token_type = token_type\\n         self.text = text\\n\"]", "test_patch": "[\"diff --git a/tests/dataframe/unit/test_functions.py b/tests/dataframe/unit/test_functions.py\\nindex befa68b..556001c 100644\\n--- a/tests/dataframe/unit/test_functions.py\\n+++ b/tests/dataframe/unit/test_functions.py\\n@@ -1278,7 +1278,7 @@ class TestFunctions(unittest.TestCase):\\n         col = SF.concat(SF.col(\\\"cola\\\"), SF.col(\\\"colb\\\"))\\n         self.assertEqual(\\\"CONCAT(cola, colb)\\\", col.sql())\\n         col_single = SF.concat(\\\"cola\\\")\\n-        self.assertEqual(\\\"cola\\\", col_single.sql())\\n+        self.assertEqual(\\\"CONCAT(cola)\\\", col_single.sql())\\n \\n     def test_array_position(self):\\n         col_str = SF.array_position(\\\"cola\\\", SF.col(\\\"colb\\\"))\\n\",\"diff --git a/tests/dialects/test_clickhouse.py b/tests/dialects/test_clickhouse.py\\nindex db46b89..7584c67 100644\\n--- a/tests/dialects/test_clickhouse.py\\n+++ b/tests/dialects/test_clickhouse.py\\n@@ -53,6 +53,14 @@ class TestClickhouse(Validator):\\n         )\\n \\n         self.validate_all(\\n+            \\\"CONCAT(CASE WHEN COALESCE(a, '') IS NULL THEN COALESCE(a, '') ELSE CAST(COALESCE(a, '') AS TEXT) END, CASE WHEN COALESCE(b, '') IS NULL THEN COALESCE(b, '') ELSE CAST(COALESCE(b, '') AS TEXT) END)\\\",\\n+            read={\\\"postgres\\\": \\\"CONCAT(a, b)\\\"},\\n+        )\\n+        self.validate_all(\\n+            \\\"CONCAT(CASE WHEN a IS NULL THEN a ELSE CAST(a AS TEXT) END, CASE WHEN b IS NULL THEN b ELSE CAST(b AS TEXT) END)\\\",\\n+            read={\\\"mysql\\\": \\\"CONCAT(a, b)\\\"},\\n+        )\\n+        self.validate_all(\\n             r\\\"'Enum8(\\\\'Sunday\\\\' = 0)'\\\", write={\\\"clickhouse\\\": \\\"'Enum8(''Sunday'' = 0)'\\\"}\\n         )\\n         self.validate_all(\\n\",\"diff --git a/tests/dialects/test_dialect.py b/tests/dialects/test_dialect.py\\nindex 7e20812..09d39b4 100644\\n--- a/tests/dialects/test_dialect.py\\n+++ b/tests/dialects/test_dialect.py\\n@@ -1085,6 +1085,14 @@ class TestDialect(Validator):\\n \\n         self.validate_all(\\\"LIKE(x, 'z')\\\", write={\\\"\\\": \\\"'z' LIKE x\\\"})\\n         self.validate_all(\\n+            \\\"CONCAT(a, b, c)\\\",\\n+            write={\\n+                \\\"\\\": \\\"CONCAT(a, b, c)\\\",\\n+                \\\"redshift\\\": \\\"a || b || c\\\",\\n+                \\\"sqlite\\\": \\\"a || b || c\\\",\\n+            },\\n+        )\\n+        self.validate_all(\\n             \\\"x ILIKE '%y'\\\",\\n             read={\\n                 \\\"clickhouse\\\": \\\"x ILIKE '%y'\\\",\\n@@ -1177,11 +1185,22 @@ class TestDialect(Validator):\\n         self.validate_all(\\n             \\\"CONCAT(a)\\\",\\n             write={\\n-                \\\"mysql\\\": \\\"a\\\",\\n+                \\\"clickhouse\\\": \\\"a\\\",\\n+                \\\"presto\\\": \\\"a\\\",\\n+                \\\"trino\\\": \\\"a\\\",\\n                 \\\"tsql\\\": \\\"a\\\",\\n             },\\n         )\\n         self.validate_all(\\n+            \\\"COALESCE(a, '')\\\",\\n+            read={\\n+                \\\"drill\\\": \\\"CONCAT(a)\\\",\\n+                \\\"duckdb\\\": \\\"CONCAT(a)\\\",\\n+                \\\"postgres\\\": \\\"CONCAT(a)\\\",\\n+                \\\"tsql\\\": \\\"CONCAT(a)\\\",\\n+            },\\n+        )\\n+        self.validate_all(\\n             \\\"IF(x > 1, 1, 0)\\\",\\n             write={\\n                 \\\"drill\\\": \\\"`IF`(x > 1, 1, 0)\\\",\\n\",\"diff --git a/tests/dialects/test_postgres.py b/tests/dialects/test_postgres.py\\nindex 972a8c8..7a392da 100644\\n--- a/tests/dialects/test_postgres.py\\n+++ b/tests/dialects/test_postgres.py\\n@@ -540,3 +540,24 @@ class TestPostgres(Validator):\\n             \\\"SELECT a, LOGICAL_OR(b) FROM table GROUP BY a\\\",\\n             write={\\\"postgres\\\": \\\"SELECT a, BOOL_OR(b) FROM table GROUP BY a\\\"},\\n         )\\n+\\n+    def test_string_concat(self):\\n+        self.validate_all(\\n+            \\\"CONCAT(a, b)\\\",\\n+            write={\\n+                \\\"\\\": \\\"CONCAT(COALESCE(a, ''), COALESCE(b, ''))\\\",\\n+                \\\"duckdb\\\": \\\"CONCAT(COALESCE(a, ''), COALESCE(b, ''))\\\",\\n+                \\\"postgres\\\": \\\"CONCAT(COALESCE(a, ''), COALESCE(b, ''))\\\",\\n+                \\\"presto\\\": \\\"CONCAT(CAST(COALESCE(a, '') AS VARCHAR), CAST(COALESCE(b, '') AS VARCHAR))\\\",\\n+            },\\n+        )\\n+        self.validate_all(\\n+            \\\"a || b\\\",\\n+            write={\\n+                \\\"\\\": \\\"a || b\\\",\\n+                \\\"clickhouse\\\": \\\"CONCAT(CAST(a AS TEXT), CAST(b AS TEXT))\\\",\\n+                \\\"duckdb\\\": \\\"a || b\\\",\\n+                \\\"postgres\\\": \\\"a || b\\\",\\n+                \\\"presto\\\": \\\"CONCAT(CAST(a AS VARCHAR), CAST(b AS VARCHAR))\\\",\\n+            },\\n+        )\\n\",\"diff --git a/tests/test_executor.py b/tests/test_executor.py\\nindex a121dea..b91a28b 100644\\n--- a/tests/test_executor.py\\n+++ b/tests/test_executor.py\\n@@ -496,6 +496,7 @@ class TestExecutor(unittest.TestCase):\\n             (\\\"SELECT 1\\\", [\\\"1\\\"], [(1,)]),\\n             (\\\"SELECT 1 + 2 AS x\\\", [\\\"x\\\"], [(3,)]),\\n             (\\\"SELECT CONCAT('a', 'b') AS x\\\", [\\\"x\\\"], [(\\\"ab\\\",)]),\\n+            (\\\"SELECT CONCAT('a', 1) AS x\\\", [\\\"x\\\"], [(\\\"a1\\\",)]),\\n             (\\\"SELECT 1 AS x, 2 AS y\\\", [\\\"x\\\", \\\"y\\\"], [(1, 2)]),\\n             (\\\"SELECT 'foo' LIMIT 1\\\", [\\\"foo\\\"], [(\\\"foo\\\",)]),\\n             (\"]", "hints_text": ""}

{"instance_id": "1357554135715593", "repo": "skypilot-org/skypilot", "base_commit": "a9c194a4ab3d75eea9e388dddc92ff07dfe6fcf0", "problem_statement": "Resource Specification for # of CPUs:\\nSky currently supports users requesting X amount of GPUs/TPUs, e.g. \\r\\n```\\r\\nresources:\\r\\n  accelerators:\\r\\n    V100: 8\\r\\n```\\r\\nUsers should also be able to specify how many CPU cores they want, e.g.\\r\\n```\\r\\nresources:\\r\\n  cores: 16\\r\\n  accelerators:\\r\\n    V100: 8\\r\\n```\\r\\nAdditional changes are needed to the optimizer (to consider this additional resource constraint). In additional, while Google decouples # of CPUs and # of GPUs, AWS advertises their GPUs in fixed packages of (CPUs, GPUs) (e.g. `p3.2x (16 CPU, 1 V100), 3.8x, ...`), which is not as flexible as Google's model. The optimizer needs to account for this and select the right packages in AWS that meet the user's constraint.", "FAIL_TO_PASS": ["tests/test_optimizer_dryruns.py::test_partial_m60", "tests/test_optimizer_dryruns.py::test_partial_cpus", "tests/test_optimizer_dryruns.py::test_partial_k80", "tests/test_optimizer_dryruns.py::test_parse_cpus_from_yaml", "tests/test_optimizer_dryruns.py::test_partial_v100", "tests/test_optimizer_dryruns.py::test_partial_t4", "tests/test_optimizer_dryruns.py::test_invalid_cpus", "tests/test_optimizer_dryruns.py::test_instance_type_mismatches_cpus", "tests/test_optimizer_dryruns.py::test_partial_tpu", "tests/test_optimizer_dryruns.py::test_instance_type_matches_cpus", "tests/test_optimizer_dryruns.py::test_partial_p100"], "PASS_TO_PASS": ["tests/test_cli.py::test_infer_gpunode_type", "tests/test_cli.py::test_accelerator_mismatch", "tests/test_cli.py::test_infer_cpunode_type", "tests/test_storage.py::TestStorageSpecValidation::test_name_and_nosource", "tests/test_storage.py::TestStorageSpecLocalSource::test_source_multifile_conflict", "tests/test_optimizer_dryruns.py::test_clouds_not_enabled", "tests/test_list_accelerators.py::test_list_accelerators", "tests/test_storage.py::TestStorageSpecLocalSource::test_source_trailing_slashes", "tests/test_optimizer_dryruns.py::test_instance_type_mistmatches_accelerators", "tests/test_optimizer_dryruns.py::test_resources_gcp", "tests/test_storage.py::TestStorageSpecValidation::test_source_and_noname", "tests/test_optimizer_dryruns.py::test_resources_aws", "tests/test_optimizer_dryruns.py::test_parse_accelerators_from_yaml", "tests/test_optimizer_dryruns.py::test_resources_azure", "tests/test_smoke.py::TestYamlSpecs::test_load_dump_yaml_config_equivalent", "tests/test_storage.py::TestStorageSpecValidation::test_source_and_name", "tests/test_spot.py::TestReservedClustersOperations::test_down_spot_controller", "tests/test_spot.py::test_spot_nonexist_strategy", "tests/test_optimizer_dryruns.py::test_infer_cloud_from_instance_type", "tests/test_list_accelerators.py::test_list_accelerators_region_filter", "tests/test_spot.py::TestReservedClustersOperations::test_cancel_on_spot_controller", "tests/test_optimizer_dryruns.py::test_invalid_cloud_tpu", "tests/test_spot.py::TestReservedClustersOperations::test_autostop_spot_controller", "tests/test_optimizer_dryruns.py::test_invalid_zone", "tests/test_storage.py::TestStorageSpecLocalSource::test_source_single_file", "tests/test_optimizer_dryruns.py::test_invalid_instance_type", "tests/test_optimizer_dryruns.py::test_invalid_image", "tests/test_storage.py::TestStorageSpecLocalSource::test_nonexist_local_source", "tests/test_optimizer_random_dag.py::test_optimizer", "tests/test_optimizer_dryruns.py::test_valid_image", "tests/test_cli.py::test_infer_tpunode_type", "tests/test_optimizer_dryruns.py::test_invalid_num_nodes", "tests/test_storage.py::TestStorageSpecValidation::test_noname_and_nosource", "tests/test_optimizer_dryruns.py::test_invalid_region", "tests/test_wheels.py::test_build_wheels", "tests/test_pycryptodome_version.py::test_pycryptodome_version", "tests/test_smoke.py::test_core_api", "tests/test_list_accelerators.py::test_list_accelerators_name_filter", "tests/test_optimizer_dryruns.py::test_instance_type_matches_accelerators", "tests/test_spot.py::TestReservedClustersOperations::test_stop_spot_controller", "tests/test_list_accelerators.py::test_list_ccelerators_all"], "language": "python", "test_command": "source /saved/ENV || source /saved/*/ENV && pytest --no-header -rA --tb=no -p no:cacheprovider --continue-on-collection-errors", "test_output_parser": "python/parse_log_pytest_v3", "image_storage_uri": "vmvm-registry.fbinfra.net/repomate_image_activ_pytest/skypilot-org_skypilot:a9c194a4ab3d75eea9e388dddc92ff07dfe6fcf0", "patch": "[\"diff --git a/docs/source/reference/yaml-spec.rst b/docs/source/reference/yaml-spec.rst\\nindex 586e0366cbc..1465deff853 100644\\n--- a/docs/source/reference/yaml-spec.rst\\n+++ b/docs/source/reference/yaml-spec.rst\\n@@ -47,6 +47,12 @@ Available fields:\\n       # Format: <name>:<count> (or simply <name>, short for a count of 1).\\n       accelerators: V100:4\\n \\n+      # Number of vCPUs per node (optional).\\n+      #\\n+      # Format: <count> (exactly <count> vCPUs) or <count>+\\n+      # (at least <count> vCPUs).\\n+      cpus: 32\\n+\\n       # Instance type to use (optional). If 'accelerators' is specified,\\n       # the corresponding instance type is automatically inferred.\\n       instance_type: p3.8xlarge\\n\",\"diff --git a/examples/example_app.py b/examples/example_app.py\\nindex 4c48147ea6b..c26c4970343 100644\\n--- a/examples/example_app.py\\n+++ b/examples/example_app.py\\n@@ -43,7 +43,7 @@ def make_application():\\n             sky.Resources(sky.AWS(), 'p3.2xlarge'),  # 1 V100, EC2.\\n             sky.Resources(sky.AWS(), 'p3.8xlarge'),  # 4 V100s, EC2.\\n             # Tuples mean all resources are required.\\n-            sky.Resources(sky.GCP(), 'n1-standard-8', 'tpu-v3-8'),\\n+            sky.Resources(sky.GCP(), 'n1-standard-8', accelerators='tpu-v3-8'),\\n         })\\n \\n         train_op.set_time_estimator(time_estimators.resnet50_estimate_runtime)\\n@@ -60,8 +60,8 @@ def make_application():\\n         infer_op.set_resources({\\n             sky.Resources(sky.AWS(), 'inf1.2xlarge'),\\n             sky.Resources(sky.AWS(), 'p3.2xlarge'),\\n-            sky.Resources(sky.GCP(), 'n1-standard-4', 'T4'),\\n-            sky.Resources(sky.GCP(), 'n1-standard-8', 'T4'),\\n+            sky.Resources(sky.GCP(), 'n1-standard-4', accelerators='T4'),\\n+            sky.Resources(sky.GCP(), 'n1-standard-8', accelerators='T4'),\\n         })\\n \\n         infer_op.set_time_estimator(\\n\",\"diff --git a/sky/clouds/aws.py b/sky/clouds/aws.py\\nindex 418415040c7..48c9282420a 100644\\n--- a/sky/clouds/aws.py\\n+++ b/sky/clouds/aws.py\\n@@ -274,10 +274,10 @@ def is_same_cloud(self, other: clouds.Cloud):\\n         return isinstance(other, AWS)\\n \\n     @classmethod\\n-    def get_default_instance_type(cls) -> str:\\n-        # General-purpose instance with 8 vCPUs and 32 GB RAM.\\n-        # Intel Ice Lake 8375C\\n-        return 'm6i.2xlarge'\\n+    def get_default_instance_type(cls,\\n+                                  cpus: Optional[str] = None) -> Optional[str]:\\n+        return service_catalog.get_default_instance_type(cpus=cpus,\\n+                                                         clouds='aws')\\n \\n     # TODO: factor the following three methods, as they are the same logic\\n     # between Azure and AWS.\\n@@ -334,12 +334,11 @@ def make_deploy_resources_variables(\\n \\n     def get_feasible_launchable_resources(self,\\n                                           resources: 'resources_lib.Resources'):\\n-        fuzzy_candidate_list: List[str] = []\\n         if resources.instance_type is not None:\\n             assert resources.is_launchable(), resources\\n             # Treat Resources(AWS, p3.2x, V100) as Resources(AWS, p3.2x).\\n             resources = resources.copy(accelerators=None)\\n-            return ([resources], fuzzy_candidate_list)\\n+            return ([resources], [])\\n \\n         def _make(instance_list):\\n             resource_list = []\\n@@ -350,6 +349,7 @@ def _make(instance_list):\\n                     # Setting this to None as AWS doesn't separately bill /\\n                     # attach the accelerators.  Billed as part of the VM type.\\n                     accelerators=None,\\n+                    cpus=None,\\n                 )\\n                 resource_list.append(r)\\n             return resource_list\\n@@ -357,9 +357,13 @@ def _make(instance_list):\\n         # Currently, handle a filter on accelerators only.\\n         accelerators = resources.accelerators\\n         if accelerators is None:\\n-            # No requirements to filter, so just return a default VM type.\\n-            return (_make([AWS.get_default_instance_type()]),\\n-                    fuzzy_candidate_list)\\n+            # Return a default instance type with the given number of vCPUs.\\n+            default_instance_type = AWS.get_default_instance_type(\\n+                cpus=resources.cpus)\\n+            if default_instance_type is None:\\n+                return ([], [])\\n+            else:\\n+                return (_make([default_instance_type]), [])\\n \\n         assert len(accelerators) == 1, resources\\n         acc, acc_count = list(accelerators.items())[0]\\n@@ -368,6 +372,7 @@ def _make(instance_list):\\n             acc,\\n             acc_count,\\n             use_spot=resources.use_spot,\\n+            cpus=resources.cpus,\\n             region=resources.region,\\n             zone=resources.zone,\\n             clouds='aws')\\n\",\"diff --git a/sky/clouds/azure.py b/sky/clouds/azure.py\\nindex ab1da9331c0..299f4458457 100644\\n--- a/sky/clouds/azure.py\\n+++ b/sky/clouds/azure.py\\n@@ -94,10 +94,10 @@ def is_same_cloud(self, other):\\n         return isinstance(other, Azure)\\n \\n     @classmethod\\n-    def get_default_instance_type(cls) -> str:\\n-        # General-purpose instance with 8 vCPUs and 32 GB RAM.\\n-        # Intel Ice Lake 8370C\\n-        return 'Standard_D8_v5'\\n+    def get_default_instance_type(cls,\\n+                                  cpus: Optional[str] = None) -> Optional[str]:\\n+        return service_catalog.get_default_instance_type(cpus=cpus,\\n+                                                         clouds='azure')\\n \\n     def _get_image_config(self, gen_version, instance_type):\\n         # az vm image list \\\\\\n@@ -250,12 +250,11 @@ def get_feasible_launchable_resources(self, resources):\\n             # TODO(zhwu): our azure subscription offer ID does not support spot.\\n             # Need to support it.\\n             return ([], [])\\n-        fuzzy_candidate_list = []\\n         if resources.instance_type is not None:\\n             assert resources.is_launchable(), resources\\n             # Treat Resources(AWS, p3.2x, V100) as Resources(AWS, p3.2x).\\n             resources = resources.copy(accelerators=None)\\n-            return ([resources], fuzzy_candidate_list)\\n+            return ([resources], [])\\n \\n         def _make(instance_list):\\n             resource_list = []\\n@@ -265,16 +264,22 @@ def _make(instance_list):\\n                     instance_type=instance_type,\\n                     # Setting this to None as Azure doesn't separately bill /\\n                     # attach the accelerators.  Billed as part of the VM type.\\n-                    accelerators=None)\\n+                    accelerators=None,\\n+                    cpus=None,\\n+                )\\n                 resource_list.append(r)\\n             return resource_list\\n \\n         # Currently, handle a filter on accelerators only.\\n         accelerators = resources.accelerators\\n         if accelerators is None:\\n-            # No requirements to filter, so just return a default VM type.\\n-            return (_make([Azure.get_default_instance_type()]),\\n-                    fuzzy_candidate_list)\\n+            # Return a default instance type with the given number of vCPUs.\\n+            default_instance_type = Azure.get_default_instance_type(\\n+                cpus=resources.cpus)\\n+            if default_instance_type is None:\\n+                return ([], [])\\n+            else:\\n+                return (_make([default_instance_type]), [])\\n \\n         assert len(accelerators) == 1, resources\\n         acc, acc_count = list(accelerators.items())[0]\\n@@ -282,6 +287,7 @@ def _make(instance_list):\\n         ) = service_catalog.get_instance_type_for_accelerator(\\n             acc,\\n             acc_count,\\n+            cpus=resources.cpus,\\n             use_spot=resources.use_spot,\\n             region=resources.region,\\n             zone=resources.zone,\\n\",\"diff --git a/sky/clouds/cloud.py b/sky/clouds/cloud.py\\nindex 19b9865a911..9c50b93b7b5 100644\\n--- a/sky/clouds/cloud.py\\n+++ b/sky/clouds/cloud.py\\n@@ -180,7 +180,18 @@ def get_accelerators_from_instance_type(\\n         raise NotImplementedError\\n \\n     @classmethod\\n-    def get_default_instance_type(cls) -> str:\\n+    def get_default_instance_type(cls,\\n+                                  cpus: Optional[str] = None) -> Optional[str]:\\n+        \\\"\\\"\\\"Returns the default instance type with the given number of vCPUs.\\n+\\n+        For example, if cpus='4', this method returns the default instance type\\n+        with 4 vCPUs.  If cpus='4+', this method returns the default instance\\n+        type with 4 or more vCPUs.\\n+\\n+        When cpus is None, this method will never return None.\\n+        This method may return None if the cloud's default instance family\\n+        does not have a VM with the given number of vCPUs (e.g., when cpus='7').\\n+        \\\"\\\"\\\"\\n         raise NotImplementedError\\n \\n     @classmethod\\n\",\"diff --git a/sky/clouds/gcp.py b/sky/clouds/gcp.py\\nindex 24dc3155aa2..28c79308678 100644\\n--- a/sky/clouds/gcp.py\\n+++ b/sky/clouds/gcp.py\\n@@ -279,10 +279,10 @@ def get_image_size(self, image_id: str, region: Optional[str]) -> float:\\n             raise\\n \\n     @classmethod\\n-    def get_default_instance_type(cls) -> str:\\n-        # General-purpose instance with 8 vCPUs and 32 GB RAM.\\n-        # Intel Ice Lake 8373C or Cascade Lake 6268CL\\n-        return 'n2-standard-8'\\n+    def get_default_instance_type(cls,\\n+                                  cpus: Optional[str] = None) -> Optional[str]:\\n+        return service_catalog.get_default_instance_type(cpus=cpus,\\n+                                                         clouds='gcp')\\n \\n     @classmethod\\n     def _get_default_region(cls) -> clouds.Region:\\n@@ -377,45 +377,73 @@ def make_deploy_resources_variables(\\n         return resources_vars\\n \\n     def get_feasible_launchable_resources(self, resources):\\n-        fuzzy_candidate_list = []\\n         if resources.instance_type is not None:\\n             assert resources.is_launchable(), resources\\n-            return ([resources], fuzzy_candidate_list)\\n+            return ([resources], [])\\n \\n-        # No other resources (cpu/mem) to filter for now, so just return a\\n-        # default VM type.\\n-        host_vm_type = GCP.get_default_instance_type()\\n-        acc_dict = None\\n-        # Find instance candidates to meet user's requirements\\n-        if resources.accelerators is not None:\\n-            assert len(resources.accelerators.items(\\n-            )) == 1, 'cannot handle more than one accelerator candidates.'\\n-            acc, acc_count = list(resources.accelerators.items())[0]\\n-            (instance_list, fuzzy_candidate_list\\n-            ) = service_catalog.get_instance_type_for_accelerator(\\n-                acc,\\n-                acc_count,\\n-                use_spot=resources.use_spot,\\n-                region=resources.region,\\n-                zone=resources.zone,\\n-                clouds='gcp')\\n-\\n-            if instance_list is None:\\n-                return ([], fuzzy_candidate_list)\\n-            assert len(\\n-                instance_list\\n-            ) == 1, f'More than one instance type matched, {instance_list}'\\n+        if resources.accelerators is None:\\n+            # Return a default instance type with the given number of vCPUs.\\n+            host_vm_type = GCP.get_default_instance_type(cpus=resources.cpus)\\n+            if host_vm_type is None:\\n+                return ([], [])\\n+            else:\\n+                r = resources.copy(\\n+                    cloud=GCP(),\\n+                    instance_type=host_vm_type,\\n+                    accelerators=None,\\n+                    cpus=None,\\n+                )\\n+                return ([r], [])\\n+\\n+        use_tpu_vm = False\\n+        if resources.accelerator_args is not None:\\n+            use_tpu_vm = resources.accelerator_args.get('tpu_vm', False)\\n \\n+        # Find instance candidates to meet user's requirements\\n+        assert len(resources.accelerators.items()\\n+                  ) == 1, 'cannot handle more than one accelerator candidates.'\\n+        acc, acc_count = list(resources.accelerators.items())[0]\\n+\\n+        # For TPU VMs, the instance type is fixed to 'TPU-VM'. However, we still\\n+        # need to call the below function to get the fuzzy candidate list.\\n+        (instance_list, fuzzy_candidate_list\\n+        ) = service_catalog.get_instance_type_for_accelerator(\\n+            acc,\\n+            acc_count,\\n+            cpus=resources.cpus if not use_tpu_vm else None,\\n+            use_spot=resources.use_spot,\\n+            region=resources.region,\\n+            zone=resources.zone,\\n+            clouds='gcp')\\n+\\n+        if instance_list is None:\\n+            return ([], fuzzy_candidate_list)\\n+        assert len(\\n+            instance_list\\n+        ) == 1, f'More than one instance type matched, {instance_list}'\\n+\\n+        if use_tpu_vm:\\n+            host_vm_type = 'TPU-VM'\\n+            # FIXME(woosuk): This leverages the fact that TPU VMs have 96 vCPUs.\\n+            num_cpus_in_tpu_vm = 96\\n+            if resources.cpus is not None:\\n+                if resources.cpus.endswith('+'):\\n+                    cpus = float(resources.cpus[:-1])\\n+                    if cpus > num_cpus_in_tpu_vm:\\n+                        return ([], fuzzy_candidate_list)\\n+                else:\\n+                    cpus = float(resources.cpus)\\n+                    if cpus != num_cpus_in_tpu_vm:\\n+                        return ([], fuzzy_candidate_list)\\n+        else:\\n             host_vm_type = instance_list[0]\\n-            acc_dict = {acc: acc_count}\\n-            if resources.accelerator_args is not None:\\n-                use_tpu_vm = resources.accelerator_args.get('tpu_vm', False)\\n-                if use_tpu_vm:\\n-                    host_vm_type = 'TPU-VM'\\n+\\n+        acc_dict = {acc: acc_count}\\n         r = resources.copy(\\n             cloud=GCP(),\\n             instance_type=host_vm_type,\\n             accelerators=acc_dict,\\n+            cpus=None,\\n         )\\n         return ([r], fuzzy_candidate_list)\\n \\n\",\"diff --git a/sky/clouds/local.py b/sky/clouds/local.py\\nindex 627358f7dc1..bad0d79b8c7 100644\\n--- a/sky/clouds/local.py\\n+++ b/sky/clouds/local.py\\n@@ -94,8 +94,9 @@ def is_same_cloud(self, other: clouds.Cloud) -> bool:\\n         return isinstance(other, Local)\\n \\n     @classmethod\\n-    def get_default_instance_type(cls) -> str:\\n+    def get_default_instance_type(cls, cpus: Optional[str] = None) -> str:\\n         # There is only \\\"1\\\" instance type for local cloud: on-prem\\n+        del cpus  # Unused.\\n         return Local._DEFAULT_INSTANCE_TYPE\\n \\n     @classmethod\\n\",\"diff --git a/sky/clouds/service_catalog/__init__.py b/sky/clouds/service_catalog/__init__.py\\nindex a722701cc53..00680e2c294 100644\\n--- a/sky/clouds/service_catalog/__init__.py\\n+++ b/sky/clouds/service_catalog/__init__.py\\n@@ -159,6 +159,17 @@ def get_vcpus_from_instance_type(instance_type: str,\\n                                instance_type)\\n \\n \\n+def get_default_instance_type(cpus: Optional[str] = None,\\n+                              clouds: CloudFilter = None) -> Optional[str]:\\n+    \\\"\\\"\\\"Returns the cloud's default instance type for the given number of vCPUs.\\n+\\n+    For example, if cpus='4', this method returns the default instance type\\n+    with 4 vCPUs.  If cpus='4+', this method returns the default instance\\n+    type with 4 or more vCPUs.\\n+    \\\"\\\"\\\"\\n+    return _map_clouds_catalog(clouds, 'get_default_instance_type', cpus)\\n+\\n+\\n def get_accelerators_from_instance_type(\\n         instance_type: str,\\n         clouds: CloudFilter = None) -> Optional[Dict[str, int]]:\\n@@ -170,6 +181,7 @@ def get_accelerators_from_instance_type(\\n def get_instance_type_for_accelerator(\\n     acc_name: str,\\n     acc_count: int,\\n+    cpus: Optional[str] = None,\\n     use_spot: bool = False,\\n     region: Optional[str] = None,\\n     zone: Optional[str] = None,\\n@@ -180,7 +192,8 @@ def get_instance_type_for_accelerator(\\n     accelerators with sorted prices and a list of candidates with fuzzy search.\\n     \\\"\\\"\\\"\\n     return _map_clouds_catalog(clouds, 'get_instance_type_for_accelerator',\\n-                               acc_name, acc_count, use_spot, region, zone)\\n+                               acc_name, acc_count, cpus, use_spot, region,\\n+                               zone)\\n \\n \\n def get_accelerator_hourly_cost(\\n\",\"diff --git a/sky/clouds/service_catalog/common.py b/sky/clouds/service_catalog/common.py\\nindex 84b2c67be12..d0f83597b7b 100644\\n--- a/sky/clouds/service_catalog/common.py\\n+++ b/sky/clouds/service_catalog/common.py\\n@@ -270,6 +270,39 @@ def get_vcpus_from_instance_type_impl(\\n     return float(vcpus)\\n \\n \\n+def _filter_with_cpus(df: pd.DataFrame, cpus: Optional[str]) -> pd.DataFrame:\\n+    if cpus is None:\\n+        return df\\n+\\n+    # The following code is redundant with the code in resources.py::_set_cpus()\\n+    # but we add it here for safety.\\n+    if cpus.endswith('+'):\\n+        num_cpus_str = cpus[:-1]\\n+    else:\\n+        num_cpus_str = cpus\\n+    try:\\n+        num_cpus = float(num_cpus_str)\\n+    except ValueError:\\n+        with ux_utils.print_exception_no_traceback():\\n+            raise ValueError(f'The \\\"cpus\\\" field should be either a number or '\\n+                             f'a string \\\"<number>+\\\". Found: {cpus!r}') from None\\n+\\n+    if cpus.endswith('+'):\\n+        return df[df['vCPUs'] >= num_cpus]\\n+    else:\\n+        return df[df['vCPUs'] == num_cpus]\\n+\\n+\\n+def get_instance_type_for_cpus_impl(\\n+        df: pd.DataFrame, cpus: Optional[str] = None) -> Optional[str]:\\n+    df = _filter_with_cpus(df, cpus)\\n+    if df.empty:\\n+        return None\\n+    # Sort by the number of vCPUs and then by the price.\\n+    df = df.sort_values(by=['vCPUs', 'Price'], ascending=True)\\n+    return df['InstanceType'].iloc[0]\\n+\\n+\\n def get_accelerators_from_instance_type_impl(\\n     df: pd.DataFrame,\\n     instance_type: str,\\n@@ -289,6 +322,7 @@ def get_instance_type_for_accelerator_impl(\\n     df: pd.DataFrame,\\n     acc_name: str,\\n     acc_count: int,\\n+    cpus: Optional[str] = None,\\n     use_spot: bool = False,\\n     region: Optional[str] = None,\\n     zone: Optional[str] = None,\\n@@ -313,6 +347,7 @@ def get_instance_type_for_accelerator_impl(\\n                                             f'{int(row[\\\"AcceleratorCount\\\"])}')\\n         return (None, fuzzy_candidate_list)\\n \\n+    result = _filter_with_cpus(result, cpus)\\n     if region is not None:\\n         result = result[result['Region'] == region]\\n     if zone is not None:\\n\",\"diff --git a/sky/execution.py b/sky/execution.py\\nindex 8164f107c33..8eb85451bae 100644\\n--- a/sky/execution.py\\n+++ b/sky/execution.py\\n@@ -176,6 +176,15 @@ def _execute(\\n         existing_handle = global_user_state.get_handle_from_cluster_name(\\n             cluster_name)\\n         cluster_exists = existing_handle is not None\\n+    if cluster_exists:\\n+        assert len(task.resources) == 1\\n+        task_resources = list(task.resources)[0]\\n+        if task_resources.cpus is not None:\\n+            with ux_utils.print_exception_no_traceback():\\n+                raise ValueError(\\n+                    'Cannot specify CPU when using an existing cluster. '\\n+                    'CPU is only used for selecting the instance type when '\\n+                    'creating a new cluster.')\\n \\n     stages = stages if stages is not None else list(Stage)\\n \\n\",\"diff --git a/sky/optimizer.py b/sky/optimizer.py\\nindex 3a9189fa545..7d5d4aede50 100644\\n--- a/sky/optimizer.py\\n+++ b/sky/optimizer.py\\n@@ -960,6 +960,10 @@ def _fill_in_launchable_resources(\\n                                 f'{colorama.Fore.CYAN}'\\n                                 f'{sorted(all_fuzzy_candidates)}'\\n                                 f'{colorama.Style.RESET_ALL}')\\n+                elif resources.cpus is not None:\\n+                    logger.info('Try specifying a different CPU count, '\\n+                                'or add \\\"+\\\" to the end of the CPU count '\\n+                                'to allow for larger instances.')\\n \\n         launchable[resources] = _filter_out_blocked_launchable_resources(\\n             launchable[resources], blocked_resources)\\n\",\"diff --git a/sky/resources.py b/sky/resources.py\\nindex 10baeaae93f..f5b960c7465 100644\\n--- a/sky/resources.py\\n+++ b/sky/resources.py\\n@@ -41,16 +41,15 @@ class Resources:\\n         # TODO:\\n         sky.Resources(requests={'mem': '16g', 'cpu': 8})\\n     \\\"\\\"\\\"\\n-    # If any fields changed:\\n-    # 1. Increment the version. For backward compatibility.\\n-    # 2. Change the __setstate__ method to handle the new fields.\\n-    # 3. Modify the to_config method to handle the new fields.\\n-    _VERSION = 6\\n+    # If any fields changed, increment the version. For backward compatibility,\\n+    # modify the __setstate__ method to handle the old version.\\n+    _VERSION = 7\\n \\n     def __init__(\\n         self,\\n         cloud: Optional[clouds.Cloud] = None,\\n         instance_type: Optional[str] = None,\\n+        cpus: Union[None, int, float, str] = None,\\n         accelerators: Union[None, str, Dict[str, int]] = None,\\n         accelerator_args: Optional[Dict[str, str]] = None,\\n         use_spot: Optional[bool] = None,\\n@@ -96,10 +95,12 @@ def __init__(\\n                     k.strip(): v.strip() for k, v in image_id.items()\\n                 }\\n \\n+        self._set_cpus(cpus)\\n         self._set_accelerators(accelerators, accelerator_args)\\n \\n         self._try_validate_local()\\n         self._try_validate_instance_type()\\n+        self._try_validate_cpus()\\n         self._try_validate_accelerators()\\n         self._try_validate_spot()\\n         self._try_validate_image_id()\\n@@ -135,6 +136,10 @@ def __repr__(self) -> str:\\n             if self.accelerator_args is not None:\\n                 accelerator_args = f', accelerator_args={self.accelerator_args}'\\n \\n+        cpus = ''\\n+        if self.cpus is not None:\\n+            cpus = f', cpus={self.cpus}'\\n+\\n         if isinstance(self.cloud, clouds.Local):\\n             return f'{self.cloud}({self.accelerators})'\\n \\n@@ -160,7 +165,7 @@ def __repr__(self) -> str:\\n \\n         hardware_str = (\\n             f'{instance_type}{use_spot}'\\n-            f'{accelerators}{accelerator_args}{image_id}{disk_size}')\\n+            f'{cpus}{accelerators}{accelerator_args}{image_id}{disk_size}')\\n         # It may have leading ',' (for example, instance_type not set) or empty\\n         # spaces.  Remove them.\\n         while hardware_str and hardware_str[0] in (',', ' '):\\n@@ -188,6 +193,19 @@ def zone(self):\\n     def instance_type(self):\\n         return self._instance_type\\n \\n+    @property\\n+    def cpus(self) -> Optional[str]:\\n+        \\\"\\\"\\\"Returns the number of vCPUs that each instance must have.\\n+\\n+        For example, cpus='4' means each instance must have exactly 4 vCPUs,\\n+        and cpus='4+' means each instance must have at least 4 vCPUs.\\n+\\n+        (Developer note: The cpus field is only used to select the instance type\\n+        at launch time. Thus, Resources in the backend's ResourceHandle will\\n+        always have the cpus field set to None.)\\n+        \\\"\\\"\\\"\\n+        return self._cpus\\n+\\n     @property\\n     def accelerators(self) -> Optional[Dict[str, int]]:\\n         \\\"\\\"\\\"Returns the accelerators field directly or by inferring.\\n@@ -227,6 +245,36 @@ def disk_size(self) -> int:\\n     def image_id(self) -> Optional[Dict[str, str]]:\\n         return self._image_id\\n \\n+    def _set_cpus(\\n+        self,\\n+        cpus: Union[None, int, float, str],\\n+    ) -> None:\\n+        if cpus is None:\\n+            self._cpus = None\\n+            return\\n+\\n+        self._cpus = str(cpus)\\n+        if isinstance(cpus, str):\\n+            if cpus.endswith('+'):\\n+                num_cpus_str = cpus[:-1]\\n+            else:\\n+                num_cpus_str = cpus\\n+\\n+            try:\\n+                num_cpus = float(num_cpus_str)\\n+            except ValueError:\\n+                with ux_utils.print_exception_no_traceback():\\n+                    raise ValueError(\\n+                        f'The \\\"cpus\\\" field should be either a number or '\\n+                        f'a string \\\"<number>+\\\". Found: {cpus!r}') from None\\n+        else:\\n+            num_cpus = float(cpus)\\n+\\n+        if num_cpus <= 0:\\n+            with ux_utils.print_exception_no_traceback():\\n+                raise ValueError(\\n+                    f'The \\\"cpus\\\" field should be positive. Found: {cpus!r}')\\n+\\n     def _set_accelerators(\\n         self,\\n         accelerators: Union[None, str, Dict[str, int]],\\n@@ -375,6 +423,30 @@ def _try_validate_instance_type(self) -> None:\\n                 f'inferred from the instance_type {self.instance_type!r}.')\\n             self._cloud = valid_clouds[0]\\n \\n+    def _try_validate_cpus(self) -> None:\\n+        if self.cpus is None:\\n+            return\\n+        if self.instance_type is not None:\\n+            # The assertion should be true because we have already executed\\n+            # _try_validate_instance_type() before this method.\\n+            # The _try_validate_instance_type() method infers and sets\\n+            # self.cloud if self.instance_type is not None.\\n+            assert self.cloud is not None\\n+            cpus = self.cloud.get_vcpus_from_instance_type(self.instance_type)\\n+            if self.cpus.endswith('+'):\\n+                if cpus < float(self.cpus[:-1]):\\n+                    with ux_utils.print_exception_no_traceback():\\n+                        raise ValueError(\\n+                            f'{self.instance_type} does not have enough vCPUs. '\\n+                            f'{self.instance_type} has {cpus} vCPUs, '\\n+                            f'but {self.cpus} is requested.')\\n+            elif cpus != float(self.cpus):\\n+                with ux_utils.print_exception_no_traceback():\\n+                    raise ValueError(\\n+                        f'{self.instance_type} does not have the requested '\\n+                        f'number of vCPUs. {self.instance_type} has {cpus} '\\n+                        f'vCPUs, but {self.cpus} is requested.')\\n+\\n     def _try_validate_accelerators(self) -> None:\\n         \\\"\\\"\\\"Validate accelerators against the instance type and region/zone.\\\"\\\"\\\"\\n         acc_requested = self.accelerators\\n@@ -526,62 +598,6 @@ def get_cost(self, seconds: float) -> float:\\n                 self.accelerators, self.use_spot, self._region, self._zone)\\n         return hourly_cost * hours\\n \\n-    def is_same_resources(self, other: 'Resources') -> bool:\\n-        \\\"\\\"\\\"Returns whether two resources are the same.\\n-\\n-        Returns True if they are the same, False if not.\\n-        \\\"\\\"\\\"\\n-        if (self.cloud is None) != (other.cloud is None):\\n-            # self and other's cloud should be both None or both not None\\n-            return False\\n-\\n-        if self.cloud is not None and not self.cloud.is_same_cloud(other.cloud):\\n-            return False\\n-        # self.cloud == other.cloud\\n-\\n-        if (self.region is None) != (other.region is None):\\n-            # self and other's region should be both None or both not None\\n-            return False\\n-\\n-        if self.region is not None and self.region != other.region:\\n-            return False\\n-        # self.region <= other.region\\n-\\n-        if (self.zone is None) != (other.zone is None):\\n-            # self and other's zone should be both None or both not None\\n-            return False\\n-\\n-        if self.zone is not None and self.zone != other.zone:\\n-            return False\\n-\\n-        if (self.image_id is None) != (other.image_id is None):\\n-            # self and other's image id should be both None or both not None\\n-            return False\\n-\\n-        if (self.image_id is not None and self.image_id != other.image_id):\\n-            return False\\n-\\n-        if (self._instance_type is not None and\\n-                self._instance_type != other.instance_type):\\n-            return False\\n-        # self._instance_type == other.instance_type\\n-\\n-        other_accelerators = other.accelerators\\n-        accelerators = self.accelerators\\n-        if accelerators != other_accelerators:\\n-            return False\\n-        # self.accelerators == other.accelerators\\n-\\n-        if self.accelerator_args != other.accelerator_args:\\n-            return False\\n-        # self.accelerator_args == other.accelerator_args\\n-\\n-        if self.use_spot != other.use_spot:\\n-            return False\\n-\\n-        # self == other\\n-        return True\\n-\\n     def less_demanding_than(self,\\n                             other: Union[List['Resources'], 'Resources'],\\n                             requested_num_nodes: int = 1) -> bool:\\n@@ -677,6 +693,7 @@ def is_empty(self) -> bool:\\n         return all([\\n             self.cloud is None,\\n             self._instance_type is None,\\n+            self.cpus is None,\\n             self.accelerators is None,\\n             self.accelerator_args is None,\\n             not self._use_spot_specified,\\n@@ -688,6 +705,7 @@ def copy(self, **override) -> 'Resources':\\n         resources = Resources(\\n             cloud=override.pop('cloud', self.cloud),\\n             instance_type=override.pop('instance_type', self.instance_type),\\n+            cpus=override.pop('cpus', self.cpus),\\n             accelerators=override.pop('accelerators', self.accelerators),\\n             accelerator_args=override.pop('accelerator_args',\\n                                           self.accelerator_args),\\n@@ -726,6 +744,8 @@ def from_yaml_config(cls, config: Optional[Dict[str, str]]) -> 'Resources':\\n                 config.pop('cloud'))\\n         if config.get('instance_type') is not None:\\n             resources_fields['instance_type'] = config.pop('instance_type')\\n+        if config.get('cpus') is not None:\\n+            resources_fields['cpus'] = str(config.pop('cpus'))\\n         if config.get('accelerators') is not None:\\n             resources_fields['accelerators'] = config.pop('accelerators')\\n         if config.get('accelerator_args') is not None:\\n@@ -759,6 +779,7 @@ def add_if_not_none(key, value):\\n \\n         add_if_not_none('cloud', str(self.cloud))\\n         add_if_not_none('instance_type', self.instance_type)\\n+        add_if_not_none('cpus', self.cpus)\\n         add_if_not_none('accelerators', self.accelerators)\\n         add_if_not_none('accelerator_args', self.accelerator_args)\\n \\n@@ -818,6 +839,9 @@ def __setstate__(self, state):\\n                 }\\n             state['_accelerators'] = accelerators\\n \\n+        if version < 7:\\n+            self._cpus = None\\n+\\n         image_id = state.get('_image_id', None)\\n         if isinstance(image_id, str):\\n             state['_image_id'] = {state.get('_region', None): image_id}\\n\",\"diff --git a/sky/task.py b/sky/task.py\\nindex 613f23edb14..d9f4642232b 100644\\n--- a/sky/task.py\\n+++ b/sky/task.py\\n@@ -448,6 +448,7 @@ def set_resources(\\n         \\\"\\\"\\\"\\n         if isinstance(resources, sky.Resources):\\n             resources = {resources}\\n+        # TODO(woosuk): Check if the resources are None.\\n         self.resources = resources\\n         return self\\n \\n\",\"diff --git a/sky/utils/schemas.py b/sky/utils/schemas.py\\nindex cdd1865aaaf..c71c83b0e8f 100644\\n--- a/sky/utils/schemas.py\\n+++ b/sky/utils/schemas.py\\n@@ -25,6 +25,13 @@ def get_resources_schema():\\n             'zone': {\\n                 'type': 'string',\\n             },\\n+            'cpus': {\\n+                'anyOf': [{\\n+                    'type': 'string',\\n+                }, {\\n+                    'type': 'number',\\n+                }],\\n+            },\\n             'accelerators': {\\n                 'anyOf': [{\\n                     'type': 'string',\\n\"]", "test_patch": "[\"diff --git a/sky/cli.py b/sky/cli.py\\nindex 8d504a0ce59..7a757df0c0f 100644\\n--- a/sky/cli.py\\n+++ b/sky/cli.py\\n@@ -174,6 +174,13 @@ def _interactive_node_cli_command(cli_func):\\n                                         default=None,\\n                                         type=str,\\n                                         help='Instance type to use.')\\n+    cpus = click.option(\\n+        '--cpus',\\n+        default=None,\\n+        type=str,\\n+        help=('Number of vCPUs each instance must have '\\n+              '(e.g., ``--cpus=4`` (exactly 4) or ``--cpus=4+`` (at least 4)). '\\n+              'This is used to automatically select the instance type.'))\\n     gpus = click.option('--gpus',\\n                         default=None,\\n                         type=str,\\n@@ -268,6 +275,7 @@ def _interactive_node_cli_command(cli_func):\\n         region_option,\\n         zone_option,\\n         instance_type_option,\\n+        cpus,\\n         *([gpus] if cli_func.__name__ == 'gpunode' else []),\\n         *([tpus] if cli_func.__name__ == 'tpunode' else []),\\n         spot_option,\\n@@ -556,6 +564,7 @@ def _parse_override_params(cloud: Optional[str] = None,\\n                            region: Optional[str] = None,\\n                            zone: Optional[str] = None,\\n                            gpus: Optional[str] = None,\\n+                           cpus: Optional[str] = None,\\n                            instance_type: Optional[str] = None,\\n                            use_spot: Optional[bool] = None,\\n                            image_id: Optional[str] = None,\\n@@ -582,6 +591,11 @@ def _parse_override_params(cloud: Optional[str] = None,\\n             override_params['accelerators'] = None\\n         else:\\n             override_params['accelerators'] = gpus\\n+    if cpus is not None:\\n+        if cpus.lower() == 'none':\\n+            override_params['cpus'] = None\\n+        else:\\n+            override_params['cpus'] = cpus\\n     if instance_type is not None:\\n         if instance_type.lower() == 'none':\\n             override_params['instance_type'] = None\\n@@ -908,6 +922,7 @@ def _make_task_from_entrypoint_with_overrides(\\n     region: Optional[str] = None,\\n     zone: Optional[str] = None,\\n     gpus: Optional[str] = None,\\n+    cpus: Optional[str] = None,\\n     instance_type: Optional[str] = None,\\n     num_nodes: Optional[int] = None,\\n     use_spot: Optional[bool] = None,\\n@@ -949,6 +964,7 @@ def _make_task_from_entrypoint_with_overrides(\\n                                              region=region,\\n                                              zone=zone,\\n                                              gpus=gpus,\\n+                                             cpus=cpus,\\n                                              instance_type=instance_type,\\n                                              use_spot=use_spot,\\n                                              image_id=image_id,\\n@@ -1090,6 +1106,13 @@ def cli():\\n               default=False,\\n               help='If used, runs locally inside a docker container.')\\n @_add_click_options(_TASK_OPTIONS + _EXTRA_RESOURCES_OPTIONS)\\n+@click.option('--cpus',\\n+              default=None,\\n+              type=str,\\n+              required=False,\\n+              help=('Number of vCPUs each instance must have (e.g., '\\n+                    '``--cpus=4`` (exactly 4) or ``--cpus=4+`` (at least 4)). '\\n+                    'This is used to automatically select the instance type.'))\\n @click.option('--disk-size',\\n               default=None,\\n               type=int,\\n@@ -1154,6 +1177,7 @@ def launch(\\n     region: Optional[str],\\n     zone: Optional[str],\\n     gpus: Optional[str],\\n+    cpus: Optional[str],\\n     instance_type: Optional[str],\\n     num_nodes: Optional[int],\\n     use_spot: Optional[bool],\\n@@ -1198,6 +1222,7 @@ def launch(\\n         region=region,\\n         zone=zone,\\n         gpus=gpus,\\n+        cpus=cpus,\\n         instance_type=instance_type,\\n         num_nodes=num_nodes,\\n         use_spot=use_spot,\\n@@ -1343,6 +1368,7 @@ def exec(\\n         region=region,\\n         zone=zone,\\n         gpus=gpus,\\n+        cpus=None,\\n         instance_type=instance_type,\\n         use_spot=use_spot,\\n         image_id=image_id,\\n@@ -2414,11 +2440,11 @@ def _down_or_stop(name: str):\\n # pylint: disable=redefined-outer-name\\n def gpunode(cluster: str, yes: bool, port_forward: Optional[List[int]],\\n             cloud: Optional[str], region: Optional[str], zone: Optional[str],\\n-            instance_type: Optional[str], gpus: Optional[str],\\n-            use_spot: Optional[bool], screen: Optional[bool],\\n-            tmux: Optional[bool], disk_size: Optional[int],\\n-            idle_minutes_to_autostop: Optional[int], down: bool,\\n-            retry_until_up: bool):\\n+            instance_type: Optional[str], cpus: Optional[str],\\n+            gpus: Optional[str], use_spot: Optional[bool],\\n+            screen: Optional[bool], tmux: Optional[bool],\\n+            disk_size: Optional[int], idle_minutes_to_autostop: Optional[int],\\n+            down: bool, retry_until_up: bool):\\n     \\\"\\\"\\\"Launch or attach to an interactive GPU node.\\n \\n     Examples:\\n@@ -2457,7 +2483,8 @@ def gpunode(cluster: str, yes: bool, port_forward: Optional[List[int]],\\n \\n     user_requested_resources = not (cloud is None and region is None and\\n                                     zone is None and instance_type is None and\\n-                                    gpus is None and use_spot is None)\\n+                                    cpus is None and gpus is None and\\n+                                    use_spot is None)\\n     default_resources = _INTERACTIVE_NODE_DEFAULT_RESOURCES['gpunode']\\n     cloud_provider = clouds.CLOUD_REGISTRY.from_str(cloud)\\n     if gpus is None and instance_type is None:\\n@@ -2470,6 +2497,7 @@ def gpunode(cluster: str, yes: bool, port_forward: Optional[List[int]],\\n                               region=region,\\n                               zone=zone,\\n                               instance_type=instance_type,\\n+                              cpus=cpus,\\n                               accelerators=gpus,\\n                               use_spot=use_spot,\\n                               disk_size=disk_size)\\n@@ -2493,10 +2521,11 @@ def gpunode(cluster: str, yes: bool, port_forward: Optional[List[int]],\\n # pylint: disable=redefined-outer-name\\n def cpunode(cluster: str, yes: bool, port_forward: Optional[List[int]],\\n             cloud: Optional[str], region: Optional[str], zone: Optional[str],\\n-            instance_type: Optional[str], use_spot: Optional[bool],\\n-            screen: Optional[bool], tmux: Optional[bool],\\n-            disk_size: Optional[int], idle_minutes_to_autostop: Optional[int],\\n-            down: bool, retry_until_up: bool):\\n+            instance_type: Optional[str], cpus: Optional[str],\\n+            use_spot: Optional[bool], screen: Optional[bool],\\n+            tmux: Optional[bool], disk_size: Optional[int],\\n+            idle_minutes_to_autostop: Optional[int], down: bool,\\n+            retry_until_up: bool):\\n     \\\"\\\"\\\"Launch or attach to an interactive CPU node.\\n \\n     Examples:\\n@@ -2534,7 +2563,7 @@ def cpunode(cluster: str, yes: bool, port_forward: Optional[List[int]],\\n \\n     user_requested_resources = not (cloud is None and region is None and\\n                                     zone is None and instance_type is None and\\n-                                    use_spot is None)\\n+                                    cpus is None and use_spot is None)\\n     default_resources = _INTERACTIVE_NODE_DEFAULT_RESOURCES['cpunode']\\n     cloud_provider = clouds.CLOUD_REGISTRY.from_str(cloud)\\n     if instance_type is None:\\n@@ -2545,6 +2574,7 @@ def cpunode(cluster: str, yes: bool, port_forward: Optional[List[int]],\\n                               region=region,\\n                               zone=zone,\\n                               instance_type=instance_type,\\n+                              cpus=cpus,\\n                               use_spot=use_spot,\\n                               disk_size=disk_size)\\n \\n@@ -2567,11 +2597,12 @@ def cpunode(cluster: str, yes: bool, port_forward: Optional[List[int]],\\n # pylint: disable=redefined-outer-name\\n def tpunode(cluster: str, yes: bool, port_forward: Optional[List[int]],\\n             region: Optional[str], zone: Optional[str],\\n-            instance_type: Optional[str], tpus: Optional[str],\\n-            use_spot: Optional[bool], tpu_vm: Optional[bool],\\n-            screen: Optional[bool], tmux: Optional[bool],\\n-            disk_size: Optional[int], idle_minutes_to_autostop: Optional[int],\\n-            down: bool, retry_until_up: bool):\\n+            instance_type: Optional[str], cpus: Optional[str],\\n+            tpus: Optional[str], use_spot: Optional[bool],\\n+            tpu_vm: Optional[bool], screen: Optional[bool],\\n+            tmux: Optional[bool], disk_size: Optional[int],\\n+            idle_minutes_to_autostop: Optional[int], down: bool,\\n+            retry_until_up: bool):\\n     \\\"\\\"\\\"Launch or attach to an interactive TPU node.\\n \\n     Examples:\\n@@ -2608,8 +2639,8 @@ def tpunode(cluster: str, yes: bool, port_forward: Optional[List[int]],\\n         name = _default_interactive_node_name('tpunode')\\n \\n     user_requested_resources = not (region is None and zone is None and\\n-                                    instance_type is None and tpus is None and\\n-                                    use_spot is None)\\n+                                    instance_type is None and cpus is None and\\n+                                    tpus is None and use_spot is None)\\n     default_resources = _INTERACTIVE_NODE_DEFAULT_RESOURCES['tpunode']\\n     accelerator_args = default_resources.accelerator_args\\n     if tpu_vm:\\n@@ -2625,6 +2656,7 @@ def tpunode(cluster: str, yes: bool, port_forward: Optional[List[int]],\\n                               region=region,\\n                               zone=zone,\\n                               instance_type=instance_type,\\n+                              cpus=cpus,\\n                               accelerators=tpus,\\n                               accelerator_args=accelerator_args,\\n                               use_spot=use_spot,\\n@@ -2967,6 +2999,13 @@ def spot():\\n                 **_get_shell_complete_args(_complete_file_name))\\n # TODO(zhwu): Add --dryrun option to test the launch command.\\n @_add_click_options(_TASK_OPTIONS + _EXTRA_RESOURCES_OPTIONS)\\n+@click.option('--cpus',\\n+              default=None,\\n+              type=str,\\n+              required=False,\\n+              help=('Number of vCPUs each instance must have (e.g., '\\n+                    '``--cpus=4`` (exactly 4) or ``--cpus=4+`` (at least 4)). '\\n+                    'This is used to automatically select the instance type.'))\\n @click.option('--spot-recovery',\\n               default=None,\\n               type=str,\\n@@ -3009,6 +3048,7 @@ def spot_launch(\\n     region: Optional[str],\\n     zone: Optional[str],\\n     gpus: Optional[str],\\n+    cpus: Optional[str],\\n     instance_type: Optional[str],\\n     num_nodes: Optional[int],\\n     use_spot: Optional[bool],\\n@@ -3047,6 +3087,7 @@ def spot_launch(\\n         region=region,\\n         zone=zone,\\n         gpus=gpus,\\n+        cpus=cpus,\\n         instance_type=instance_type,\\n         num_nodes=num_nodes,\\n         use_spot=use_spot,\\n\",\"diff --git a/sky/clouds/service_catalog/aws_catalog.py b/sky/clouds/service_catalog/aws_catalog.py\\nindex 150e45b384e..dfcba50848a 100644\\n--- a/sky/clouds/service_catalog/aws_catalog.py\\n+++ b/sky/clouds/service_catalog/aws_catalog.py\\n@@ -19,6 +19,12 @@\\n \\n logger = sky_logging.init_logger(__name__)\\n \\n+# This is the latest general-purpose instance family as of Jan 2023.\\n+# CPU: Intel Ice Lake 8375C.\\n+# Memory: 4 GiB RAM per 1 vCPU.\\n+_DEFAULT_INSTANCE_FAMILY = 'm6i'\\n+_DEFAULT_NUM_VCPUS = 8\\n+\\n # Keep it synced with the frequency in\\n # skypilot-catalog/.github/workflows/update-aws-catalog.yml\\n _PULL_FREQUENCY_HOURS = 7\\n@@ -94,6 +100,14 @@ def get_vcpus_from_instance_type(instance_type: str) -> Optional[float]:\\n     return common.get_vcpus_from_instance_type_impl(_df, instance_type)\\n \\n \\n+def get_default_instance_type(cpus: Optional[str] = None) -> Optional[str]:\\n+    if cpus is None:\\n+        cpus = str(_DEFAULT_NUM_VCPUS)\\n+    instance_type_prefix = f'{_DEFAULT_INSTANCE_FAMILY}.'\\n+    df = _df[_df['InstanceType'].str.startswith(instance_type_prefix)]\\n+    return common.get_instance_type_for_cpus_impl(df, cpus)\\n+\\n+\\n def get_accelerators_from_instance_type(\\n         instance_type: str) -> Optional[Dict[str, int]]:\\n     return common.get_accelerators_from_instance_type_impl(_df, instance_type)\\n@@ -102,6 +116,7 @@ def get_accelerators_from_instance_type(\\n def get_instance_type_for_accelerator(\\n     acc_name: str,\\n     acc_count: int,\\n+    cpus: Optional[str] = None,\\n     use_spot: bool = False,\\n     region: Optional[str] = None,\\n     zone: Optional[str] = None,\\n@@ -113,6 +128,7 @@ def get_instance_type_for_accelerator(\\n     return common.get_instance_type_for_accelerator_impl(df=_df,\\n                                                          acc_name=acc_name,\\n                                                          acc_count=acc_count,\\n+                                                         cpus=cpus,\\n                                                          use_spot=use_spot,\\n                                                          region=region,\\n                                                          zone=zone)\\n\",\"diff --git a/sky/clouds/service_catalog/azure_catalog.py b/sky/clouds/service_catalog/azure_catalog.py\\nindex c07f8e8ac7c..a3428c6791b 100644\\n--- a/sky/clouds/service_catalog/azure_catalog.py\\n+++ b/sky/clouds/service_catalog/azure_catalog.py\\n@@ -3,6 +3,7 @@\\n This module loads the service catalog file and can be used to query\\n instance types and pricing information for Azure.\\n \\\"\\\"\\\"\\n+import re\\n from typing import Dict, List, Optional, Tuple\\n \\n from sky import clouds as cloud_lib\\n@@ -11,6 +12,12 @@\\n \\n _df = common.read_catalog('azure/vms.csv')\\n \\n+# This is the latest general-purpose instance family as of Jan 2023.\\n+# CPU: Intel Ice Lake 8370C.\\n+# Memory: 4 GiB RAM per 1 vCPU.\\n+_DEFAULT_INSTANCE_FAMILY = 'D_v5'\\n+_DEFAULT_NUM_VCPUS = 8\\n+\\n \\n def instance_type_exists(instance_type: str) -> bool:\\n     return common.instance_type_exists_impl(_df, instance_type)\\n@@ -53,6 +60,37 @@ def get_vcpus_from_instance_type(instance_type: str) -> Optional[float]:\\n     return common.get_vcpus_from_instance_type_impl(_df, instance_type)\\n \\n \\n+def _get_instance_family(instance_type: str) -> str:\\n+    if instance_type.startswith('Basic_A'):\\n+        return 'basic_a'\\n+\\n+    assert instance_type.startswith('Standard_')\\n+    # Remove the 'Standard_' prefix.\\n+    instance_type = instance_type[len('Standard_'):]\\n+    # Remove the '_Promo' suffix if exists.\\n+    if '_Promo' in instance_type:\\n+        instance_type = instance_type[:-len('_Promo')]\\n+\\n+    # TODO(woosuk): Use better regex.\\n+    if '-' in instance_type:\\n+        x = re.match(r'([A-Za-z]+)([0-9]+)(-)([0-9]+)(.*)', instance_type)\\n+        assert x is not None, x\\n+        instance_family = x.group(1) + '_' + x.group(5)\\n+    else:\\n+        x = re.match(r'([A-Za-z]+)([0-9]+)(.*)', instance_type)\\n+        assert x is not None, x\\n+        instance_family = x.group(1) + x.group(3)\\n+    return instance_family\\n+\\n+\\n+def get_default_instance_type(cpus: Optional[str] = None) -> Optional[str]:\\n+    if cpus is None:\\n+        cpus = str(_DEFAULT_NUM_VCPUS)\\n+    df = _df[_df['InstanceType'].apply(_get_instance_family) ==\\n+             _DEFAULT_INSTANCE_FAMILY]\\n+    return common.get_instance_type_for_cpus_impl(df, cpus)\\n+\\n+\\n def get_accelerators_from_instance_type(\\n         instance_type: str) -> Optional[Dict[str, int]]:\\n     return common.get_accelerators_from_instance_type_impl(_df, instance_type)\\n@@ -61,6 +99,7 @@ def get_accelerators_from_instance_type(\\n def get_instance_type_for_accelerator(\\n         acc_name: str,\\n         acc_count: int,\\n+        cpus: Optional[str] = None,\\n         use_spot: bool = False,\\n         region: Optional[str] = None,\\n         zone: Optional[str] = None) -> Tuple[Optional[List[str]], List[str]]:\\n@@ -74,6 +113,7 @@ def get_instance_type_for_accelerator(\\n     return common.get_instance_type_for_accelerator_impl(df=_df,\\n                                                          acc_name=acc_name,\\n                                                          acc_count=acc_count,\\n+                                                         cpus=cpus,\\n                                                          use_spot=use_spot,\\n                                                          region=region,\\n                                                          zone=zone)\\n\",\"diff --git a/sky/clouds/service_catalog/gcp_catalog.py b/sky/clouds/service_catalog/gcp_catalog.py\\nindex b2cb8f4b893..01fbea39256 100644\\n--- a/sky/clouds/service_catalog/gcp_catalog.py\\n+++ b/sky/clouds/service_catalog/gcp_catalog.py\\n@@ -25,6 +25,13 @@\\n     'asia-east1',\\n ]\\n \\n+# Default instance family for CPU-only VMs.\\n+# This is the latest general-purpose instance family as of Jan 2023.\\n+# CPU: Intel Ice Lake 8373C or Cascade Lake 6268CL.\\n+# Memory: 4 GiB RAM per 1 vCPU.\\n+_DEFAULT_INSTANCE_FAMILY = 'n2-standard'\\n+_DEFAULT_NUM_VCPUS = 8\\n+\\n # This can be switched between n1 and n2.\\n # n2 is not allowed for launching GPUs.\\n _DEFAULT_HOST_VM_FAMILY = 'n1'\\n@@ -164,9 +171,19 @@ def get_vcpus_from_instance_type(instance_type: str) -> Optional[float]:\\n     return common.get_vcpus_from_instance_type_impl(_df, instance_type)\\n \\n \\n+def get_default_instance_type(cpus: Optional[str] = None) -> Optional[str]:\\n+    if cpus is None:\\n+        cpus = str(_DEFAULT_NUM_VCPUS)\\n+    instance_type_prefix = f'{_DEFAULT_INSTANCE_FAMILY}-'\\n+    df = _df[_df['InstanceType'].notna()]\\n+    df = df[df['InstanceType'].str.startswith(instance_type_prefix)]\\n+    return common.get_instance_type_for_cpus_impl(df, cpus)\\n+\\n+\\n def get_instance_type_for_accelerator(\\n         acc_name: str,\\n         acc_count: int,\\n+        cpus: Optional[str] = None,\\n         use_spot: bool = False,\\n         region: Optional[str] = None,\\n         zone: Optional[str] = None) -> Tuple[Optional[List[str]], List[str]]:\\n@@ -178,20 +195,48 @@ def get_instance_type_for_accelerator(\\n     \\\"\\\"\\\"\\n     (instance_list,\\n      fuzzy_candidate_list) = common.get_instance_type_for_accelerator_impl(\\n-         _df, acc_name, acc_count, use_spot, region, zone)\\n+         _df, acc_name, acc_count, cpus, use_spot, region, zone)\\n     if instance_list is None:\\n         return None, fuzzy_candidate_list\\n \\n     if acc_name in _A100_INSTANCE_TYPE_DICTS:\\n         # If A100 is used, host VM type must be A2.\\n         # https://cloud.google.com/compute/docs/gpus#a100-gpus\\n+\\n+        # FIXME(woosuk): This uses the knowledge that the A2 machines provide\\n+        # 12 vCPUs per GPU, except for a2-megagpu-16g which has 16 GPUs.\\n+        if cpus is not None:\\n+            num_a2_cpus = min(12 * acc_count, 96)\\n+            if cpus.endswith('+'):\\n+                if num_a2_cpus < float(cpus[:-1]):\\n+                    return None, []\\n+            else:\\n+                if num_a2_cpus != float(cpus):\\n+                    return None, []\\n         return [_A100_INSTANCE_TYPE_DICTS[acc_name][acc_count]], []\\n+\\n     if acc_name not in _NUM_ACC_TO_NUM_CPU:\\n         acc_name = 'DEFAULT'\\n \\n-    num_cpus = _NUM_ACC_TO_NUM_CPU[acc_name].get(acc_count, None)\\n-    # The (acc_name, acc_count) should be validated in the caller.\\n-    assert num_cpus is not None, (acc_name, acc_count)\\n+    assert _DEFAULT_HOST_VM_FAMILY == 'n1'\\n+    num_cpus = None\\n+    if cpus is None:\\n+        num_cpus = _NUM_ACC_TO_NUM_CPU[acc_name].get(acc_count, None)\\n+    else:\\n+        # FIXME(woosuk): This uses the knowledge that the N1-highmem machines\\n+        # have 2, 4, 8, 16, 32, 64, or 96 vCPUs.\\n+        for num_n1_cpus in [2, 4, 8, 16, 32, 64, 96]:\\n+            if cpus.endswith('+'):\\n+                if num_n1_cpus >= float(cpus[:-1]):\\n+                    num_cpus = num_n1_cpus\\n+                    break\\n+            else:\\n+                if num_n1_cpus == float(cpus):\\n+                    num_cpus = num_n1_cpus\\n+                    break\\n+    if num_cpus is None:\\n+        return None, []\\n+\\n     mem_type = 'highmem'\\n     # patches for the number of cores per GPU, as some of the combinations\\n     # are not supported by GCP.\\n@@ -403,7 +448,7 @@ def check_accelerator_attachable_to_host(instance_type: str,\\n     acc_name, acc_count = acc[0]\\n \\n     if acc_name.startswith('tpu-'):\\n-        # TODO(woosuk): Check max vcpus and memory for each TPU type.\\n+        # TODO(woosuk): Check max vCPUs and memory for each TPU type.\\n         assert instance_type == 'TPU-VM' or instance_type.startswith('n1-')\\n         return\\n \\n\",\"diff --git a/tests/test_optimizer_dryruns.py b/tests/test_optimizer_dryruns.py\\nindex 079d28232a0..16fd6c6e93d 100644\\n--- a/tests/test_optimizer_dryruns.py\\n+++ b/tests/test_optimizer_dryruns.py\\n@@ -9,6 +9,15 @@\\n from sky import exceptions\\n \\n \\n+def _test_parse_cpus(spec, expected_cpus):\\n+    with tempfile.NamedTemporaryFile('w') as f:\\n+        f.write(spec)\\n+        f.flush()\\n+        with sky.Dag():\\n+            task = sky.Task.from_yaml(f.name)\\n+            assert list(task.resources)[0].cpus == expected_cpus\\n+\\n+\\n def _test_parse_accelerators(spec, expected_accelerators):\\n     with tempfile.NamedTemporaryFile('w') as f:\\n         f.write(spec)\\n@@ -90,6 +99,12 @@ def test_resources_gcp(monkeypatch):\\n     _test_resources_launch(monkeypatch, sky.GCP(), 'n1-standard-16')\\n \\n \\n+def test_partial_cpus(monkeypatch):\\n+    _test_resources_launch(monkeypatch, cpus=4)\\n+    _test_resources_launch(monkeypatch, cpus='4')\\n+    _test_resources_launch(monkeypatch, cpus='7+')\\n+\\n+\\n def test_partial_k80(monkeypatch):\\n     _test_resources_launch(monkeypatch, accelerators='K80')\\n \\n@@ -148,6 +163,41 @@ def test_clouds_not_enabled(monkeypatch):\\n                                enabled_clouds=[sky.AWS()])\\n \\n \\n+def test_instance_type_mismatches_cpus(monkeypatch):\\n+    bad_instance_and_cpus = [\\n+        # Actual: 8\\n+        ('m6i.2xlarge', 4),\\n+        # Actual: 2\\n+        ('c6i.large', 4),\\n+    ]\\n+    for instance, cpus in bad_instance_and_cpus:\\n+        with pytest.raises(ValueError) as e:\\n+            _test_resources_launch(monkeypatch,\\n+                                   sky.AWS(),\\n+                                   instance_type=instance,\\n+                                   cpus=cpus)\\n+        assert 'does not have the requested number of vCPUs' in str(e.value)\\n+\\n+\\n+def test_instance_type_matches_cpus(monkeypatch):\\n+    _test_resources_launch(monkeypatch,\\n+                           sky.AWS(),\\n+                           instance_type='c6i.8xlarge',\\n+                           cpus=32)\\n+    _test_resources_launch(monkeypatch,\\n+                           sky.Azure(),\\n+                           instance_type='Standard_E8s_v5',\\n+                           cpus='8')\\n+    _test_resources_launch(monkeypatch,\\n+                           sky.GCP(),\\n+                           instance_type='n1-standard-8',\\n+                           cpus='7+')\\n+    _test_resources_launch(monkeypatch,\\n+                           sky.AWS(),\\n+                           instance_type='g4dn.2xlarge',\\n+                           cpus=8.0)\\n+\\n+\\n def test_instance_type_mistmatches_accelerators(monkeypatch):\\n     bad_instance_and_accs = [\\n         # Actual: V100\\n@@ -209,6 +259,13 @@ def test_infer_cloud_from_instance_type(monkeypatch):\\n                     expected_cloud=sky.Azure())\\n \\n \\n+def test_invalid_cpus(monkeypatch):\\n+    for cloud in [sky.AWS(), sky.Azure(), sky.GCP(), None]:\\n+        with pytest.raises(ValueError) as e:\\n+            _test_resources(monkeypatch, cloud, cpus='invalid')\\n+        assert '\\\"cpus\\\" field should be' in str(e.value)\\n+\\n+\\n def test_invalid_region(monkeypatch):\\n     for cloud in [sky.AWS(), sky.Azure(), sky.GCP()]:\\n         with pytest.raises(ValueError) as e:\\n@@ -287,6 +344,23 @@ def test_valid_image(monkeypatch):\\n     )\\n \\n \\n+def test_parse_cpus_from_yaml():\\n+    spec = textwrap.dedent(\\\"\\\"\\\"\\\\\\n+        resources:\\n+            cpus: 1\\\"\\\"\\\")\\n+    _test_parse_cpus(spec, '1')\\n+\\n+    spec = textwrap.dedent(\\\"\\\"\\\"\\\\\\n+        resources:\\n+            cpus: 1.5\\\"\\\"\\\")\\n+    _test_parse_cpus(spec, '1.5')\\n+\\n+    spec = textwrap.dedent(\\\"\\\"\\\"\\\\\\n+        resources:\\n+            cpus: '3+' \\\"\\\"\\\")\\n+    _test_parse_cpus(spec, '3+')\\n+\\n+\\n def test_parse_accelerators_from_yaml():\\n     spec = textwrap.dedent(\\\"\\\"\\\"\\\\\\n       resources:\"]", "hints_text": ""}

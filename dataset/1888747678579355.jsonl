{"instance_id": "1888747678579355", "repo": "agronholm/anyio", "base_commit": "791d1d231cd390a047bf2c0a766f88ef5a1b477b", "problem_statement": "Function is missing type annotation for __init__(self):\\nThe minimal code is:\\r\\n~~~~\\r\\nclass MyClass:\\r\\n    def __init__(self):\\r\\n        pass\\r\\n~~~~\\r\\n\\r\\nWhen running `mypy code.cpp` with the following `mypy.ini`\\r\\n\\r\\n~~~~\\r\\n[mypy]\\r\\nignore_missing_imports = True\\r\\ndisallow_untyped_defs = True\\r\\n~~~~\\r\\n\\r\\nit says:\\r\\n\\r\\n~~~~~\\r\\ncode.py:2: error: Function is missing a type annotation\\r\\n~~~~~\\r\\n\\r\\nThe expected result is not errors\\r\\n", "FAIL_TO_PASS": ["tests/test_debugging.py::test_non_main_task_name[asyncio+uvloop-name-b'name']", "tests/streams/test_text.py::test_bidirectional_stream[asyncio+uvloop]", "tests/streams/test_text.py::test_bidirectional_stream[asyncio]", "tests/test_debugging.py::test_non_main_task_name[asyncio+uvloop--]", "tests/test_debugging.py::test_non_main_task_name[asyncio--]", "tests/test_debugging.py::test_non_main_task_name[asyncio-name-b'name']"], "PASS_TO_PASS": [], "language": "python", "test_command": "source /saved/ENV || source /saved/*/ENV && pytest --no-header -rA --tb=no -p no:cacheprovider --continue-on-collection-errors", "test_output_parser": "python/parse_log_pytest_v3", "image_storage_uri": "vmvm-registry.fbinfra.net/repomate_image_activ_pytest/agronholm_anyio:791d1d231cd390a047bf2c0a766f88ef5a1b477b", "patch": "", "test_patch": "[\"diff --git a/setup.cfg b/setup.cfg\\nindex 353182a..931b930 100644\\n--- a/setup.cfg\\n+++ b/setup.cfg\\n@@ -60,3 +60,4 @@ pytest11 =\\n \\n [mypy]\\n ignore_missing_imports = true\\n+disallow_untyped_defs = true\\n\",\"diff --git a/src/anyio/_backends/_trio.py b/src/anyio/_backends/_trio.py\\nindex 48be7a5..4276490 100644\\n--- a/src/anyio/_backends/_trio.py\\n+++ b/src/anyio/_backends/_trio.py\\n@@ -8,11 +8,12 @@ from io import IOBase\\n from os import PathLike\\n from types import TracebackType\\n from typing import (\\n-    Any, Awaitable, Callable, Collection, Coroutine, Dict, Generic, List, Mapping, NoReturn,\\n-    Optional, Set, Tuple, Type, TypeVar, Union)\\n+    Any, Awaitable, Callable, Collection, ContextManager, Coroutine, Deque, Dict, Generic, List,\\n+    Mapping, NoReturn, Optional, Sequence, Set, Tuple, Type, TypeVar, Union)\\n \\n import trio.from_thread\\n-from outcome import Error, Value\\n+from outcome import Error, Outcome, Value\\n+from trio.socket import SocketType as TrioSocketType\\n from trio.to_thread import run_sync\\n \\n from .. import CapacityLimiterStatistics, EventStatistics, TaskInfo, abc\\n@@ -36,6 +37,7 @@ except ImportError:\\n else:\\n     from trio.lowlevel import wait_readable, wait_writable\\n \\n+\\n T_Retval = TypeVar('T_Retval')\\n T_SockAddr = TypeVar('T_SockAddr', str, IPSockAddrType)\\n \\n@@ -61,17 +63,20 @@ sleep = trio.sleep\\n #\\n \\n class CancelScope(BaseCancelScope):\\n-    def __new__(cls, original: Optional[trio.CancelScope] = None, **kwargs):\\n+    def __new__(cls, original: Optional[trio.CancelScope] = None,\\n+                **kwargs: object) -> 'CancelScope':\\n         return object.__new__(cls)\\n \\n-    def __init__(self, original: Optional[trio.CancelScope] = None, **kwargs):\\n+    def __init__(self, original: Optional[trio.CancelScope] = None, **kwargs: object) -> None:\\n         self.__original = original or trio.CancelScope(**kwargs)\\n \\n-    def __enter__(self):\\n+    def __enter__(self) -> 'CancelScope':\\n         self.__original.__enter__()\\n         return self\\n \\n-    def __exit__(self, exc_type, exc_val, exc_tb):\\n+    def __exit__(self, exc_type: Optional[Type[BaseException]],\\n+                 exc_val: Optional[BaseException],\\n+                 exc_tb: Optional[TracebackType]) -> Optional[bool]:\\n         return self.__original.__exit__(exc_type, exc_val, exc_tb)\\n \\n     def cancel(self) -> DeprecatedAwaitable:\\n@@ -116,12 +121,12 @@ class ExceptionGroup(BaseExceptionGroup, trio.MultiError):\\n \\n \\n class TaskGroup(abc.TaskGroup):\\n-    def __init__(self):\\n+    def __init__(self) -> None:\\n         self._active = False\\n         self._nursery_manager = trio.open_nursery()\\n-        self.cancel_scope = None\\n+        self.cancel_scope = None  # type: ignore[assignment]\\n \\n-    async def __aenter__(self):\\n+    async def __aenter__(self) -> 'TaskGroup':\\n         self._active = True\\n         self._nursery = await self._nursery_manager.__aenter__()\\n         self.cancel_scope = CancelScope(self._nursery.cancel_scope)\\n@@ -137,13 +142,14 @@ class TaskGroup(abc.TaskGroup):\\n         finally:\\n             self._active = False\\n \\n-    def start_soon(self, func: Callable, *args, name=None) -> None:\\n+    def start_soon(self, func: Callable, *args: object, name: object = None) -> None:\\n         if not self._active:\\n             raise RuntimeError('This task group is not active; no new tasks can be started.')\\n \\n         self._nursery.start_soon(func, *args, name=name)\\n \\n-    async def start(self, func: Callable[..., Coroutine], *args, name=None):\\n+    async def start(self, func: Callable[..., Coroutine],\\n+                    *args: object, name: object = None) -> object:\\n         if not self._active:\\n             raise RuntimeError('This task group is not active; no new tasks can be started.')\\n \\n@@ -155,9 +161,9 @@ class TaskGroup(abc.TaskGroup):\\n \\n \\n async def run_sync_in_worker_thread(\\n-        func: Callable[..., T_Retval], *args, cancellable: bool = False,\\n+        func: Callable[..., T_Retval], *args: object, cancellable: bool = False,\\n         limiter: Optional[trio.CapacityLimiter] = None) -> T_Retval:\\n-    def wrapper():\\n+    def wrapper() -> T_Retval:\\n         with claim_worker_thread('trio'):\\n             return func(*args)\\n \\n@@ -168,15 +174,15 @@ run_sync_from_thread = trio.from_thread.run_sync\\n \\n \\n class BlockingPortal(abc.BlockingPortal):\\n-    def __new__(cls):\\n+    def __new__(cls) -> 'BlockingPortal':\\n         return object.__new__(cls)\\n \\n-    def __init__(self):\\n+    def __init__(self) -> None:\\n         super().__init__()\\n         self._token = trio.lowlevel.current_trio_token()\\n \\n     def _spawn_task_from_thread(self, func: Callable, args: tuple, kwargs: Dict[str, Any],\\n-                                name, future: Future) -> None:\\n+                                name: object, future: Future) -> None:\\n         return trio.from_thread.run_sync(\\n             partial(self._task_group.start_soon, name=name), self._call_func, func, args, kwargs,\\n             future, trio_token=self._token)\\n@@ -273,7 +279,8 @@ class Process(abc.Process):\\n         return self._stderr\\n \\n \\n-async def open_process(command, *, shell: bool, stdin: int, stdout: int, stderr: int,\\n+async def open_process(command: Union[str, Sequence[str]], *, shell: bool,\\n+                       stdin: int, stdout: int, stderr: int,\\n                        cwd: Union[str, bytes, PathLike, None] = None,\\n                        env: Optional[Mapping[str, str]] = None) -> Process:\\n     process = await trio.open_process(command, stdin=stdin, stdout=stdout, stderr=stderr,\\n@@ -285,7 +292,7 @@ async def open_process(command, *, shell: bool, stdin: int, stdout: int, stderr:\\n \\n \\n class _ProcessPoolShutdownInstrument(trio.abc.Instrument):\\n-    def after_run(self):\\n+    def after_run(self) -> None:\\n         super().after_run()\\n \\n \\n@@ -316,7 +323,7 @@ def setup_process_pool_exit_at_shutdown(workers: Set[Process]) -> None:\\n #\\n \\n class _TrioSocketMixin(Generic[T_SockAddr]):\\n-    def __init__(self, trio_socket):\\n+    def __init__(self, trio_socket: TrioSocketType) -> None:\\n         self._trio_socket = trio_socket\\n         self._closed = False\\n \\n@@ -347,7 +354,7 @@ class _TrioSocketMixin(Generic[T_SockAddr]):\\n \\n \\n class SocketStream(_TrioSocketMixin, abc.SocketStream):\\n-    def __init__(self, trio_socket):\\n+    def __init__(self, trio_socket: TrioSocketType) -> None:\\n         super().__init__(trio_socket)\\n         self._receive_guard = ResourceGuard('reading from')\\n         self._send_guard = ResourceGuard('writing to')\\n@@ -467,7 +474,7 @@ class UNIXSocketListener(_TrioSocketMixin, abc.SocketListener):\\n \\n \\n class UDPSocket(_TrioSocketMixin[IPSockAddrType], abc.UDPSocket):\\n-    def __init__(self, trio_socket):\\n+    def __init__(self, trio_socket: TrioSocketType) -> None:\\n         super().__init__(trio_socket)\\n         self._receive_guard = ResourceGuard('reading from')\\n         self._send_guard = ResourceGuard('writing to')\\n@@ -489,7 +496,7 @@ class UDPSocket(_TrioSocketMixin[IPSockAddrType], abc.UDPSocket):\\n \\n \\n class ConnectedUDPSocket(_TrioSocketMixin[IPSockAddrType], abc.ConnectedUDPSocket):\\n-    def __init__(self, trio_socket):\\n+    def __init__(self, trio_socket: TrioSocketType) -> None:\\n         super().__init__(trio_socket)\\n         self._receive_guard = ResourceGuard('reading from')\\n         self._send_guard = ResourceGuard('writing to')\\n@@ -562,7 +569,7 @@ getaddrinfo = trio.socket.getaddrinfo\\n getnameinfo = trio.socket.getnameinfo\\n \\n \\n-async def wait_socket_readable(sock):\\n+async def wait_socket_readable(sock: socket.SocketType) -> None:\\n     try:\\n         await wait_readable(sock)\\n     except trio.ClosedResourceError as exc:\\n@@ -571,7 +578,7 @@ async def wait_socket_readable(sock):\\n         raise BusyResourceError('reading from') from None\\n \\n \\n-async def wait_socket_writable(sock):\\n+async def wait_socket_writable(sock: socket.SocketType) -> None:\\n     try:\\n         await wait_writable(sock)\\n     except trio.ClosedResourceError as exc:\\n@@ -585,34 +592,34 @@ async def wait_socket_writable(sock):\\n #\\n \\n class Event(BaseEvent):\\n-    def __new__(cls):\\n+    def __new__(cls) -> 'Event':\\n         return object.__new__(cls)\\n \\n-    def __init__(self):\\n+    def __init__(self) -> None:\\n         self.__original = trio.Event()\\n \\n     def is_set(self) -> bool:\\n         return self.__original.is_set()\\n \\n-    async def wait(self) -> bool:\\n+    async def wait(self) -> None:\\n         return await self.__original.wait()\\n \\n     def statistics(self) -> EventStatistics:\\n         return self.__original.statistics()\\n \\n-    def set(self):\\n+    def set(self) -> DeprecatedAwaitable:\\n         self.__original.set()\\n         return DeprecatedAwaitable(self.set)\\n \\n \\n class CapacityLimiter(BaseCapacityLimiter):\\n-    def __new__(cls, *args, **kwargs):\\n+    def __new__(cls, *args: object, **kwargs: object) -> \\\"CapacityLimiter\\\":\\n         return object.__new__(cls)\\n \\n-    def __init__(self, *args, original: Optional[trio.CapacityLimiter] = None):\\n+    def __init__(self, *args: object, original: Optional[trio.CapacityLimiter] = None) -> None:\\n         self.__original = original or trio.CapacityLimiter(*args)\\n \\n-    async def __aenter__(self):\\n+    async def __aenter__(self) -> None:\\n         return await self.__original.__aenter__()\\n \\n     async def __aexit__(self, exc_type: Optional[Type[BaseException]],\\n@@ -636,24 +643,24 @@ class CapacityLimiter(BaseCapacityLimiter):\\n     def available_tokens(self) -> float:\\n         return self.__original.available_tokens\\n \\n-    def acquire_nowait(self):\\n+    def acquire_nowait(self) -> DeprecatedAwaitable:\\n         self.__original.acquire_nowait()\\n         return DeprecatedAwaitable(self.acquire_nowait)\\n \\n-    def acquire_on_behalf_of_nowait(self, borrower):\\n+    def acquire_on_behalf_of_nowait(self, borrower: object) -> DeprecatedAwaitable:\\n         self.__original.acquire_on_behalf_of_nowait(borrower)\\n         return DeprecatedAwaitable(self.acquire_on_behalf_of_nowait)\\n \\n     async def acquire(self) -> None:\\n         await self.__original.acquire()\\n \\n-    async def acquire_on_behalf_of(self, borrower) -> None:\\n+    async def acquire_on_behalf_of(self, borrower: object) -> None:\\n         await self.__original.acquire_on_behalf_of(borrower)\\n \\n     def release(self) -> None:\\n         return self.__original.release()\\n \\n-    def release_on_behalf_of(self, borrower) -> None:\\n+    def release_on_behalf_of(self, borrower: object) -> None:\\n         return self.__original.release_on_behalf_of(borrower)\\n \\n     def statistics(self) -> CapacityLimiterStatistics:\\n@@ -677,17 +684,19 @@ def current_default_thread_limiter() -> CapacityLimiter:\\n #\\n \\n class _SignalReceiver(DeprecatedAsyncContextManager):\\n-    def __init__(self, cm):\\n+    def __init__(self, cm: ContextManager[T]):\\n         self._cm = cm\\n \\n     def __enter__(self) -> T:\\n         return self._cm.__enter__()\\n \\n-    def __exit__(self, exc_type, exc_val, exc_tb):\\n+    def __exit__(self, exc_type: Optional[Type[BaseException]],\\n+                 exc_val: Optional[BaseException],\\n+                 exc_tb: Optional[TracebackType]) -> Optional[bool]:\\n         return self._cm.__exit__(exc_type, exc_val, exc_tb)\\n \\n \\n-def open_signal_receiver(*signals: int):\\n+def open_signal_receiver(*signals: int) -> _SignalReceiver:\\n     cm = trio.open_signal_receiver(*signals)\\n     return _SignalReceiver(cm)\\n \\n@@ -723,18 +732,18 @@ def get_running_tasks() -> List[TaskInfo]:\\n     return task_infos\\n \\n \\n-def wait_all_tasks_blocked():\\n+def wait_all_tasks_blocked() -> Awaitable[None]:\\n     import trio.testing\\n     return trio.testing.wait_all_tasks_blocked()\\n \\n \\n class TestRunner(abc.TestRunner):\\n-    def __init__(self, **options):\\n+    def __init__(self, **options: object) -> None:\\n         from collections import deque\\n         from queue import Queue\\n \\n-        self._call_queue = Queue()\\n-        self._result_queue = deque()\\n+        self._call_queue: \\\"Queue[Callable[..., object]]\\\" = Queue()\\n+        self._result_queue: Deque[Outcome] = deque()\\n         self._stop_event: Optional[trio.Event] = None\\n         self._nursery: Optional[trio.Nursery] = None\\n         self._options = options\\n@@ -744,7 +753,8 @@ class TestRunner(abc.TestRunner):\\n         async with trio.open_nursery() as self._nursery:\\n             await self._stop_event.wait()\\n \\n-    async def _call_func(self, func, args, kwargs):\\n+    async def _call_func(self, func: Callable[..., Awaitable[object]],\\n+                         args: tuple, kwargs: dict) -> None:\\n         try:\\n             retval = await func(*args, **kwargs)\\n         except BaseException as exc:\\n@@ -752,7 +762,7 @@ class TestRunner(abc.TestRunner):\\n         else:\\n             self._result_queue.append(Value(retval))\\n \\n-    def _main_task_finished(self, outcome) -> None:\\n+    def _main_task_finished(self, outcome: object) -> None:\\n         self._nursery = None\\n \\n     def close(self) -> None:\\n@@ -761,7 +771,8 @@ class TestRunner(abc.TestRunner):\\n             while self._nursery is not None:\\n                 self._call_queue.get()()\\n \\n-    def call(self, func: Callable[..., Awaitable], *args, **kwargs):\\n+    def call(self, func: Callable[..., Awaitable[T_Retval]],\\n+             *args: object, **kwargs: object) -> T_Retval:\\n         if self._nursery is None:\\n             trio.lowlevel.start_guest_run(\\n                 self._trio_main, run_sync_soon_threadsafe=self._call_queue.put,\\n\",\"diff --git a/src/anyio/_core/_compat.py b/src/anyio/_core/_compat.py\\nindex 9f44ea9..0ebfeb2 100644\\n--- a/src/anyio/_core/_compat.py\\n+++ b/src/anyio/_core/_compat.py\\n@@ -1,13 +1,24 @@\\n from abc import ABCMeta, abstractmethod\\n from contextlib import AbstractContextManager\\n+from types import TracebackType\\n from typing import (\\n-    AsyncContextManager, Callable, ContextManager, Generic, List, Optional, TypeVar, Union,\\n-    overload)\\n+    TYPE_CHECKING, AsyncContextManager, Callable, ContextManager, Generic, Iterable, List,\\n+    Optional, Tuple, Type, TypeVar, Union, overload)\\n from warnings import warn\\n \\n+if TYPE_CHECKING:\\n+    from ._testing import TaskInfo\\n+else:\\n+    TaskInfo = object\\n+\\n T = TypeVar('T')\\n AnyDeprecatedAwaitable = Union['DeprecatedAwaitable', 'DeprecatedAwaitableFloat',\\n-                               'DeprecatedAwaitableList']\\n+                               'DeprecatedAwaitableList', TaskInfo]\\n+\\n+\\n+@overload\\n+async def maybe_async(__obj: TaskInfo) -> TaskInfo:\\n+    ...\\n \\n \\n @overload\\n@@ -16,7 +27,7 @@ async def maybe_async(__obj: 'DeprecatedAwaitableFloat') -> float:\\n \\n \\n @overload\\n-async def maybe_async(__obj: 'DeprecatedAwaitableList') -> list:\\n+async def maybe_async(__obj: 'DeprecatedAwaitableList[T]') -> List[T]:\\n     ...\\n \\n \\n@@ -25,7 +36,7 @@ async def maybe_async(__obj: 'DeprecatedAwaitable') -> None:\\n     ...\\n \\n \\n-async def maybe_async(__obj: AnyDeprecatedAwaitable) -> Union[float, list, None]:\\n+async def maybe_async(__obj: AnyDeprecatedAwaitable) -> Union[TaskInfo, float, list, None]:\\n     \\\"\\\"\\\"\\n     Await on the given object if necessary.\\n \\n@@ -49,7 +60,9 @@ class _ContextManagerWrapper:\\n     async def __aenter__(self) -> T:\\n         return self._cm.__enter__()\\n \\n-    async def __aexit__(self, exc_type, exc_val, exc_tb) -> Optional[bool]:\\n+    async def __aexit__(self, exc_type: Optional[Type[BaseException]],\\n+                        exc_val: Optional[BaseException],\\n+                        exc_tb: Optional[TracebackType]) -> Optional[bool]:\\n         return self._cm.__exit__(exc_type, exc_val, exc_tb)\\n \\n \\n@@ -74,7 +87,7 @@ def maybe_async_cm(cm: Union[ContextManager[T], AsyncContextManager[T]]) -> Asyn\\n \\n def _warn_deprecation(awaitable: AnyDeprecatedAwaitable, stacklevel: int = 1) -> None:\\n     warn(f'Awaiting on {awaitable._name}() is deprecated. Use \\\"await '\\n-         f'anyio.maybe_awaitable({awaitable._name}(...)) if you have to support both AnyIO 2.x '\\n+         f'anyio.maybe_async({awaitable._name}(...)) if you have to support both AnyIO 2.x '\\n          f'and 3.x, or just remove the \\\"await\\\" if you are completely migrating to AnyIO 3+.',\\n          DeprecationWarning, stacklevel=stacklevel + 1)\\n \\n@@ -83,33 +96,35 @@ class DeprecatedAwaitable:\\n     def __init__(self, func: Callable[..., 'DeprecatedAwaitable']):\\n         self._name = f'{func.__module__}.{func.__qualname__}'\\n \\n-    def __await__(self):\\n+    def __await__(self) -> Iterable[None]:\\n         _warn_deprecation(self)\\n         if False:\\n             yield\\n \\n-    def __reduce__(self):\\n+    def __reduce__(self) -> Tuple[Type[None], Tuple]:\\n         return type(None), ()\\n \\n-    def _unwrap(self):\\n+    def _unwrap(self) -> None:\\n         return None\\n \\n \\n class DeprecatedAwaitableFloat(float):\\n-    def __new__(cls, x, func):\\n+    def __new__(\\n+        cls, x: float, func: Callable[..., 'DeprecatedAwaitableFloat']\\n+    ) -> 'DeprecatedAwaitableFloat':\\n         return super().__new__(cls, x)\\n \\n     def __init__(self, x: float, func: Callable[..., 'DeprecatedAwaitableFloat']):\\n         self._name = f'{func.__module__}.{func.__qualname__}'\\n \\n-    def __await__(self):\\n+    def __await__(self) -> Iterable[float]:\\n         _warn_deprecation(self)\\n         if False:\\n             yield\\n \\n         return float(self)\\n \\n-    def __reduce__(self):\\n+    def __reduce__(self) -> Tuple[Type[float], Tuple[float]]:\\n         return float, (float(self),)\\n \\n     def _unwrap(self) -> float:\\n@@ -117,18 +132,18 @@ class DeprecatedAwaitableFloat(float):\\n \\n \\n class DeprecatedAwaitableList(List[T]):\\n-    def __init__(self, *args, func: Callable[..., 'DeprecatedAwaitableList']):\\n+    def __init__(self, *args: T, func: Callable[..., 'DeprecatedAwaitableList']):\\n         super().__init__(*args)\\n         self._name = f'{func.__module__}.{func.__qualname__}'\\n \\n-    def __await__(self):\\n+    def __await__(self) -> Iterable[List[T]]:\\n         _warn_deprecation(self)\\n         if False:\\n             yield\\n \\n-        return self\\n+        return list(self)\\n \\n-    def __reduce__(self):\\n+    def __reduce__(self) -> Tuple[Type[list], Tuple[List[T]]]:\\n         return list, (list(self),)\\n \\n     def _unwrap(self) -> List[T]:\\n@@ -141,7 +156,9 @@ class DeprecatedAsyncContextManager(Generic[T], metaclass=ABCMeta):\\n         pass\\n \\n     @abstractmethod\\n-    def __exit__(self, exc_type, exc_val, exc_tb):\\n+    def __exit__(self, exc_type: Optional[Type[BaseException]],\\n+                 exc_val: Optional[BaseException],\\n+                 exc_tb: Optional[TracebackType]) -> Optional[bool]:\\n         pass\\n \\n     async def __aenter__(self) -> T:\\n@@ -151,5 +168,7 @@ class DeprecatedAsyncContextManager(Generic[T], metaclass=ABCMeta):\\n              f'you are completely migrating to AnyIO 3+.', DeprecationWarning)\\n         return self.__enter__()\\n \\n-    async def __aexit__(self, exc_type, exc_val, exc_tb) -> Optional[bool]:\\n+    async def __aexit__(self, exc_type: Optional[Type[BaseException]],\\n+                        exc_val: Optional[BaseException],\\n+                        exc_tb: Optional[TracebackType]) -> Optional[bool]:\\n         return self.__exit__(exc_type, exc_val, exc_tb)\\n\",\"diff --git a/src/anyio/_core/_testing.py b/src/anyio/_core/_testing.py\\nindex 269923d..c48bd45 100644\\n--- a/src/anyio/_core/_testing.py\\n+++ b/src/anyio/_core/_testing.py\\n@@ -1,10 +1,10 @@\\n-from typing import Coroutine, Optional\\n+from typing import Coroutine, Generator, Optional\\n \\n-from ._compat import DeprecatedAwaitable, DeprecatedAwaitableList\\n+from ._compat import DeprecatedAwaitableList, _warn_deprecation\\n from ._eventloop import get_asynclib\\n \\n \\n-class TaskInfo(DeprecatedAwaitable):\\n+class TaskInfo:\\n     \\\"\\\"\\\"\\n     Represents an asynchronous task.\\n \\n@@ -15,31 +15,38 @@ class TaskInfo(DeprecatedAwaitable):\\n     :ivar ~collections.abc.Coroutine coro: the coroutine object of the task\\n     \\\"\\\"\\\"\\n \\n-    __slots__ = 'id', 'parent_id', 'name', 'coro'\\n+    __slots__ = '_name', 'id', 'parent_id', 'name', 'coro'\\n \\n     def __init__(self, id: int, parent_id: Optional[int], name: Optional[str], coro: Coroutine):\\n-        super().__init__(get_current_task)\\n+        func = get_current_task\\n+        self._name = f'{func.__module__}.{func.__qualname__}'\\n         self.id = id\\n         self.parent_id = parent_id\\n         self.name = name\\n         self.coro = coro\\n \\n-    def __await__(self):\\n-        yield from super().__await__()\\n-        return self\\n-\\n-    def __eq__(self, other):\\n+    def __eq__(self, other: object) -> bool:\\n         if isinstance(other, TaskInfo):\\n             return self.id == other.id\\n \\n         return NotImplemented\\n \\n-    def __hash__(self):\\n+    def __hash__(self) -> int:\\n         return hash(self.id)\\n \\n-    def __repr__(self):\\n+    def __repr__(self) -> str:\\n         return f'{self.__class__.__name__}(id={self.id!r}, name={self.name!r})'\\n \\n+    def __await__(self) -> Generator[None, None, \\\"TaskInfo\\\"]:\\n+        _warn_deprecation(self)\\n+        if False:\\n+            yield\\n+\\n+        return self\\n+\\n+    def _unwrap(self) -> 'TaskInfo':\\n+        return self\\n+\\n \\n def get_current_task() -> TaskInfo:\\n     \\\"\\\"\\\"\\n\",\"diff --git a/src/anyio/abc/_testing.py b/src/anyio/abc/_testing.py\\nindex ace2d9b..68aeb00 100644\\n--- a/src/anyio/abc/_testing.py\\n+++ b/src/anyio/abc/_testing.py\\n@@ -1,5 +1,8 @@\\n+import types\\n from abc import ABCMeta, abstractmethod\\n-from typing import Any, Awaitable, Callable, Dict\\n+from typing import Any, Awaitable, Callable, Dict, Optional, Type, TypeVar\\n+\\n+_T = TypeVar(\\\"_T\\\")\\n \\n \\n class TestRunner(metaclass=ABCMeta):\\n@@ -11,15 +14,19 @@ class TestRunner(metaclass=ABCMeta):\\n     def __enter__(self) -> 'TestRunner':\\n         return self\\n \\n-    def __exit__(self, exc_type, exc_val, exc_tb):\\n+    def __exit__(self, exc_type: Optional[Type[BaseException]],\\n+                 exc_val: Optional[BaseException],\\n+                 exc_tb: Optional[types.TracebackType]) -> Optional[bool]:\\n         self.close()\\n+        return None\\n \\n     @abstractmethod\\n     def close(self) -> None:\\n         \\\"\\\"\\\"Close the event loop.\\\"\\\"\\\"\\n \\n     @abstractmethod\\n-    def call(self, func: Callable[..., Awaitable], *args: tuple, **kwargs: Dict[str, Any]):\\n+    def call(self, func: Callable[..., Awaitable[_T]],\\n+             *args: tuple, **kwargs: Dict[str, Any]) -> _T:\\n         \\\"\\\"\\\"\\n         Call the given function within the backend's event loop.\\n \\n\",\"diff --git a/src/anyio/pytest_plugin.py b/src/anyio/pytest_plugin.py\\nindex 1db5176..0e99a45 100644\\n--- a/src/anyio/pytest_plugin.py\\n+++ b/src/anyio/pytest_plugin.py\\n@@ -1,7 +1,7 @@\\n import sys\\n from contextlib import contextmanager\\n from inspect import iscoroutinefunction\\n-from typing import Any, Dict, Iterator, Optional, Tuple, cast\\n+from typing import TYPE_CHECKING, Any, Dict, Iterator, Optional, Tuple, cast\\n \\n import pytest\\n import sniffio\\n@@ -14,10 +14,13 @@ if sys.version_info >= (3, 7):\\n else:\\n     from async_generator import isasyncgenfunction\\n \\n+if TYPE_CHECKING:\\n+    from _pytest.config import Config\\n+\\n _current_runner: Optional[TestRunner] = None\\n \\n \\n-def extract_backend_and_options(backend) -> Tuple[str, Dict[str, Any]]:\\n+def extract_backend_and_options(backend: object) -> Tuple[str, Dict[str, Any]]:\\n     if isinstance(backend, str):\\n         return backend, {}\\n     elif isinstance(backend, tuple) and len(backend) == 2:\\n@@ -51,13 +54,13 @@ def get_runner(backend_name: str, backend_options: Dict[str, Any]) -> Iterator[T\\n             sniffio.current_async_library_cvar.reset(token)\\n \\n \\n-def pytest_configure(config):\\n+def pytest_configure(config: \\\"Config\\\") -> None:\\n     config.addinivalue_line('markers', 'anyio: mark the (coroutine function) test to be run '\\n                                        'asynchronously via anyio.')\\n \\n \\n-def pytest_fixture_setup(fixturedef, request):\\n-    def wrapper(*args, anyio_backend, **kwargs):\\n+def pytest_fixture_setup(fixturedef: Any, request: Any) -> None:\\n+    def wrapper(*args, anyio_backend, **kwargs):  # type: ignore[no-untyped-def]\\n         backend_name, backend_options = extract_backend_and_options(anyio_backend)\\n         if has_backend_arg:\\n             kwargs['anyio_backend'] = anyio_backend\\n@@ -94,7 +97,7 @@ def pytest_fixture_setup(fixturedef, request):\\n \\n \\n @pytest.hookimpl(tryfirst=True)\\n-def pytest_pycollect_makeitem(collector, name, obj):\\n+def pytest_pycollect_makeitem(collector: Any, name: Any, obj: Any) -> None:\\n     if collector.istestfunction(obj, name):\\n         inner_func = obj.hypothesis.inner_test if hasattr(obj, 'hypothesis') else obj\\n         if iscoroutinefunction(inner_func):\\n@@ -105,8 +108,8 @@ def pytest_pycollect_makeitem(collector, name, obj):\\n \\n \\n @pytest.hookimpl(tryfirst=True)\\n-def pytest_pyfunc_call(pyfuncitem):\\n-    def run_with_hypothesis(**kwargs):\\n+def pytest_pyfunc_call(pyfuncitem: Any) -> Optional[bool]:\\n+    def run_with_hypothesis(**kwargs: Any) -> None:\\n         with get_runner(backend_name, backend_options) as runner:\\n             runner.call(original_func, **kwargs)\\n \\n@@ -131,14 +134,16 @@ def pytest_pyfunc_call(pyfuncitem):\\n \\n             return True\\n \\n+    return None\\n+\\n \\n @pytest.fixture(params=get_all_backends())\\n-def anyio_backend(request):\\n+def anyio_backend(request: Any) -> Any:\\n     return request.param\\n \\n \\n @pytest.fixture\\n-def anyio_backend_name(anyio_backend) -> str:\\n+def anyio_backend_name(anyio_backend: Any) -> str:\\n     if isinstance(anyio_backend, str):\\n         return anyio_backend\\n     else:\\n@@ -146,7 +151,7 @@ def anyio_backend_name(anyio_backend) -> str:\\n \\n \\n @pytest.fixture\\n-def anyio_backend_options(anyio_backend) -> Dict[str, Any]:\\n+def anyio_backend_options(anyio_backend: Any) -> Dict[str, Any]:\\n     if isinstance(anyio_backend, str):\\n         return {}\\n     else:\\n\",\"diff --git a/tests/streams/test_text.py b/tests/streams/test_text.py\\nindex 47ba8f9..16374dc 100644\\n--- a/tests/streams/test_text.py\\n+++ b/tests/streams/test_text.py\\n@@ -55,3 +55,4 @@ async def test_bidirectional_stream():\\n \\n     await send_stream.send(b'\\\\xc3\\\\xa6\\\\xc3\\\\xb8')\\n     assert await text_stream.receive() == 'æø'\\n+    assert text_stream.extra_attributes == {}\\n\",\"diff --git a/tests/test_compat.py b/tests/test_compat.py\\nindex f662e82..007e541 100644\\n--- a/tests/test_compat.py\\n+++ b/tests/test_compat.py\\n@@ -35,6 +35,10 @@ class TestMaybeAsync:\\n         tasks = await maybe_async(get_running_tasks())\\n         assert type(tasks) is list\\n \\n+    async def test_get_current_task(self):\\n+        task = await maybe_async(get_current_task())\\n+        assert type(task) is TaskInfo\\n+\\n \\n async def test_maybe_async_cm():\\n     async with maybe_async_cm(CancelScope()):\\n\",\"diff --git a/tests/test_debugging.py b/tests/test_debugging.py\\nindex e763609..7d98227 100644\\n--- a/tests/test_debugging.py\\n+++ b/tests/test_debugging.py\\n@@ -29,6 +29,25 @@ def test_main_task_name(anyio_backend_name, anyio_backend_options):\\n             loop.close()\\n \\n \\n+@pytest.mark.parametrize(\\n+    \\\"name_input,expected\\\",\\n+    [\\n+        (None, 'test_debugging.test_non_main_task_name.<locals>.non_main'),\\n+        (b'name', \\\"b'name'\\\"),\\n+        (\\\"name\\\", \\\"name\\\"),\\n+        (\\\"\\\", \\\"\\\"),\\n+    ],\\n+)\\n+async def test_non_main_task_name(name_input, expected):\\n+    async def non_main(*, task_status):\\n+        task_status.started(anyio.get_current_task().name)\\n+\\n+    async with anyio.create_task_group() as tg:\\n+        name = await tg.start(non_main, name=name_input)\\n+\\n+    assert name == expected\\n+\\n+\\n async def test_get_running_tasks():\\n     async def inspect():\\n         await wait_all_tasks_blocked()\"]", "hints_text": ""}

{"instance_id": "1931046424122390", "repo": "alcides/geneticengine", "base_commit": "5ec85842292b9aad34fb381170339c72d9f99e8f", "problem_statement": "Mutability:\\nMutation and Crossover are not creating duplicates, but rather changing the original trees.\\r\\n\\r\\n\\r\\nIdea for test: \\r\\n- Random population of a complex tree\\r\\n- Store a string (or object id-based) representation of the population\\r\\n- Mutate the population (100 or 200%)\\r\\n- Test whether the original string representation holds with the original population object. It should!", "FAIL_TO_PASS": ["tests/immutability_test.py::TestImmutability::test_mutation[test_step0]", "tests/immutability_test.py::TestImmutability::test_mutation[test_step1]"], "PASS_TO_PASS": ["tests/metahandlers_test.py::TestMetaHandler::test_var", "tests/ind_gen_test.py::TestFullMethod::test_middle_double", "tests/depthing_test.py::TestDepthing::test_expansion_depthing", "tests/non_abstract_error_test.py::test_non_abs_error", "tests/grammar_test.py::TestGrammar::test_root", "tests/smt_test.py::TestMetaHandler::test_object_navigation", "tests/probabilistic_test.py::TestProbabilisticGrammar::test_probabilistic_grammar_dsge", "tests/grammar_test.py::TestGrammar::test_rec_alt", "tests/is_terminal_test.py::TestIsTerminal::test_non_terminals", "tests/smt_test.py::TestMetaHandler::test_bool", "tests/ind_gen_test.py::TestPIGrow::test_leaf2", "tests/probabilistic_test.py::TestProbabilisticGrammar::test_probabilistic_grammar_sge", "tests/is_terminal_test.py::TestIsTerminal::test_terminals", "tests/metahandlers_test.py::TestMetaHandler::test_weightedstrings", "tests/ind_gen_test.py::TestPIGrow::test_root", "tests/probabilistic_test.py::TestProbabilisticGrammar::test_probabilistic_grammar_ge", "tests/grammar_test.py::TestGrammar::test_invalid_node", "tests/metahandlers_test.py::TestMetaHandler::test_list", "tests/parallel_test.py::TestParallel::test_parallel", "tests/nondataclass_test.py::test_crossover", "tests/relabel_test.py::TestRelabel::test_relabel_simple", "tests/smt_test.py::TestMetaHandler::test_complex_int", "tests/type_safety_test.py::TestGrammar::test_safety", "tests/test_non_abstract_error.py::test_non_abs_error", "tests/ind_gen_test.py::TestPIGrow::test_concrete_list", "tests/nondataclass_test.py::test_mutation", "tests/metahandlers_test.py::TestMetaHandler::test_float", "tests/depthing_test.py::TestDepthing::test_normal_depthing", "tests/metahandlers_test.py::TestMetaHandler::test_intervalrange", "tests/ind_gen_test.py::TestPIGrow::test_middle_has_right_distance_to_term", "tests/ind_gen_test.py::TestFullMethod::test_root", "tests/immutability_test.py::TestImmutability::test_hash", "tests/ind_gen_test.py::TestPIGrow::test_middle_list", "tests/stopping_test.py::TestStoppingCriteria::test_evaluations", "tests/smt_test.py::TestMetaHandler::test_int", "tests/rampedhah_test.py::TestRamped::test_ramped_half_and_half", "tests/metahandlers_test.py::TestMetaHandler::test_int", "tests/smt_test.py::TestMetaHandler::test_real", "tests/ind_gen_test.py::TestPIGrow::test_concrete_annotated_list", "tests/probabilistic_test.py::TestProbabilisticGrammar::test_probabilistic_grammar_tree_based", "tests/smt_test.py::TestMetaHandler::test_comprehensions", "tests/ind_gen_test.py::TestPIGrow::test_leaf", "tests/grammar_test.py::TestGrammar::test_rec"], "language": "python", "test_command": "source /saved/ENV || source /saved/*/ENV && pytest --no-header -rA --tb=no -p no:cacheprovider --continue-on-collection-errors", "test_output_parser": "python/parse_log_pytest_v3", "image_storage_uri": "vmvm-registry.fbinfra.net/repomate_image_activ_pytest/alcides_geneticengine:5ec85842292b9aad34fb381170339c72d9f99e8f", "patch": "[\"diff --git a/examples/example.py b/examples/example.py\\nindex 9ad81502..fe66c6b2 100644\\n--- a/examples/example.py\\n+++ b/examples/example.py\\n@@ -48,7 +48,6 @@ def target(x):\\n problem = SingleObjectiveProblem(\\n     minimize=True,\\n     fitness_function=fit,\\n-    target_fitness=None,\\n )\\n stopping_criterium = TimeStoppingCriterium(3)\\n \\n@@ -60,7 +59,7 @@ def target(x):\\n )\\n ind = alg_gp.evolve()\\n print(\\\"\\\\n======\\\\nGP\\\\n======\\\\n\\\")\\n-print(f\\\"{ind.evaluate(problem)} - {ind}\\\")\\n+print(f\\\"{ind.get_fitness(problem)} - {ind}\\\")\\n \\n \\n alg_hc = HC(\\n@@ -70,7 +69,7 @@ def target(x):\\n )\\n ind = alg_hc.evolve()\\n print(\\\"\\\\n======\\\\nHC\\\\n======\\\\n\\\")\\n-print(f\\\"{ind.evaluate(problem)} - {ind}\\\")\\n+print(f\\\"{ind.get_fitness(problem)} - {ind}\\\")\\n \\n alg_rs = RandomSearch(\\n     representation=representation,\\n@@ -79,4 +78,4 @@ def target(x):\\n )\\n ind = alg_rs.evolve()\\n print(\\\"\\\\n======\\\\nRS\\\\n======\\\\n\\\")\\n-print(f\\\"{ind.evaluate(problem)} - {ind}\\\")\\n+print(f\\\"{ind.get_fitness(problem)} - {ind}\\\")\\n\",\"diff --git a/examples/exponentiation.py b/examples/exponentiation.py\\nindex 36b9b96a..b97b882c 100644\\n--- a/examples/exponentiation.py\\n+++ b/examples/exponentiation.py\\n@@ -83,7 +83,6 @@ def get_problem(self) -> Problem:\\n         return SingleObjectiveProblem(\\n             minimize=False,\\n             fitness_function=fitness_function,\\n-            target_fitness=None,\\n         )\\n \\n     def get_grammar(self) -> Grammar:\\n\",\"diff --git a/examples/game_of_life.py b/examples/game_of_life.py\\nindex 690863b0..b74294ec 100644\\n--- a/examples/game_of_life.py\\n+++ b/examples/game_of_life.py\\n@@ -84,7 +84,6 @@ def get_problem(self) -> Problem:\\n         return SingleObjectiveProblem(\\n             minimize=False,\\n             fitness_function=fitness_function,\\n-            target_fitness=None,\\n         )\\n \\n     def get_grammar(self) -> Grammar:\\n\",\"diff --git a/examples/game_of_life_vectorial.py b/examples/game_of_life_vectorial.py\\nindex 18df8e6c..8cd34078 100644\\n--- a/examples/game_of_life_vectorial.py\\n+++ b/examples/game_of_life_vectorial.py\\n@@ -324,7 +324,6 @@ def get_problem(self) -> Problem:\\n         return SingleObjectiveProblem(\\n             minimize=False,\\n             fitness_function=fitness_function,\\n-            target_fitness=None,\\n         )\\n \\n     def get_grammar(self) -> Grammar:\\n\",\"diff --git a/examples/progsys/Median.py b/examples/progsys/Median.py\\nindex dccba50c..9cb05d9d 100644\\n--- a/examples/progsys/Median.py\\n+++ b/examples/progsys/Median.py\\n@@ -118,7 +118,6 @@ def evolve(g, seed, mode, representation=\\\"\\\"):\\n         problem=SingleObjectiveProblem(\\n             minimize=True,\\n             fitness_function=fitness_function,\\n-            target_fitness=None,\\n         ),\\n         number_of_generations=5,\\n         seed=seed,\\n\",\"diff --git a/examples/progsys/Number_IO.py b/examples/progsys/Number_IO.py\\nindex 896b4a23..9a097c21 100644\\n--- a/examples/progsys/Number_IO.py\\n+++ b/examples/progsys/Number_IO.py\\n@@ -74,7 +74,6 @@ def evolve(g, seed, mode, representation=\\\"\\\"):\\n         problem=SingleObjectiveProblem(\\n             minimize=True,\\n             fitness_function=fitness_function,\\n-            target_fitness=None,\\n         ),\\n         number_of_generations=50,\\n         seed=seed,\\n\",\"diff --git a/examples/progsys/Smallest.py b/examples/progsys/Smallest.py\\nindex 1d198aac..0f60dce3 100644\\n--- a/examples/progsys/Smallest.py\\n+++ b/examples/progsys/Smallest.py\\n@@ -144,7 +144,6 @@ def evolve(g, seed, mode, representation=\\\"\\\"):\\n         problem=SingleObjectiveProblem(\\n             minimize=True,\\n             fitness_function=fitness_function,\\n-            target_fitness=None,\\n         ),\\n         number_of_generations=5,\\n         seed=seed,\\n\",\"diff --git a/examples/progsys/Sum_of_Squares.py b/examples/progsys/Sum_of_Squares.py\\nindex d30bed0c..9cc46e52 100644\\n--- a/examples/progsys/Sum_of_Squares.py\\n+++ b/examples/progsys/Sum_of_Squares.py\\n@@ -118,7 +118,6 @@ def evolve(g, seed, mode, representation=\\\"\\\"):\\n         problem=SingleObjectiveProblem(\\n             minimize=True,\\n             fitness_function=fitness_function,\\n-            target_fitness=None,\\n         ),\\n         number_of_generations=5,\\n         seed=seed,\\n\",\"diff --git a/examples/progsys/Vector_Average.py b/examples/progsys/Vector_Average.py\\nindex d44f941b..b13e2469 100644\\n--- a/examples/progsys/Vector_Average.py\\n+++ b/examples/progsys/Vector_Average.py\\n@@ -122,7 +122,6 @@ def evolve(g, seed, mode, representation=\\\"\\\"):\\n         problem=SingleObjectiveProblem(\\n             minimize=True,\\n             fitness_function=fitness_function,\\n-            target_fitness=None,\\n         ),\\n         number_of_generations=5,\\n         seed=seed,\\n\",\"diff --git a/examples/pymax.py b/examples/pymax.py\\nindex 35cc42c1..7653352a 100644\\n--- a/examples/pymax.py\\n+++ b/examples/pymax.py\\n@@ -68,7 +68,6 @@ def get_problem(self) -> Problem:\\n         return SingleObjectiveProblem(\\n             minimize=False,\\n             fitness_function=fit,\\n-            target_fitness=None,\\n         )\\n \\n     def get_grammar(self) -> Grammar:\\n\",\"diff --git a/examples/recurrence.py b/examples/recurrence.py\\nindex 70afdb02..50fee4df 100644\\n--- a/examples/recurrence.py\\n+++ b/examples/recurrence.py\\n@@ -76,7 +76,6 @@ def fitness_function(p):\\n     prob = SingleObjectiveProblem(\\n         minimize=True,\\n         fitness_function=fitness_function,\\n-        target_fitness=None,\\n     )\\n     gp = SimpleGP(\\n         grammar=g,\\n@@ -89,7 +88,7 @@ def fitness_function(p):\\n         probability_crossover=0.4,\\n     )\\n     best = gp.evolve()\\n-    fitness = prob.overall_fitness(best.get_phenotype())\\n+    fitness = best.get_fitness(prob)\\n     print(\\n         f\\\"Fitness of {fitness} by genotype: {best.genotype} with phenotype: {best.get_phenotype()}\\\",\\n     )\\n\",\"diff --git a/examples/regression.py b/examples/regression.py\\nindex 4559dab8..f690334e 100644\\n--- a/examples/regression.py\\n+++ b/examples/regression.py\\n@@ -83,7 +83,6 @@ def get_problem(self) -> Problem:\\n         return SingleObjectiveProblem(\\n             minimize=True,\\n             fitness_function=fitness_function,\\n-            target_fitness=None,\\n         )\\n \\n     def get_grammar(self) -> Grammar:\\n\",\"diff --git a/examples/regression_diabetes.py b/examples/regression_diabetes.py\\nindex bfe6d43c..64595c96 100644\\n--- a/examples/regression_diabetes.py\\n+++ b/examples/regression_diabetes.py\\n@@ -66,7 +66,6 @@ def get_problem(self) -> Problem:\\n         return SingleObjectiveProblem(\\n             minimize=True,\\n             fitness_function=fitness_function,\\n-            target_fitness=None,\\n         )\\n \\n     def get_grammar(self) -> Grammar:\\n\",\"diff --git a/examples/string_match.py b/examples/string_match.py\\nindex 4988bcbe..053dbd04 100644\\n--- a/examples/string_match.py\\n+++ b/examples/string_match.py\\n@@ -42,7 +42,6 @@ def get_problem(self) -> Problem:\\n         return SingleObjectiveProblem(\\r\\n             minimize=True,\\r\\n             fitness_function=fitness_function,\\r\\n-            target_fitness=None,\\r\\n         )\\r\\n \\r\\n     def get_grammar(self) -> Grammar:\\r\\n\",\"diff --git a/examples/synthetic_grammar_example.py b/examples/synthetic_grammar_example.py\\nindex bc219749..575c2c2a 100644\\n--- a/examples/synthetic_grammar_example.py\\n+++ b/examples/synthetic_grammar_example.py\\n@@ -3,13 +3,17 @@\\n from argparse import ArgumentParser\\n \\n from geneticengine.algorithms.callbacks.callback import ProgressCallback\\n-from geneticengine.algorithms.gp.operators.stop import GenerationStoppingCriterium\\n+from geneticengine.algorithms.gp.operators.stop import (\\n+    AnyOfStoppingCriterium,\\n+    FitnessTargetStoppingCriterium,\\n+    GenerationStoppingCriterium,\\n+)\\n from polyleven import levenshtein\\n \\n from geneticengine.algorithms.callbacks.csv_callback import CSVCallback\\n from geneticengine.algorithms.gp.gp import GP\\n from geneticengine.core.grammar import Grammar, extract_grammar\\n-from geneticengine.core.problems import SingleObjectiveProblem\\n+from geneticengine.core.problems import FitnessSingleObjective, SingleObjectiveProblem\\n from geneticengine.core.random.sources import RandomSource\\n from geneticengine.core.representations.tree.treebased import TreeBasedRepresentation\\n from geneticengine.grammars.synthetic_grammar import create_arbitrary_grammar\\n@@ -48,7 +52,11 @@ def fitness_function(n):\\n     problem = SingleObjectiveProblem(\\n         fitness_function=fitness_function,\\n         minimize=True,\\n-        target_fitness=0,\\n+    )\\n+\\n+    stopping_criterium = AnyOfStoppingCriterium(\\n+        GenerationStoppingCriterium(10),\\n+        FitnessTargetStoppingCriterium(FitnessSingleObjective(0)),\\n     )\\n \\n     filename = f\\\"synthetic_grammar_{seed}.csv\\\"\\n@@ -56,7 +64,7 @@ def fitness_function(n):\\n         representation=TreeBasedRepresentation(g, max_depth=g.get_min_tree_depth() + 10),\\n         problem=problem,\\n         population_size=10,\\n-        stopping_criterium=GenerationStoppingCriterium(10),\\n+        stopping_criterium=stopping_criterium,\\n         random_source=RandomSource(seed),\\n         callbacks=[\\n             ProgressCallback(),\\n\",\"diff --git a/examples/tutorial_example.py b/examples/tutorial_example.py\\nindex 03726fea..b969c5a7 100644\\n--- a/examples/tutorial_example.py\\n+++ b/examples/tutorial_example.py\\n@@ -5,8 +5,13 @@\\n from typing import Annotated\\n \\n from geneticengine.algorithms.gp.gp import GP\\n+from geneticengine.algorithms.gp.operators.stop import (\\n+    AnyOfStoppingCriterium,\\n+    FitnessTargetStoppingCriterium,\\n+    GenerationStoppingCriterium,\\n+)\\n from geneticengine.core.grammar import extract_grammar\\n-from geneticengine.core.problems import SingleObjectiveProblem\\n+from geneticengine.core.problems import FitnessSingleObjective, SingleObjectiveProblem\\n from geneticengine.core.random.sources import RandomSource\\n from geneticengine.core.representations.tree.treebased import TreeBasedRepresentation\\n from geneticengine.metahandlers.ints import IntRange\\n@@ -60,13 +65,19 @@ def main(seed=123):\\n     prob = SingleObjectiveProblem(\\n         fitness_function=fitness_function,\\n         minimize=True,\\n-        target_fitness=0,\\n     )\\n+\\n+    stopping_criterium = AnyOfStoppingCriterium(\\n+        GenerationStoppingCriterium(100),\\n+        FitnessTargetStoppingCriterium(FitnessSingleObjective(0)),\\n+    )\\n+\\n     alg = GP(\\n         representation=TreeBasedRepresentation(grammar, 10),\\n         problem=prob,\\n         population_size=20,\\n         random_source=RandomSource(seed),\\n+        stopping_criterium=stopping_criterium,\\n     )\\n     best = alg.evolve()\\n     print(\\n\",\"diff --git a/examples/vectorialgp_example.py b/examples/vectorialgp_example.py\\nindex 80e776dd..f7731d7a 100644\\n--- a/examples/vectorialgp_example.py\\n+++ b/examples/vectorialgp_example.py\\n@@ -3127,7 +3127,6 @@ def get_problem(self) -> Problem:\\n         return SingleObjectiveProblem(\\n             minimize=True,\\n             fitness_function=fitness_function,\\n-            target_fitness=None,\\n         )\\n \\n     def get_grammar(self) -> Grammar:\\n\",\"diff --git a/geneticengine/algorithms/gp/operators/stop.py b/geneticengine/algorithms/gp/operators/stop.py\\nindex d53d8df7..cad685db 100644\\n--- a/geneticengine/algorithms/gp/operators/stop.py\\n+++ b/geneticengine/algorithms/gp/operators/stop.py\\n@@ -3,7 +3,8 @@\\n from geneticengine.algorithms.gp.individual import Individual\\n from geneticengine.algorithms.gp.structure import StoppingCriterium\\n from geneticengine.core.evaluators import Evaluator\\n-from geneticengine.core.problems import Problem\\n+from geneticengine.core.fitness_helpers import best_individual\\n+from geneticengine.core.problems import Fitness, Problem\\n \\n \\n class GenerationStoppingCriterium(StoppingCriterium):\\n@@ -76,3 +77,52 @@ def is_ended(\\n         evaluator: Evaluator,\\n     ) -> bool:\\n         return evaluator.get_count() >= self.max_evaluations\\n+\\n+\\n+class FitnessTargetStoppingCriterium(StoppingCriterium):\\n+    \\\"\\\"\\\"Stops the evolution when the fitness gets to a given value.\\\"\\\"\\\"\\n+\\n+    def __init__(self, target_fitness: Fitness):\\n+        self.target_fitness = target_fitness\\n+\\n+    def is_ended(\\n+        self,\\n+        problem: Problem,\\n+        population: list[Individual],\\n+        generation: int,\\n+        elapsed_time: float,\\n+        evaluator: Evaluator,\\n+    ) -> bool:\\n+        evaluator.eval(problem, population)\\n+        best_fitness = best_individual(population, problem).get_fitness(problem)\\n+        return problem.is_better(best_fitness, self.target_fitness)\\n+\\n+\\n+class AnyOfStoppingCriterium(StoppingCriterium):\\n+    \\\"\\\"\\\"Stops the evolution when any of the two stopping criteria is done.\\\"\\\"\\\"\\n+\\n+    def __init__(self, one: StoppingCriterium, other: StoppingCriterium):\\n+        self.one = one\\n+        self.other = other\\n+\\n+    def is_ended(\\n+        self,\\n+        problem: Problem,\\n+        population: list[Individual],\\n+        generation: int,\\n+        elapsed_time: float,\\n+        evaluator: Evaluator,\\n+    ) -> bool:\\n+        return self.one.is_ended(\\n+            problem=problem,\\n+            population=population,\\n+            generation=generation,\\n+            elapsed_time=elapsed_time,\\n+            evaluator=evaluator,\\n+        ) or self.other.is_ended(\\n+            problem=problem,\\n+            population=population,\\n+            generation=generation,\\n+            elapsed_time=elapsed_time,\\n+            evaluator=evaluator,\\n+        )\\n\",\"diff --git a/geneticengine/algorithms/gp/simplegp.py b/geneticengine/algorithms/gp/simplegp.py\\nindex da0dc1e9..7133bd0b 100644\\n--- a/geneticengine/algorithms/gp/simplegp.py\\n+++ b/geneticengine/algorithms/gp/simplegp.py\\n@@ -25,14 +25,18 @@\\n from geneticengine.algorithms.gp.operators.novelty import NoveltyStep\\n from geneticengine.algorithms.gp.operators.selection import LexicaseSelection\\n from geneticengine.algorithms.gp.operators.selection import TournamentSelection\\n-from geneticengine.algorithms.gp.operators.stop import GenerationStoppingCriterium\\n+from geneticengine.algorithms.gp.operators.stop import (\\n+    AnyOfStoppingCriterium,\\n+    FitnessTargetStoppingCriterium,\\n+    GenerationStoppingCriterium,\\n+)\\n from geneticengine.algorithms.gp.operators.stop import TimeStoppingCriterium\\n from geneticengine.algorithms.gp.structure import GeneticStep\\n from geneticengine.algorithms.gp.structure import PopulationInitializer\\n from geneticengine.algorithms.gp.structure import StoppingCriterium\\n from geneticengine.core.grammar import Grammar\\n from geneticengine.core.evaluators import SequentialEvaluator\\n-from geneticengine.core.problems import MultiObjectiveProblem\\n+from geneticengine.core.problems import Fitness, FitnessMultiObjective, FitnessSingleObjective, MultiObjectiveProblem\\n from geneticengine.core.problems import Problem\\n from geneticengine.core.problems import SingleObjectiveProblem\\n from geneticengine.core.problems import wrap_depth_minimization\\n@@ -187,7 +191,6 @@ def __init__(\\n                 problem,\\n                 evaluation_function,\\n                 minimize,\\n-                target_fitness,\\n             ),\\n             favor_less_complex_trees,\\n         )\\n@@ -262,6 +265,13 @@ def __init__(\\n             stopping_criterium = TimeStoppingCriterium(timer_limit)\\n         else:\\n             stopping_criterium = GenerationStoppingCriterium(number_of_generations)\\n+        if target_fitness is not None:\\n+            tg: Fitness\\n+            if isinstance(processed_problem, SingleObjectiveProblem):\\n+                tg = FitnessSingleObjective(target_fitness)\\n+            else:\\n+                tg = FitnessMultiObjective(multiple_fitnesses=[target_fitness], fitness=target_fitness)\\n+            stopping_criterium = AnyOfStoppingCriterium(stopping_criterium, FitnessTargetStoppingCriterium(tg))\\n \\n         self.callbacks: list[Callback] = []\\n         self.callbacks.extend(callbacks or [])\\n@@ -317,7 +327,6 @@ def process_problem(\\n         problem: Problem | None,\\n         evaluation_function: Callable[[P], float] | None = None,\\n         minimize: bool = False,\\n-        target_fitness: float | None = None,\\n     ) -> Problem:\\n         \\\"\\\"\\\"This function is a placeholder until we deprecate all the old usage\\n         of GP class.\\\"\\\"\\\"\\n@@ -326,7 +335,7 @@ def process_problem(\\n         elif isinstance(minimize, list) and evaluation_function:\\n             return MultiObjectiveProblem(minimize, evaluation_function)\\n         elif isinstance(minimize, bool) and evaluation_function:\\n-            return SingleObjectiveProblem(evaluation_function, minimize, target_fitness)\\n+            return SingleObjectiveProblem(evaluation_function, minimize)\\n         else:\\n             raise NotImplementedError(\\n                 \\\"This combination of parameters to define the problem is not valid\\\",\\n\",\"diff --git a/geneticengine/core/fitness_helpers.py b/geneticengine/core/fitness_helpers.py\\nnew file mode 100644\\nindex 00000000..9bdc480f\\n--- /dev/null\\n+++ b/geneticengine/core/fitness_helpers.py\\n@@ -0,0 +1,16 @@\\n+from geneticengine.algorithms.gp.individual import Individual\\n+from geneticengine.core.problems import Problem\\n+\\n+\\n+def best_individual(population: list[Individual], problem: Problem) -> Individual:\\n+    \\\"\\\"\\\"Returns the best individual of a population.\\\"\\\"\\\"\\n+    return max(population, key=lambda x: -problem.key_function(x))\\n+\\n+\\n+def is_better(problem: Problem, individual: Individual, other: Individual) -> bool:\\n+    \\\"\\\"\\\"Returns whether one individual is better than other.\\\"\\\"\\\"\\n+    return problem.is_better(individual.get_fitness(problem), other.get_fitness(problem))\\n+\\n+\\n+def sort_population(population: list[Individual], problem: Problem) -> list[Individual]:\\n+    return sorted(population, key=problem.fitness_function, reverse=True)\\n\",\"diff --git a/geneticengine/core/problems.py b/geneticengine/core/problems.py\\nindex 0656aa27..2bc6394b 100644\\n--- a/geneticengine/core/problems.py\\n+++ b/geneticengine/core/problems.py\\n@@ -60,15 +60,17 @@ class Problem(abc.ABC, Generic[FT]):\\n     def evaluate(self, phenotype: P) -> FT:\\n         ...\\n \\n-    def solved(self, best_fitness: FT):\\n-        return False\\n-\\n     @abc.abstractmethod\\n     def key_function(self, a: P) -> float:\\n         \\\"\\\"\\\"Returns the (maximizing) fitness of the individual as a single\\n         float.\\\"\\\"\\\"\\n         ...\\n \\n+    @abc.abstractmethod\\n+    def is_better(self, a: FT, b: FT) -> bool:\\n+        \\\"\\\"\\\"Returns whether the first fitness is better than the second.\\\"\\\"\\\"\\n+        ...\\n+\\n \\n class SingleObjectiveProblem(Problem[FitnessSingleObjective]):\\n     \\\"\\\"\\\"SingleObjectiveProblem is a class that extends the Problem class.\\n@@ -78,45 +80,35 @@ class SingleObjectiveProblem(Problem[FitnessSingleObjective]):\\n             function corresponds to a less fit solution.\\n         fitness_function (Callable[[P], float]): The fitness function. Should take in any valid individual and return a\\n             float.\\n-        target_fitness (Optional[float]): Sets a target fitness. When this fitness is reached, the algorithm stops\\n-            running (default = None).\\n     \\\"\\\"\\\"\\n \\n     # Uses dict to avoid the mismatch between functions and methods (first argument)\\n     fitness_function_host: GenericWrapper[SingleObjectiveCallable]\\n     minimize: bool\\n-    target_fitness: FitnessSingleObjective | None = None\\n \\n-    def __init__(\\n-        self,\\n-        fitness_function: SingleObjectiveCallable,\\n-        minimize: bool = False,\\n-        target_fitness: float | None = None,\\n-    ):\\n+    def __init__(self, fitness_function: SingleObjectiveCallable, minimize: bool = False):\\n         self.fitness_function_host = GenericWrapper(fitness_function)\\n         self.minimize = minimize\\n-        if target_fitness:\\n-            self.target_fitness = FitnessSingleObjective(target_fitness)\\n \\n     def evaluate(self, phenotype: P) -> FitnessSingleObjective:\\n         c: SingleObjectiveCallable = self.fitness_function_host.get()\\n         v = float(c(phenotype))\\n         return FitnessSingleObjective(fitness=v)\\n \\n-    def solved(self, best_fitness: FitnessSingleObjective):\\n-        if not self.target_fitness:\\n-            return False\\n-        elif self.minimize:\\n-            return self.target_fitness.fitness >= best_fitness.fitness\\n-        else:\\n-            return self.target_fitness.fitness <= best_fitness.fitness\\n-\\n     def key_function(self, a: P) -> float:\\n         if self.minimize:\\n             return -self.evaluate(a).fitness\\n         else:\\n             return self.evaluate(a).fitness\\n \\n+    def is_better(self, a: FT, b: FT) -> bool:\\n+        assert isinstance(a, FitnessSingleObjective)\\n+        assert isinstance(b, FitnessSingleObjective)\\n+        if self.minimize:\\n+            return a.fitness < b.fitness\\n+        else:\\n+            return a.fitness > b.fitness\\n+\\n \\n class MultiObjectiveProblem(Problem[FitnessMultiObjective]):\\n     \\\"\\\"\\\"MultiObjectiveProblem is a class that extends the Problem class.\\n@@ -168,6 +160,14 @@ def evaluate(self, phenotype: P) -> FitnessMultiObjective:\\n     def key_function(self, a: P) -> float:\\n         return self.evaluate(a).fitness\\n \\n+    def is_better(self, a: FT, b: FT) -> bool:\\n+        assert isinstance(a, FitnessMultiObjective)\\n+        assert isinstance(b, FitnessMultiObjective)\\n+        if self.minimize:\\n+            return a.fitness < b.fitness\\n+        else:\\n+            return a.fitness > b.fitness\\n+\\n \\n def wrap_depth_minimization(p: SingleObjectiveProblem) -> SingleObjectiveProblem:\\n     \\\"\\\"\\\"This wrapper takes a SingleObjectiveProblem and adds a penalty for\\n@@ -179,8 +179,4 @@ def w(i):\\n         else:\\n             return p.evaluate(i).fitness - i.gengy_distance_to_term * 10**-25\\n \\n-    return SingleObjectiveProblem(\\n-        minimize=p.minimize,\\n-        fitness_function=w,\\n-        target_fitness=None,\\n-    )\\n+    return SingleObjectiveProblem(minimize=p.minimize, fitness_function=w)\\n\",\"diff --git a/geneticengine/off_the_shelf/classifiers.py b/geneticengine/off_the_shelf/classifiers.py\\nindex fe8933f6..b3110013 100644\\n--- a/geneticengine/off_the_shelf/classifiers.py\\n+++ b/geneticengine/off_the_shelf/classifiers.py\\n@@ -144,7 +144,6 @@ def fitness_function(n: Number):\\n             problem=SingleObjectiveProblem(\\n                 minimize=False,\\n                 fitness_function=fitness_function,\\n-                target_fitness=None,\\n             ),\\n             representation=self.representation_class,\\n             population_size=self.population_size,\\n@@ -274,7 +273,6 @@ def fitness_function(n: Number):\\n             problem=SingleObjectiveProblem(\\n                 minimize=False,\\n                 fitness_function=fitness_function,\\n-                target_fitness=None,\\n             ),\\n             stopping_criterium=GenerationStoppingCriterium(self.number_of_generations),\\n             random_source=RandomSource(self.seed),\\n\",\"diff --git a/geneticengine/off_the_shelf/regressors.py b/geneticengine/off_the_shelf/regressors.py\\nindex addd1559..9807c0b3 100644\\n--- a/geneticengine/off_the_shelf/regressors.py\\n+++ b/geneticengine/off_the_shelf/regressors.py\\n@@ -157,7 +157,6 @@ def fitness_function(n: Number):\\n             problem=SingleObjectiveProblem(\\n                 minimize=minimise,\\n                 fitness_function=fitness_function,\\n-                target_fitness=None,\\n             ),\\n             representation=self.representation_class,\\n             population_size=self.population_size,\\n@@ -300,7 +299,6 @@ def fitness_function(n: Number):\\n             problem=SingleObjectiveProblem(\\n                 minimize=False,\\n                 fitness_function=fitness_function,\\n-                target_fitness=None,\\n             ),\\n             stopping_criterium=GenerationStoppingCriterium(self.number_of_generations),\\n             random_source=RandomSource(self.seed),\\n\",\"diff --git a/geneticengine/core/fitness_helpers.py b/geneticengine/core/fitness_helpers.py\\nindex 9bdc480f..0eb8e99c 100644\\n--- a/geneticengine/core/fitness_helpers.py\\n+++ b/geneticengine/core/fitness_helpers.py\\n@@ -4,13 +4,20 @@\\n \\n def best_individual(population: list[Individual], problem: Problem) -> Individual:\\n     \\\"\\\"\\\"Returns the best individual of a population.\\\"\\\"\\\"\\n-    return max(population, key=lambda x: -problem.key_function(x))\\n+    return max(population, key=lambda x: problem.key_function(x.get_phenotype()))\\n \\n \\n def is_better(problem: Problem, individual: Individual, other: Individual) -> bool:\\n-    \\\"\\\"\\\"Returns whether one individual is better than other.\\\"\\\"\\\"\\n+    \\\"\\\"\\\"Returns whether one individual is better than other.\\n+\\n+    Requires the individuals to be evaluated.\\n+    \\\"\\\"\\\"\\n     return problem.is_better(individual.get_fitness(problem), other.get_fitness(problem))\\n \\n \\n def sort_population(population: list[Individual], problem: Problem) -> list[Individual]:\\n-    return sorted(population, key=problem.fitness_function, reverse=True)\\n+    \\\"\\\"\\\"Sorts the population so the best one is first.\\n+\\n+    Requires the individuals to be evaluated.\\n+    \\\"\\\"\\\"\\n+    return sorted(population, key=lambda ind: problem.key_function(ind.get_phenotype()), reverse=True)\\n\",\"diff --git a/geneticengine/core/problems.py b/geneticengine/core/problems.py\\nindex 2bc6394b..9c34b845 100644\\n--- a/geneticengine/core/problems.py\\n+++ b/geneticengine/core/problems.py\\n@@ -131,7 +131,7 @@ def __init__(\\n         self,\\n         minimize: list[bool],\\n         fitness_function: MultiObjectiveCallable,\\n-        best_individual_criteria_function: SingleObjectiveCallable | None,\\n+        best_individual_criteria_function: SingleObjectiveCallable | None = None,\\n     ):\\n         self.minimize = minimize\\n         self.fitness_function_host = GenericWrapper(fitness_function)\\n\",\"diff --git a/geneticengine/algorithms/callbacks/debug.py b/geneticengine/algorithms/callbacks/debug.py\\nindex f42e19fb..6536ad3f 100644\\n--- a/geneticengine/algorithms/callbacks/debug.py\\n+++ b/geneticengine/algorithms/callbacks/debug.py\\n@@ -1,5 +1,5 @@\\n from geneticengine.algorithms.callbacks.callback import Callback\\n-from geneticengine.algorithms.gp.individual import Individual\\n+from geneticengine.core.fitness_helpers import best_individual, is_better\\n \\n \\n class ElitismDebugCallback(Callback):\\n@@ -10,10 +10,8 @@ def __init__(self):\\n \\n     def process_iteration(self, generation: int, population, time: float, gp):\\n         gp.evaluator.eval(gp.problem, population)\\n-        best = max(population, key=Individual.key_function(gp.problem))\\n-        best = Individual.key_function(gp.problem)(best)\\n-        if self.bests:\\n-            assert best >= self.bests[-1]\\n+        best = best_individual(population=population, problem=gp.problem)\\n+        assert is_better(gp.problem, best, self.bests[-1])\\n         self.bests.append(best)\\n \\n     def end_evolution(self):\\n\",\"diff --git a/geneticengine/algorithms/gp/operators/elitism.py b/geneticengine/algorithms/gp/operators/elitism.py\\nindex d60fd660..c7c279a1 100644\\n--- a/geneticengine/algorithms/gp/operators/elitism.py\\n+++ b/geneticengine/algorithms/gp/operators/elitism.py\\n@@ -1,8 +1,8 @@\\n from __future__ import annotations\\n-from copy import copy\\n \\n from geneticengine.algorithms.gp.individual import Individual\\n from geneticengine.algorithms.gp.structure import GeneticStep\\n+from geneticengine.core.fitness_helpers import sort_population\\n from geneticengine.core.problems import Problem\\n from geneticengine.core.random.sources import Source\\n from geneticengine.core.representations.api import Representation\\n@@ -22,7 +22,6 @@ def iterate(\\n         target_size: int,\\n         generation: int,\\n     ) -> list[Individual]:\\n-        new_population = copy(population)\\n-        evaluator.eval(problem, new_population)\\n-        new_population.sort(key=Individual.key_function(problem), reverse=True)\\n+        evaluator.eval(problem, population)\\n+        new_population = sort_population(population, problem)\\n         return new_population[:target_size]\\n\",\"diff --git a/geneticengine/algorithms/gp/operators/mutation.py b/geneticengine/algorithms/gp/operators/mutation.py\\nindex 14cf2373..6ebe96a3 100644\\n--- a/geneticengine/algorithms/gp/operators/mutation.py\\n+++ b/geneticengine/algorithms/gp/operators/mutation.py\\n@@ -5,6 +5,7 @@\\n \\n from geneticengine.algorithms.gp.individual import Individual\\n from geneticengine.algorithms.gp.structure import GeneticStep\\n+from geneticengine.core.fitness_helpers import best_individual\\n from geneticengine.core.problems import Problem\\n from geneticengine.core.random.sources import Source\\n from geneticengine.core.representations.api import MutationOperator\\n@@ -95,8 +96,6 @@ def mutate(\\n         ]\\n \\n         evaluator.eval(problem, new_individuals)\\n-        best_individual = min(\\n-            new_individuals,\\n-            key=Individual.key_function(problem),\\n-        )\\n-        return best_individual.genotype\\n+        bi = best_individual(new_individuals, problem)\\n+\\n+        return bi.genotype\\n\",\"diff --git a/geneticengine/algorithms/heuristics.py b/geneticengine/algorithms/heuristics.py\\nindex 5e4e4ebb..857de66e 100644\\n--- a/geneticengine/algorithms/heuristics.py\\n+++ b/geneticengine/algorithms/heuristics.py\\n@@ -4,6 +4,7 @@\\n from abc import abstractmethod\\n \\n from geneticengine.algorithms.gp.individual import Individual\\n+from geneticengine.core.fitness_helpers import best_individual\\n from geneticengine.core.grammar import Grammar\\n from geneticengine.core.problems import Problem\\n from geneticengine.core.random.sources import RandomSource\\n@@ -60,5 +61,5 @@ def get_best_individual(\\n         \\\"\\\"\\\"\\n         assert individuals\\n         self.evaluator.eval(self.problem, individuals)\\n-        best_individual = max(individuals, key=Individual.key_function(problem))\\n-        return best_individual\\n+        bi = best_individual(individuals, self.problem)\\n+        return bi\\n\",\"diff --git a/geneticengine/core/fitness_helpers.py b/geneticengine/core/fitness_helpers.py\\nindex 0eb8e99c..1b345a72 100644\\n--- a/geneticengine/core/fitness_helpers.py\\n+++ b/geneticengine/core/fitness_helpers.py\\n@@ -4,7 +4,7 @@\\n \\n def best_individual(population: list[Individual], problem: Problem) -> Individual:\\n     \\\"\\\"\\\"Returns the best individual of a population.\\\"\\\"\\\"\\n-    return max(population, key=lambda x: problem.key_function(x.get_phenotype()))\\n+    return max(population, key=Individual.key_function(problem))\\n \\n \\n def is_better(problem: Problem, individual: Individual, other: Individual) -> bool:\\n@@ -20,4 +20,4 @@ def sort_population(population: list[Individual], problem: Problem) -> list[Indi\\n \\n     Requires the individuals to be evaluated.\\n     \\\"\\\"\\\"\\n-    return sorted(population, key=lambda ind: problem.key_function(ind.get_phenotype()), reverse=True)\\n+    return sorted(population, key=Individual.key_function(problem), reverse=True)\\n\",\"diff --git a/geneticengine/core/representations/tree/treebased.py b/geneticengine/core/representations/tree/treebased.py\\nindex 2511911a..b122f6c0 100644\\n--- a/geneticengine/core/representations/tree/treebased.py\\n+++ b/geneticengine/core/representations/tree/treebased.py\\n@@ -76,16 +76,11 @@ def mutate_inner(\\n         c = r.randint(0, counter - 1)\\n         if c == 0 or (c <= i.gengy_distance_to_term and depth_aware_mut) or force_mutate:\\n             # If Metahandler mutation exists, the mutation process is different\\n-            args_with_specific_mutation = [has_annotated_mutation(arg[1]) for arg in get_arguments(i)]\\n-            if any(args_with_specific_mutation):\\n-                mutation_possibilities = len(args_with_specific_mutation)\\n-                mutation_choice = r.randint(\\n-                    0,\\n-                    mutation_possibilities - 1,\\n-                )\\n-                (index, arg_to_be_mutated) = [\\n-                    (kdx, arg[1]) for kdx, arg in enumerate(get_arguments(i)) if args_with_specific_mutation[kdx]\\n-                ][mutation_choice]\\n+            if any(has_annotated_mutation(arg[1]) for arg in get_arguments(i)):\\n+                options = [(kdx, arg[1]) for kdx, arg in enumerate(get_arguments(i)) if has_annotated_mutation(arg[1])]\\n+                index = r.randint(0, len(options) - 1)\\n+                (index, arg_to_be_mutated) = options[index]\\n+\\n                 args = list(i.gengy_init_values)\\n                 args[index] = arg_to_be_mutated.__metadata__[0].mutate(  # type: ignore\\n                     r,\\n\",\"diff --git a/geneticengine/core/representations/tree/treebased.py b/geneticengine/core/representations/tree/treebased.py\\nindex b122f6c0..379f5713 100644\\n--- a/geneticengine/core/representations/tree/treebased.py\\n+++ b/geneticengine/core/representations/tree/treebased.py\\n@@ -294,23 +294,24 @@ def crossover_inner(\\n                 if not options:\\n                     pass  # Replace whole node\\n                 else:\\n-                    (index, arg_to_be_crossovered) = [\\n-                        (kdx, arg) for kdx, arg in enumerate(get_arguments(i)) if args_with_specific_crossover[kdx]\\n-                    ][crossover_choice]\\n+                    (index, arg_to_be_crossovered) = [(kdx, arg) for kdx, arg in enumerate(get_arguments(i))][\\n+                        crossover_choice\\n+                    ]\\n                     args = list(i.gengy_init_values)\\n-                    args[index] = (\\n-                        arg_to_be_crossovered[1]\\n-                        .__metadata__[0]  # type: ignore\\n-                        .crossover(\\n-                            r,\\n-                            g,\\n-                            options,\\n-                            arg_to_be_crossovered[0],\\n-                            ty,\\n-                            current_node=args[index],\\n+                    if has_annotated_crossover(arg_to_be_crossovered[1]):\\n+                        args[index] = (\\n+                            arg_to_be_crossovered[1]\\n+                            .__metadata__[0]  # type: ignore\\n+                            .crossover(\\n+                                r,\\n+                                g,\\n+                                options,\\n+                                arg_to_be_crossovered[0],\\n+                                ty,\\n+                                current_node=args[index],\\n+                            )\\n                         )\\n-                    )\\n-                    return mk_save_init(type(i), lambda x: x)(*args)\\n+                        return mk_save_init(type(i), lambda x: x)(*args)\\n \\n             options = list(find_in_tree(g, ty, o, max_depth))\\n             if options:\\n\",\"diff --git a/geneticengine/metahandlers/lists.py b/geneticengine/metahandlers/lists.py\\nindex 1a0660af..eac3a2e0 100644\\n--- a/geneticengine/metahandlers/lists.py\\n+++ b/geneticengine/metahandlers/lists.py\\n@@ -1,4 +1,5 @@\\n from __future__ import annotations\\n+import copy\\n \\n from geneticengine.core.grammar import Grammar\\n from geneticengine.core.random.sources import Source\\n@@ -53,6 +54,7 @@ def mutate(\\n         method=pi_grow_method,\\n     ):\\n         mutation_method = r.randint(0, 1)\\n+        current_node = copy.copy(current_node)\\n         if (mutation_method == 0) and (len(current_node) != self.min):  # del\\n             element_to_be_deleted = r.randint(0, len(current_node) - 1)\\n             current_node.remove(current_node[element_to_be_deleted])\\n@@ -82,6 +84,7 @@ def crossover(\\n         big_enough_options = [getattr(o, arg) for o in options if len(getattr(o, arg)) >= n_elements_replaced]\\n         while not big_enough_options:\\n             if n_elements_replaced == 1:\\n+                print(2)\\n                 return GengyList(list_type, current_node)\\n             n_elements_replaced = r.randint(1, n_elements_replaced - 1)\\n             big_enough_options = [getattr(o, arg) for o in options if len(getattr(o, arg)) >= n_elements_replaced]\\n@@ -90,7 +93,8 @@ def crossover(\\n         # Always cut beginning as we do double crossovers,\\n         # first using one tree as the current node,\\n         # and then the second tree as current node.\\n-        new_node = option[0:n_elements_replaced] + current_node[n_elements_replaced:]\\n+        new_node = copy.deepcopy(option[0:n_elements_replaced]) + current_node[n_elements_replaced:]\\n+        print(3)\\n         return GengyList(list_type, new_node)\\n \\n     def __class_getitem__(self, args):\\n\"]", "test_patch": "[\"diff --git a/examples/classification.py b/examples/classification.py\\nindex f6a809e7..05fabbef 100644\\n--- a/examples/classification.py\\n+++ b/examples/classification.py\\n@@ -116,11 +116,7 @@ def fitness_test_function(n: Number):\\n \\n class ClassificationBenchmark:\\n     def get_problem(self) -> Problem:\\n-        return SingleObjectiveProblem(\\n-            minimize=False,\\n-            fitness_function=fitness_function,\\n-            target_fitness=None,\\n-        )\\n+        return SingleObjectiveProblem(minimize=False, fitness_function=fitness_function)\\n \\n     def get_grammar(self) -> Grammar:\\n         return extract_grammar(\\n\",\"diff --git a/examples/classification_probabilisticGE.py b/examples/classification_probabilisticGE.py\\nindex b6d7a2df..c95713c2 100644\\n--- a/examples/classification_probabilisticGE.py\\n+++ b/examples/classification_probabilisticGE.py\\n@@ -117,11 +117,7 @@ def fitness_test_function(n: Number):\\n \\n class ClassificationProbabilisticGEBenchmark:\\n     def get_problem(self) -> Problem:\\n-        return SingleObjectiveProblem(\\n-            minimize=False,\\n-            fitness_function=fitness_function,\\n-            target_fitness=None,\\n-        )\\n+        return SingleObjectiveProblem(minimize=False, fitness_function=fitness_function)\\n \\n     def get_grammar(self) -> Grammar:\\n         return extract_grammar(\\n\",\"diff --git a/tests/probabilistic_test.py b/tests/probabilistic_test.py\\nindex 1506c66a..4d458d44 100644\\n--- a/tests/probabilistic_test.py\\n+++ b/tests/probabilistic_test.py\\n@@ -1,11 +1,15 @@\\n from __future__ import annotations\\n \\n from geneticengine.algorithms.gp.gp import GP\\n-from geneticengine.algorithms.gp.operators.stop import GenerationStoppingCriterium\\n+from geneticengine.algorithms.gp.operators.stop import (\\n+    AnyOfStoppingCriterium,\\n+    FitnessTargetStoppingCriterium,\\n+    GenerationStoppingCriterium,\\n+)\\n from geneticengine.core.decorators import abstract\\n from geneticengine.core.decorators import weight\\n from geneticengine.core.grammar import extract_grammar\\n-from geneticengine.core.problems import SingleObjectiveProblem\\n+from geneticengine.core.problems import FitnessSingleObjective, SingleObjectiveProblem\\n from geneticengine.core.representations.grammatical_evolution.dynamic_structured_ge import (\\n     DynamicStructuredGrammaticalEvolutionRepresentation,\\n )\\n@@ -42,7 +46,6 @@ def test_probabilistic_grammar_tree_based(self):\\n             problem=SingleObjectiveProblem(\\n                 lambda p: isinstance(p, OptionA) and 1 or 2,\\n                 minimize=True,\\n-                target_fitness=0,\\n             ),\\n             population_size=1000,\\n             stopping_criterium=GenerationStoppingCriterium(max_generations=50),\\n@@ -54,15 +57,18 @@ def test_probabilistic_grammar_tree_based(self):\\n     def test_probabilistic_grammar_ge(self):\\n         g = extract_grammar([OptionA, OptionB], Option)\\n \\n+        stopping_criterium = AnyOfStoppingCriterium(\\n+            GenerationStoppingCriterium(max_generations=50),\\n+            FitnessTargetStoppingCriterium(FitnessSingleObjective(0)),\\n+        )\\n         gp = GP(\\n             representation=GrammaticalEvolutionRepresentation(grammar=g, max_depth=10),\\n             problem=SingleObjectiveProblem(\\n                 lambda p: isinstance(p, OptionA) and 1 or 2,\\n                 minimize=True,\\n-                target_fitness=0,\\n             ),\\n             population_size=1000,\\n-            stopping_criterium=GenerationStoppingCriterium(max_generations=50),\\n+            stopping_criterium=stopping_criterium,\\n         )\\n         ind = gp.evolve()\\n         tree = ind.get_phenotype()\\n@@ -79,10 +85,12 @@ def test_probabilistic_grammar_sge(self):\\n             problem=SingleObjectiveProblem(\\n                 lambda p: isinstance(p, OptionA) and 1 or 2,\\n                 minimize=True,\\n-                target_fitness=0,\\n             ),\\n             population_size=1000,\\n-            stopping_criterium=GenerationStoppingCriterium(max_generations=50),\\n+            stopping_criterium=AnyOfStoppingCriterium(\\n+                GenerationStoppingCriterium(max_generations=50),\\n+                FitnessTargetStoppingCriterium(FitnessSingleObjective(0)),\\n+            ),\\n         )\\n         ind = gp.evolve()\\n         tree = ind.get_phenotype()\\n@@ -99,10 +107,12 @@ def test_probabilistic_grammar_dsge(self):\\n             problem=SingleObjectiveProblem(\\n                 lambda p: isinstance(p, OptionA) and 1 or 2,\\n                 minimize=True,\\n-                target_fitness=0,\\n             ),\\n             population_size=1000,\\n-            stopping_criterium=GenerationStoppingCriterium(max_generations=50),\\n+            stopping_criterium=AnyOfStoppingCriterium(\\n+                GenerationStoppingCriterium(max_generations=50),\\n+                FitnessTargetStoppingCriterium(FitnessSingleObjective(0)),\\n+            ),\\n         )\\n         ind = gp.evolve()\\n         tree = ind.get_phenotype()\\n\",\"diff --git a/tests/rampedhah_test.py b/tests/rampedhah_test.py\\nindex af1a476b..b975d4f1 100644\\n--- a/tests/rampedhah_test.py\\n+++ b/tests/rampedhah_test.py\\n@@ -46,7 +46,6 @@ def test_ramped_half_and_half(self):\\n         problem = SingleObjectiveProblem(\\n             minimize=False,\\n             fitness_function=lambda x: x,\\n-            target_fitness=None,\\n         )\\n \\n         max_depth = 10\\n\",\"diff --git a/tests/rampedhah_test.py b/tests/rampedhah_test.py\\nindex b975d4f1..14847d6e 100644\\n--- a/tests/rampedhah_test.py\\n+++ b/tests/rampedhah_test.py\\n@@ -5,7 +5,6 @@\\n from typing import Annotated\\n \\n from geneticengine.core.grammar import extract_grammar\\n-from geneticengine.core.grammar import Grammar\\n from geneticengine.core.problems import SingleObjectiveProblem\\n from geneticengine.core.random.sources import RandomSource\\n from geneticengine.core.representations.tree.operators import (\\n@@ -42,7 +41,7 @@ class Middle(Root):\\n class TestRamped:\\n     def test_ramped_half_and_half(self):\\n         r = RandomSource(seed=1)\\n-        g: Grammar = extract_grammar([Concrete, Middle], Root, False)\\n+        g = extract_grammar([Concrete, Middle], Root, False)\\n         problem = SingleObjectiveProblem(\\n             minimize=False,\\n             fitness_function=lambda x: x,\\n\",\"diff --git a/tests/fitness_helpers_test.py b/tests/fitness_helpers_test.py\\nnew file mode 100644\\nindex 00000000..71c3ce62\\n--- /dev/null\\n+++ b/tests/fitness_helpers_test.py\\n@@ -0,0 +1,76 @@\\n+from __future__ import annotations\\n+\\n+from abc import ABC\\n+from dataclasses import dataclass\\n+from geneticengine.algorithms.gp.individual import Individual\\n+from geneticengine.core.evaluators import SequentialEvaluator\\n+from geneticengine.core.fitness_helpers import best_individual, is_better, sort_population\\n+\\n+from geneticengine.core.grammar import extract_grammar\\n+from geneticengine.core.problems import MultiObjectiveProblem, SingleObjectiveProblem\\n+from geneticengine.core.representations.tree.treebased import TreeBasedRepresentation\\n+\\n+\\n+class Root(ABC):\\n+    pass\\n+\\n+\\n+@dataclass\\n+class Leaf(Root):\\n+    a: int\\n+\\n+\\n+class TestFitnessHelpers:\\n+    def test_best_individual(self):\\n+        g = extract_grammar([Leaf], Root)\\n+        representation = TreeBasedRepresentation(g, 2)\\n+\\n+        population = [\\n+            Individual(genotype=Leaf(1), genotype_to_phenotype=representation.genotype_to_phenotype),\\n+            Individual(genotype=Leaf(2), genotype_to_phenotype=representation.genotype_to_phenotype),\\n+        ]\\n+\\n+        problem = SingleObjectiveProblem(fitness_function=lambda x: x.a, minimize=False)\\n+        x = best_individual(population, problem)\\n+        assert x.get_phenotype().a == 2\\n+\\n+        problem = SingleObjectiveProblem(fitness_function=lambda x: x.a, minimize=True)\\n+        x = best_individual(population, problem)\\n+        assert x.get_phenotype().a == 1\\n+\\n+        problem = MultiObjectiveProblem(minimize=[True, True], fitness_function=lambda x: [x.a, x.a])\\n+        x = best_individual(population, problem)\\n+        assert x.get_phenotype().a == 1\\n+\\n+    def test_is_better(self):\\n+        g = extract_grammar([Leaf], Root)\\n+        representation = TreeBasedRepresentation(g, 2)\\n+        evaluator = SequentialEvaluator()\\n+\\n+        a = Individual(genotype=Leaf(1), genotype_to_phenotype=representation.genotype_to_phenotype)\\n+        b = Individual(genotype=Leaf(2), genotype_to_phenotype=representation.genotype_to_phenotype)\\n+\\n+        problem = SingleObjectiveProblem(fitness_function=lambda x: x.a, minimize=True)\\n+        evaluator.eval(problem, [a, b])\\n+        assert is_better(problem, a, b)\\n+\\n+        problem = SingleObjectiveProblem(fitness_function=lambda x: x.a, minimize=False)\\n+        evaluator.eval(problem, [a, b])\\n+        assert not is_better(problem, a, b)\\n+\\n+    def test_sort(self):\\n+        g = extract_grammar([Leaf], Root)\\n+        representation = TreeBasedRepresentation(g, 2)\\n+        evaluator = SequentialEvaluator()\\n+\\n+        a = Individual(genotype=Leaf(1), genotype_to_phenotype=representation.genotype_to_phenotype)\\n+        b = Individual(genotype=Leaf(3), genotype_to_phenotype=representation.genotype_to_phenotype)\\n+        c = Individual(genotype=Leaf(2), genotype_to_phenotype=representation.genotype_to_phenotype)\\n+        population = [a, b, c]\\n+\\n+        problem = SingleObjectiveProblem(fitness_function=lambda x: x.a, minimize=True)\\n+        evaluator.eval(problem, population)\\n+        sorted_population = sort_population(population, problem)\\n+        assert sorted_population[0].get_phenotype().a == 1\\n+        assert sorted_population[1].get_phenotype().a == 2\\n+        assert sorted_population[2].get_phenotype().a == 3\\n\",\"diff --git a/tests/immutability_test.py b/tests/immutability_test.py\\nindex 89664642..5fd79288 100644\\n--- a/tests/immutability_test.py\\n+++ b/tests/immutability_test.py\\n@@ -2,8 +2,10 @@\\n \\n from dataclasses import dataclass\\n from typing import Annotated\\n+from geneticengine.algorithms.gp.individual import Individual\\n \\n from geneticengine.core.decorators import abstract\\n+from geneticengine.core.evaluators import SequentialEvaluator\\n from geneticengine.core.grammar import extract_grammar\\n from geneticengine.core.random.sources import RandomSource\\n from geneticengine.core.representations.tree.treebased import TreeBasedRepresentation\\n@@ -12,6 +14,7 @@\\n from geneticengine.metahandlers.ints import IntRange\\n from geneticengine.metahandlers.lists import ListSizeBetween\\n from geneticengine.metahandlers.vars import VarRange\\n+from geneticengine.algorithms.gp.operators.mutation import GenericMutationStep\\n \\n \\n @abstract\\n@@ -45,3 +48,26 @@ def test_hash(self):\\n         r = RandomSource(3)\\n         ind = rep.create_individual(r, 10)\\n         assert isinstance(hash(ind), int)\\n+\\n+    def test_mutation(self):\\n+        g = extract_grammar([A, B], A)\\n+        rep = TreeBasedRepresentation(g, max_depth=10)\\n+        r = RandomSource(3)\\n+\\n+        initial_population = [\\n+            Individual(genotype=rep.create_individual(r, 10), genotype_to_phenotype=rep.genotype_to_phenotype)\\n+            for _ in range(10)\\n+        ]\\n+        cpy = str(initial_population)\\n+\\n+        step = GenericMutationStep(1.0)\\n+        _ = step.iterate(\\n+            problem=None,\\n+            evaluator=SequentialEvaluator(),\\n+            representation=rep,\\n+            random_source=r,\\n+            population=initial_population,\\n+            target_size=10,\\n+            generation=1,\\n+        )\\n+        assert str(initial_population == cpy)\\n\",\"diff --git a/tests/immutability_test.py b/tests/immutability_test.py\\nindex 5fd79288..02e49b79 100644\\n--- a/tests/immutability_test.py\\n+++ b/tests/immutability_test.py\\n@@ -3,6 +3,9 @@\\n from dataclasses import dataclass\\n from typing import Annotated\\n from geneticengine.algorithms.gp.individual import Individual\\n+from geneticengine.algorithms.gp.operators.crossover import GenericCrossoverStep\\n+\\n+import pytest\\n \\n from geneticengine.core.decorators import abstract\\n from geneticengine.core.evaluators import SequentialEvaluator\\n@@ -49,7 +52,8 @@ def test_hash(self):\\n         ind = rep.create_individual(r, 10)\\n         assert isinstance(hash(ind), int)\\n \\n-    def test_mutation(self):\\n+    @pytest.mark.parametrize(\\\"test_step\\\", [GenericMutationStep(1.0), GenericCrossoverStep(1.0)])\\n+    def test_mutation(self, test_step):\\n         g = extract_grammar([A, B], A)\\n         rep = TreeBasedRepresentation(g, max_depth=10)\\n         r = RandomSource(3)\\n@@ -59,15 +63,16 @@ def test_mutation(self):\\n             for _ in range(10)\\n         ]\\n         cpy = str(initial_population)\\n+        population = initial_population\\n \\n-        step = GenericMutationStep(1.0)\\n-        _ = step.iterate(\\n-            problem=None,\\n-            evaluator=SequentialEvaluator(),\\n-            representation=rep,\\n-            random_source=r,\\n-            population=initial_population,\\n-            target_size=10,\\n-            generation=1,\\n-        )\\n-        assert str(initial_population == cpy)\\n+        for i in range(10):\\n+            population = test_step.iterate(\\n+                problem=None,\\n+                evaluator=SequentialEvaluator(),\\n+                representation=rep,\\n+                random_source=r,\\n+                population=population,\\n+                target_size=10,\\n+                generation=1,\\n+            )\\n+        assert str(initial_population) == cpy\\n\",\"diff --git a/tests/immutability_test.py b/tests/immutability_test.py\\nindex 02e49b79..99e3a147 100644\\n--- a/tests/immutability_test.py\\n+++ b/tests/immutability_test.py\\n@@ -62,7 +62,11 @@ def test_mutation(self, test_step):\\n             Individual(genotype=rep.create_individual(r, 10), genotype_to_phenotype=rep.genotype_to_phenotype)\\n             for _ in range(10)\\n         ]\\n-        cpy = str(initial_population)\\n+\\n+        def encode_population(pop: list[Individual]) -> list[str]:\\n+            return [str(ind.genotype) for ind in pop]\\n+\\n+        cpy = encode_population(initial_population)\\n         population = initial_population\\n \\n         for i in range(10):\\n@@ -75,4 +79,5 @@ def test_mutation(self, test_step):\\n                 target_size=10,\\n                 generation=1,\\n             )\\n-        assert str(initial_population) == cpy\\n+        for (a, b) in zip(encode_population(initial_population), cpy):\\n+            assert a == b\\n\",\"diff --git a/tests/immutability_test.py b/tests/immutability_test.py\\nindex 99e3a147..2393cd73 100644\\n--- a/tests/immutability_test.py\\n+++ b/tests/immutability_test.py\\n@@ -58,26 +58,27 @@ def test_mutation(self, test_step):\\n         rep = TreeBasedRepresentation(g, max_depth=10)\\n         r = RandomSource(3)\\n \\n+        population_size = 1000\\n+\\n         initial_population = [\\n             Individual(genotype=rep.create_individual(r, 10), genotype_to_phenotype=rep.genotype_to_phenotype)\\n-            for _ in range(10)\\n+            for _ in range(population_size)\\n         ]\\n \\n         def encode_population(pop: list[Individual]) -> list[str]:\\n             return [str(ind.genotype) for ind in pop]\\n \\n         cpy = encode_population(initial_population)\\n-        population = initial_population\\n \\n         for i in range(10):\\n-            population = test_step.iterate(\\n+            _ = test_step.iterate(\\n                 problem=None,\\n                 evaluator=SequentialEvaluator(),\\n                 representation=rep,\\n                 random_source=r,\\n-                population=population,\\n-                target_size=10,\\n-                generation=1,\\n+                population=initial_population,\\n+                target_size=population_size,\\n+                generation=i,\\n             )\\n         for (a, b) in zip(encode_population(initial_population), cpy):\\n             assert a == b\"]", "hints_text": ""}

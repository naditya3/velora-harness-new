{"instance_id": "1113250230163796", "repo": "alcides/aeon", "base_commit": "de942c616a72d39c013749e34221e9dd8f58a940", "problem_statement": "Metadata in decorators:\\nThe idea of this feature is two-fold:\\r\\n\\r\\nFirstly, we want to support multiple decorators (e.g., multiple minimize targets that just append to a list of objectives).\\r\\n\\r\\n```\\r\\n@dec1(...)\\r\\n@dec2(...)\\r\\ndef f : Int := 3;\\r\\n```\\r\\n\\r\\nSecondly, we want to save information together with the AST (\"eg: what is the list of fitness functions, what functions to ignore, etc).\\r\\n\\r\\n\\r\\nHow to implement:\\r\\n* Decorators need to accept a metadata dictionary, and return the new metadata dictionary. \\r\\n* When decorators are being applied for each function, the new metadata is passed to the next decorator. \\r\\n* Between function definitions, the metadata dictionary is also passed on to the next one.\\r\\n* Metadata needs to be passed on to the synthesis procedure.\\r\\n", "FAIL_TO_PASS": ["tests/native_test.py::test_anf", "tests/smt_test.py::test_uninterpreted2", "tests/optimization_decorators_test.py::test_hole_minimize_int", "tests/smt_test.py::test_uninterpreted", "tests/optimization_decorators_test.py::test_eq", "tests/liquid_test.py::test_liquid_types_syntax", "tests/hole_test.py::test_hole2", "tests/hole_test.py::test_hole3", "tests/hole_test.py::test_hole1", "tests/pow_test.py::test_anf", "tests/hole_test.py::test_hole_identification", "tests/recursion_test.py::test_anf", "tests/synth_fitness_test.py::test_fitness", "tests/synth_fitness_test.py::test_fitness2"], "PASS_TO_PASS": ["tests/frontend_test.py::test_abs", "tests/horn_test.py::test_merge_assignments", "tests/wellformed_test.py::test_dependent", "tests/backend_test.py::test_literal", "tests/simplification_constraints_test.py::test_simplify_constraint_implication", "tests/substitutions_test.py::test_substitution_type_shadow", "tests/end_to_end_test.py::test_anf", "tests/backend_test.py::test_let", "tests/frontend_test.py::test_literals", "tests/infer_test.py::test_abs_f", "tests/frontend_test.py::test_poly_abs_plus", "tests/end_to_end_test.py::test_annotation", "tests/wellformed_test.py::test_refined", "tests/instantiation_test.py::test_substitution_type_simple", "tests/simplification_constraints_test.py::test_simplify_constraint", "tests/infer_test.py::test_sub", "tests/substitutions_test.py::test_substitution_autorename_ref", "tests/infer_test.py::test_abs_if", "tests/substitutions_test.py::test_substitution_term", "tests/substitutions_test.py::test_substitution_term_shadow_let", "tests/end_to_end_test.py::test_anf_typed_smaller", "tests/infer_test.py::test_sumToSimple5", "tests/pprint_term_test.py::test_rewrite_op_term", "tests/infer_test.py::test_sumTo", "tests/backend_test.py::test_if_str", "tests/infer_test.py::test_sumSimple4", "tests/infer_test.py::test_two", "tests/infer_test.py::test_sumToSimple6", "tests/simplification_constraints_test.py::test_simplify_liquid_multiple", "tests/horn_test.py::test_fresh", "tests/infer_test.py::test_a_is_bool", "tests/end_to_end_test.py::test_anf_typed", "tests/wellformed_test.py::test_inhabited", "tests/infer_test.py::test_sub_simple", "tests/infer_test.py::test_capture_avoiding_subs", "tests/frontend_test.py::test_poly_parse", "tests/end_to_end_test.py::test_annotation_anf", "tests/substitutions_test.py::test_substitution_autorename", "tests/infer_test.py::test_sumSimple5", "tests/horn_test.py::test_possible_args", "tests/frontend_test.py::test_refinedtypes", "tests/infer_test.py::test_abs_is_int", "tests/backend_test.py::test_application", "tests/wellformed_test.py::test_wf2", "tests/infer_test.py::test_or", "tests/infer_test.py::test_if", "tests/infer_test.py::test_sumToSimple4", "tests/infer_test.py::test_sumSimple1", "tests/liquid_test.py::test_simple_eq", "tests/smt_test.py::test_smt_example3", "tests/substitutions_test.py::test_substitution_type", "tests/infer_test.py::test_simplerec", "tests/frontend_test.py::test_poly_abs", "tests/horn_test.py::test_solve", "tests/backend_test.py::test_if", "tests/infer_test.py::test_one_is_int", "tests/simplification_constraints_test.py::test_simplify_liquid_right", "tests/infer_test.py::test_six", "tests/infer_test.py::test_nine", "tests/infer_test.py::test_sumSimple3", "tests/simplification_constraints_test.py::test_simplify_constraint_implication2", "tests/frontend_test.py::test_poly_app", "tests/wellformed_test.py::test_wf1", "tests/end_to_end_test.py::test_annotation_anf2", "tests/frontend_test.py::test_precedence", "tests/infer_test.py::test_let_let", "tests/wellformed_test.py::test_poly", "tests/infer_test.py::test_not", "tests/polymorphism_test.py::test_poly", "tests/infer_test.py::test_a_is_not_bool", "tests/substitutions_test.py::test_substitution_type_abs", "tests/frontend_test.py::test_let", "tests/horn_test.py::test_possible_args2", "tests/get_core_test.py::test_get_core", "tests/infer_test.py::test_abs", "tests/substitutions_test.py::test_substitution_term_let", "tests/instantiation_test.py::test_substitution_type_no_change", "tests/horn_test.py::test_flat", "tests/infer_test.py::test_one_is_float", "tests/frontend_test.py::test_ann", "tests/horn_test.py::test_base_assignment_helper2", "tests/infer_test.py::test_and", "tests/infer_test.py::test_true_is_bool", "tests/substitutions_test.py::test_substitution_term_shadow", "tests/end_to_end_test.py::test_annotation_anf3", "tests/infer_test.py::test_max", "tests/frontend_test.py::test_if", "tests/frontend_test.py::test_operators", "tests/infer_test.py::test_sumSimple2", "tests/smt_test.py::test_other_sorts", "tests/frontend_test.py::test_abstractiontypes", "tests/horn_test.py::test_base_assignment_helper", "tests/simplification_constraints_test.py::test_simplify_liquid_left", "tests/infer_test.py::test_fifteen", "tests/infer_test.py::test_negatives", "tests/liquid_test.py::test_liquefaction", "tests/frontend_test.py::test_basetypes", "tests/substitutions_test.py::test_substitution_type_abs_shadow"], "language": "python", "test_command": "source /saved/ENV || source /saved/*/ENV && pytest --no-header -rA --tb=no -p no:cacheprovider --continue-on-collection-errors", "test_output_parser": "python/parse_log_pytest_v3", "image_storage_uri": "vmvm-registry.fbinfra.net/repomate_image_activ_pytest/alcides_aeon:de942c616a72d39c013749e34221e9dd8f58a940", "patch": "", "test_patch": "[\"diff --git a/libraries/PSB2.ae b/libraries/PSB2.ae\\nindex 82cf79a7..2a9079d5 100644\\n--- a/libraries/PSB2.ae\\n+++ b/libraries/PSB2.ae\\n@@ -4,66 +4,114 @@ type TestData;\\n type List;\\n type Tuple;\\n \\n-@ignore()\\n-def psb2_aeon : Unit = native_import \\\"psb2\\\";\\n \\n-@ignore()\\n-def textdistance_aeon : Unit = native_import \\\"textdistance\\\";\\n+def load_dataset : (name:String) -> (nTrain:Int) -> (nTest:Int) -> Dataset = native \\\"lambda s: lambda train: lambda test: __import__('psb2').fetch_examples('path/to/PSB2/datasets/', s, train, test, format='lists')\\\";\\n \\n-@ignore()\\n-def load_dataset : (name:String) -> (nTrain:Int) -> (nTest:Int) -> Dataset = native \\\"lambda s: lambda train: lambda test: psb2_aeon.fetch_examples('path/to/PSB2/datasets/', s, train, test, format='lists')\\\";\\n \\n-@ignore()\\n def extract_train_data : (ds:Dataset) -> TrainData = native \\\"lambda ds: ds[0]\\\";\\n \\n-@ignore()\\n+\\n def unpack_train_data : (td:TrainData) -> Tuple = native \\\"lambda td: list(map(list, zip(*td)))\\\";\\n \\n-@ignore()\\n+\\n def get_input_list : (t:Tuple) -> List = native \\\"lambda t: t[0]\\\";\\n \\n-@ignore()\\n+\\n def get_output_list : (t:Tuple) -> List = native \\\"lambda t: sum(t[1], [])\\\";\\n \\n-@ignore()\\n+\\n def extract_test_data : (ds:Dataset) -> TestData = native \\\"lambda ds: ds[1]\\\";\\n \\n-@ignore()\\n-def mean_absolute_error : (true_values : List) -> (expected_values : List) ->  Float = native \\\"lambda t: lambda e: __import__('numpy').mean(__import__('numpy').abs(__import__('numpy').array(t) - __import__('numpy').array(e)))\\\";\\n \\n-# add a refinement to make sure that the lists are all the same size\\n-@ignore()\\n-def calculate_list_errors : (true_values : List) -> (expected_values : List) ->  List =  native \\\"lambda t: lambda e: [abs(p - r) for p, r in zip(t, e)]\\\";\\n+def mean_absolute_error : (true_values : List) -> (expected_values : List) ->  Float = native \\\"lambda t: lambda e: __import__('numpy').mean(__import__('numpy').abs(__import__('numpy').array(t) - __import__('numpy').array(e)))\\\";\\n \\n # maybe move this method to string lib\\n def String_distance : (str1 : String) -> (str2 : String) -> Float = native \\\"lambda s1: lambda s2: __import__('textdistance').levenshtein(s1, s2)\\\";\\n \\n-@ignore()\\n+\\n+# add a refinement to make sure that the lists are all the same siz\\n+def calculate_list_errors : (true_values : List) -> (expected_values : List) ->  List =  native \\\"lambda t: lambda e: [abs(p - r) for p, r in zip(t, e)]\\\";\\n+\\n+\\n+def calculate_list_difference : (true_values : List) -> (expected_values : List) ->  List =  native \\\"lambda x: lambda y: [0 if a == b else 1 for a, b in zip(x, y)]\\\";\\n+\\n+\\n def calculate_str_list_errors : (true_values : List) -> (expected_values : List) ->  List =  native \\\"lambda t: lambda e: [__import__('textdistance').levenshtein(p, r) for p, r in zip(t, e)]\\\";\\n \\n-@ignore()\\n+\\n def join_string_list : (list: List) -> String = native \\\"lambda xs: ' '.join(word.strip() for word in xs) \\\";\\n \\n-@ignore()\\n+\\n+def get_b_synth_values : (input : List) -> (f:(a: List) -> Int) -> List = native \\\" lambda inputs: lambda function: [function(x) for x in inputs]\\\";\\n+\\n+\\n def get_bb_synth_values : (input : List) -> (f:(a: Float) ->( b:Float ) -> (c:Int) -> Float ) -> List = native \\\" lambda inputs: lambda function: [function(x)(y)(z) for x, y, z in inputs]\\\";\\n \\n-@ignore()\\n+\\n+def get_bowling_synth_values : (input : List) -> (f:(a: String) -> Int ) -> List = native \\\" lambda inputs: lambda function: [function(x) for x in inputs]\\\";\\n+\\n+\\n+def get_c_synth_values : (input : List) -> (f:(a: String) -> String ) -> List = native \\\" lambda inputs: lambda function: [function(x) for x in inputs]\\\";\\n+\\n+\\n+def get_cs_synth_values : (input : List) -> (f:(a: Int) -> List ) -> List = native \\\" lambda inputs: lambda function: [function(x) for x in inputs]\\\";\\n+\\n+\\n+def get_cv_synth_values : (input : List) -> (f:(a: List) -> List ) -> List = native \\\" lambda inputs: lambda function: [function(x) for x in inputs]\\\";\\n+\\n+\\n def get_dg_synth_values : (input : List) -> (f: (a:Int) ->( b:Int ) -> Float ) -> List = native \\\" lambda inputs: lambda function: [function(x)(y) for x, y in inputs]\\\";\\n \\n-@ignore()\\n+\\n+def get_fp_synth_values : (input : List) -> (f: (a:List) ->( b:Int ) -> List ) -> List = native \\\" lambda inputs: lambda function: [function(x)(y) for x, y in inputs]\\\";\\n+\\n+\\n def get_fb_synth_values : (input : List) -> (f: (a: Int) -> String ) -> List = native \\\" lambda inputs: lambda function: [function(x) for x in inputs]\\\";\\n \\n-@ignore()\\n+\\n+def get_fc_synth_values : (input : List) -> (f: (a: List) -> Int ) -> List = native \\\" lambda inputs: lambda function: [function(x) for x in inputs]\\\";\\n+\\n+\\n def get_gcd_synth_values : (input : List) -> (f:(a: Int) -> (b: Int)->  Int ) -> List = native \\\" lambda inputs: lambda function: [function(x)(y) for x,y in inputs]\\\";\\n \\n-@ignore()\\n+\\n+def get_is_synth_values : (input : List) -> (f:(a: String) -> (b: String)->  List ) -> List = native \\\" lambda inputs: lambda function: [function(x)(y) for x,y in inputs]\\\";\\n+\\n+\\n+def get_l_synth_values : (input : List) -> (f:(a: List) -> List ) -> List = native \\\" lambda inputs: lambda function: [function(x)for x in inputs]\\\";\\n+\\n+\\n+def get_luhn_synth_values : (input : List) -> (f:(a: List) -> Int ) -> List = native \\\" lambda inputs: lambda function: [function(x)for x in inputs]\\\";\\n+\\n+\\n+def get_mm_synth_values : (input : List) -> (f:(a: String) -> (b:String) -> List ) -> List = native \\\" lambda inputs: lambda function: [function(x)(y)for x, y in inputs]\\\";\\n+\\n+\\n def get_mc_synth_values : (input : List) -> (f:(a: String) -> String ) -> List = native \\\" lambda inputs: lambda function: [function(x) for x in inputs]\\\";\\n \\n-@ignore()\\n+\\n+def get_pd_synth_values : (input : List) -> (f:(a: String) -> Int ) -> List = native \\\" lambda inputs: lambda function: [function(x) for x in inputs]\\\";\\n+\\n+\\n+def get_shop_synth_values : (input : List) -> (f:(a: List) -> (b: List) -> Int ) -> List = native \\\" lambda inputs: lambda function: [function(x)(y) for x, y in inputs]\\\";\\n+\\n+\\n def get_snowd_synth_values : (input : List) -> (f:(a: Int) ->( b:Float ) -> (c:Float) ->(d:Float)  -> Float ) -> List = native \\\" lambda inputs: lambda function: [function(x)(y)(z)(w) for x, y, z, w in inputs]\\\";\\n \\n-@ignore()\\n+\\n+def get_sbool_synth_values : (input : List) -> (f:(a: String) -> Bool ) -> List = native \\\" lambda inputs: lambda function: [function(x) for x in inputs]\\\";\\n+\\n+\\n+def get_sw_synth_values : (input : List) -> (f:(a: String) -> String ) -> List = native \\\" lambda inputs: lambda function: [function(x) for x in inputs]\\\";\\n+\\n+\\n def get_sd_synth_values : (input : List) -> (f:(a: Int) -> String ) -> List = native \\\" lambda inputs: lambda function: [function(x) for x in inputs]\\\";\\n \\n-@ignore()\\n+\\n+def get_sc_synth_values : (input : List) -> (f:(a: String) -> (b: String) -> (c: String) ->  String ) -> List = native \\\" lambda inputs: lambda function: [function(x)(y)(z) for x, y, z in inputs]\\\";\\n+\\n+\\n def get_tt_synth_values : (input : List) -> (f:(a: String) -> String ) -> List = native \\\" lambda inputs: lambda function: [function(x) for x in inputs]\\\";\\n+\\n+\\n+def get_vd_synth_values : (input : List) -> (f:(a: List) -> (b: List) -> Float ) -> List = native \\\" lambda inputs: lambda function: [function(x)(y) for x, y in inputs]\\\";\\n\",\"diff --git a/tests/hole_test.py b/tests/hole_test.py\\nindex e5179426..85971591 100644\\n--- a/tests/hole_test.py\\n+++ b/tests/hole_test.py\\n@@ -9,7 +9,7 @@\\n def extract_target_functions(source):\\n     prog = parse_program(source)\\n     prog = apply_decorators_in_program(prog)\\n-    core, ctx, _ = desugar(prog)\\n+    core, ctx, _, _ = desugar(prog)\\n     core_anf = ensure_anf(core)\\n     check_type_errors(ctx, core_anf, top)\\n     return incomplete_functions_and_holes(ctx, core_anf)\\n\",\"diff --git a/tests/liquid_test.py b/tests/liquid_test.py\\nindex d069c85b..d416835f 100644\\n--- a/tests/liquid_test.py\\n+++ b/tests/liquid_test.py\\n@@ -14,7 +14,7 @@\\n \\n \\n def check_compile(source, ty, res):\\n-    p, ctx, ectx = desugar(parse_program(source))\\n+    p, ctx, ectx, _ = desugar(parse_program(source))\\n     assert check_type(ctx, p, ty)\\n \\n \\n\",\"diff --git a/tests/native_test.py b/tests/native_test.py\\nindex c0dfa038..c5ca5467 100644\\n--- a/tests/native_test.py\\n+++ b/tests/native_test.py\\n@@ -8,7 +8,7 @@\\n \\n \\n def check_compile(source, ty):\\n-    p, ctx, ectx = desugar(parse_program(source))\\n+    p, ctx, ectx, _ = desugar(parse_program(source))\\n     assert check_type(ctx, p, ty)\\n     assert eval(p, ectx) == 2\\n \\n\",\"diff --git a/tests/optimization_decorators_test.py b/tests/optimization_decorators_test.py\\nindex 3d0ef0f9..bb389712 100644\\n--- a/tests/optimization_decorators_test.py\\n+++ b/tests/optimization_decorators_test.py\\n@@ -10,7 +10,7 @@\\n \\n def extract_core(source: str) -> Term:\\n     prog = parse_program(source)\\n-    core, ctx, _ = desugar(prog)\\n+    core, ctx, _, _ = desugar(prog)\\n     core_anf = ensure_anf(core)\\n     check_type_errors(ctx, core_anf, top)\\n     return core_anf\\n@@ -24,7 +24,7 @@ def minus : (a:Int) -> (b:Int) -> Int = \\\\\\\\x -> \\\\\\\\y -> x - y;\\n             def synth(a: Int) : Int { (?hole:Int) * a}\\n         \\\"\\\"\\\"\\n     core = extract_core(code)\\n-    assert len(list(iterate_top_level(core))) == 4\\n+    assert len(list(iterate_top_level(core))) == 3 + 1\\n \\n \\n def test_eq():\\n@@ -41,6 +41,7 @@ def main(args:Int) : Unit {\\n         core_ast,\\n         typing_ctx,\\n         evaluation_ctx,\\n+        metadata,\\n     ) = desugar(prog)\\n \\n     core_ast_anf = ensure_anf(core_ast)\\n\",\"diff --git a/tests/pow_test.py b/tests/pow_test.py\\nindex a967f59e..3732c657 100644\\n--- a/tests/pow_test.py\\n+++ b/tests/pow_test.py\\n@@ -7,7 +7,7 @@\\n \\n \\n def check_compile(source, ty):\\n-    p, ctx, _ = desugar(parse_program(source))\\n+    p, ctx, _, _ = desugar(parse_program(source))\\n     assert check_type(ctx, p, ty)\\n \\n \\n\",\"diff --git a/tests/recursion_test.py b/tests/recursion_test.py\\nindex 50a9e292..02351d6f 100644\\n--- a/tests/recursion_test.py\\n+++ b/tests/recursion_test.py\\n@@ -7,7 +7,7 @@\\n \\n \\n def check_compile(source, ty, res):\\n-    p, ctx, ectx = desugar(parse_program(source))\\n+    p, ctx, ectx, _ = desugar(parse_program(source))\\n     assert check_type(ctx, p, ty)\\n     # assert eval(p, ectx) == res\\n \\n\",\"diff --git a/tests/smt_test.py b/tests/smt_test.py\\nindex 6fd671c4..05006ea7 100644\\n--- a/tests/smt_test.py\\n+++ b/tests/smt_test.py\\n@@ -20,7 +20,7 @@\\n \\n def extract_core(source: str) -> Term:\\n     prog = parse_program(source)\\n-    core, ctx, _ = desugar(prog)\\n+    core, ctx, _, _ = desugar(prog)\\n     core_anf = ensure_anf(core)\\n     check_type_errors(ctx, core_anf, top)\\n     return core_anf\\n@@ -30,8 +30,7 @@ def extract_core(source: str) -> Term:\\n     \\\"x\\\",\\n     t_int,\\n     LiquidApp(\\\"==\\\", [LiquidVar(\\\"x\\\"), LiquidLiteralInt(3)]),\\n-    LiquidConstraint(LiquidApp(\\n-        \\\"==\\\", [LiquidVar(\\\"x\\\"), LiquidLiteralInt(3)])),\\n+    LiquidConstraint(LiquidApp(\\\"==\\\", [LiquidVar(\\\"x\\\"), LiquidLiteralInt(3)])),\\n )\\n \\n \\n@@ -47,8 +46,7 @@ def test_smt_example3():\\n         \\\"y\\\",\\n         BaseType(\\\"a\\\"),\\n         LiquidApp(\\\"==\\\", [LiquidVar(\\\"x\\\"), LiquidVar(\\\"y\\\")]),\\n-        LiquidConstraint(LiquidApp(\\n-            \\\"==\\\", [LiquidVar(\\\"x\\\"), LiquidVar(\\\"y\\\")])),\\n+        LiquidConstraint(LiquidApp(\\\"==\\\", [LiquidVar(\\\"x\\\"), LiquidVar(\\\"y\\\")])),\\n     ),\\n )\\n \\n@@ -80,6 +78,7 @@ def main (x:Int) : Unit {\\n         core_ast,\\n         typing_ctx,\\n         evaluation_ctx,\\n+        metadata,\\n     ) = desugar(prog)\\n \\n     core_ast_anf = ensure_anf(core_ast)\\n@@ -104,6 +103,7 @@ def main (x:Int) : Unit {\\n         core_ast,\\n         typing_ctx,\\n         evaluation_ctx,\\n+        metadata,\\n     ) = desugar(prog)\\n \\n     core_ast_anf = ensure_anf(core_ast)\\n\",\"diff --git a/tests/synth_fitness_test.py b/tests/synth_fitness_test.py\\nindex 6c136d50..9fe6ad71 100644\\n--- a/tests/synth_fitness_test.py\\n+++ b/tests/synth_fitness_test.py\\n@@ -2,12 +2,13 @@\\n \\n from abc import ABC\\n \\n-from aeon.core.terms import Term\\n-from aeon.core.types import top\\n+from aeon.core.terms import Term, Application, Literal, Var\\n+from aeon.core.types import top, BaseType\\n from aeon.frontend.anf_converter import ensure_anf\\n from aeon.logger.logger import setup_logger\\n from aeon.sugar.desugar import desugar\\n from aeon.sugar.parser import parse_program\\n+from aeon.sugar.program import Definition\\n from aeon.synthesis_grammar.grammar import mk_method_core_literal\\n from aeon.synthesis_grammar.synthesizer import synthesize\\n from aeon.typechecking.typeinfer import check_type_errors\\n@@ -33,13 +34,18 @@ def __init__(self, value: int):\\n def test_fitness():\\n     code = \\\"\\\"\\\"def year : Int = 2023;\\n         def synth (i: Int): Int { (?hole: Int) * i}\\n-        def __internal__fitness_function_synth : Int  =  year - synth(7);\\n     \\\"\\\"\\\"\\n     prog = parse_program(code)\\n-    p, ctx, ectx = desugar(prog)\\n+    p, ctx, ectx, _ = desugar(prog)\\n     p = ensure_anf(p)\\n     check_type_errors(ctx, p, top)\\n-    term = synthesize(ctx, ectx, p, [(\\\"synth\\\", [\\\"hole\\\"])])\\n+    internal_minimize = Definition(\\n+        name=\\\"__internal__minimize_int_synth_0\\\",\\n+        args=[],\\n+        type=BaseType(\\\"Int\\\"),\\n+        body=Application(Application(Var(\\\"synth\\\"), Literal(7, BaseType(\\\"Int\\\"))), Application(Var(\\\"-\\\"), Var(\\\"synth\\\"))),\\n+    )\\n+    term = synthesize(ctx, ectx, p, [(\\\"synth\\\", [\\\"hole\\\"])], {\\\"synth\\\": {\\\"minimize_int\\\": [internal_minimize]}})\\n \\n     assert isinstance(term, Term)\\n \\n@@ -50,9 +56,9 @@ def test_fitness2():\\n             def synth (i:Int) : Int {(?hole: Int) * i}\\n         \\\"\\\"\\\"\\n     prog = parse_program(code)\\n-    p, ctx, ectx = desugar(prog)\\n+    p, ctx, ectx, metadata = desugar(prog)\\n     p = ensure_anf(p)\\n     check_type_errors(ctx, p, top)\\n-    term = synthesize(ctx, ectx, p, [(\\\"synth\\\", [\\\"hole\\\"])])\\n+    term = synthesize(ctx, ectx, p, [(\\\"synth\\\", [\\\"hole\\\"])], metadata)\\n \\n     assert isinstance(term, Term)\"]", "hints_text": ""}

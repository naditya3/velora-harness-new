{"instance_id": "1645678606093191", "repo": "abhitronix/vidgear", "base_commit": "f06585dfcfacc6ced95e77921e9dfa6e8cf162d6", "problem_statement": "Context manager support for all gears:\\n## Brief Description\\r\\n\\r\\nMany Python developers (including me) expect objects with an \"open/start -> close\" workflow to behave as context managers, i.e. support the `with ... as ...` construct.\\r\\n\\r\\n\\r\\n### Context\\r\\n\\r\\nThis feature would implement the `__enter__()` and `__exit__()` methods for all gears. Internally these only call the gear's `start()` and `close()/stop()/clean()` methods.\\r\\n\\r\\nThere are two major advantages for using Python's context managers instead of calling `start()` and `close()` independently:\\r\\n\\r\\n- The resource is automatically closed so calling `close()` in the end cannot be forgotten.\\r\\n- The resource is even closed in case of an exception since the `with` construct runs the contained code as `try ... finally`. The resource is closed in the finally block.\\r\\n\\r\\nFurthermore:\\r\\n\\r\\n- It will make the API consistent with other established Python modules/packages, e.g. [`open()`](https://docs.python.org/3/library/functions.html#open), [`threading.Lock`](https://docs.python.org/3/library/threading.html#using-locks-conditions-and-semaphores-in-the-with-statement) or [`pytest.raises()`](https://docs.pytest.org/en/stable/reference/reference.html#pytest.raises)\\r\\n- It will be backwards compatible since it does not change existing APIs.\\r\\n- There is no risk involved.\\r\\n- Future usages will be more correct since the `close()` cannot be forgotten.\\r\\n- (Opinion) Nicer looking code.\\r\\n\\r\\n#### Usage example\\r\\n\\r\\nSimplifying the [NetGear bare-minimum example](https://abhitronix.github.io/vidgear/v0.2.5-stable/gears/netgear/usage/):\\r\\n```python\\r\\n# import required libraries\\r\\nfrom vidgear.gears import VideoGear\\r\\nfrom vidgear.gears import NetGear\\r\\n\\r\\n# open any valid video stream(for e.g `test.mp4` file)\\r\\n# Define Netgear Server with default parameters\\r\\nwith VideoGear(source=\"test.mp4\") as stream, NetGear() as server:\\r\\n    \\r\\n    # loop over until KeyBoard Interrupted\\r\\n    while True:\\r\\n    \\r\\n        try:\\r\\n    \\r\\n            # read frames from stream\\r\\n            frame = stream.read()\\r\\n    \\r\\n            # check for frame if Nonetype\\r\\n            if frame is None:\\r\\n                break\\r\\n    \\r\\n            # {do something with the frame here}\\r\\n    \\r\\n            # send frame to server\\r\\n            server.send(frame)\\r\\n    \\r\\n        except KeyboardInterrupt:\\r\\n            break\\r\\n\\r\\n# video stream and server safely closed\\r\\n```\\r\\n\\r\\n\\r\\n### Your Current Environment\\r\\n* VidGear version: 0.2.6\\r\\n* Branch: testing\\r\\n* Python version: Python 3.10.4\\r\\n* Operating System and version: Arch Linux (Kernel 5.17.9-arch1-1)\\n[Proposal]: Add support for user-defined and higher than 8-bit depth input frames pixel-formats.:\\n### Issue guidelines\\n\\n- [X] I've read the [Issue Guidelines](https://abhitronix.github.io/vidgear/latest/contribution/issue/#submitting-an-issue-guidelines) and wholeheartedly agree.\\n\\n### Issue Checklist\\n\\n- [X] I have searched open or closed [issues](https://github.com/abhiTronix/vidgear/issues) and found nothing related to my idea.\\n- [X] I have read the [Documentation](https://abhitronix.github.io/vidgear/latest) and it doesn't mention anything about my idea.\\n- [X] To my best knowledge, my idea wouldn't break something for other users.\\n\\n### Describe your Idea\\n\\nPresently, WriteGear API with its compression mode auto-controls input pixel-format (`-pix_fmt` parameter) of incoming video-frames, which only accepts frames with exactly 8-bit depth (i.e. `uint8`). Apart from this, there's currently no way to manually override this input pixel-format to any desire value. \\r\\n\\r\\nThis limits the capabilities of this API with its FFmpeg backend can easily handle frames with higher than 8-bit depth such 10-bit, 16-bit, 20bit YUV pixel formats, which can significantly reduce output file size. Therefore this Proposal is aimed at supporting both user-defined and higher than 8-bit depth input frames pixel-formats \\n\\n### Use Cases\\n\\n### Supporting higher than 8-bit depth input frames pixel-formats:\\r\\n\\r\\n#### What is bit depth?\\r\\n\"Color depth, also known as bit depth, is number of bits used for each color component of a single pixel.\" For example `uint8` (8 bit/ 1 byte per colour channel), `uint16` (16 bit / 2 bytes per colour channel), and so on.\\r\\n\\r\\n#### What are advantages of higher bit depth frames?\\r\\nIn more general sense, bit-depth determines the smallest changes you can make, relative to some range of values. If our scale is brightness from pure black to pure white, then the 4 values we get from a 2-bit number would include only: black, dark midtones, light midtones, and white, which is a pretty lumpy scale and not very useful for a high dynamic range video frames. But if we have more bits with higher bit depth, we have enough gray values to make what appears to be a perfectly smooth gradient from black to white. **Here’s an example comparing a black to white gradient at different bit depths:** \\r\\n\\r\\n_(Note: Depending on the quality of your monitor, you can probably only display differences up to fewer bits)_\\r\\n\\r\\n![image](https://user-images.githubusercontent.com/34266896/185957985-4d77e18c-60ca-447b-b16c-3cca211b7169.png)\\r\\n\\r\\n### Supporting user-defined input pixel-formats: \\r\\nThis will allow users to define any thinkable pixel-format _(supported by installed FFmpeg)_ thereby providing them with full control of the incoming frames bit depth. \\r\\n\\r\\n\\n\\n### Any other Relevant Information?\\n\\n_No response_", "FAIL_TO_PASS": ["vidgear/tests/videocapture_tests/test_pigear.py::test_pigear_parameters[0-resolution6-60-0-options6-None-RuntimeError]", "vidgear/tests/videocapture_tests/test_pigear.py::test_pigear_parameters[0-resolution8-60-0-options8-COLOR_BGR2GRAY-SystemError]", "vidgear/tests/videocapture_tests/test_pigear.py::test_pigear_parameters[invalid-None--0-options0-None-AssertionError]", "vidgear/tests/videocapture_tests/test_pigear.py::test_pigear_parameters[-1-resolution7-60-0-options7-None-None]", "vidgear/tests/videocapture_tests/test_pigear.py::test_pigear_parameters[1-None-invalid-0.1-options2-None-AssertionError]", "vidgear/tests/videocapture_tests/test_pigear.py::test_pigear_parameters[0-resolution5-60-1-options5-None-RuntimeError]", "vidgear/tests/videocapture_tests/test_pigear.py::test_pigear_parameters[0-resolution4-60-invalid-options4-COLOR_BGR2INVALID-None]", "vidgear/tests/videocapture_tests/test_pigear.py::test_pigear_parameters[-1-invalid--0.1-options1-None-AssertionError]", "vidgear/tests/videocapture_tests/test_pigear.py::test_pigear_parameters[0-resolution3-60-0-options3-None-ValueError]"], "PASS_TO_PASS": ["vidgear/tests/test_helper.py::test_dimensions_to_resolutions[value0-result0]", "vidgear/tests/streamer_tests/asyncio_tests/test_webgear_rtc.py::test_webgear_rtc_custom_stream_class[stream_class3-False]", "vidgear/tests/streamer_tests/asyncio_tests/test_webgear_rtc.py::test_webgear_rtc_options[options2]", "vidgear/tests/test_helper.py::test_delete_ext_safe[ext0-True]", "vidgear/tests/test_helper.py::test_create_blank_frame[frame3-123]", "vidgear/tests/test_helper.py::test_dimensions_to_resolutions[value1-result1]", "vidgear/tests/videocapture_tests/test_screengear.py::test_screengear[1--options0-None]", "vidgear/tests/writer_tests/test_IO.py::test_failedextension", "vidgear/tests/streamer_tests/asyncio_tests/test_webgear_rtc.py::test_webgear_rtc_routes", "vidgear/tests/network_tests/asyncio_tests/test_netgear_async.py::test_netgear_async_bidirectionalmode[custom_frame_generator-Hi-options_server0-options_client0-False]", "vidgear/tests/streamer_tests/test_init.py::test_outputs[None]", "vidgear/tests/test_helper.py::test_delete_ext_safe[ext1-False]", "vidgear/tests/network_tests/test_netgear.py::test_bidirectional_mode[1-target_data2-options2]", "vidgear/tests/network_tests/test_netgear.py::test_multiserver_mode[1-options2]", "vidgear/tests/network_tests/asyncio_tests/test_helper.py::test_retrieve_best_interpolation[invalid]", "vidgear/tests/writer_tests/test_IO.py::test_paths[True-output.mp4]", "vidgear/tests/test_helper.py::test_get_supported_resolution[360P-360p]", "vidgear/tests/network_tests/asyncio_tests/test_netgear_async.py::test_netgear_async_bidirectionalmode[generator2-data2-options_server2-options_client2-True]", "vidgear/tests/streamer_tests/test_streamgear_modes.py::test_multistreams[dash-stream_params0]", "vidgear/tests/test_helper.py::test_get_video_bitrate", "vidgear/tests/streamer_tests/test_streamgear_modes.py::test_input_framerate_rtf[dash]", "vidgear/tests/streamer_tests/asyncio_tests/test_webgear_rtc.py::test_webpage_reload[options1]", "vidgear/tests/writer_tests/test_IO.py::test_paths[True-rtmp://live.twitch.tv/]", "vidgear/tests/writer_tests/test_non_compression_mode.py::test_WriteGear_compression[Output_twc.avi-output_params3-False]", "vidgear/tests/network_tests/test_netgear.py::test_bidirectional_mode[2-target_data3-options3]", "vidgear/tests/streamer_tests/test_IO_ss.py::test_paths_ss[rtmp://live.twitch.tv/output.mpd-dash]", "vidgear/tests/streamer_tests/asyncio_tests/test_webgear_rtc.py::test_webgear_rtc_custom_middleware[middleware1-True]", "vidgear/tests/network_tests/test_netgear.py::test_multiserver_mode[0-options1]", "vidgear/tests/network_tests/test_netgear.py::test_ports[5555-0-options1]", "vidgear/tests/writer_tests/test_IO.py::test_paths[True-/dev/video0]", "vidgear/tests/network_tests/asyncio_tests/test_netgear_async.py::test_netgear_async_custom_server_generator[custom_frame_generator-True]", "vidgear/tests/streamer_tests/test_streamgear_modes.py::test_input_framerate_rtf[hls]", "vidgear/tests/network_tests/asyncio_tests/test_netgear_async.py::test_netgear_async_custom_server_generator[generator2-False]", "vidgear/tests/test_helper.py::test_get_valid_ffmpeg_path[/tmp/Downloads/FFmpeg_static/ffmpeg/ffmpeg--True]", "vidgear/tests/streamer_tests/test_init.py::test_formats[mash]", "vidgear/tests/network_tests/test_netgear.py::test_client_reliablity[options0]", "vidgear/tests/test_helper.py::test_reducer[None-80-3-False]", "vidgear/tests/network_tests/test_netgear.py::test_multiserver_mode[1-options0]", "vidgear/tests/network_tests/asyncio_tests/test_netgear_async.py::test_netgear_async_recv_generator", "vidgear/tests/test_helper.py::test_validate_ffmpeg[wrong_test_path]", "vidgear/tests/test_helper.py::test_ffmpeg_binaries_download[/tmp/temp_ffmpeg-0]", "vidgear/tests/test_helper.py::test_generate_auth_certificates[/root/.vidgear-False-True]", "vidgear/tests/test_helper.py::test_validate_video[None-False]", "vidgear/tests/test_helper.py::test_generate_auth_certificates[test_folder-False-True]", "vidgear/tests/test_helper.py::test_get_valid_ffmpeg_path[-wrong_test_path-False]", "vidgear/tests/test_helper.py::test_create_blank_frame[frame1-ok]", "vidgear/tests/network_tests/test_netgear.py::test_server_reliablity[options4]", "vidgear/tests/test_helper.py::test_validate_ffmpeg[/tmp/Downloads/FFmpeg_static/ffmpeg/ffmpeg]", "vidgear/tests/network_tests/test_netgear.py::test_server_reliablity[options1]", "vidgear/tests/streamer_tests/asyncio_tests/test_webgear_rtc.py::test_webgear_rtc_custom_stream_class[stream_class1-True]", "vidgear/tests/test_helper.py::test_retrieve_best_interpolation[invalid]", "vidgear/tests/streamer_tests/test_IO_rtf.py::test_failedchannels[size0]", "vidgear/tests/videocapture_tests/test_camgear.py::test_stream_mode[https://www.youtube.com/playlist?list=PLXsatjadpxK5wpQVrWKSxu4_ItvpwfCby-720p-invalid]", "vidgear/tests/videocapture_tests/test_camgear.py::test_stream_mode[https://youtu.be/viOkh9al0xM-720p-invalid]", "vidgear/tests/test_helper.py::test_ffmpeg_binaries_download[/tmp/temp_ffmpeg-1]", "vidgear/tests/streamer_tests/test_streamgear_modes.py::test_rtf_livestream[dash]", "vidgear/tests/test_helper.py::test_dimensions_to_resolutions[invalid-result2]", "vidgear/tests/network_tests/asyncio_tests/test_netgear_async.py::test_netgear_async_options[0-options1]", "vidgear/tests/videocapture_tests/test_videogear.py::test_video_stablization[/tmp/Downloads/Test_videos/BigBuckBunny_4sec.mp4-options3]", "vidgear/tests/streamer_tests/test_streamgear_modes.py::test_ss_stream[hls]", "vidgear/tests/streamer_tests/asyncio_tests/test_webgear_rtc.py::test_webgear_rtc_custom_stream_class[None-False]", "vidgear/tests/videocapture_tests/test_camgear.py::test_stream_mode[https://www.dailymotion.com/video/x2yrnum-invalid-parameters3]", "vidgear/tests/streamer_tests/test_streamgear_modes.py::test_rtf_livestream[hls]", "vidgear/tests/streamer_tests/asyncio_tests/test_webgear_rtc.py::test_webgear_rtc_options[options3]", "vidgear/tests/streamer_tests/test_streamgear_modes.py::test_audio[stream_params0-dash]", "vidgear/tests/videocapture_tests/test_camgear.py::test_stream_mode[im_not_a_url--parameters4]", "vidgear/tests/streamer_tests/test_streamgear_modes.py::test_audio[stream_params2-dash]", "vidgear/tests/network_tests/asyncio_tests/test_netgear_async.py::test_netgear_async_addresses[172.31.11.33.44-5555]", "vidgear/tests/videocapture_tests/test_camgear.py::test_network_playback", "vidgear/tests/videocapture_tests/test_camgear.py::test_threaded_queue_mode[im_not_a_source.mp4-options2]", "vidgear/tests/streamer_tests/asyncio_tests/test_webgear_rtc.py::test_webgear_rtc_class[/tmp/Downloads/Test_videos/BigBuckBunny_4sec.mp4-False-COLOR_BGR2HSV-1]", "vidgear/tests/streamer_tests/asyncio_tests/test_webgear_rtc.py::test_webgear_rtc_custom_middleware[middleware2-False]", "vidgear/tests/streamer_tests/test_streamgear_modes.py::test_params[stream_params0-hls]", "vidgear/tests/network_tests/test_netgear.py::test_client_reliablity[options1]", "vidgear/tests/network_tests/asyncio_tests/test_netgear_async.py::test_netgear_async_playback[2]", "vidgear/tests/test_helper.py::test_dict2Args[dictionary2]", "vidgear/tests/streamer_tests/test_streamgear_modes.py::test_params[stream_params1-hls]", "vidgear/tests/network_tests/asyncio_tests/test_helper.py::test_reducer_asyncio[None-80-3-False]", "vidgear/tests/writer_tests/test_IO.py::test_paths[True-unknown://invalid.com/]", "vidgear/tests/network_tests/asyncio_tests/test_netgear_async.py::test_netgear_async_playback[1]", "vidgear/tests/videocapture_tests/test_screengear.py::test_screengear[None-mss-options3-COLOR_BGR2GRAY]", "vidgear/tests/streamer_tests/test_streamgear_modes.py::test_multistreams[dash-stream_params2]", "vidgear/tests/videocapture_tests/test_screengear.py::test_screengear[3--options5-None]", "vidgear/tests/test_helper.py::test_generate_webdata[/root-False-True]", "vidgear/tests/writer_tests/test_non_compression_mode.py::test_WriteGear_compression[/tmp/temp_write-output_params1-True]", "vidgear/tests/test_helper.py::test_generate_webdata[/root/.vidgear-True-True]", "vidgear/tests/network_tests/asyncio_tests/test_helper.py::test_reducer_asyncio[frame2-95-3-False]", "vidgear/tests/streamer_tests/test_streamgear_modes.py::test_multistreams[dash-stream_params4]", "vidgear/tests/network_tests/test_netgear.py::test_patterns[3]", "vidgear/tests/streamer_tests/test_streamgear_modes.py::test_rtf_stream[None-dash]", "vidgear/tests/streamer_tests/test_streamgear_modes.py::test_rtf_stream[COLOR_BGR2BGRA-dash]", "vidgear/tests/test_helper.py::test_is_valid_url[None-False]", "vidgear/tests/network_tests/test_netgear.py::test_server_reliablity[options3]", "vidgear/tests/test_helper.py::test_get_valid_ffmpeg_path[--True]", "vidgear/tests/network_tests/asyncio_tests/test_netgear_async.py::test_netgear_async_addresses[172.31.11.15.77-5555]", "vidgear/tests/network_tests/test_netgear.py::test_compression[options_server0]", "vidgear/tests/test_helper.py::test_create_blank_frame[None-]", "vidgear/tests/test_helper.py::test_reducer[frame4-80-797-False]", "vidgear/tests/test_helper.py::test_validate_audio[/tmp/Downloads/Test_videos/BigBuckBunny_4sec.mp4-True]", "vidgear/tests/streamer_tests/test_streamgear_modes.py::test_multistreams[hls-stream_params5]", "vidgear/tests/streamer_tests/test_streamgear_modes.py::test_rtf_stream[COLOR_BGR2GRAY-hls]", "vidgear/tests/network_tests/asyncio_tests/test_helper.py::test_create_blank_frame_asyncio[frame3-123]", "vidgear/tests/network_tests/test_netgear.py::test_server_reliablity[options6]", "vidgear/tests/network_tests/test_netgear.py::test_ports[0-5555-options0]", "vidgear/tests/streamer_tests/test_streamgear_modes.py::test_multistreams[hls-stream_params1]", "vidgear/tests/writer_tests/test_IO.py::test_fail_framedimension[True]", "vidgear/tests/writer_tests/test_IO.py::test_fail_framedimension[False]", "vidgear/tests/network_tests/asyncio_tests/test_helper.py::test_retrieve_best_interpolation[interpolations1]", "vidgear/tests/network_tests/asyncio_tests/test_helper.py::test_reducer_asyncio[frame4-80-797-False]", "vidgear/tests/network_tests/test_netgear.py::test_multiclient_mode[1]", "vidgear/tests/videocapture_tests/test_camgear.py::test_stream_mode[https://youtu.be/uCy5OuSQnyA-73p-invalid]", "vidgear/tests/network_tests/test_netgear.py::test_multiserver_mode[2-options3]", "vidgear/tests/network_tests/asyncio_tests/test_netgear_async.py::test_netgear_async_playback[4]", "vidgear/tests/streamer_tests/test_IO_ss.py::test_failedextension[output.m3u8]", "vidgear/tests/test_helper.py::test_reducer[frame3-80-invalid-False]", "vidgear/tests/writer_tests/test_IO.py::test_paths[False-rtmp://live.twitch.tv/]", "vidgear/tests/network_tests/test_netgear.py::test_compression[options_server2]", "vidgear/tests/writer_tests/test_IO.py::test_failedchannels[size0]", "vidgear/tests/network_tests/asyncio_tests/test_netgear_async.py::test_netgear_async_custom_server_generator[None-False]", "vidgear/tests/network_tests/asyncio_tests/test_helper.py::test_create_blank_frame_asyncio[frame0-ok]", "vidgear/tests/network_tests/test_netgear.py::test_compression[options_server1]", "vidgear/tests/network_tests/test_netgear.py::test_client_reliablity[options2]", "vidgear/tests/test_helper.py::test_get_valid_ffmpeg_path[-/tmp/temp_ffmpeg-True]", "vidgear/tests/network_tests/asyncio_tests/test_helper.py::test_create_blank_frame_asyncio[None-]", "vidgear/tests/network_tests/test_netgear.py::test_multiclient_mode[0]", "vidgear/tests/videocapture_tests/test_camgear.py::test_threaded_queue_mode[/tmp/Downloads/Test_videos/BigBuckBunny_4sec.mp4-options0]", "vidgear/tests/streamer_tests/test_IO_ss.py::test_failedextension[garbage.garbage]", "vidgear/tests/streamer_tests/asyncio_tests/test_webgear_rtc.py::test_webgear_rtc_options[options0]", "vidgear/tests/streamer_tests/test_IO_rtf.py::test_failedchannels[size1]", "vidgear/tests/test_helper.py::test_extract_time[Duration:", "vidgear/tests/test_helper.py::test_generate_webdata[test_folder-False-True]", "vidgear/tests/network_tests/test_netgear.py::test_secure_mode[0-1-custom_cert_location1-True]", "vidgear/tests/network_tests/asyncio_tests/test_helper.py::test_reducer_asyncio[frame3-80-invalid-False]", "vidgear/tests/videocapture_tests/test_screengear.py::test_screengear[None--options2-None]", "vidgear/tests/network_tests/asyncio_tests/test_netgear_async.py::test_netgear_async_playback[3]", "vidgear/tests/streamer_tests/test_streamgear_modes.py::test_audio[stream_params1-dash]", "vidgear/tests/test_helper.py::test_delete_file_safe", "vidgear/tests/test_helper.py::test_get_valid_ffmpeg_path[wrong_test_path--False]", "vidgear/tests/streamer_tests/asyncio_tests/test_webgear_rtc.py::test_webgear_rtc_routes_validity", "vidgear/tests/videocapture_tests/test_videogear.py::test_PiGear_import", "vidgear/tests/network_tests/test_netgear.py::test_secure_mode[0-1-/tmp-True]", "vidgear/tests/streamer_tests/test_streamgear_modes.py::test_multistreams[hls-stream_params3]", "vidgear/tests/test_helper.py::test_retrieve_best_interpolation[interpolations1]", "vidgear/tests/streamer_tests/test_streamgear_modes.py::test_params[stream_params3-dash]", "vidgear/tests/streamer_tests/test_streamgear_modes.py::test_ss_stream[dash]", "vidgear/tests/network_tests/test_netgear.py::test_bidirectional_mode[0-target_data0-options0]", "vidgear/tests/network_tests/asyncio_tests/test_netgear_async.py::test_netgear_async_options[1-options2]", "vidgear/tests/streamer_tests/asyncio_tests/test_webgear_rtc.py::test_webgear_rtc_custom_stream_class[stream_class2-True]", "vidgear/tests/network_tests/asyncio_tests/test_netgear_async.py::test_netgear_async_options[2-options3]", "vidgear/tests/network_tests/asyncio_tests/test_helper.py::test_reducer_asyncio[frame0-85-3-True]", "vidgear/tests/network_tests/asyncio_tests/test_helper.py::test_retrieve_best_interpolation[interpolations2]", "vidgear/tests/streamer_tests/test_streamgear_modes.py::test_params[stream_params2-dash]", "vidgear/tests/network_tests/test_netgear.py::test_primary_mode[False]", "vidgear/tests/test_helper.py::test_dict2Args[dictionary1]", "vidgear/tests/network_tests/asyncio_tests/test_netgear_async.py::test_netgear_async_options[0-options0]", "vidgear/tests/streamer_tests/test_streamgear_modes.py::test_audio[stream_params5-hls]", "vidgear/tests/network_tests/test_netgear.py::test_server_reliablity[options0]", "vidgear/tests/test_helper.py::test_generate_auth_certificates[/tmp/temp_ffmpeg-True-True]", "vidgear/tests/test_helper.py::test_validate_video[/tmp/Downloads/Test_videos/BigBuckBunny_4sec.mp4-True]", "vidgear/tests/network_tests/test_netgear.py::test_server_reliablity[options2]", "vidgear/tests/streamer_tests/asyncio_tests/test_webgear_rtc.py::test_webgear_rtc_class[/tmp/Downloads/Test_videos/BigBuckBunny_4sec.mp4-True-None-0]", "vidgear/tests/streamer_tests/test_streamgear_modes.py::test_ss_livestream[hls]", "vidgear/tests/test_helper.py::test_reducer[frame0-85-3-True]", "vidgear/tests/streamer_tests/test_init.py::test_formats[None]", "vidgear/tests/test_helper.py::test_reducer[frame2-95-3-False]", "vidgear/tests/test_helper.py::test_validate_audio[None-False]", "vidgear/tests/writer_tests/test_IO.py::test_failedchannels[size1]", "vidgear/tests/network_tests/test_netgear.py::test_secure_mode[1-2-/-False]", "vidgear/tests/streamer_tests/test_IO_rtf.py::test_invalid_params_rtf[dash]", "vidgear/tests/streamer_tests/test_streamgear_modes.py::test_ss_livestream[dash]", "vidgear/tests/network_tests/test_netgear.py::test_client_reliablity[options3]", "vidgear/tests/test_helper.py::test_is_valid_url[rtmp://live.twitch.tv/-True]", "vidgear/tests/streamer_tests/test_IO_rtf.py::test_fail_framedimension", "vidgear/tests/streamer_tests/test_init.py::test_outputs[output.m3u8]", "vidgear/tests/network_tests/asyncio_tests/test_netgear_async.py::test_netgear_async_bidirectionalmode[generator3-data3-options_server3-options_client3-True]", "vidgear/tests/network_tests/test_netgear.py::test_playback[172.31.11.15.77-5555]", "vidgear/tests/streamer_tests/test_init.py::test_custom_ffmpeg[wrong_path]", "vidgear/tests/videocapture_tests/test_camgear.py::test_threaded_queue_mode[/tmp/Downloads/Test_videos/BigBuckBunny_4sec.mp4-options1]", "vidgear/tests/streamer_tests/asyncio_tests/test_webgear_rtc.py::test_webgear_rtc_custom_middleware[None-False]", "vidgear/tests/test_helper.py::test_retrieve_best_interpolation[interpolations2]", "vidgear/tests/test_helper.py::test_is_valid_url[unknown://invalid.com/-False]", "vidgear/tests/network_tests/asyncio_tests/test_netgear_async.py::test_netgear_async_bidirectionalmode[generator1-444404444-options_server1-options_client1-False]", "vidgear/tests/test_helper.py::test_get_valid_ffmpeg_path[/tmp/Downloads/FFmpeg_static/ffmpeg--True]", "vidgear/tests/test_helper.py::test_ffmpeg_binaries_download[wrong_test_path-wrong_bit]", "vidgear/tests/test_helper.py::test_create_blank_frame[frame0-ok]", "vidgear/tests/streamer_tests/test_streamgear_modes.py::test_audio[stream_params3-hls]", "vidgear/tests/network_tests/test_netgear.py::test_bidirectional_mode[1-target_data1-options1]", "vidgear/tests/streamer_tests/test_IO_rtf.py::test_invalid_params_rtf[hls]", "vidgear/tests/streamer_tests/asyncio_tests/test_webgear_rtc.py::test_webgear_rtc_options[options1]", "vidgear/tests/streamer_tests/test_init.py::test_custom_ffmpeg[1234]", "vidgear/tests/test_helper.py::test_extract_time[-False]", "vidgear/tests/writer_tests/test_non_compression_mode.py::test_WriteGear_compression[-output_params0-False]", "vidgear/tests/streamer_tests/test_init.py::test_formats[hls]", "vidgear/tests/network_tests/asyncio_tests/test_netgear_async.py::test_netgear_async_addresses[None-5555]", "vidgear/tests/test_helper.py::test_get_supported_resolution[invalid-best]", "vidgear/tests/writer_tests/test_IO.py::test_paths[False-output.mp4]", "vidgear/tests/test_helper.py::test_dict2Args[dictionary0]", "vidgear/tests/videocapture_tests/test_pigear.py::test_pigear_playback", "vidgear/tests/network_tests/test_netgear.py::test_server_reliablity[options5]", "vidgear/tests/network_tests/test_netgear.py::test_patterns[2]", "vidgear/tests/videocapture_tests/test_screengear.py::test_screengear[None-jil-options4-COLOR_BGR2INVALID]", "vidgear/tests/test_helper.py::test_check_output", "vidgear/tests/test_helper.py::test_generate_auth_certificates[/tmp/temp_ffmpeg-False-True]", "vidgear/tests/streamer_tests/test_streamgear_modes.py::test_audio[stream_params4-hls]", "vidgear/tests/network_tests/test_netgear.py::test_playback[None-5555]", "vidgear/tests/network_tests/asyncio_tests/test_helper.py::test_create_blank_frame_asyncio[frame1-ok]", "vidgear/tests/streamer_tests/test_IO_ss.py::test_paths_ss[unknown://invalid.com/output.mpd-dash]", "vidgear/tests/network_tests/test_netgear.py::test_primary_mode[True]", "vidgear/tests/test_helper.py::test_get_supported_resolution[720p-720p]", "vidgear/tests/test_helper.py::test_validate_audio[/tmp/Downloads/Test_videos/BigBuckBunny_4sec_VO.mp4-False]", "vidgear/tests/streamer_tests/test_init.py::test_formats[1234]", "vidgear/tests/streamer_tests/test_IO_ss.py::test_paths_ss[rtmp://live.twitch.tv/output.m3u8-hls]", "vidgear/tests/videocapture_tests/test_screengear.py::test_screengear[1-mss-options1-COLOR_BGR2INVALID]"], "language": "python", "test_command": "source /saved/ENV || source /saved/*/ENV && pytest --no-header -rA --tb=no -p no:cacheprovider --continue-on-collection-errors", "test_output_parser": "python/parse_log_pytest_v3", "image_storage_uri": "vmvm-registry.fbinfra.net/repomate_image_activ_pytest/abhitronix_vidgear:f06585dfcfacc6ced95e77921e9dfa6e8cf162d6", "patch": "[\"diff --git a/docs/gears/netgear_async/usage.md b/docs/gears/netgear_async/usage.md\\nindex db66549..fb31159 100644\\n--- a/docs/gears/netgear_async/usage.md\\n+++ b/docs/gears/netgear_async/usage.md\\n@@ -392,7 +392,7 @@ import cv2, asyncio\\n # define and launch Client with `receive_mode=True`\\n client = NetGear_Async(receive_mode=True).launch()\\n # Define writer with output filename 'Output.mp4'\\n-writer = WriteGear(output_filename=\\\"Output.mp4\\\", logging=True)\\n+writer = WriteGear(output=\\\"Output.mp4\\\", logging=True)\\n \\n \\n # Create a async function where you want to show/manipulate your received frames\\n\",\"diff --git a/docs/gears/pigear/usage.md b/docs/gears/pigear/usage.md\\nindex 2eb67e9..69621a1 100644\\n--- a/docs/gears/pigear/usage.md\\n+++ b/docs/gears/pigear/usage.md\\n@@ -236,7 +236,7 @@ output_params = {\\\"-vcodec\\\": \\\"libx264\\\", \\\"-crf\\\": 0, \\\"-preset\\\": \\\"fast\\\"}\\n stream = PiGear(resolution=(640, 480), framerate=60, logging=True, **options).start()\\n \\n # Define writer with defined parameters and suitable output filename for e.g. `Output.mp4`\\n-writer = WriteGear(output_filename=\\\"Output.mp4\\\", logging=True, **output_params)\\n+writer = WriteGear(output=\\\"Output.mp4\\\", logging=True, **output_params)\\n \\n # loop over\\n while True:\\n\",\"diff --git a/docs/gears/screengear/usage.md b/docs/gears/screengear/usage.md\\nindex e52dc1a..9ce8d7c 100644\\n--- a/docs/gears/screengear/usage.md\\n+++ b/docs/gears/screengear/usage.md\\n@@ -299,7 +299,7 @@ output_params = {\\\"-vcodec\\\": \\\"libx264\\\", \\\"-crf\\\": 0, \\\"-preset\\\": \\\"fast\\\"}\\n stream = ScreenGear(monitor=1, logging=True, **options).start()\\n \\n # Define writer with defined parameters and suitable output filename for e.g. `Output.mp4`\\n-writer = WriteGear(output_filename=\\\"Output.mp4\\\", logging=True, **output_params)\\n+writer = WriteGear(output=\\\"Output.mp4\\\", logging=True, **output_params)\\n \\n # loop over\\n while True:\\n\",\"diff --git a/docs/gears/stabilizer/usage.md b/docs/gears/stabilizer/usage.md\\nindex 00e7b73..c11233a 100644\\n--- a/docs/gears/stabilizer/usage.md\\n+++ b/docs/gears/stabilizer/usage.md\\n@@ -222,7 +222,7 @@ stream = CamGear(source=\\\"unstabilized_stream.mp4\\\").start()\\n stab = Stabilizer()\\n \\n # Define writer with default parameters and suitable output filename for e.g. `Output.mp4`\\n-writer = WriteGear(output_filename=\\\"Output.mp4\\\")\\n+writer = WriteGear(output=\\\"Output.mp4\\\")\\n \\n # loop over\\n while True:\\n\",\"diff --git a/docs/gears/writegear/compression/advanced/cciw.md b/docs/gears/writegear/compression/advanced/cciw.md\\nindex 03b1445..9580e43 100644\\n--- a/docs/gears/writegear/compression/advanced/cciw.md\\n+++ b/docs/gears/writegear/compression/advanced/cciw.md\\n@@ -92,7 +92,7 @@ url_to_stream = (\\n )\\n \\n # Define writer with default parameters\\n-writer = WriteGear(output_filename=\\\"Output.mp4\\\", logging=True)\\n+writer = WriteGear(output=\\\"Output.mp4\\\", logging=True)\\n \\n # format command to convert stream audio as 'output_audio.aac' as list\\n ffmpeg_command_to_save_audio = [\\n@@ -145,7 +145,7 @@ output_params = {\\n }  # output framerate must match source framerate\\n \\n # Define writer with defined parameters and suitable output filename for e.g. `Output.mp4`\\n-writer = WriteGear(output_filename=\\\"Output.mp4\\\", **output_params)\\n+writer = WriteGear(output=\\\"Output.mp4\\\", **output_params)\\n \\n # loop over\\n while True:\\n\",\"diff --git a/docs/gears/writegear/compression/usage.md b/docs/gears/writegear/compression/usage.md\\nindex 74974cb..b263d06 100644\\n--- a/docs/gears/writegear/compression/usage.md\\n+++ b/docs/gears/writegear/compression/usage.md\\n@@ -57,7 +57,7 @@ import cv2\\n stream = CamGear(source=\\\"myvideo.avi\\\").start()\\n \\n # Define writer with default parameters and suitable output filename for e.g. `Output.mp4`\\n-writer = WriteGear(output_filename=\\\"Output.mp4\\\")\\n+writer = WriteGear(output=\\\"Output.mp4\\\")\\n \\n # loop over\\n while True:\\n@@ -110,7 +110,7 @@ import cv2\\n stream = VideoGear(source=0).start()\\n \\n # Define writer with default parameters and suitable output filename for e.g. `Output.mp4`\\n-writer = WriteGear(output_filename=\\\"Output.mp4\\\")\\n+writer = WriteGear(output=\\\"Output.mp4\\\")\\n \\n # loop over\\n while True:\\n@@ -160,7 +160,7 @@ WriteGear API provides [`-input_framerate`](../params/#supported-parameters)  at\\n     # set output constant framerate to (say 60 fps)\\n     output_params = {\\\"-input_framerate\\\":60, \\\"-r\\\":60}\\n     # assign that to WriteGear\\n-    writer = WriteGear(output_filename=\\\"out.mp4\\\", logging =True, **output_params)\\n+    writer = WriteGear(output=\\\"out.mp4\\\", logging =True, **output_params)\\n     ```\\n \\n     But make sure you ==MUST set value of `-r` and `-input_framerate` parameter less than or equal to your input source framerate.==\\n@@ -181,7 +181,7 @@ stream = CamGear(source=0).start()\\n output_params = {\\\"-input_framerate\\\": stream.framerate}\\n \\n # Define writer with defined parameters and suitable output filename for e.g. `Output.mp4`\\n-writer = WriteGear(output_filename=\\\"Output.mp4\\\", **output_params)\\n+writer = WriteGear(output=\\\"Output.mp4\\\", **output_params)\\n \\n # loop over\\n while True:\\n@@ -221,7 +221,7 @@ writer.close()\\n \\n ## Using Compression Mode for live streaming\\n \\n-In Compression Mode, WriteGear also allows URL strings _(as output)_ for live streaming realtime frames with its [`output_filename`](../params/#output_filename) parameter.  \\n+In Compression Mode, WriteGear also allows URL strings _(as output)_ for live streaming realtime frames with its [`output`](../params/#output) parameter.  \\n \\n In this example, we will stream live camera frames directly to Twitch :fontawesome-brands-twitch::\\n \\n@@ -257,7 +257,7 @@ TWITCH_KEY = \\\"live_XXXXXXXXXX~XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\\\"\\n \\n # Define writer with defined parameters and\\n writer = WriteGear(\\n-    output_filename=\\\"rtmp://live.twitch.tv/app/{}\\\".format(TWITCH_KEY),\\n+    output=\\\"rtmp://live.twitch.tv/app/{}\\\".format(TWITCH_KEY),\\n     logging=True,\\n     **output_params\\n )\\n@@ -341,7 +341,7 @@ output_params = {\\n }\\n \\n # Define writer with defined parameters and suitable output filename for e.g. `Output.mp4`\\n-writer = WriteGear(output_filename=\\\"Output.mp4\\\", **output_params)\\n+writer = WriteGear(output=\\\"Output.mp4\\\", **output_params)\\n \\n # loop over\\n while True:\\n@@ -394,7 +394,7 @@ output_params = {\\\"-vcodec\\\": \\\"libx264\\\", \\\"-crf\\\": 0, \\\"-preset\\\": \\\"fast\\\"}\\n stream = cv2.VideoCapture(0)\\n \\n # Define writer with defined parameters and suitable output filename for e.g. `Output.mp4`\\n-writer = WriteGear(output_filename=\\\"Output.mp4\\\", logging=True, **output_params)\\n+writer = WriteGear(output=\\\"Output.mp4\\\", logging=True, **output_params)\\n \\n # loop over\\n while True:\\n@@ -604,7 +604,7 @@ output_params = {\\n }\\n \\n # Define writer with defined parameters and suitable output filename for e.g. `Output.mp4\\n-writer = WriteGear(output_filename=\\\"Output.mp4\\\", logging=True, **output_params)\\n+writer = WriteGear(output=\\\"Output.mp4\\\", logging=True, **output_params)\\n \\n # loop over\\n while True:\\n\",\"diff --git a/docs/gears/writegear/non_compression/params.md b/docs/gears/writegear/non_compression/params.md\\nindex 5d17ade..b9ae65f 100644\\n--- a/docs/gears/writegear/non_compression/params.md\\n+++ b/docs/gears/writegear/non_compression/params.md\\n@@ -22,11 +22,11 @@ limitations under the License.\\n \\n &thinsp;\\n \\n-## **`output_filename`**\\n+## **`output`**\\n \\n This parameter sets the valid output Video filename/path for the output video.\\n \\n-!!! warning \\\"WriteGear API will throw `RuntimeError` if `output_filename` provided is empty or invalid.\\\"\\n+!!! warning \\\"WriteGear API will throw `RuntimeError` if `output` provided is empty or invalid.\\\"\\n \\n **Data-Type:** String\\n \\n@@ -41,18 +41,18 @@ Its valid input can be one of the following:\\n * **Path to directory**: Valid path of the directory to save the output video file. In this case, WriteGear API will automatically assign a unique filename (_with a default extension i.e.`.mp4`_) as follows:\\n \\n     ```python\\n-    writer = WriteGear(output_filename = '/home/foo/foo1', compression_mode=False) # Define writer \\n+    writer = WriteGear(output = '/home/foo/foo1', compression_mode=False) # Define writer \\n     ```\\n \\n * **Filename** _(with/without path)_: Valid filename(_with valid extension_) of the output video file. In case filename is provided without path, then current working directory will be used.\\n \\n     ```python\\n-    writer = WriteGear(output_filename = 'output.mp4', compression_mode=False) # Define writer \\n+    writer = WriteGear(output = 'output.mp4', compression_mode=False) # Define writer \\n     ```\\n \\n * **GStreamer Pipeline:** \\n    \\n-    WriteGear API also supports GStreamer Pipeline as input to its `output_filename` parameter in Non-Compression Mode, when [GStreamer Pipeline Mode](#b-exclusive-parameters) is enabled. It can be used as follows:\\n+    WriteGear API also supports GStreamer Pipeline as input to its `output` parameter in Non-Compression Mode, when [GStreamer Pipeline Mode](#b-exclusive-parameters) is enabled. It can be used as follows:\\n \\n     !!! warning \\\"Requirement for GStreamer Pipelining\\\"\\n \\n@@ -67,7 +67,7 @@ Its valid input can be one of the following:\\n     output_params = {\\\"-gst_pipeline_mode\\\": True}\\n     # Define writer\\n     writer = WriteGear(\\n-    output_filename=\\\"appsrc ! videoconvert ! avenc_mpeg4 bitrate=100000 ! mp4mux ! filesink location=foo.mp4\\\", compression_mode=False) \\n+    output=\\\"appsrc ! videoconvert ! avenc_mpeg4 bitrate=100000 ! mp4mux ! filesink location=foo.mp4\\\", compression_mode=False) \\n     ```\\n \\n &nbsp;\\n@@ -84,7 +84,7 @@ This parameter selects the WriteGear's Primary [Mode of Operation](../../introdu\\n **Usage:**\\n \\n ```python\\n-WriteGear(output_filename = 'output.mp4', compression_mode=False)\\n+WriteGear(output = 'output.mp4', compression_mode=False)\\n ```\\n \\n &nbsp;\\n@@ -131,7 +131,7 @@ WriteGear provides access to all available [**OpenCV's VideoWriter API**](https:\\n \\n In addition to OpenCV Parameters, WriteGear API also provides few exclusive attribute, which are as follows: \\n \\n-* **`-gst_pipeline_mode`**: a boolean attribute to enable **GStreamer Pipeline Mode** to supports GStreamer Pipeline as input to its `output_filename` parameter in Non-Compression Mode.\\n+* **`-gst_pipeline_mode`**: a boolean attribute to enable **GStreamer Pipeline Mode** to supports GStreamer Pipeline as input to its `output` parameter in Non-Compression Mode.\\n \\n     !!! note \\\"Enabling `-gst_pipeline_mode` will enforce `-backend` parameter value to `\\\"CAP_GSTREAMER\\\"`\\\"\\n \\n@@ -149,7 +149,7 @@ To assign desired parameters in Non-Compression Mode, you can format it as dicti\\n # format parameter as dictionary attribute\\n output_params = {\\\"-fps\\\":30} \\n # and then, assign it\\n-WriteGear(output_filename = 'output.mp4', **output_params)\\n+WriteGear(output = 'output.mp4', **output_params)\\n ```\\n \\n !!! example \\\"Its usage example can be found [here ➶](../usage/#using-non-compression-mode-with-videocapture-gears).\\\"\\n@@ -170,7 +170,7 @@ To select desired FOURCC codec in Non-Compression Mode, you can format it as dic\\n # format codec as dictionary attribute\\n output_params = {\\\"-fourcc\\\":\\\"MJPG\\\"} \\n # and then, assign it\\n-WriteGear(output_filename = 'output.mp4', **output_params)\\n+WriteGear(output = 'output.mp4', **output_params)\\n ```\\n \\n !!! example \\\"Its usage example can be found [here ➶](../usage/#using-non-compression-mode-with-videocapture-gears).\\\"\\n@@ -188,7 +188,7 @@ This parameter enables logging _(if `True`)_, essential for debugging.\\n **Usage:**\\n \\n ```python\\n-WriteGear(output_filename = 'output.mp4', logging=True)\\n+WriteGear(output = 'output.mp4', logging=True)\\n ```\\n \\n &nbsp;\\n\",\"diff --git a/docs/gears/writegear/non_compression/usage.md b/docs/gears/writegear/non_compression/usage.md\\nindex 8430c9a..71c4c5d 100644\\n--- a/docs/gears/writegear/non_compression/usage.md\\n+++ b/docs/gears/writegear/non_compression/usage.md\\n@@ -50,7 +50,7 @@ import cv2\\n stream = CamGear(source=\\\"myvideo.avi\\\").start()\\n \\n # Define writer with Non-compression mode and suitable output filename for e.g. `Output.mp4`\\n-writer = WriteGear(output_filename=\\\"Output.mp4\\\", compression_mode=False)\\n+writer = WriteGear(output=\\\"Output.mp4\\\", compression_mode=False)\\n \\n # loop over\\n while True:\\n@@ -111,7 +111,7 @@ stream = VideoGear(source=0, logging=True).start()\\n \\n # Define writer with defined parameters and suitable output filename for e.g. `Output.mp4`\\n writer = WriteGear(\\n-    output_filename=\\\"Output.mp4\\\", compression_mode=False, logging=True, **output_params\\n+    output=\\\"Output.mp4\\\", compression_mode=False, logging=True, **output_params\\n )\\n \\n \\n@@ -172,7 +172,7 @@ stream = cv2.VideoCapture(0)\\n \\n # Define writer with defined parameters and suitable output filename for e.g. `Output.mp4`\\n writer = WriteGear(\\n-    output_filename=\\\"Output.mp4\\\", compression_mode=False, logging=True, **output_params\\n+    output=\\\"Output.mp4\\\", compression_mode=False, logging=True, **output_params\\n )\\n \\n # loop over\\n@@ -217,7 +217,7 @@ writer.close()\\n \\n ## Using Non-Compression Mode with GStreamer Pipeline\\n \\n-  WriteGear API's Non-Compression Mode also supports GStreamer Pipeline as input to its `output_filename` parameter, when [GStreamer Pipeline Mode](../params/#b-exclusive-parameters) is enabled. This provides flexible way to write video frames to file or network stream with controlled framerate and bitrate. The complete usage example is as follows:\\n+  WriteGear API's Non-Compression Mode also supports GStreamer Pipeline as input to its `output` parameter, when [GStreamer Pipeline Mode](../params/#b-exclusive-parameters) is enabled. This provides flexible way to write video frames to file or network stream with controlled framerate and bitrate. The complete usage example is as follows:\\n \\n !!! warning \\\"Requirement for GStreamer Pipelining\\\"\\n     GStreamer Pipelining in WriteGear requires your OpenCV to be built with GStreamer support. Checkout [this FAQ](../../../../help/camgear_faqs/#how-to-compile-opencv-with-gstreamer-support) for compiling OpenCV with GStreamer support.\\n@@ -245,7 +245,7 @@ GSTPipeline = \\\"appsrc ! videoconvert ! avenc_mpeg4 bitrate=100000 ! mp4mux ! fil\\n \\n # Define writer with defined parameters and with our Gstreamer pipeline\\n writer = WriteGear(\\n-    output_filename=GSTPipeline, compression_mode=False, logging=True, **output_params\\n+    output=GSTPipeline, compression_mode=False, logging=True, **output_params\\n )\\n \\n # loop over\\n\",\"diff --git a/docs/help/screengear_ex.md b/docs/help/screengear_ex.md\\nindex b32eed4..ce0e1f2 100644\\n--- a/docs/help/screengear_ex.md\\n+++ b/docs/help/screengear_ex.md\\n@@ -59,7 +59,7 @@ client = NetGear(\\n )\\n \\n # Define writer with default parameters and suitable output filename for e.g. `Output.mp4`\\n-writer = WriteGear(output_filename=\\\"Output.mp4\\\")\\n+writer = WriteGear(output=\\\"Output.mp4\\\")\\n \\n # loop over\\n while True:\\n\",\"diff --git a/docs/help/stabilizer_ex.md b/docs/help/stabilizer_ex.md\\nindex 0704973..3e0e1aa 100644\\n--- a/docs/help/stabilizer_ex.md\\n+++ b/docs/help/stabilizer_ex.md\\n@@ -197,7 +197,7 @@ output_params = {\\n }\\n \\n # Define writer with defined parameters and suitable output filename for e.g. `Output.mp4\\n-writer = WriteGear(output_filename=\\\"Output.mp4\\\", logging=True, **output_params)\\n+writer = WriteGear(output=\\\"Output.mp4\\\", logging=True, **output_params)\\n \\n # loop over\\n while True:\\n@@ -274,7 +274,7 @@ output_params = {\\n \\n \\n # Define writer with defined parameters and suitable output filename for e.g. `Output.mp4\\n-writer = WriteGear(output_filename=\\\"Output.mp4\\\", logging=True, **output_params)\\n+writer = WriteGear(output=\\\"Output.mp4\\\", logging=True, **output_params)\\n \\n # loop over\\n while True:\\n\",\"diff --git a/docs/help/videogear_ex.md b/docs/help/videogear_ex.md\\nindex 1013b7d..e544cd2 100644\\n--- a/docs/help/videogear_ex.md\\n+++ b/docs/help/videogear_ex.md\\n@@ -256,7 +256,7 @@ output_params = {\\n }\\n \\n # Define writer with defined parameters and suitable output filename for e.g. `Output.mp4\\n-writer = WriteGear(output_filename=\\\"Output.mp4\\\", logging=True, **output_params)\\n+writer = WriteGear(output=\\\"Output.mp4\\\", logging=True, **output_params)\\n \\n # loop over\\n while True:\\n\",\"diff --git a/docs/help/writegear_ex.md b/docs/help/writegear_ex.md\\nindex 7d1a17b..63b73ab 100644\\n--- a/docs/help/writegear_ex.md\\n+++ b/docs/help/writegear_ex.md\\n@@ -53,7 +53,7 @@ output_params = {\\\"-f\\\": \\\"rtsp\\\", \\\"-rtsp_transport\\\": \\\"tcp\\\"}\\n # Define writer with defined parameters and RTSP address\\n # [WARNING] Change your RTSP address `rtsp://localhost:8554/mystream` with yours!\\n writer = WriteGear(\\n-    output_filename=\\\"rtsp://localhost:8554/mystream\\\", logging=True, **output_params\\n+    output=\\\"rtsp://localhost:8554/mystream\\\", logging=True, **output_params\\n )\\n \\n # loop over\\n@@ -119,7 +119,7 @@ In Compression Mode, you can also use WriteGear for Youtube-Livestreaming. The e\\n \\n     # Define writer with defined parameters\\n     writer = WriteGear(\\n-        output_filename=\\\"rtmp://a.rtmp.youtube.com/live2/{}\\\".format(YOUTUBE_STREAM_KEY),\\n+        output=\\\"rtmp://a.rtmp.youtube.com/live2/{}\\\".format(YOUTUBE_STREAM_KEY),\\n         logging=True,\\n         **output_params\\n     )\\n@@ -182,7 +182,7 @@ In Compression Mode, you can also use WriteGear for Youtube-Livestreaming. The e\\n \\n     # Define writer with defined parameters\\n     writer = WriteGear(\\n-        output_filename=\\\"rtmp://a.rtmp.youtube.com/live2/{}\\\".format(YOUTUBE_STREAM_KEY),\\n+        output=\\\"rtmp://a.rtmp.youtube.com/live2/{}\\\".format(YOUTUBE_STREAM_KEY),\\n         logging=True,\\n         **output_params\\n     )\\n@@ -284,7 +284,7 @@ output_params = {\\n }\\n \\n # Define writer with \\\"/dev/video0\\\" as source and user-defined parameters \\n-writer = WriteGear(output_filename=\\\"/dev/video0\\\", logging=True, **output_params)\\n+writer = WriteGear(output=\\\"/dev/video0\\\", logging=True, **output_params)\\n \\n # loop over\\n while True:\\n@@ -347,7 +347,7 @@ output_params = {\\n }\\n \\n # Define writer with defined parameters\\n-writer = WriteGear(output_filename=\\\"output%03d.mp4\\\", logging=True, **output_params)\\n+writer = WriteGear(output=\\\"output%03d.mp4\\\", logging=True, **output_params)\\n \\n # loop over\\n while True:\\n@@ -410,7 +410,7 @@ stream_params = {\\n }\\n \\n # Define writer with defined parameters\\n-writer = WriteGear(output_filename=\\\"Output.mp4\\\", logging=True, **stream_params)\\n+writer = WriteGear(output=\\\"Output.mp4\\\", logging=True, **stream_params)\\n \\n # loop over\\n while True:\\n@@ -465,7 +465,7 @@ In this example we are capturing video from desktop screen in a Timely Accurate \\n     from vidgear.gears import WriteGear\\n \\n     # Define writer with defined parameters and with some dummy name\\n-    writer = WriteGear(output_filename=\\\"Output.mp4\\\", logging=True)\\n+    writer = WriteGear(output=\\\"Output.mp4\\\", logging=True)\\n \\n     # format FFmpeg command to generate time accurate video\\n     ffmpeg_command = [\\n@@ -493,7 +493,7 @@ In this example we are capturing video from desktop screen in a Timely Accurate \\n     from vidgear.gears import WriteGear\\n \\n     # Define writer with defined parameters and with some dummy name\\n-    writer = WriteGear(output_filename=\\\"Output.mp4\\\", logging=True)\\n+    writer = WriteGear(output=\\\"Output.mp4\\\", logging=True)\\n \\n     # format FFmpeg command to generate time accurate video\\n     ffmpeg_command = [\\n@@ -521,7 +521,7 @@ In this example we are capturing video from desktop screen in a Timely Accurate \\n     from vidgear.gears import WriteGear\\n \\n     # Define writer with defined parameters and with some dummy name\\n-    writer = WriteGear(output_filename=\\\"Output.mp4\\\", logging=True)\\n+    writer = WriteGear(output=\\\"Output.mp4\\\", logging=True)\\n \\n     # format FFmpeg command to generate time accurate video\\n     ffmpeg_command = [\\n@@ -574,13 +574,13 @@ from vidgear.gears import WriteGear\\n \\n # custom publisher class\\n class image_subscriber:\\n-    def __init__(self, output_filename=\\\"Output.mp4\\\"):\\n+    def __init__(self, output=\\\"Output.mp4\\\"):\\n         # create CV bridge\\n         self.bridge = CvBridge()\\n         # define publisher topic\\n         self.image_pub = rospy.Subscriber(\\\"image_topic_sub\\\", Image, self.callback)\\n         # Define writer with default parameters\\n-        self.writer = WriteGear(output_filename=output_filename)\\n+        self.writer = WriteGear(output=output)\\n \\n     def callback(self, data):\\n         # convert received data to frame\\n@@ -609,7 +609,7 @@ class image_subscriber:\\n def main(args):\\n     # define publisher with suitable output filename\\n     # such as `Output.mp4` for saving output\\n-    ic = image_subscriber(output_filename=\\\"Output.mp4\\\")\\n+    ic = image_subscriber(output=\\\"Output.mp4\\\")\\n     # initiate ROS node on publisher\\n     rospy.init_node(\\\"image_subscriber\\\", anonymous=True)\\n     try:\\n\",\"diff --git a/docs/switch_from_cv.md b/docs/switch_from_cv.md\\nindex 2044d52..d39dba1 100644\\n--- a/docs/switch_from_cv.md\\n+++ b/docs/switch_from_cv.md\\n@@ -227,7 +227,7 @@ Let's extend previous bare-minimum python code and save those extracted frames t\\n     stream = CamGear(source=0).start() \\n \\n     # Define WriteGear Object with suitable output filename for e.g. `Output.mp4`\\n-    writer = WriteGear(output_filename = 'Output.mp4') \\n+    writer = WriteGear(output = 'Output.mp4') \\n \\n     # loop over\\n     while True:\\n@@ -274,7 +274,7 @@ Let's breakdown a few noteworthy difference in both syntaxes:\\n \\n | Task | OpenCV VideoWriter Class | VidGear's WriteGear API |\\n | :----------: | :--------------------: | :---------------------: |\\n-| Initiating | `#!python writer = cv2.VideoWriter('output.avi', cv2.VideoWriter_fourcc(*'XVID'), 20.0, (640, 480))` | `#!python writer = WriteGear(output_filename='Output.mp4')` |\\n+| Initiating | `#!python writer = cv2.VideoWriter('output.avi', cv2.VideoWriter_fourcc(*'XVID'), 20.0, (640, 480))` | `#!python writer = WriteGear(output='Output.mp4')` |\\n | Writing frames | `#!python writer.write(frame)` | `#!python writer.write(frame)` |\\n | Terminating | `#!python writer.release()` | `#!python writer.close()` |\\n \\n\",\"diff --git a/scripts/bash/install_opencv.sh b/scripts/bash/install_opencv.sh\\nindex c745d50..1fa4a19 100644\\n--- a/scripts/bash/install_opencv.sh\\n+++ b/scripts/bash/install_opencv.sh\\n@@ -33,7 +33,7 @@ echo \\\"Installing OpenCV Dependencies...\\\"\\n \\n sudo apt-get install -y -qq --allow-unauthenticated build-essential cmake pkg-config gfortran libavutil-dev ffmpeg\\n \\n-sudo apt-get install -y -qq --allow-unauthenticated yasm libv4l-dev libgtk-3-dev libtbb-dev libavresample-dev\\n+sudo apt-get install -y -qq --allow-unauthenticated yasm libv4l-dev libgtk-3-dev libtbb-dev libswresample-dev\\n \\n sudo apt-get install -y -qq --allow-unauthenticated libavcodec-dev libavformat-dev libswscale-dev libopenexr-dev\\n \\n@@ -41,9 +41,9 @@ sudo apt-get install -y -qq --allow-unauthenticated libxvidcore-dev libx264-dev \\n \\n sudo apt-get install -y -qq --allow-unauthenticated zlib1g-dev libjpeg-dev checkinstall libwebp-dev libpng-dev libopenblas-dev libopenblas-base\\n \\n-sudo apt-get install -y -qq --allow-unauthenticated libgstreamer1.0-0 gstreamer1.0-plugins-base gstreamer1.0-plugins-good gstreamer1.0-plugins-bad gstreamer1.0-plugins-ugly gstreamer1.0-libav gstreamer1.0-doc gstreamer1.0-tools gstreamer1.0-x gstreamer1.0-alsa gstreamer1.0-gl gstreamer1.0-gtk3 gstreamer1.0-qt5 gstreamer1.0-pulseaudio\\n+sudo apt-get install -y -qq --allow-unauthenticated libgstreamer1.0-0 libgstreamer-plugins-base1.0-dev libgstreamer1.0-dev\\n \\n-sudo apt-get install -y -qq --allow-unauthenticated libgstreamer-plugins-base1.0-dev libgstreamer1.0-dev\\n+sudo apt-get install -y -qq --allow-unauthenticated gstreamer1.0-plugins-base gstreamer1.0-plugins-good gstreamer1.0-plugins-bad gstreamer1.0-plugins-ugly gstreamer1.0-libav gstreamer1.0-doc gstreamer1.0-tools gstreamer1.0-x gstreamer1.0-alsa gstreamer1.0-gl gstreamer1.0-gtk3 gstreamer1.0-qt5 gstreamer1.0-pulseaudio\\n \\n echo \\\"Installing OpenCV Library\\\"\\n \\n@@ -61,7 +61,7 @@ while [ \\\"$RETRY\\\" -gt 0 ]; do\\n   #opencv version to install\\n   OPENCV_FILENAME=$(basename $LATEST_VERSION)\\n   if [ -f $(find . -name '$OPENCV_FILENAME') ]; then\\n-    echo \\\"Downloaded OpenCV binary successfully.\\\"\\n+    echo \\\"Downloaded OpenCV binary: $OPENCV_FILENAME successfully at $LATEST_VERSION\\\"\\n     break\\n   else\\n     echo \\\"Retrying!!!\\\"\\n\",\"diff --git a/vidgear/gears/helper.py b/vidgear/gears/helper.py\\nindex ecd2f96..948782a 100755\\n--- a/vidgear/gears/helper.py\\n+++ b/vidgear/gears/helper.py\\n@@ -489,6 +489,38 @@ def get_supported_demuxers(path):\\n     return [o.strip() for o in outputs]\\r\\n \\r\\n \\r\\n+def get_supported_pixfmts(path):\\r\\n+    \\\"\\\"\\\"\\r\\n+    ## get_supported_pixfmts\\r\\n+\\r\\n+    Find and returns all FFmpeg's supported pixel formats.\\r\\n+\\r\\n+    Parameters:\\r\\n+        path (string): absolute path of FFmpeg binaries\\r\\n+\\r\\n+    **Returns:** List of supported pixel formats.\\r\\n+    \\\"\\\"\\\"\\r\\n+    pxfmts = check_output([path, \\\"-hide_banner\\\", \\\"-pix_fmts\\\"])\\r\\n+    splitted = pxfmts.split(b\\\"\\\\n\\\")\\r\\n+    srtindex = [i for i, s in enumerate(splitted) if b\\\"-----\\\" in s]\\r\\n+    # extract video encoders\\r\\n+    supported_pxfmts = [\\r\\n+        x.decode(\\\"utf-8\\\").strip()\\r\\n+        for x in splitted[srtindex[0] + 1 :]\\r\\n+        if x.decode(\\\"utf-8\\\").strip()\\r\\n+    ]\\r\\n+    # compile regex\\r\\n+    finder = re.compile(r\\\"([A-Z]*[\\\\.]+[A-Z]*\\\\s[a-z0-9_-]*)(\\\\s+[0-4])(\\\\s+[0-9]+)\\\")\\r\\n+    # find all outputs\\r\\n+    outputs = finder.findall(\\\"\\\\n\\\".join(supported_pxfmts))\\r\\n+    # return output findings\\r\\n+    return [\\r\\n+        [s for s in o[0].split(\\\" \\\")][-1]\\r\\n+        for o in outputs\\r\\n+        if len(o) == 3\\r\\n+    ]\\r\\n+\\r\\n+\\r\\n def is_valid_url(path, url=None, logging=False):\\r\\n     \\\"\\\"\\\"\\r\\n     ## is_valid_url\\r\\n\",\"diff --git a/vidgear/gears/streamgear.py b/vidgear/gears/streamgear.py\\nindex f33aae7..2b0ffc1 100644\\n--- a/vidgear/gears/streamgear.py\\n+++ b/vidgear/gears/streamgear.py\\n@@ -301,10 +301,7 @@ def __init__(\\n                 self.__out_file = abs_path.replace(\\n                     \\\"\\\\\\\\\\\", \\\"/\\\"\\n                 )  # workaround for Windows platform only, others will not be affected\\n-            elif (\\n-                platform.system() == \\\"Linux\\\"\\n-                and pathlib.Path(output).is_char_device()\\n-            ):\\n+            elif platform.system() == \\\"Linux\\\" and pathlib.Path(output).is_char_device():\\n                 # check if linux video device path (such as `/dev/video0`)\\n                 self.__logging and logger.debug(\\n                     \\\"Path:`{}` is a valid Linux Video Device path.\\\".format(output)\\n@@ -1022,6 +1019,20 @@ def __Build_n_Execute(self, input_params, output_params):\\n                     )\\n                 )\\n \\n+    def __enter__(self):\\n+        \\\"\\\"\\\"\\n+        Handles entry with the `with` statement. See [PEP343 -- The 'with' statement'](https://peps.python.org/pep-0343/).\\n+\\n+        **Returns:** Returns a reference to the StreamGear Class\\n+        \\\"\\\"\\\"\\n+        return self\\n+\\n+    def __exit__(self, exc_type, exc_val, exc_tb):\\n+        \\\"\\\"\\\"\\n+        Handles exit with the `with` statement. See [PEP343 -- The 'with' statement'](https://peps.python.org/pep-0343/).\\n+        \\\"\\\"\\\"\\n+        self.terminate()\\n+\\n     def terminate(self):\\n         \\\"\\\"\\\"\\n         Safely terminates StreamGear.\\n\"]", "test_patch": "", "hints_text": ""}

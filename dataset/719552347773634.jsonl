{"instance_id": "719552347773634", "repo": "tobymao/sqlglot", "base_commit": "966dfbb990a12e14bab83b18f554c0f36ed8bae3", "problem_statement": "Incorrect join parse?:\\nHi, I'm new to using this library so let me know if I've missed something.\\r\\n\\r\\nI parsed the following query, an inner join of `a` and `b` cross joined with `c`\\r\\n\\r\\n```sql\\r\\nSELECT * FROM a JOIN b ON a.id = b.a_id, c\\r\\n```\\r\\n\\r\\nWhen parsed and printed back, I see that sqlglot returns the following, which reads differently than the original input. The inner join and cross join have swapped tables: `a` cross joined with the inner join of `b` and `c`.\\r\\n\\r\\n```sql\\r\\nSELECT * FROM a, c JOIN b ON a.id = b.a_id\\r\\n```\\r\\n\\r\\nThe parse tree is the following, where I seemingly can't tell that `a` is joined with `b`. I would think the `JOIN` node in the tree should be nested under the `FROM` so that the join order is preserved (but I'm not an expert)\\r\\n\\r\\n```\\r\\n(SELECT expressions: \\r\\n  (STAR ), from: \\r\\n  (FROM expressions: \\r\\n    (TABLE this: \\r\\n      (IDENTIFIER this: a, quoted: False)), \\r\\n    (TABLE this: \\r\\n      (IDENTIFIER this: c, quoted: False))), joins: \\r\\n  (JOIN this: \\r\\n    (TABLE this: \\r\\n      (IDENTIFIER this: b, quoted: False)), on: \\r\\n    (EQ this: \\r\\n      (COLUMN this: \\r\\n        (IDENTIFIER this: id, quoted: False), table: \\r\\n        (IDENTIFIER this: a, quoted: False)), expression: \\r\\n      (COLUMN this: \\r\\n        (IDENTIFIER this: a_id, quoted: False), table: \\r\\n        (IDENTIFIER this: b, quoted: False)))))\\r\\n```\\r\\n\\r\\n**Before you file an issue**\\r\\n- [x] Make sure you specify the \"read\" dialect eg. parse_one(sql, read=\"spark\")\\r\\n- [x] Check if the issue still exists on main \\r\\n\\r\\n**Fully reproducible code snippet**\\r\\n\\r\\nI added a similar query in the following example for comparison. I used the postgres dialect here (but the behavior is at least the same for sqlite).\\r\\n\\r\\n```python\\r\\nfrom sqlglot import parse_one\\r\\n\\r\\np1 = parse_one('SELECT * FROM a, b JOIN c ON b.id = c.b_id', read=\"postgres\")\\r\\np2 = parse_one('SELECT * FROM a JOIN b ON a.id = b.a_id, c', read=\"postgres\")\\r\\n\\r\\nprint(repr(p1))\\r\\nprint(repr(p2))\\r\\n\\r\\nprint(p1)\\r\\nprint(p2)\\r\\n```\\r\\n\\r\\nThe output is the following: \\r\\n\\r\\n<details>\\r\\n  <summary>Output (click to expand) </summary>\\r\\n\\r\\n```\\r\\n(SELECT expressions: \\r\\n  (STAR ), from: \\r\\n  (FROM expressions: \\r\\n    (TABLE this: \\r\\n      (IDENTIFIER this: a, quoted: False)), \\r\\n    (TABLE this: \\r\\n      (IDENTIFIER this: b, quoted: False))), joins: \\r\\n  (JOIN this: \\r\\n    (TABLE this: \\r\\n      (IDENTIFIER this: c, quoted: False)), on: \\r\\n    (EQ this: \\r\\n      (COLUMN this: \\r\\n        (IDENTIFIER this: id, quoted: False), table: \\r\\n        (IDENTIFIER this: b, quoted: False)), expression: \\r\\n      (COLUMN this: \\r\\n        (IDENTIFIER this: b_id, quoted: False), table: \\r\\n        (IDENTIFIER this: c, quoted: False)))))\\r\\n(SELECT expressions: \\r\\n  (STAR ), from: \\r\\n  (FROM expressions: \\r\\n    (TABLE this: \\r\\n      (IDENTIFIER this: a, quoted: False)), \\r\\n    (TABLE this: \\r\\n      (IDENTIFIER this: c, quoted: False))), joins: \\r\\n  (JOIN this: \\r\\n    (TABLE this: \\r\\n      (IDENTIFIER this: b, quoted: False)), on: \\r\\n    (EQ this: \\r\\n      (COLUMN this: \\r\\n        (IDENTIFIER this: id, quoted: False), table: \\r\\n        (IDENTIFIER this: a, quoted: False)), expression: \\r\\n      (COLUMN this: \\r\\n        (IDENTIFIER this: a_id, quoted: False), table: \\r\\n        (IDENTIFIER this: b, quoted: False)))))\\r\\nSELECT * FROM a, b JOIN c ON b.id = c.b_id\\r\\nSELECT * FROM a, c JOIN b ON a.id = b.a_id\\r\\n```\\r\\n</details>\\r\\n\\r\\n**Official Documentation**\\r\\n\\r\\n* Postgres docs: https://www.postgresql.org/docs/current/queries-table-expressions.html#QUERIES-FROM\\r\\n  * \"If more than one table reference is listed in the FROM clause, the tables are cross-joined\" (so `FROM a, b` is a cross join of `a` and `b`)\\r\\n  * \"Joins of all types can be chained together, or nested: either or both T1 and T2 can be joined tables. Parentheses can be used around JOIN clauses to control the join order. In the absence of parentheses, JOIN clauses nest left-to-right.\"\\r\\n* Sqlite docs: https://www.sqlite.org/lang_select.html\\r\\n  * Mainly, the flow chart shows that JOIN clauses nest under a FROM in the syntax tree", "FAIL_TO_PASS": ["dialects.test_tsql.TestTSQL.test_identifier_prefixes", "test_expressions.TestExpressions.test_alias_or_name", "test_parser.TestParser.test_select", "test_parser.TestParser.test_multi"], "PASS_TO_PASS": ["dataframe.unit.test_functions.TestFunctions.test_element_at", "dialects.test_snowflake.TestSnowflake.test_minus", "dialects.test_tsql.TestTSQL.test_types", "dialects.test_mysql.TestMySQL.test_hexadecimal_literal", "dataframe.unit.test_functions.TestFunctions.test_levenshtein", "dataframe.unit.test_functions.TestFunctions.test_locate", "dataframe.unit.test_functions.TestFunctions.test_lit", "dataframe.unit.test_functions.TestFunctions.test_stddev_samp", "dataframe.unit.test_functions.TestFunctions.test_variance", "dialects.test_dialect.TestDialect.test_substring", "dialects.test_teradata.TestTeradata.test_abbrev", "dialects.test_dialect.TestDialect.test_hash_comments", "dataframe.unit.test_functions.TestFunctions.test_stddev", "dialects.test_tsql.TestTSQL.test_format", "dataframe.unit.test_functions.TestFunctions.test_quarter", "dialects.test_dialect.TestDialect.test_alias", "dialects.test_presto.TestPresto.test_interval_plural_to_singular", "dataframe.unit.test_functions.TestFunctions.test_ltrim", "dialects.test_tsql.TestTSQL.test_jsonvalue", "dialects.test_postgres.TestPostgres.test_bool_or", "dataframe.unit.test_functions.TestFunctions.test_rpad", "test_diff.TestDiff.test_window_functions", "dialects.test_dialect.TestDialect.test_cast", "dataframe.unit.test_functions.TestFunctions.test_rint", "dataframe.unit.test_functions.TestFunctions.test_date_diff", "dataframe.unit.test_functions.TestFunctions.test_bitwise_not", "dataframe.unit.test_functions.TestFunctions.test_sha2", "dataframe.unit.test_column.TestDataframeColumn.test_eq", "test_expressions.TestExpressions.test_to_dot", "test_tokens.TestTokens.test_command", "dataframe.unit.test_functions.TestFunctions.test_rank", "dataframe.unit.test_dataframe.TestDataframe.test_cache", "test_generator.TestGenerator.test_fallback_function_sql", "dataframe.unit.test_functions.TestFunctions.test_array_except", "dataframe.unit.test_functions.TestFunctions.test_first", "test_expressions.TestExpressions.test_alias", "dataframe.unit.test_functions.TestFunctions.test_corr", "test_transpile.TestTranspile.test_comments", "dialects.test_clickhouse.TestClickhouse.test_clickhouse", "test_transforms.TestTransforms.test_eliminate_distinct_on", "test_expressions.TestExpressions.test_replace_placeholders", "dataframe.unit.test_functions.TestFunctions.test_to_timestamp", "dataframe.unit.test_functions.TestFunctions.test_weekofyear", "dialects.test_dialect.TestDialect.test_nullsafe_eq", "dataframe.unit.test_functions.TestFunctions.test_dayofweek", "dataframe.unit.test_dataframe_writer.TestDataFrameWriter.test_saveAsTable_cache", "dataframe.unit.test_functions.TestFunctions.test_transform", "test_tokens.TestTokens.test_token_line", "dataframe.unit.test_session.TestDataframeSession.test_typed_schema_basic", "dataframe.unit.test_functions.TestFunctions.test_date_format", "test_expressions.TestExpressions.test_is_star", "dataframe.unit.test_functions.TestFunctions.test_sqrt", "dataframe.unit.test_functions.TestFunctions.test_collect_set", "dataframe.unit.test_functions.TestFunctions.test_map_values", "test_serde.TestSerDe.test_type_annotations", "dataframe.unit.test_types.TestDataframeTypes.test_integer", "test_expressions.TestExpressions.test_arg_key", "test_expressions.TestExpressions.test_find", "dialects.test_teradata.TestTeradata.test_create", "dialects.test_tsql.TestTSQL.test_iif", "dataframe.unit.test_functions.TestFunctions.test_transform_keys", "dataframe.unit.test_functions.TestFunctions.test_radians", "dataframe.unit.test_functions.TestFunctions.test_last", "dataframe.unit.test_functions.TestFunctions.test_minute", "dialects.test_mysql.TestMySQL.test_canonical_functions", "test_schema.TestSchema.test_schema", "dataframe.unit.test_functions.TestFunctions.test_dayofyear", "dataframe.unit.test_functions.TestFunctions.test_date_add", "test_transforms.TestTransforms.test_eliminate_qualify", "dataframe.unit.test_functions.TestFunctions.test_window", "dataframe.unit.test_column.TestDataframeColumn.test_asc_nulls_last", "dialects.test_mysql.TestMySQL.test_set_variable", "dataframe.unit.test_dataframe.TestDataframe.test_hash_select_expression", "dialects.test_oracle.TestOracle.test_hints", "dataframe.unit.test_window.TestDataframeWindow.test_window_spec_rows_between", "dialects.test_snowflake.TestSnowflake.test_parse_like_any", "test_expressions.TestExpressions.test_replace_tables", "dataframe.unit.test_functions.TestFunctions.test_posexplode_outer", "dataframe.unit.test_functions.TestFunctions.test_rtrim", "dialects.test_starrocks.TestMySQL.test_identity", "dataframe.unit.test_functions.TestFunctions.test_to_date", "dataframe.unit.test_window.TestDataframeWindow.test_window_range_between", "dialects.test_mysql.TestMySQL.test_show_profile", "dataframe.unit.test_functions.TestFunctions.test_format_string", "dataframe.unit.test_functions.TestFunctions.test_upper", "dialects.test_mysql.TestMySQL.test_show_simple", "dialects.test_tsql.TestTSQL.test_len", "dialects.test_dialect.TestDialect.test_transactions", "test_expressions.TestExpressions.test_comment_alias", "test_parser.TestParser.test_var", "dataframe.unit.test_functions.TestFunctions.test_crc32", "dataframe.unit.test_functions.TestFunctions.test_md5", "dataframe.unit.test_column.TestDataframeColumn.test_desc_nulls_first", "dialects.test_mysql.TestMySQL.test_show_columns", "dataframe.unit.test_functions.TestFunctions.test_log10", "test_transforms.TestTransforms.test_unalias_group", "test_expressions.TestExpressions.test_transform_with_arguments", "dialects.test_tsql.TestTSQL.test_tsql", "test_parser.TestParser.test_pivot_columns", "dataframe.unit.test_functions.TestFunctions.test_asc_nulls_first", "test_diff.TestDiff.test_node_position_changed", "test_parser.TestParser.test_parameter", "test_expressions.TestExpressions.test_table", "dataframe.unit.test_types.TestDataframeTypes.test_map", "test_diff.TestDiff.test_pre_matchings", "dialects.test_tsql.TestTSQL.test_hints", "dataframe.unit.test_functions.TestFunctions.test_signum", "dataframe.unit.test_functions.TestFunctions.test_trunc", "test_schema.TestSchema.test_schema_get_column_type", "dataframe.unit.test_functions.TestFunctions.test_nth_value", "dataframe.unit.test_column.TestDataframeColumn.test_and", "dialects.test_presto.TestPresto.test_time", "test_transpile.TestTranspile.test_normalize_name", "dataframe.unit.test_functions.TestFunctions.test_abs", "dataframe.unit.test_functions.TestFunctions.test_expm1", "dataframe.unit.test_functions.TestFunctions.test_last_day", "dataframe.unit.test_functions.TestFunctions.test_monotonically_increasing_id", "dataframe.unit.test_functions.TestFunctions.test_sec", "dataframe.unit.test_types.TestDataframeTypes.test_string", "dialects.test_presto.TestPresto.test_unnest", "dataframe.unit.test_functions.TestFunctions.test_timestamp_seconds", "dataframe.unit.test_functions.TestFunctions.test_length", "dialects.test_tsql.TestTSQL.test_current_user", "dataframe.unit.test_functions.TestFunctions.test_array_repeat", "dataframe.unit.test_column.TestDataframeColumn.test_le", "dataframe.unit.test_column.TestDataframeColumn.test_rmul", "dataframe.unit.test_functions.TestFunctions.test_kurtosis", "dataframe.unit.test_functions.TestFunctions.test_forall", "test_schema.TestSchema.test_schema_add_table_with_and_without_mapping", "dialects.test_redshift.TestRedshift.test_redshift", "dialects.test_presto.TestPresto.test_cast", "dialects.test_tsql.TestTSQL.test_replicate", "test_transpile.TestTranspile.test_paren", "dataframe.unit.test_dataframe.TestDataframe.test_columns", "dialects.test_postgres.TestPostgres.test_ddl", "dataframe.unit.test_functions.TestFunctions.test_unix_timestamp", "dataframe.unit.test_functions.TestFunctions.test_hour", "dataframe.unit.test_functions.TestFunctions.test_octet_length", "dataframe.unit.test_column.TestDataframeColumn.test_rpow", "dialects.test_spark.TestSpark.test_hint", "dialects.test_presto.TestPresto.test_json", "test_transpile.TestTranspile.test_partial", "dataframe.unit.test_column.TestDataframeColumn.test_when_otherwise", "dataframe.unit.test_functions.TestFunctions.test_grouping_id", "dataframe.unit.test_functions.TestFunctions.test_schema_of_csv", "test_expressions.TestExpressions.test_data_type_builder", "test_expressions.TestExpressions.test_transform_node_removal", "dialects.test_dialect.TestDialect.test_get_or_raise", "dialects.test_teradata.TestTeradata.test_cast", "dataframe.unit.test_functions.TestFunctions.test_lag", "dialects.test_dialect.TestDialect.test_nullsafe_neq", "dialects.test_bigquery.TestBigQuery.test_merge", "dataframe.unit.test_functions.TestFunctions.test_acos", "dataframe.unit.test_functions.TestFunctions.test_randn", "dialects.test_tsql.TestTSQL.test_lateral_table_valued_function", "dataframe.unit.test_functions.TestFunctions.test_map_zip_with", "dataframe.unit.test_session.TestDataframeSession.test_cdf_one_row", "dialects.test_oracle.TestOracle.test_match_recognize", "dialects.test_presto.TestPresto.test_hex_unhex", "dataframe.unit.test_functions.TestFunctions.test_array_union", "dialects.test_mysql.TestMySQL.test_escape", "test_parser.TestParser.test_column", "dialects.test_mysql.TestMySQL.test_types", "dataframe.unit.test_functions.TestFunctions.test_add_months", "test_parser.TestParser.test_table", "dialects.test_duckdb.TestDuckDB.test_rename_table", "test_generator.TestGenerator.test_fallback_function_var_args_sql", "dataframe.unit.test_functions.TestFunctions.test_from_json", "test_expressions.TestExpressions.test_functions", "dataframe.unit.test_column.TestDataframeColumn.test_asc_nulls_first", "dataframe.unit.test_column.TestDataframeColumn.test_invert", "dialects.test_teradata.TestTeradata.test_translate", "dataframe.unit.test_column.TestDataframeColumn.test_like", "dataframe.unit.test_functions.TestFunctions.test_year", "test_expressions.TestExpressions.test_find_ancestor", "dialects.test_snowflake.TestSnowflake.test_table_literal", "dialects.test_redshift.TestRedshift.test_rename_table", "dataframe.unit.test_functions.TestFunctions.test_explode", "test_serde.TestSerDe.test_custom_expression", "test_parser.TestParser.test_comment_error_r", "dataframe.unit.test_functions.TestFunctions.test_lead", "test_transpile.TestTranspile.test_leading_comma", "test_lineage.TestLineage.test_lineage", "test_expressions.TestExpressions.test_sql", "test_build.TestBuild.test_build", "dialects.test_dialect.TestDialect.test_set_operators", "dataframe.unit.test_column.TestDataframeColumn.test_mul", "dialects.test_spark.TestSpark.test_iif", "dataframe.unit.test_types.TestDataframeTypes.test_short", "dataframe.unit.test_column.TestDataframeColumn.test_between", "dialects.test_clickhouse.TestClickhouse.test_ternary", "dialects.test_tsql.TestTSQL.test_openjson", "test_parser.TestParser.test_union_order", "dataframe.unit.test_functions.TestFunctions.test_transform_values", "dialects.test_redshift.TestRedshift.test_identity", "dialects.test_dialect.TestDialect.test_json", "dataframe.unit.test_types.TestDataframeTypes.test_struct_type", "dialects.test_mysql.TestMySQL.test_show_tables", "test_transpile.TestTranspile.test_with", "dataframe.unit.test_functions.TestFunctions.test_var_pop", "test_serde.TestSerDe.test_meta", "dialects.test_mysql.TestMySQL.test_show_index", "dialects.test_tsql.TestTSQL.test_eomonth", "dataframe.unit.test_functions.TestFunctions.test_format_number", "dataframe.unit.test_types.TestDataframeTypes.test_long", "dataframe.unit.test_functions.TestFunctions.test_base64", "dataframe.unit.test_functions.TestFunctions.test_array_remove", "dataframe.unit.test_functions.TestFunctions.test_log2", "dataframe.unit.test_functions.TestFunctions.test_array_max", "dataframe.unit.test_session.TestDataframeSession.test_sql_with_aggs", "test_expressions.TestExpressions.test_unit", "dialects.test_sqlite.TestSQLite.test_sqlite", "dataframe.unit.test_column.TestDataframeColumn.test_or", "dialects.test_presto.TestPresto.test_quotes", "dataframe.unit.test_functions.TestFunctions.test_csc", "dataframe.unit.test_functions.TestFunctions.test_sequence", "dialects.test_bigquery.TestBigQuery.test_rename_table", "dataframe.unit.test_dataframe.TestDataframe.test_persist_storagelevel", "dialects.test_dialect.TestDialect.test_decode", "dialects.test_snowflake.TestSnowflake.test_semi_structured_types", "dataframe.unit.test_functions.TestFunctions.test_regexp_extract", "dialects.test_presto.TestPresto.test_encode_decode", "dataframe.unit.test_column.TestDataframeColumn.test_is_null", "dataframe.unit.test_functions.TestFunctions.test_months_between", "dataframe.unit.test_session.TestDataframeSession.test_typed_schema_nested", "dataframe.unit.test_functions.TestFunctions.test_from_unixtime", "dataframe.unit.test_functions.TestFunctions.test_tanh", "dataframe.unit.test_functions.TestFunctions.test_get_json_object", "test_transpile.TestTranspile.test_space", "test_transforms.TestTransforms.test_remove_precision_parameterized_types", "dialects.test_mysql.TestMySQL.test_mysql", "test_parser.TestParser.test_transactions", "dataframe.unit.test_dataframe_writer.TestDataFrameWriter.test_saveAsTable_ignore", "dialects.test_snowflake.TestSnowflake.test_null_treatment", "dialects.test_oracle.TestOracle.test_oracle", "dataframe.unit.test_functions.TestFunctions.test_sin", "test_parser.TestParser.test_create_table_error", "dialects.test_mysql.TestMySQL.test_show_name", "dataframe.unit.test_column.TestDataframeColumn.test_is_not_null", "dialects.test_spark.TestSpark.test_bool_or", "dataframe.unit.test_functions.TestFunctions.test_decode", "dialects.test_drill.TestDrill.test_table_function", "dataframe.unit.test_functions.TestFunctions.test_covar_pop", "dialects.test_mysql.TestMySQL.test_identity", "dataframe.unit.test_dataframe_writer.TestDataFrameWriter.test_insertInto_full_path", "dataframe.unit.test_functions.TestFunctions.test_cosh", "dataframe.unit.test_functions.TestFunctions.test_array_sort", "dataframe.unit.test_column.TestDataframeColumn.test_radd", "dialects.test_hive.TestHive.test_bits", "test_parser.TestParser.test_type_literals", "dataframe.unit.test_functions.TestFunctions.test_asinh", "test_parser.TestParser.test_command", "dataframe.unit.test_functions.TestFunctions.test_flatten", "dialects.test_hive.TestHive.test_ddl", "dataframe.unit.test_functions.TestFunctions.test_create_map", "dataframe.unit.test_functions.TestFunctions.test_collect_list", "dialects.test_tsql.TestTSQL.test_datepart", "dataframe.unit.test_functions.TestFunctions.test_array_join", "dataframe.unit.test_session.TestDataframeSession.test_cdf_str_schema", "dataframe.unit.test_functions.TestFunctions.test_desc", "dialects.test_duckdb.TestDuckDB.test_time", "dataframe.unit.test_functions.TestFunctions.test_from_csv", "dialects.test_mysql.TestMySQL.test_ddl", "dataframe.unit.test_functions.TestFunctions.test_concat", "dataframe.unit.test_functions.TestFunctions.test_count", "dialects.test_snowflake.TestSnowflake.test_snowflake", "dataframe.unit.test_functions.TestFunctions.test_max_by", "dialects.test_presto.TestPresto.test_explode_to_unnest", "dialects.test_tableau.TestTableau.test_tableau", "dataframe.unit.test_functions.TestFunctions.test_bit_length", "dialects.test_tsql.TestTSQL.test_string", "test_lineage.TestLineage.test_lineage_source_with_star", "dialects.test_tsql.TestTSQL.test_udf", "dataframe.unit.test_column.TestDataframeColumn.test_desc_nulls_last", "dialects.test_tsql.TestTSQL.test_lateral_subquery", "dataframe.unit.test_dataframe_writer.TestDataFrameWriter.test_insertInto_cache", "dataframe.unit.test_dataframe_writer.TestDataFrameWriter.test_quotes", "dialects.test_tsql.TestTSQL.test_top", "dataframe.unit.test_functions.TestFunctions.test_array_position", "dataframe.unit.test_functions.TestFunctions.test_schema_of_json", "test_expressions.TestExpressions.test_union", "dataframe.unit.test_types.TestDataframeTypes.test_decimal", "dialects.test_presto.TestPresto.test_ddl", "dialects.test_dialect.TestDialect.test_array", "dataframe.unit.test_functions.TestFunctions.test_round", "dataframe.unit.test_column.TestDataframeColumn.test_desc", "test_transpile.TestTranspile.test_some", "dataframe.unit.test_functions.TestFunctions.test_reverse", "dataframe.unit.test_functions.TestFunctions.test_acosh", "test_schema.TestSchema.test_schema_db", "dataframe.unit.test_functions.TestFunctions.test_map_from_arrays", "test_transpile.TestTranspile.test_alter", "test_expressions.TestExpressions.test_to_interval", "dataframe.unit.test_functions.TestFunctions.test_percent_rank", "dataframe.unit.test_functions.TestFunctions.test_array_contains", "dataframe.unit.test_functions.TestFunctions.test_ntile", "dialects.test_duckdb.TestDuckDB.test_cast", "dataframe.unit.test_functions.TestFunctions.test_asin", "test_transpile.TestTranspile.test_not_range", "dialects.test_tsql.TestTSQL.test_add_date", "dataframe.unit.test_types.TestDataframeTypes.test_date", "dataframe.unit.test_functions.TestFunctions.test_second", "dataframe.unit.test_functions.TestFunctions.test_desc_nulls_last", "dataframe.unit.test_functions.TestFunctions.test_lower", "dialects.test_drill.TestDrill.test_string_literals", "test_expressions.TestExpressions.test_replace", "test_expressions.TestExpressions.test_table_name", "dataframe.unit.test_window.TestDataframeWindow.test_window_spec_range_between", "dataframe.unit.test_functions.TestFunctions.test_product", "dataframe.unit.test_functions.TestFunctions.test_sinh", "dialects.test_mysql.TestMySQL.test_show_like_or_where", "dataframe.unit.test_types.TestDataframeTypes.test_char", "test_transpile.TestTranspile.test_time", "dialects.test_tsql.TestTSQL.test_datefromparts", "dataframe.unit.test_functions.TestFunctions.test_date_trunc", "dataframe.unit.test_functions.TestFunctions.test_max", "dataframe.unit.test_column.TestDataframeColumn.test_startswith", "dataframe.unit.test_functions.TestFunctions.test_concat_ws", "test_expressions.TestExpressions.test_ctes", "dialects.test_databricks.TestDatabricks.test_databricks", "dataframe.unit.test_session.TestDataframeSession.test_cdf_dict_rows", "dataframe.unit.test_functions.TestFunctions.test_asc", "dataframe.unit.test_functions.TestFunctions.test_nanvl", "dataframe.unit.test_functions.TestFunctions.test_unhex", "dialects.test_hive.TestHive.test_time", "dataframe.unit.test_functions.TestFunctions.test_slice", "dialects.test_dialect.TestDialect.test_logarithm", "test_expressions.TestExpressions.test_function_building", "test_lineage.TestLineage.test_lineage_external_col", "dataframe.unit.test_column.TestDataframeColumn.test_lt", "dataframe.unit.test_functions.TestFunctions.test_array_zip", "dataframe.unit.test_functions.TestFunctions.test_shiftright", "test_transpile.TestTranspile.test_unary", "dataframe.unit.test_session.TestDataframeSession.test_cdf_row_mixed_primitives", "dataframe.unit.test_functions.TestFunctions.test_substring_index", "test_parser.TestParser.test_float", "dialects.test_postgres.TestPostgres.test_postgres", "dataframe.unit.test_functions.TestFunctions.test_approx_count_distinct", "dataframe.unit.test_functions.TestFunctions.test_size", "dataframe.unit.test_functions.TestFunctions.test_encode", "dialects.test_bigquery.TestBigQuery.test_user_defined_functions", "dialects.test_snowflake.TestSnowflake.test_ddl", "dataframe.unit.test_functions.TestFunctions.test_when", "dialects.test_duckdb.TestDuckDB.test_duckdb", "dialects.test_tsql.TestTSQL.test_isnull", "dialects.test_snowflake.TestSnowflake.test_match_recognize", "dialects.test_tsql.TestTSQL.test_date_diff", "dataframe.unit.test_dataframe.TestDataframe.test_persist_default", "dataframe.unit.test_functions.TestFunctions.test_min_by", "dataframe.unit.test_window.TestDataframeWindow.test_window_partition_by", "dialects.test_mysql.TestMySQL.test_introducers", "dataframe.unit.test_functions.TestFunctions.test_pow", "test_diff.TestDiff.test_join", "dialects.test_dialect.TestDialect.test_time", "dataframe.unit.test_functions.TestFunctions.test_coalesce", "test_expressions.TestExpressions.test_properties_from_dict", "test_parser.TestParser.test_expression", "dataframe.unit.test_functions.TestFunctions.test_shiftrightunsigned", "dataframe.unit.test_column.TestDataframeColumn.test_alias", "dataframe.unit.test_functions.TestFunctions.test_bround", "test_parser.TestParser.test_parse_into_errors", "dataframe.unit.test_column.TestDataframeColumn.test_gt", "dataframe.unit.test_functions.TestFunctions.test_log", "dataframe.unit.test_functions.TestFunctions.test_sum_distinct", "test_generator.TestGenerator.test_identify", "dataframe.unit.test_column.TestDataframeColumn.test_neq", "dataframe.unit.test_functions.TestFunctions.test_arrays_overlap", "dataframe.unit.test_column.TestDataframeColumn.test_cast", "dataframe.unit.test_window.TestDataframeWindow.test_window_rows_between", "dataframe.unit.test_functions.TestFunctions.test_instr", "dataframe.unit.test_window.TestDataframeWindow.test_window_spec_partition_by", "dialects.test_spark.TestSpark.test_to_date", "dataframe.unit.test_functions.TestFunctions.test_filter", "dataframe.unit.test_functions.TestFunctions.test_current_timestamp", "test_expressions.TestExpressions.test_text", "dataframe.unit.test_functions.TestFunctions.test_map_concat", "test_transpile.TestTranspile.test_asc", "dataframe.unit.test_window.TestDataframeWindow.test_window_spec_order_by", "dataframe.unit.test_functions.TestFunctions.test_json_tuple", "test_lineage.TestLineage.test_lineage_sql_with_cte", "test_diff.TestDiff.test_simple", "dataframe.unit.test_functions.TestFunctions.test_map_from_entries", "dataframe.unit.test_functions.TestFunctions.test_hex", "dataframe.unit.test_types.TestDataframeTypes.test_timestamp", "test_parser.TestParser.test_space", "dataframe.unit.test_types.TestDataframeTypes.test_binary", "dataframe.unit.test_column.TestDataframeColumn.test_rlike", "dataframe.unit.test_functions.TestFunctions.test_min", "test_parser.TestParser.test_parse_into", "dataframe.unit.test_functions.TestFunctions.test_exists", "dataframe.unit.test_functions.TestFunctions.test_asc_nulls_last", "dialects.test_databricks.TestDatabricks.test_json", "test_expressions.TestExpressions.test_to_column", "dataframe.unit.test_column.TestDataframeColumn.test_substring", "dataframe.unit.test_functions.TestFunctions.test_sha1", "dataframe.unit.test_functions.TestFunctions.test_conv", "dataframe.unit.test_dataframe_writer.TestDataFrameWriter.test_mode_override", "test_expressions.TestExpressions.test_identifier", "dialects.test_snowflake.TestSnowflake.test_flatten", "dataframe.unit.test_functions.TestFunctions.test_ascii", "test_expressions.TestExpressions.test_alias_column_names", "dialects.test_clickhouse.TestClickhouse.test_cte", "dialects.test_duckdb.TestDuckDB.test_bool_or", "dataframe.unit.test_functions.TestFunctions.test_lpad", "dialects.test_duckdb.TestDuckDB.test_sample", "test_expressions.TestExpressions.test_function_normalizer", "dataframe.unit.test_functions.TestFunctions.test_floor", "dataframe.unit.test_window.TestDataframeWindow.test_window_range_unbounded", "dataframe.unit.test_functions.TestFunctions.test_to_json", "dataframe.unit.test_functions.TestFunctions.test_unbase64", "dataframe.unit.test_functions.TestFunctions.test_to_csv", "test_transpile.TestTranspile.test_index_offset", "test_parser.TestParser.test_rename_table", "test_time.TestTime.test_format_time", "dataframe.unit.test_functions.TestFunctions.test_rand", "test_expressions.TestExpressions.test_values", "dialects.test_tsql.TestTSQL.test_convert_date_format", "test_parser.TestParser.test_pretty_config_override", "dialects.test_teradata.TestTeradata.test_update", "dialects.test_mysql.TestMySQL.test_show_processlist", "dataframe.unit.test_dataframe_writer.TestDataFrameWriter.test_saveAsTable_append", "dialects.test_drill.TestDrill.test_quotes", "dialects.test_bigquery.TestBigQuery.test_bigquery", "dataframe.unit.test_column.TestDataframeColumn.test_isin", "test_transpile.TestTranspile.test_pretty", "test_expressions.TestExpressions.test_walk", "test_expressions.TestExpressions.test_named_selects", "dialects.test_hive.TestHive.test_hive", "dataframe.unit.test_functions.TestFunctions.test_avg", "dialects.test_mysql.TestMySQL.test_match_against", "dialects.test_mysql.TestMySQL.test_date_format", "dialects.test_dialect.TestDialect.test_order_by", "dataframe.unit.test_functions.TestFunctions.test_dayofmonth", "test_transpile.TestTranspile.test_unsupported_level", "test_parser.TestParser.test_unary_plus", "dataframe.unit.test_functions.TestFunctions.test_row_number", "dataframe.unit.test_dataframe_writer.TestDataFrameWriter.test_insertInto_table", "dataframe.unit.test_session.TestDataframeSession.test_session_create_builder_patterns", "dialects.test_oracle.TestOracle.test_join_marker", "dataframe.unit.test_functions.TestFunctions.test_soundex", "dataframe.unit.test_functions.TestFunctions.test_tan", "dataframe.unit.test_types.TestDataframeTypes.test_float", "test_diff.TestDiff.test_identifier", "test_parser.TestParser.test_comment_error_n", "dialects.test_spark.TestSpark.test_current_user", "test_expressions.TestExpressions.test_eq", "dataframe.unit.test_column.TestDataframeColumn.test_ge", "dialects.test_mysql.TestMySQL.test_show_replica_status", "dialects.test_hive.TestHive.test_order_by", "dialects.test_starrocks.TestMySQL.test_time", "dataframe.unit.test_functions.TestFunctions.test_skewness", "dataframe.unit.test_functions.TestFunctions.test_make_date", "dataframe.unit.test_functions.TestFunctions.test_cbrt", "dataframe.unit.test_functions.TestFunctions.test_sum", "dataframe.unit.test_types.TestDataframeTypes.test_byte", "dialects.test_dialect.TestDialect.test_count_if", "dialects.test_dialect.TestDialect.test_merge", "dataframe.unit.test_functions.TestFunctions.test_isnan", "dataframe.unit.test_types.TestDataframeTypes.test_boolean", "dialects.test_presto.TestPresto.test_presto", "dataframe.unit.test_dataframe_writer.TestDataFrameWriter.test_insertInto_db_table", "dialects.test_redshift.TestRedshift.test_values", "dataframe.unit.test_functions.TestFunctions.test_desc_nulls_first", "dataframe.unit.test_session.TestDataframeSession.test_sql_insert", "dialects.test_mysql.TestMySQL.test_show_db_like_or_where_sql", "dataframe.unit.test_dataframe_writer.TestDataFrameWriter.test_saveAsTable_format", "dataframe.unit.test_functions.TestFunctions.test_isnull", "dataframe.unit.test_functions.TestFunctions.test_atan2", "dialects.test_snowflake.TestSnowflake.test_values", "test_parser.TestParser.test_comments", "dataframe.unit.test_session.TestDataframeSession.test_select_quoted", "test_transpile.TestTranspile.test_identify_lambda", "dataframe.unit.test_functions.TestFunctions.test_greatest", "dataframe.unit.test_functions.TestFunctions.test_struct", "dataframe.unit.test_types.TestDataframeTypes.test_varchar", "dialects.test_tsql.TestTSQL.test_datename", "dialects.test_hive.TestHive.test_lateral_view", "dataframe.unit.test_dataframe_writer.TestDataFrameWriter.test_insertInto_overwrite", "dataframe.unit.test_dataframe_writer.TestDataFrameWriter.test_mode_standalone", "dataframe.unit.test_functions.TestFunctions.test_shiftleft", "test_expressions.TestExpressions.test_to_table", "dialects.test_hive.TestHive.test_escapes", "dataframe.unit.test_functions.TestFunctions.test_cot", "dialects.test_tsql.TestTSQL.test_charindex", "dataframe.unit.test_column.TestDataframeColumn.test_div", "dataframe.unit.test_dataframe_writer.TestDataFrameWriter.test_saveAsTable_error", "dialects.test_mysql.TestMySQL.test_mysql_time", "dataframe.unit.test_functions.TestFunctions.test_hypot", "dataframe.unit.test_functions.TestFunctions.test_raise_error", "dialects.test_snowflake.TestSnowflake.test_describe_table", "dataframe.unit.test_column.TestDataframeColumn.test_add", "dataframe.unit.test_functions.TestFunctions.test_overlay", "dataframe.unit.test_dataframe_writer.TestDataFrameWriter.test_insertInto_byName", "dialects.test_drill.TestDrill.test_drill", "dialects.test_dialect.TestDialect.test_lateral_subquery", "test_expressions.TestExpressions.test_hash", "test_expressions.TestExpressions.test_column", "dialects.test_spark.TestSpark.test_spark", "test_expressions.TestExpressions.test_transform_simple", "dialects.test_sqlite.TestSQLite.test_window_null_treatment", "dataframe.unit.test_functions.TestFunctions.test_percentile_approx", "dataframe.unit.test_functions.TestFunctions.test_degrees", "dialects.test_hive.TestHive.test_regex", "test_parser.TestParser.test_set_expression", "dataframe.unit.test_session.TestDataframeSession.test_sql_create", "dataframe.unit.test_column.TestDataframeColumn.test_over", "dataframe.unit.test_functions.TestFunctions.test_to_utc_timestamp", "test_expressions.TestExpressions.test_set_metadata", "dataframe.unit.test_functions.TestFunctions.test_exp", "dialects.test_hive.TestHive.test_data_type", "dataframe.unit.test_functions.TestFunctions.test_map_keys", "dialects.test_sqlite.TestSQLite.test_hexadecimal_literal", "dataframe.unit.test_types.TestDataframeTypes.test_double", "dialects.test_clickhouse.TestClickhouse.test_ddl", "dialects.test_snowflake.TestSnowflake.test_user_defined_functions", "dataframe.unit.test_column.TestDataframeColumn.test_rdiv", "dataframe.unit.test_column.TestDataframeColumn.test_sub", "dialects.test_mysql.TestMySQL.test_show_events", "test_expressions.TestExpressions.test_transform_multiple_children", "dialects.test_presto.TestPresto.test_match_recognize", "test_transpile.TestTranspile.test_types", "dataframe.unit.test_functions.TestFunctions.test_stddev_pop", "test_diff.TestDiff.test_cte", "dataframe.unit.test_functions.TestFunctions.test_cume_dist", "dialects.test_redshift.TestRedshift.test_no_schema_binding", "dataframe.unit.test_functions.TestFunctions.test_sentences", "dataframe.unit.test_functions.TestFunctions.test_array_min", "dataframe.unit.test_functions.TestFunctions.test_translate", "dataframe.unit.test_functions.TestFunctions.test_count_distinct", "dialects.test_presto.TestPresto.test_regex", "dialects.test_snowflake.TestSnowflake.test_sample", "dataframe.unit.test_window.TestDataframeWindow.test_window_order_by", "dataframe.unit.test_functions.TestFunctions.test_explode_outer", "dialects.test_mysql.TestMySQL.test_show_errors", "test_transpile.TestTranspile.test_extract", "dataframe.unit.test_functions.TestFunctions.test_hash", "dialects.test_dialect.TestDialect.test_cross_join", "test_expressions.TestExpressions.test_transform_no_infinite_recursion", "dialects.test_mysql.TestMySQL.test_bits_literal", "test_schema.TestSchema.test_schema_catalog", "dialects.test_oracle.TestOracle.test_xml_table", "test_expressions.TestExpressions.test_rename_table", "dataframe.unit.test_functions.TestFunctions.test_pos_explode", "test_parser.TestParser.test_identify", "test_transpile.TestTranspile.test_identity", "dialects.test_tsql.TestTSQL.test_system_time", "dialects.test_bigquery.TestBigQuery.test_remove_precision_parameterized_types", "dataframe.unit.test_functions.TestFunctions.test_xxhash64", "dataframe.unit.test_functions.TestFunctions.test_substring", "dialects.test_hive.TestHive.test_cast", "dialects.test_dialect.TestDialect.test_enum", "test_helper.TestHelper.test_tsort", "dataframe.unit.test_functions.TestFunctions.test_map_entries", "test_expressions.TestExpressions.test_selects", "dialects.test_mysql.TestMySQL.test_show_engine", "dataframe.unit.test_column.TestDataframeColumn.test_rsub", "test_schema.TestSchema.test_schema_normalization", "dataframe.unit.test_column.TestDataframeColumn.test_endswith", "dialects.test_dialect.TestDialect.test_limit", "test_expressions.TestExpressions.test_root", "test_parser.TestParser.test_parse_into_error", "dataframe.unit.test_column.TestDataframeColumn.test_ilike", "dataframe.unit.test_functions.TestFunctions.test_dense_rank", "dialects.test_teradata.TestTeradata.test_insert", "dataframe.unit.test_functions.TestFunctions.test_covar_samp", "dataframe.unit.test_session.TestDataframeSession.test_cdf_multiple_rows", "dataframe.unit.test_functions.TestFunctions.test_bin", "dataframe.unit.test_dataframe_writer.TestDataFrameWriter.test_saveAsTable_overwrite", "dialects.test_mysql.TestMySQL.test_show_grants", "test_transpile.TestTranspile.test_alias", "dataframe.unit.test_functions.TestFunctions.test_log1p", "test_transpile.TestTranspile.test_if", "dataframe.unit.test_column.TestDataframeColumn.test_pow", "test_expressions.TestExpressions.test_depth", "dataframe.unit.test_functions.TestFunctions.test_array_intersect", "dialects.test_redshift.TestRedshift.test_varchar_max", "dataframe.unit.test_column.TestDataframeColumn.test_mod", "dataframe.unit.test_types.TestDataframeTypes.test_array", "dialects.test_sqlite.TestSQLite.test_ddl", "test_expressions.TestExpressions.test_convert", "test_parser.TestParser.test_missing_by", "dialects.test_snowflake.TestSnowflake.test_timestamps", "dataframe.unit.test_functions.TestFunctions.test_repeat", "dataframe.unit.test_functions.TestFunctions.test_initcap", "dataframe.unit.test_functions.TestFunctions.test_atanh", "dialects.test_duckdb.TestDuckDB.test_array", "test_parser.TestParser.test_lambda_struct", "test_serde.TestSerDe.test_serde", "dataframe.unit.test_functions.TestFunctions.test_mean", "dataframe.unit.test_functions.TestFunctions.test_sort_array", "dataframe.unit.test_functions.TestFunctions.test_invoke_anonymous", "dataframe.unit.test_functions.TestFunctions.test_session_window", "dataframe.unit.test_functions.TestFunctions.test_expr", "test_lineage.TestLineage.test_lineage_source_with_cte", "dialects.test_clickhouse.TestClickhouse.test_signed_and_unsigned_types", "dataframe.unit.test_functions.TestFunctions.test_var_samp", "dialects.test_snowflake.TestSnowflake.test_stored_procedures", "dialects.test_bigquery.TestBigQuery.test_group_concat", "dialects.test_mysql.TestMySQL.test_string_literals", "dataframe.unit.test_functions.TestFunctions.test_regexp_replace", "dialects.test_databricks.TestDatabricks.test_datediff", "dataframe.unit.test_functions.TestFunctions.test_current_date", "dataframe.unit.test_functions.TestFunctions.test_factorial", "dataframe.unit.test_functions.TestFunctions.test_input_file_name", "dialects.test_starrocks.TestMySQL.test_regex", "test_expressions.TestExpressions.test_pop", "dataframe.unit.test_functions.TestFunctions.test_trim", "dataframe.unit.test_functions.TestFunctions.test_ceil", "dataframe.unit.test_functions.TestFunctions.test_least", "dialects.test_dialect.TestDialect.test_if_null", "test_lineage.TestLineage.test_lineage_values", "dataframe.unit.test_types.TestDataframeTypes.test_struct_field", "test_expressions.TestExpressions.test_find_all", "test_tokens.TestTokens.test_error_msg", "dataframe.unit.test_functions.TestFunctions.test_aggregate", "test_tokens.TestTokens.test_jinja", "test_transpile.TestTranspile.test_pretty_line_breaks", "dataframe.unit.test_types.TestDataframeTypes.test_timestamp_ntz", "dataframe.unit.test_functions.TestFunctions.test_assert_true", "dataframe.unit.test_functions.TestFunctions.test_col", "dataframe.unit.test_functions.TestFunctions.test_zip_with", "dataframe.unit.test_column.TestDataframeColumn.test_asc", "dialects.test_spark.TestSpark.test_ddl", "dialects.test_mysql.TestMySQL.test_convert", "dataframe.unit.test_functions.TestFunctions.test_atan", "dataframe.unit.test_functions.TestFunctions.test_cos", "dialects.test_databricks.TestDatabricks.test_without_as", "test_tokens.TestTokens.test_comment_attachment", "dataframe.unit.test_functions.TestFunctions.test_date_sub", "dataframe.unit.test_session.TestDataframeSession.test_cdf_no_schema", "dataframe.unit.test_functions.TestFunctions.test_map_filter", "test_parser.TestParser.test_parse_errors", "dialects.test_dialect.TestDialect.test_operators", "dataframe.unit.test_functions.TestFunctions.test_split", "dialects.test_drill.TestDrill.test_validate_pivot", "dialects.test_teradata.TestTeradata.test_mod", "dialects.test_redshift.TestRedshift.test_create_table_like", "dataframe.unit.test_functions.TestFunctions.test_month", "dataframe.unit.test_session.TestDataframeSession.test_sql_select_only", "dataframe.unit.test_functions.TestFunctions.test_array", "dataframe.unit.test_functions.TestFunctions.test_next_day", "dialects.test_sqlite.TestSQLite.test_longvarchar_dtype", "test_transpile.TestTranspile.test_error_level", "dialects.test_hive.TestHive.test_quotes", "dialects.test_sqlite.TestSQLite.test_datediff", "dataframe.unit.test_window.TestDataframeWindow.test_window_rows_unbounded", "test_parser.TestParser.test_parse_empty", "dataframe.unit.test_functions.TestFunctions.test_from_utc_timestamp", "dataframe.unit.test_functions.TestFunctions.test_array_distinct", "dialects.test_teradata.TestTeradata.test_datatype", "dialects.test_databricks.TestDatabricks.test_add_date"], "language": "python", "test_command": "source /saved/ENV || source /saved/*/ENV && /opt/hostedtoolcache/Python/3.7.17/x64/bin/python3 /app/repo/unittest_loader_no_traceback.py ./tests ;", "test_output_parser": "python/parse_log_unittest", "image_storage_uri": "vmvm-registry.fbinfra.net/repomate_image_activ_python_unittest/tobymao_sqlglot:966dfbb990a12e14bab83b18f554c0f36ed8bae3", "patch": "[\"diff --git a/sqlglot/dataframe/sql/session.py b/sqlglot/dataframe/sql/session.py\\nindex af589b0ed..79535388b 100644\\n--- a/sqlglot/dataframe/sql/session.py\\n+++ b/sqlglot/dataframe/sql/session.py\\n@@ -87,15 +87,13 @@ def createDataFrame(\\n         select_kwargs = {\\n             \\\"expressions\\\": sel_columns,\\n             \\\"from\\\": exp.From(\\n-                expressions=[\\n-                    exp.Values(\\n-                        expressions=data_expressions,\\n-                        alias=exp.TableAlias(\\n-                            this=exp.to_identifier(self._auto_incrementing_name),\\n-                            columns=[exp.to_identifier(col_name) for col_name in column_mapping],\\n-                        ),\\n+                this=exp.Values(\\n+                    expressions=data_expressions,\\n+                    alias=exp.TableAlias(\\n+                        this=exp.to_identifier(self._auto_incrementing_name),\\n+                        columns=[exp.to_identifier(col_name) for col_name in column_mapping],\\n                     ),\\n-                ],\\n+                ),\\n             ),\\n         }\\n \\n\",\"diff --git a/sqlglot/dataframe/sql/util.py b/sqlglot/dataframe/sql/util.py\\nindex 575d18a49..4b9fbb187 100644\\n--- a/sqlglot/dataframe/sql/util.py\\n+++ b/sqlglot/dataframe/sql/util.py\\n@@ -27,6 +27,6 @@ def get_tables_from_expression_with_join(expression: exp.Select) -> t.List[exp.T\\n     if not expression.args.get(\\\"joins\\\"):\\n         return []\\n \\n-    left_table = expression.args[\\\"from\\\"].args[\\\"expressions\\\"][0]\\n+    left_table = expression.args[\\\"from\\\"].this\\n     other_tables = [join.this for join in expression.args[\\\"joins\\\"]]\\n     return [left_table] + other_tables\\n\",\"diff --git a/sqlglot/dialects/bigquery.py b/sqlglot/dialects/bigquery.py\\nindex 229cce8ca..770cd1d71 100644\\n--- a/sqlglot/dialects/bigquery.py\\n+++ b/sqlglot/dialects/bigquery.py\\n@@ -96,19 +96,12 @@ def _unqualify_unnest(expression: exp.Expression) -> exp.Expression:\\n     These are added by the optimizer's qualify_column step.\\n     \\\"\\\"\\\"\\n     if isinstance(expression, exp.Select):\\n-        unnests = {\\n-            unnest.alias\\n-            for unnest in expression.args.get(\\\"from\\\", exp.From(expressions=[])).expressions\\n-            if isinstance(unnest, exp.Unnest) and unnest.alias\\n-        }\\n-\\n-        if unnests:\\n-            expression = expression.copy()\\n-\\n-            for select in expression.expressions:\\n-                for column in select.find_all(exp.Column):\\n-                    if column.table in unnests:\\n-                        column.set(\\\"table\\\", None)\\n+        for unnest in expression.find_all(exp.Unnest):\\n+            if isinstance(unnest.parent, (exp.From, exp.Join)) and unnest.alias:\\n+                for select in expression.selects:\\n+                    for column in select.find_all(exp.Column):\\n+                        if column.table == unnest.alias:\\n+                            column.set(\\\"table\\\", None)\\n \\n     return expression\\n \\n\",\"diff --git a/sqlglot/dialects/teradata.py b/sqlglot/dialects/teradata.py\\nindex a79eaeb11..3bed58bbe 100644\\n--- a/sqlglot/dialects/teradata.py\\n+++ b/sqlglot/dialects/teradata.py\\n@@ -106,7 +106,7 @@ def _parse_update(self) -> exp.Expression:\\n                 exp.Update,\\n                 **{  # type: ignore\\n                     \\\"this\\\": self._parse_table(alias_tokens=self.UPDATE_ALIAS_TOKENS),\\n-                    \\\"from\\\": self._parse_from(),\\n+                    \\\"from\\\": self._parse_from(modifiers=True),\\n                     \\\"expressions\\\": self._match(TokenType.SET)\\n                     and self._parse_csv(self._parse_equality),\\n                     \\\"where\\\": self._parse_where(),\\n\",\"diff --git a/sqlglot/expressions.py b/sqlglot/expressions.py\\nindex 8388102e7..953c0fd22 100644\\n--- a/sqlglot/expressions.py\\n+++ b/sqlglot/expressions.py\\n@@ -1404,7 +1404,13 @@ class Into(Expression):\\n \\n \\n class From(Expression):\\n-    arg_types = {\\\"expressions\\\": True}\\n+    @property\\n+    def name(self) -> str:\\n+        return self.this.name\\n+\\n+    @property\\n+    def alias_or_name(self) -> str:\\n+        return self.this.alias_or_name\\n \\n \\n class Having(Expression):\\n@@ -2318,7 +2324,9 @@ class Select(Subqueryable):\\n         **QUERY_MODIFIERS,\\n     }\\n \\n-    def from_(self, *expressions, append=True, dialect=None, copy=True, **opts) -> Select:\\n+    def from_(\\n+        self, expression: ExpOrStr, dialect: DialectType = None, copy: bool = True, **opts\\n+    ) -> Select:\\n         \\\"\\\"\\\"\\n         Set the FROM expression.\\n \\n@@ -2327,27 +2335,24 @@ def from_(self, *expressions, append=True, dialect=None, copy=True, **opts) -> S\\n             'SELECT x FROM tbl'\\n \\n         Args:\\n-            *expressions (str | Expression): the SQL code strings to parse.\\n+            expression : the SQL code strings to parse.\\n                 If a `From` instance is passed, this is used as-is.\\n                 If another `Expression` instance is passed, it will be wrapped in a `From`.\\n-            append (bool): if `True`, add to any existing expressions.\\n-                Otherwise, this flattens all the `From` expression into a single expression.\\n-            dialect (str): the dialect used to parse the input expression.\\n-            copy (bool): if `False`, modify this expression instance in-place.\\n-            opts (kwargs): other options to use to parse the input expressions.\\n+            dialect: the dialect used to parse the input expression.\\n+            copy: if `False`, modify this expression instance in-place.\\n+            opts: other options to use to parse the input expressions.\\n \\n         Returns:\\n             Select: the modified expression.\\n         \\\"\\\"\\\"\\n-        return _apply_child_list_builder(\\n-            *expressions,\\n+        return _apply_builder(\\n+            expression=expression,\\n             instance=self,\\n             arg=\\\"from\\\",\\n-            append=append,\\n-            copy=copy,\\n-            prefix=\\\"FROM\\\",\\n             into=From,\\n+            prefix=\\\"FROM\\\",\\n             dialect=dialect,\\n+            copy=copy,\\n             **opts,\\n         )\\n \\n@@ -4624,7 +4629,7 @@ def select(*expressions: ExpOrStr, dialect: DialectType = None, **opts) -> Selec\\n     return Select().select(*expressions, dialect=dialect, **opts)\\n \\n \\n-def from_(*expressions, dialect=None, **opts) -> Select:\\n+def from_(expression: ExpOrStr, dialect: DialectType = None, **opts) -> Select:\\n     \\\"\\\"\\\"\\n     Initializes a syntax tree from a FROM expression.\\n \\n@@ -4633,9 +4638,9 @@ def from_(*expressions, dialect=None, **opts) -> Select:\\n         'SELECT col1, col2 FROM tbl'\\n \\n     Args:\\n-        *expressions (str | Expression): the SQL code string to parse as the FROM expressions of a\\n+        *expression: the SQL code string to parse as the FROM expressions of a\\n             SELECT statement. If an Expression instance is passed, this is used as-is.\\n-        dialect (str): the dialect used to parse the input expression (in the case that the\\n+        dialect: the dialect used to parse the input expression (in the case that the\\n             input expression is a SQL string).\\n         **opts: other options to use to parse the input expressions (again, in the case\\n             that the input expression is a SQL string).\\n@@ -4643,7 +4648,7 @@ def from_(*expressions, dialect=None, **opts) -> Select:\\n     Returns:\\n         Select: the syntax tree for the SELECT statement.\\n     \\\"\\\"\\\"\\n-    return Select().from_(*expressions, dialect=dialect, **opts)\\n+    return Select().from_(expression, dialect=dialect, **opts)\\n \\n \\n def update(\\n\",\"diff --git a/sqlglot/generator.py b/sqlglot/generator.py\\nindex 6d62efca3..3001a5486 100644\\n--- a/sqlglot/generator.py\\n+++ b/sqlglot/generator.py\\n@@ -1238,8 +1238,7 @@ def into_sql(self, expression: exp.Into) -> str:\\n         return f\\\"{self.seg('INTO')}{temporary or unlogged} {self.sql(expression, 'this')}\\\"\\n \\n     def from_sql(self, expression: exp.From) -> str:\\n-        expressions = self.expressions(expression, flat=True)\\n-        return f\\\"{self.seg('FROM')} {expressions}\\\"\\n+        return f\\\"{self.seg('FROM')} {self.sql(expression, 'this')}\\\"\\n \\n     def group_sql(self, expression: exp.Group) -> str:\\n         group_by = self.op_expressions(\\\"GROUP BY\\\", expression)\\n@@ -1280,19 +1279,16 @@ def having_sql(self, expression: exp.Having) -> str:\\n         return f\\\"{self.seg('HAVING')}{self.sep()}{this}\\\"\\n \\n     def join_sql(self, expression: exp.Join) -> str:\\n-        op_sql = self.seg(\\n-            \\\" \\\".join(\\n-                op\\n-                for op in (\\n-                    \\\"NATURAL\\\" if expression.args.get(\\\"natural\\\") else None,\\n-                    \\\"GLOBAL\\\" if expression.args.get(\\\"global\\\") else None,\\n-                    expression.side,\\n-                    expression.kind,\\n-                    expression.hint if self.JOIN_HINTS else None,\\n-                    \\\"JOIN\\\",\\n-                )\\n-                if op\\n+        op_sql = \\\" \\\".join(\\n+            op\\n+            for op in (\\n+                \\\"NATURAL\\\" if expression.args.get(\\\"natural\\\") else None,\\n+                \\\"GLOBAL\\\" if expression.args.get(\\\"global\\\") else None,\\n+                expression.side,\\n+                expression.kind,\\n+                expression.hint if self.JOIN_HINTS else None,\\n             )\\n+            if op\\n         )\\n         on_sql = self.sql(expression, \\\"on\\\")\\n         using = expression.args.get(\\\"using\\\")\\n@@ -1300,6 +1296,8 @@ def join_sql(self, expression: exp.Join) -> str:\\n         if not on_sql and using:\\n             on_sql = csv(*(self.sql(column) for column in using))\\n \\n+        this_sql = self.sql(expression, \\\"this\\\")\\n+\\n         if on_sql:\\n             on_sql = self.indent(on_sql, skip_first=True)\\n             space = self.seg(\\\" \\\" * self.pad) if self.pretty else \\\" \\\"\\n@@ -1307,10 +1305,11 @@ def join_sql(self, expression: exp.Join) -> str:\\n                 on_sql = f\\\"{space}USING ({on_sql})\\\"\\n             else:\\n                 on_sql = f\\\"{space}ON {on_sql}\\\"\\n+        elif not op_sql:\\n+            return f\\\", {this_sql}\\\"\\n \\n-        expression_sql = self.sql(expression, \\\"expression\\\")\\n-        this_sql = self.sql(expression, \\\"this\\\")\\n-        return f\\\"{expression_sql}{op_sql} {this_sql}{on_sql}\\\"\\n+        op_sql = f\\\"{op_sql} JOIN\\\" if op_sql else \\\"JOIN\\\"\\n+        return f\\\"{self.seg(op_sql)} {this_sql}{on_sql}\\\"\\n \\n     def lambda_sql(self, expression: exp.Lambda, arrow_sep: str = \\\"->\\\") -> str:\\n         args = self.expressions(expression, flat=True)\\n@@ -1487,9 +1486,9 @@ def query_modifiers(self, expression: exp.Expression, *sqls: str) -> str:\\n \\n         return csv(\\n             *sqls,\\n-            *[self.sql(sql) for sql in expression.args.get(\\\"joins\\\") or []],\\n+            *[self.sql(join) for join in expression.args.get(\\\"joins\\\") or []],\\n             self.sql(expression, \\\"match\\\"),\\n-            *[self.sql(sql) for sql in expression.args.get(\\\"laterals\\\") or []],\\n+            *[self.sql(lateral) for lateral in expression.args.get(\\\"laterals\\\") or []],\\n             self.sql(expression, \\\"where\\\"),\\n             self.sql(expression, \\\"group\\\"),\\n             self.sql(expression, \\\"having\\\"),\\n\",\"diff --git a/sqlglot/optimizer/eliminate_subqueries.py b/sqlglot/optimizer/eliminate_subqueries.py\\nindex 8b0650b62..294214bf9 100644\\n--- a/sqlglot/optimizer/eliminate_subqueries.py\\n+++ b/sqlglot/optimizer/eliminate_subqueries.py\\n@@ -16,9 +16,9 @@ def eliminate_subqueries(expression):\\n         'WITH y AS (SELECT * FROM x) SELECT a FROM y AS y'\\n \\n     This also deduplicates common subqueries:\\n-        >>> expression = sqlglot.parse_one(\\\"SELECT a FROM (SELECT * FROM x) AS y JOIN (SELECT * FROM x) AS z\\\")\\n+        >>> expression = sqlglot.parse_one(\\\"SELECT a FROM (SELECT * FROM x) AS y CROSS JOIN (SELECT * FROM x) AS z\\\")\\n         >>> eliminate_subqueries(expression).sql()\\n-        'WITH y AS (SELECT * FROM x) SELECT a FROM y AS y JOIN y AS z'\\n+        'WITH y AS (SELECT * FROM x) SELECT a FROM y AS y CROSS JOIN y AS z'\\n \\n     Args:\\n         expression (sqlglot.Expression): expression\\n\",\"diff --git a/sqlglot/optimizer/expand_multi_table_selects.py b/sqlglot/optimizer/expand_multi_table_selects.py\\ndeleted file mode 100644\\nindex 86f0c2d1d..000000000\\n--- a/sqlglot/optimizer/expand_multi_table_selects.py\\n+++ /dev/null\\n@@ -1,24 +0,0 @@\\n-from sqlglot import exp\\n-\\n-\\n-def expand_multi_table_selects(expression):\\n-    \\\"\\\"\\\"\\n-    Replace multiple FROM expressions with JOINs.\\n-\\n-    Example:\\n-        >>> from sqlglot import parse_one\\n-        >>> expand_multi_table_selects(parse_one(\\\"SELECT * FROM x, y\\\")).sql()\\n-        'SELECT * FROM x CROSS JOIN y'\\n-    \\\"\\\"\\\"\\n-    for from_ in expression.find_all(exp.From):\\n-        parent = from_.parent\\n-\\n-        for query in from_.expressions[1:]:\\n-            parent.join(\\n-                query,\\n-                join_type=\\\"CROSS\\\",\\n-                copy=False,\\n-            )\\n-            from_.expressions.remove(query)\\n-\\n-    return expression\\n\",\"diff --git a/sqlglot/optimizer/merge_subqueries.py b/sqlglot/optimizer/merge_subqueries.py\\nindex 1021e69c7..9597b6171 100644\\n--- a/sqlglot/optimizer/merge_subqueries.py\\n+++ b/sqlglot/optimizer/merge_subqueries.py\\n@@ -13,15 +13,15 @@ def merge_subqueries(expression, leave_tables_isolated=False):\\n \\n     Example:\\n         >>> import sqlglot\\n-        >>> expression = sqlglot.parse_one(\\\"SELECT a FROM (SELECT x.a FROM x) JOIN y\\\")\\n+        >>> expression = sqlglot.parse_one(\\\"SELECT a FROM (SELECT x.a FROM x) CROSS JOIN y\\\")\\n         >>> merge_subqueries(expression).sql()\\n-        'SELECT x.a FROM x JOIN y'\\n+        'SELECT x.a FROM x CROSS JOIN y'\\n \\n     If `leave_tables_isolated` is True, this will not merge inner queries into outer\\n     queries if it would result in multiple table selects in a single query:\\n-        >>> expression = sqlglot.parse_one(\\\"SELECT a FROM (SELECT x.a FROM x) JOIN y\\\")\\n+        >>> expression = sqlglot.parse_one(\\\"SELECT a FROM (SELECT x.a FROM x) CROSS JOIN y\\\")\\n         >>> merge_subqueries(expression, leave_tables_isolated=True).sql()\\n-        'SELECT a FROM (SELECT x.a FROM x) JOIN y'\\n+        'SELECT a FROM (SELECT x.a FROM x) CROSS JOIN y'\\n \\n     Inspired by https://dev.mysql.com/doc/refman/8.0/en/derived-table-optimization.html\\n \\n@@ -154,7 +154,7 @@ def _outer_select_joins_on_inner_select_join():\\n         inner_from = inner_scope.expression.args.get(\\\"from\\\")\\n         if not inner_from:\\n             return False\\n-        inner_from_table = inner_from.expressions[0].alias_or_name\\n+        inner_from_table = inner_from.alias_or_name\\n         inner_projections = {s.alias_or_name: s for s in inner_scope.selects}\\n         return any(\\n             col.table != inner_from_table\\n@@ -228,7 +228,7 @@ def _merge_from(outer_scope, inner_scope, node_to_replace, alias):\\n         node_to_replace (exp.Subquery|exp.Table)\\n         alias (str)\\n     \\\"\\\"\\\"\\n-    new_subquery = inner_scope.expression.args.get(\\\"from\\\").expressions[0]\\n+    new_subquery = inner_scope.expression.args[\\\"from\\\"].this\\n     node_to_replace.replace(new_subquery)\\n     for join_hint in outer_scope.join_hints:\\n         tables = join_hint.find_all(exp.Table)\\n@@ -319,7 +319,7 @@ def _merge_where(outer_scope, inner_scope, from_or_join):\\n         # Merge predicates from an outer join to the ON clause\\n         # if it only has columns that are already joined\\n         from_ = expression.args.get(\\\"from\\\")\\n-        sources = {table.alias_or_name for table in from_.expressions} if from_ else {}\\n+        sources = {from_.alias_or_name} if from_ else {}\\n \\n         for join in expression.args[\\\"joins\\\"]:\\n             source = join.alias_or_name\\n\",\"diff --git a/sqlglot/optimizer/optimize_joins.py b/sqlglot/optimizer/optimize_joins.py\\nindex 8589657fb..43436cbbc 100644\\n--- a/sqlglot/optimizer/optimize_joins.py\\n+++ b/sqlglot/optimizer/optimize_joins.py\\n@@ -1,6 +1,8 @@\\n from sqlglot import exp\\n from sqlglot.helper import tsort\\n \\n+JOIN_ATTRS = (\\\"on\\\", \\\"side\\\", \\\"kind\\\", \\\"using\\\", \\\"natural\\\")\\n+\\n \\n def optimize_joins(expression):\\n     \\\"\\\"\\\"\\n@@ -45,7 +47,7 @@ def reorder_joins(expression):\\n     Reorder joins by topological sort order based on predicate references.\\n     \\\"\\\"\\\"\\n     for from_ in expression.find_all(exp.From):\\n-        head = from_.expressions[0]\\n+        head = from_.this\\n         parent = from_.parent\\n         joins = {join.this.alias_or_name: join for join in parent.args.get(\\\"joins\\\", [])}\\n         dag = {head.alias_or_name: []}\\n@@ -65,6 +67,9 @@ def normalize(expression):\\n     Remove INNER and OUTER from joins as they are optional.\\n     \\\"\\\"\\\"\\n     for join in expression.find_all(exp.Join):\\n+        if not any(join.args.get(k) for k in JOIN_ATTRS):\\n+            join.set(\\\"kind\\\", \\\"CROSS\\\")\\n+\\n         if join.kind != \\\"CROSS\\\":\\n             join.set(\\\"kind\\\", None)\\n     return expression\\n\",\"diff --git a/sqlglot/optimizer/optimizer.py b/sqlglot/optimizer/optimizer.py\\nindex c165ffe23..85ebb4ad8 100644\\n--- a/sqlglot/optimizer/optimizer.py\\n+++ b/sqlglot/optimizer/optimizer.py\\n@@ -10,7 +10,6 @@\\n from sqlglot.optimizer.eliminate_ctes import eliminate_ctes\\n from sqlglot.optimizer.eliminate_joins import eliminate_joins\\n from sqlglot.optimizer.eliminate_subqueries import eliminate_subqueries\\n-from sqlglot.optimizer.expand_multi_table_selects import expand_multi_table_selects\\n from sqlglot.optimizer.isolate_table_selects import isolate_table_selects\\n from sqlglot.optimizer.lower_identities import lower_identities\\n from sqlglot.optimizer.merge_subqueries import merge_subqueries\\n@@ -33,7 +32,6 @@\\n     validate_qualify_columns,\\n     normalize,\\n     unnest_subqueries,\\n-    expand_multi_table_selects,\\n     pushdown_predicates,\\n     optimize_joins,\\n     eliminate_subqueries,\\n\",\"diff --git a/sqlglot/optimizer/qualify_columns.py b/sqlglot/optimizer/qualify_columns.py\\nindex 97df4ea5e..23bc05fd6 100644\\n--- a/sqlglot/optimizer/qualify_columns.py\\n+++ b/sqlglot/optimizer/qualify_columns.py\\n@@ -68,7 +68,7 @@ def validate_qualify_columns(expression):\\n             if scope.external_columns and not scope.is_correlated_subquery:\\n                 column = scope.external_columns[0]\\n                 raise OptimizeError(\\n-                    f\\\"\\\"\\\"Column '{column}' could not be resolved{\\\" for table: '{column.table}'\\\" if column.table else ''}\\\"\\\"\\\"\\n+                    f\\\"\\\"\\\"Column '{column}' could not be resolved{f\\\" for table: '{column.table}'\\\" if column.table else ''}\\\"\\\"\\\"\\n                 )\\n \\n     if unqualified_columns:\\n\",\"diff --git a/sqlglot/optimizer/scope.py b/sqlglot/optimizer/scope.py\\nindex c441847a2..88c66cdd0 100644\\n--- a/sqlglot/optimizer/scope.py\\n+++ b/sqlglot/optimizer/scope.py\\n@@ -587,7 +587,7 @@ def _traverse_tables(scope):\\n     expressions = []\\n     from_ = scope.expression.args.get(\\\"from\\\")\\n     if from_:\\n-        expressions.extend(from_.expressions)\\n+        expressions.append(from_.this)\\n \\n     for join in scope.expression.args.get(\\\"joins\\\") or []:\\n         expressions.append(join.this)\\n\",\"diff --git a/sqlglot/parser.py b/sqlglot/parser.py\\nindex 8adffa84e..a348057c8 100644\\n--- a/sqlglot/parser.py\\n+++ b/sqlglot/parser.py\\n@@ -727,6 +727,7 @@ class Parser(metaclass=_Parser):\\n     }\\n \\n     QUERY_MODIFIER_PARSERS = {\\n+        \\\"joins\\\": lambda self: list(iter(self._parse_join, None)),\\n         \\\"laterals\\\": lambda self: list(iter(self._parse_lateral, None)),\\n         \\\"match\\\": lambda self: self._parse_match_recognize(),\\n         \\\"where\\\": lambda self: self._parse_where(),\\n@@ -1096,9 +1097,7 @@ def _parse_statement(self) -> t.Optional[exp.Expression]:\\n \\n         expression = self._parse_expression()\\n         expression = self._parse_set_operations(expression) if expression else self._parse_select()\\n-\\n-        self._parse_query_modifiers(expression)\\n-        return expression\\n+        return self._parse_query_modifiers(expression)\\n \\n     def _parse_drop(self) -> t.Optional[exp.Drop | exp.Command]:\\n         start = self._prev\\n@@ -1774,7 +1773,7 @@ def _parse_update(self) -> exp.Expression:\\n             **{  # type: ignore\\n                 \\\"this\\\": self._parse_table(alias_tokens=self.UPDATE_ALIAS_TOKENS),\\n                 \\\"expressions\\\": self._match(TokenType.SET) and self._parse_csv(self._parse_equality),\\n-                \\\"from\\\": self._parse_from(),\\n+                \\\"from\\\": self._parse_from(modifiers=True),\\n                 \\\"where\\\": self._parse_where(),\\n                 \\\"returning\\\": self._parse_returning(),\\n             },\\n@@ -1890,11 +1889,10 @@ def _parse_select(\\n             if from_:\\n                 this.set(\\\"from\\\", from_)\\n \\n-            self._parse_query_modifiers(this)\\n+            this = self._parse_query_modifiers(this)\\n         elif (table or nested) and self._match(TokenType.L_PAREN):\\n             this = self._parse_table() if table else self._parse_select(nested=True)\\n-            self._parse_query_modifiers(this)\\n-            this = self._parse_set_operations(this)\\n+            this = self._parse_set_operations(self._parse_query_modifiers(this))\\n             self._match_r_paren()\\n \\n             # early return so that subquery unions aren't parsed again\\n@@ -1976,22 +1974,16 @@ def _parse_subquery(\\n             alias=self._parse_table_alias() if parse_alias else None,\\n         )\\n \\n-    def _parse_query_modifiers(self, this: t.Optional[exp.Expression]) -> None:\\n-        if not isinstance(this, self.MODIFIABLES):\\n-            return\\n-\\n-        join = self._parse_join()\\n-        while join:\\n-            this.append(\\\"joins\\\", join)\\n-            while self._match(TokenType.COMMA):\\n-                this.args[\\\"from\\\"].append(\\\"expressions\\\", self._parse_table())\\n-            join = self._parse_join()\\n-\\n-        for key, parser in self.QUERY_MODIFIER_PARSERS.items():\\n-            expression = parser(self)\\n+    def _parse_query_modifiers(\\n+        self, this: t.Optional[exp.Expression]\\n+    ) -> t.Optional[exp.Expression]:\\n+        if isinstance(this, self.MODIFIABLES):\\n+            for key, parser in self.QUERY_MODIFIER_PARSERS.items():\\n+                expression = parser(self)\\n \\n-            if expression:\\n-                this.set(key, expression)\\n+                if expression:\\n+                    this.set(key, expression)\\n+        return this\\n \\n     def _parse_hint(self) -> t.Optional[exp.Expression]:\\n         if self._match(TokenType.HINT):\\n@@ -2014,12 +2006,16 @@ def _parse_into(self) -> t.Optional[exp.Expression]:\\n             exp.Into, this=self._parse_table(schema=True), temporary=temp, unlogged=unlogged\\n         )\\n \\n-    def _parse_from(self) -> t.Optional[exp.Expression]:\\n+    def _parse_from(self, modifiers: bool = False) -> t.Optional[exp.Expression]:\\n         if not self._match(TokenType.FROM):\\n             return None\\n \\n+        this = self._parse_table()\\n+\\n         return self.expression(\\n-            exp.From, comments=self._prev_comments, expressions=self._parse_csv(self._parse_table)\\n+            exp.From,\\n+            comments=self._prev_comments,\\n+            this=self._parse_query_modifiers(this) if modifiers else this,\\n         )\\n \\n     def _parse_match_recognize(self) -> t.Optional[exp.Expression]:\\n@@ -2162,6 +2158,9 @@ def _parse_join_side_and_kind(\\n         )\\n \\n     def _parse_join(self, skip_join_token: bool = False) -> t.Optional[exp.Expression]:\\n+        if self._match(TokenType.COMMA):\\n+            return self.expression(exp.Join, this=self._parse_table())\\n+\\n         index = self._index\\n         natural, side, kind = self._parse_join_side_and_kind()\\n         hint = self._prev.text if self._match_texts(self.JOIN_HINTS) else None\\n@@ -3033,8 +3032,7 @@ def _parse_primary(self) -> t.Optional[exp.Expression]:\\n             else:\\n                 expressions = self._parse_csv(lambda: self._parse_expression(explicit_alias=True))\\n \\n-            this = seq_get(expressions, 0)\\n-            self._parse_query_modifiers(this)\\n+            this = self._parse_query_modifiers(seq_get(expressions, 0))\\n \\n             if isinstance(this, exp.Subqueryable):\\n                 this = self._parse_set_operations(\\n\",\"diff --git a/sqlglot/planner.py b/sqlglot/planner.py\\nindex 5fd96effd..1e6623801 100644\\n--- a/sqlglot/planner.py\\n+++ b/sqlglot/planner.py\\n@@ -5,7 +5,6 @@\\n import typing as t\\n \\n from sqlglot import alias, exp\\n-from sqlglot.errors import UnsupportedError\\n from sqlglot.optimizer.eliminate_joins import join_condition\\n \\n \\n@@ -105,13 +104,7 @@ def from_expression(\\n         from_ = expression.args.get(\\\"from\\\")\\n \\n         if isinstance(expression, exp.Select) and from_:\\n-            from_ = from_.expressions\\n-            if len(from_) > 1:\\n-                raise UnsupportedError(\\n-                    \\\"Multi-from statements are unsupported. Run it through the optimizer\\\"\\n-                )\\n-\\n-            step = Scan.from_expression(from_[0], ctes)\\n+            step = Scan.from_expression(from_.this, ctes)\\n         elif isinstance(expression, exp.Union):\\n             step = SetOperation.from_expression(expression, ctes)\\n         else:\\n\"]", "test_patch": "", "hints_text": ""}

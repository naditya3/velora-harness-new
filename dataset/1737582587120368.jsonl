{"instance_id": "1737582587120368", "repo": "bcdev/chartlets", "base_commit": "e3b88f2377d21d8a7c7b8cbc2f4668193b05658a", "problem_statement": "Add more tests and report coverage:\\n- Add more tests \\r\\n- Configure coverage\\r\\n- Report coverage", "FAIL_TO_PASS": ["chartlets.py/tests/extensioncontext_test.py::ExtensionContextTest::test_attributes", "chartlets.py/tests/extension_test.py::ExtensionTest::test_add", "chartlets.py/tests/extensioncontext_test.py::ExtensionContextLoadTest::test_load_invalid_ext_ref", "chartlets.py/tests/controllers/layout_test.py::GetLayoutTest::test_invalid_contrib_index", "chartlets.py/tests/extension_test.py::ExtensionTest::test_add_contrib_point", "chartlets.py/tests/controllers/callback_test.py::GetCallbackResultsTest::test_success_for_2_requests", "chartlets.py/tests/components/charts/vega_no_altair_test.py::test_no_altair", "chartlets.py/tests/controllers/layout_test.py::GetLayoutTest::test_no_layout", "chartlets.py/tests/channel_test.py::StateTest::test_component_empty_property", "chartlets.py/tests/controllers/contributions_test.py::GetContributionsTest::test_success", "chartlets.py/tests/controllers/callback_test.py::GetCallbackResultsTest::test_invalid_contrib_index", "chartlets.py/tests/extensioncontext_test.py::ExtensionContextLoadTest::test_load_ok", "chartlets.py/tests/extension_test.py::ExtensionTest::test_to_dict", "chartlets.py/tests/controllers/callback_test.py::GetCallbackResultsTest::test_invalid_contrib_point", "chartlets.py/tests/extensioncontext_test.py::ExtensionContextLoadTest::test_load_invalid_ext_type", "chartlets.py/tests/extension_test.py::ExtensionTest::test_attributes", "chartlets.py/tests/channel_test.py::InputTest::test_component_empty_property", "chartlets.py/tests/contribution_test.py::ContributionTest::test_to_dict", "chartlets.py/tests/controllers/callback_test.py::GetCallbackResultsTest::test_no_callback", "chartlets.py/tests/controllers/callback_test.py::GetCallbackResultsTest::test_invalid_callback_index"], "PASS_TO_PASS": ["chartlets.py/tests/components/progress_test.py::LinearProgressWithLabelTest::test_type_is_class_name", "chartlets.py/tests/channel_test.py::StateTest::test_container", "chartlets.py/tests/channel_test.py::OutputTest::test_unknown_id", "chartlets.py/tests/channel_test.py::StateTest::test_container_no_property", "chartlets.py/tests/components/typography_test.py::TypographyTest::test_is_json_serializable", "chartlets.py/tests/channel_test.py::OutputTest::test_to_dict", "chartlets.py/tests/components/checkbox_test.py::CheckboxTest::test_type_is_class_name", "chartlets.py/tests/channel_test.py::InputTest::test_container", "chartlets.py/tests/channel_test.py::StateTest::test_unknown_id", "chartlets.py/tests/channel_test.py::InputTest::test_container_no_property", "chartlets.py/tests/channel_test.py::OutputTest::test_keyword_arguments", "chartlets.py/tests/components/box_test.py::BoxTest::test_type_is_class_name", "chartlets.py/tests/channel_test.py::StateTest::test_app", "chartlets.py/tests/components/select_test.py::SelectTest::test_type_is_class_name", "chartlets.py/tests/component_test.py::ComponentTest::test_type_is_class_name", "chartlets.py/tests/channel_test.py::InputTest::test_component", "chartlets.py/tests/channel_test.py::OutputTest::test_container_no_property", "chartlets.py/tests/components/progress_test.py::LinearProgressTest::test_is_json_serializable", "chartlets.py/tests/channel_test.py::OutputTest::test_container", "chartlets.py/tests/callback_test.py::FromDecoratorTest::test_too_many_inputs", "chartlets.py/tests/channel_test.py::StateTest::test_component", "chartlets.py/tests/callback_test.py::FromDecoratorTest::test_too_few_inputs", "chartlets.py/tests/channel_test.py::StateTest::test_component_no_property", "chartlets.py/tests/components/button_test.py::ButtonTest::test_is_json_serializable", "chartlets.py/tests/channel_test.py::OutputTest::test_component_no_property", "chartlets.py/tests/components/select_test.py::SelectTest::test_is_json_serializable", "chartlets.py/tests/channel_test.py::OutputTest::test_component_empty_property", "chartlets.py/tests/channel_test.py::StateTest::test_app_no_property", "chartlets.py/tests/channel_test.py::OutputTest::test_component", "chartlets.py/tests/channel_test.py::InputTest::test_app_no_property", "chartlets.py/tests/components/checkbox_test.py::CheckboxTest::test_is_json_serializable", "chartlets.py/tests/components/progress_test.py::CircularProgressTest::test_is_json_serializable", "chartlets.py/tests/channel_test.py::InputTest::test_no_arguments", "chartlets.py/tests/channel_test.py::InputTest::test_component_no_property", "chartlets.py/tests/components/progress_test.py::CircularProgressWithLabelTest::test_type_is_class_name", "chartlets.py/tests/container_test.py::ContainerTest::test_to_dict", "chartlets.py/tests/channel_test.py::InputTest::test_keyword_arguments", "chartlets.py/tests/channel_test.py::InputTest::test_unknown_id", "chartlets.py/tests/channel_test.py::StateTest::test_no_arguments", "chartlets.py/tests/callback_test.py::FromDecoratorTest::test_decorator_args", "chartlets.py/tests/components/button_test.py::ButtonTest::test_type_is_class_name", "chartlets.py/tests/channel_test.py::InputTest::test_app", "chartlets.py/tests/components/charts/vega_test.py::VegaChartTest::test_without_chart_prop", "chartlets.py/tests/components/charts/vega_test.py::VegaChartTest::test_with_chart_prop", "chartlets.py/tests/components/progress_test.py::LinearProgressTest::test_type_is_class_name", "chartlets.py/tests/container_test.py::ContainerTest::test_attributes", "chartlets.py/tests/channel_test.py::InputTest::test_to_dict", "chartlets.py/tests/components/progress_test.py::LinearProgressWithLabelTest::test_is_json_serializable", "chartlets.py/tests/channel_test.py::StateTest::test_keyword_arguments", "chartlets.py/tests/channel_test.py::StateTest::test_to_dict", "chartlets.py/tests/channel_test.py::OutputTest::test_app", "chartlets.py/tests/components/progress_test.py::CircularProgressWithLabelTest::test_is_json_serializable", "chartlets.py/tests/components/progress_test.py::CircularProgressTest::test_type_is_class_name", "chartlets.py/tests/channel_test.py::OutputTest::test_app_no_property", "chartlets.py/tests/components/box_test.py::BoxTest::test_is_json_serializable", "chartlets.py/tests/callback_test.py::FromDecoratorTest::test_decorator_target", "chartlets.py/tests/component_test.py::ComponentTest::test_is_json_serializable", "chartlets.py/tests/components/charts/vega_test.py::VegaChartTest::test_type_is_class_name", "chartlets.py/tests/components/typography_test.py::TypographyTest::test_type_is_class_name", "chartlets.py/tests/channel_test.py::OutputTest::test_no_arguments"], "language": "python", "test_command": "source /saved/ENV || source /saved/*/ENV && pytest --no-header -rA --tb=no -p no:cacheprovider --continue-on-collection-errors", "test_output_parser": "python/parse_log_pytest_v3", "image_storage_uri": "vmvm-registry.fbinfra.net/repomate_image_activ_pytest/bcdev_chartlets:e3b88f2377d21d8a7c7b8cbc2f4668193b05658a", "patch": "[\"diff --git a/chartlets.js/CHANGES.md b/chartlets.js/CHANGES.md\\nindex 551a9842..223f8d27 100644\\n--- a/chartlets.js/CHANGES.md\\n+++ b/chartlets.js/CHANGES.md\\n@@ -29,6 +29,9 @@\\n   dark, light, and system mode.\\n \\n * Changed the yet unused descriptor type `CbFunction` for callback functions.\\n+  - using `schema` instead of `type` property for callback arguments\\n+  - using `return` object with `schema` property for callback return values\\n+\\n \\n ## Version 0.0.29 (from 2024/11/26)\\n \\n\",\"diff --git a/chartlets.js/packages/lib/src/hooks.ts b/chartlets.js/packages/lib/src/hooks.ts\\nindex d4096ed9..43882e14 100644\\n--- a/chartlets.js/packages/lib/src/hooks.ts\\n+++ b/chartlets.js/packages/lib/src/hooks.ts\\n@@ -1,6 +1,6 @@\\n import type { StoreState } from \\\"@/types/state/store\\\";\\n import { store } from \\\"@/store\\\";\\n-import { useMemo } from \\\"react\\\";\\n+import { useCallback, useMemo } from \\\"react\\\";\\n import type { ContributionState } from \\\"@/types/state/contribution\\\";\\n import type {\\n   ComponentChangeEvent,\\n@@ -28,31 +28,29 @@ export const useContributionsResult = () => useStore(selectContributionsResult);\\n export const useContributionsRecord = () => useStore(selectContributionsRecord);\\n export const useThemeMode = () => useStore(selectThemeMode);\\n \\n-export function makeContributionsHook<S extends object = object>(\\n-  contribPoint: string,\\n-): () => ContributionState<S>[] {\\n-  return () => {\\n-    const selectContributions = (state: StoreState) =>\\n-      state.contributionsRecord[contribPoint];\\n-    const contributions = useStore(selectContributions);\\n-    return useMemo(() => {\\n-      return (contributions || []) as ContributionState<S>[];\\n-    }, [contributions]);\\n-  };\\n-}\\n-\\n /**\\n  * A hook that retrieves the contributions for the given contribution\\n  * point given by `contribPoint`.\\n  *\\n+ * A stable empty array is returned if there are no contributions or\\n+ * the contribution point does not exist.\\n+ *\\n  * @param contribPoint Contribution point name.\\n  * @typeParam S Type of the container state.\\n+ * @returns Array of contributions.\\n  */\\n export function useContributions<S extends object = object>(\\n   contribPoint: string,\\n ): ContributionState<S>[] {\\n-  const contributionsRecord = useContributionsRecord();\\n-  return contributionsRecord[contribPoint] as ContributionState<S>[];\\n+  const selectContributions = useCallback(\\n+    (state: StoreState) => state.contributionsRecord[contribPoint],\\n+    [contribPoint],\\n+  );\\n+  const contributions = useStore(selectContributions);\\n+  return useMemo(\\n+    () => (contributions || []) as ContributionState<S>[],\\n+    [contributions],\\n+  );\\n }\\n \\n /**\\n@@ -60,9 +58,13 @@ export function useContributions<S extends object = object>(\\n  * component change handlers of type `ComponentChangeHandler` for\\n  * the contribution point given by `contribPoint`.\\n  *\\n+ * A stable empty array is returned if there are no contributions or\\n+ * the contribution point does not exist.\\n+ *\\n  * @param contribPoint Contribution point name.\\n  * @param numContribs Number of contributions. This should be the length\\n  *   of the array of contributions you get using the `useContributions` hook.\\n+ * @returns Array of component change handlers\\n  */\\n export function useComponentChangeHandlers(\\n   contribPoint: string,\\n\",\"diff --git a/chartlets.js/packages/lib/src/index.ts b/chartlets.js/packages/lib/src/index.ts\\nindex ed8a851f..d8ed9d02 100644\\n--- a/chartlets.js/packages/lib/src/index.ts\\n+++ b/chartlets.js/packages/lib/src/index.ts\\n@@ -28,7 +28,6 @@ export {\\n   useContributionsRecord,\\n   useContributions,\\n   useComponentChangeHandlers,\\n-  makeContributionsHook,\\n   useThemeMode,\\n } from \\\"@/hooks\\\";\\n \\n\",\"diff --git a/chartlets.js/packages/lib/src/plugins/mui/Select.tsx b/chartlets.js/packages/lib/src/plugins/mui/Select.tsx\\nindex 8e8ab448..3fe51100 100644\\n--- a/chartlets.js/packages/lib/src/plugins/mui/Select.tsx\\n+++ b/chartlets.js/packages/lib/src/plugins/mui/Select.tsx\\n@@ -31,19 +31,18 @@ export function Select({\\n   onChange,\\n }: SelectProps) {\\n   const handleChange = (event: SelectChangeEvent) => {\\n-    if (!id) {\\n-      return;\\n+    if (id) {\\n+      let newValue: string | number = event.target.value;\\n+      if (typeof value == \\\"number\\\") {\\n+        newValue = Number.parseInt(newValue);\\n+      }\\n+      onChange({\\n+        componentType: type,\\n+        id: id,\\n+        property: \\\"value\\\",\\n+        value: newValue,\\n+      });\\n     }\\n-    let newValue: string | number = event.target.value;\\n-    if (typeof value == \\\"number\\\") {\\n-      newValue = Number.parseInt(newValue);\\n-    }\\n-    return onChange({\\n-      componentType: type,\\n-      id: id,\\n-      property: \\\"value\\\",\\n-      value: newValue,\\n-    });\\n   };\\n   return (\\n     <MuiFormControl variant=\\\"filled\\\" size=\\\"small\\\" style={style}>\\n\",\"diff --git a/chartlets.js/packages/lib/src/plugins/vega/VegaChart.tsx b/chartlets.js/packages/lib/src/plugins/vega/VegaChart.tsx\\nindex 9c586159..69ffa09b 100644\\n--- a/chartlets.js/packages/lib/src/plugins/vega/VegaChart.tsx\\n+++ b/chartlets.js/packages/lib/src/plugins/vega/VegaChart.tsx\\n@@ -24,7 +24,6 @@ export function VegaChart({\\n }: VegaChartProps) {\\n   const signalListeners = useSignalListeners(chart, type, id, onChange);\\n   const vegaTheme = useVegaTheme(theme);\\n-  console.info(\\\"---> vegaTheme:\\\", vegaTheme);\\n   if (chart) {\\n     return (\\n       <VegaLite\\n\",\"diff --git a/chartlets.js/packages/lib/src/plugins/vega/hooks/useVegaTheme.ts b/chartlets.js/packages/lib/src/plugins/vega/hooks/useVegaTheme.ts\\nindex 3c8c531f..2c83e77b 100644\\n--- a/chartlets.js/packages/lib/src/plugins/vega/hooks/useVegaTheme.ts\\n+++ b/chartlets.js/packages/lib/src/plugins/vega/hooks/useVegaTheme.ts\\n@@ -7,8 +7,8 @@ export type VegaTheme = keyof Omit<typeof vegaThemes, \\\"version\\\">;\\n const isVegaTheme = (key?: string): key is VegaTheme =>\\n   !!key && key in vegaThemes;\\n \\n-const isSystemThemeDark = () =>\\n-  window.matchMedia(\\\"(prefers-color-scheme: dark)\\\");\\n+const isSystemThemeDark = (): boolean =>\\n+  window.matchMedia(\\\"(prefers-color-scheme: dark)\\\").matches;\\n \\n export function useVegaTheme(\\n   theme: VegaTheme | \\\"default\\\" | \\\"system\\\" | undefined,\\n\",\"diff --git a/chartlets.py/CHANGES.md b/chartlets.py/CHANGES.md\\nindex 91b0114f..776fb51c 100644\\n--- a/chartlets.py/CHANGES.md\\n+++ b/chartlets.py/CHANGES.md\\n@@ -1,6 +1,5 @@\\n ## Version 0.1.0 (in development)\\n \\n-\\n * Reorganised Chartlets project to better separate demo from library code.\\n   Created separate folder `demo` in `chartlets.py` that contains \\n   a demo `server` package and example configuration.\\n@@ -14,6 +13,9 @@\\n * Renamed `Plot` into `VegaChart`, which now also respects a `theme` property. \\n \\n * Changed schema of the yet unused descriptor for callback functions.\\n+  - using `schema` instead of `type` property for callback arguments\\n+  - using `return` object with `schema` property for callback return values\\n+\\n \\n ## Version 0.0.29 (from 2024/11/26)\\n \\n\",\"diff --git a/chartlets.py/chartlets/callback.py b/chartlets.py/chartlets/callback.py\\nindex 83e65aba..71eecf6a 100644\\n--- a/chartlets.py/chartlets/callback.py\\n+++ b/chartlets.py/chartlets/callback.py\\n@@ -2,11 +2,12 @@\\n import types\\n from typing import Any, Callable\\n \\n-from chartlets.channel import (\\n+from .channel import (\\n     Input,\\n     Output,\\n     State,\\n )\\n+from .util.logger import LOGGER\\n \\n \\n class Callback:\\n@@ -20,7 +21,7 @@ class Callback:\\n     def from_decorator(\\n         cls,\\n         decorator_name: str,\\n-        decorator_args: tuple[Any, ...],\\n+        decorator_args: tuple | list,\\n         function: Any,\\n         states_only: bool = False,\\n     ) -> \\\"Callback\\\":\\n@@ -126,11 +127,10 @@ def make_function_args(\\n                 f\\\" expected {num_inputs},\\\"\\n                 f\\\" but got {num_values}\\\"\\n             )\\n-            if delta > 0:\\n-                values = (*values, *(delta * (None,)))\\n-                print(f\\\"WARNING: {message}\\\")  # TODO use logging\\n-            else:\\n+            if delta < 0:\\n                 raise TypeError(message)\\n+            LOGGER.warning(message)\\n+            values = (*values, *(delta * (None,)))\\n \\n         param_names = self.param_names[1:]\\n         args = [context]\\n@@ -150,15 +150,14 @@ def _parameter_to_dict(parameter: inspect.Parameter) -> dict[str, Any]:\\n     empty = inspect.Parameter.empty\\n     d = {\\\"name\\\": parameter.name}\\n     if parameter.annotation is not empty:\\n-        d |= {\\\"schema\\\": _annotation_to_json_schema(parameter.annotation)}\\n+        d |= {\\\"schema\\\": annotation_to_json_schema(parameter.annotation)}\\n     if parameter.default is not empty:\\n         d |= {\\\"default\\\": parameter.default}\\n     return d\\n \\n+\\n def _return_to_dict(return_annotation: Any) -> dict[str, Any]:\\n-    return {\\n-        \\\"schema\\\": _annotation_to_json_schema(return_annotation)\\n-    }\\n+    return {\\\"schema\\\": annotation_to_json_schema(return_annotation)}\\n \\n \\n _basic_types = {\\n@@ -173,68 +172,55 @@ def _return_to_dict(return_annotation: Any) -> dict[str, Any]:\\n     dict: \\\"object\\\",\\n }\\n \\n-_object_types = {\\\"Component\\\": \\\"Component\\\", \\\"Chart\\\": \\\"Chart\\\"}\\n \\n+def annotation_to_json_schema(annotation: Any) -> dict:\\n+    from chartlets import Component\\n \\n-def _annotation_to_json_schema(annotation: Any) -> dict:\\n     if annotation is Any:\\n         return {}\\n-\\n-    if annotation in _basic_types:\\n+    elif annotation in _basic_types:\\n         return {\\\"type\\\": _basic_types[annotation]}\\n-\\n-    if isinstance(annotation, types.UnionType):\\n-        type_list = list(map(_annotation_to_json_schema, annotation.__args__))\\n+    elif isinstance(annotation, types.UnionType):\\n+        assert annotation.__args__ and len(annotation.__args__) > 1\\n+        type_list = list(map(annotation_to_json_schema, annotation.__args__))\\n         type_name_list = [\\n-            t[\\\"type\\\"] for t in type_list if isinstance(t.get(\\\"type\\\"), str)\\n+            t[\\\"type\\\"]\\n+            for t in type_list\\n+            if isinstance(t.get(\\\"type\\\"), str) and len(t) == 1\\n         ]\\n-        if len(type_name_list) == 1:\\n-            return {\\\"type\\\": type_name_list[0]}\\n-        elif len(type_name_list) > 1:\\n+        if len(type_list) == len(type_name_list):\\n             return {\\\"type\\\": type_name_list}\\n-        elif len(type_list) == 1:\\n-            return type_list[0]\\n-        elif len(type_list) > 1:\\n-            return {\\\"oneOf\\\": type_list}\\n         else:\\n-            return {}\\n-\\n-    if isinstance(annotation, types.GenericAlias):\\n+            return {\\\"oneOf\\\": type_list}\\n+    elif isinstance(annotation, types.GenericAlias):\\n+        assert annotation.__args__\\n         if annotation.__origin__ is tuple:\\n             return {\\n                 \\\"type\\\": \\\"array\\\",\\n-                \\\"items\\\": list(map(_annotation_to_json_schema, annotation.__args__)),\\n+                \\\"items\\\": list(map(annotation_to_json_schema, annotation.__args__)),\\n             }\\n         elif annotation.__origin__ is list:\\n-            if annotation.__args__:\\n-                return {\\n-                    \\\"type\\\": \\\"array\\\",\\n-                    \\\"items\\\": _annotation_to_json_schema(annotation.__args__[0]),\\n-                }\\n+            assert annotation.__args__ and len(annotation.__args__) == 1\\n+            items_schema = annotation_to_json_schema(annotation.__args__[0])\\n+            if items_schema == {}:\\n+                return {\\\"type\\\": \\\"array\\\"}\\n             else:\\n-                return {\\n-                    \\\"type\\\": \\\"array\\\",\\n-                }\\n+                return {\\\"type\\\": \\\"array\\\", \\\"items\\\": items_schema}\\n         elif annotation.__origin__ is dict:\\n-            if annotation.__args__:\\n-                if len(annotation.__args__) == 2 and annotation.__args__[0] is str:\\n-                    return {\\n-                        \\\"type\\\": \\\"object\\\",\\n-                        \\\"additionalProperties\\\": _annotation_to_json_schema(\\n-                            annotation.__args__[1]\\n-                        ),\\n-                    }\\n-            else:\\n-                return {\\n-                    \\\"type\\\": \\\"object\\\",\\n-                }\\n-    else:\\n-        type_name = (\\n-            annotation.__name__ if hasattr(annotation, \\\"__name__\\\") else str(annotation)\\n-        )\\n-        try:\\n-            return {\\\"type\\\": \\\"object\\\", \\\"class\\\": _object_types[type_name]}\\n-        except KeyError:\\n-            pass\\n+            assert annotation.__args__\\n+            assert len(annotation.__args__) == 2\\n+            if annotation.__args__[0] is str:\\n+                value_schema = annotation_to_json_schema(annotation.__args__[1])\\n+                if value_schema == {}:\\n+                    return {\\\"type\\\": \\\"object\\\"}\\n+                else:\\n+                    return {\\\"type\\\": \\\"object\\\", \\\"additionalProperties\\\": value_schema}\\n+    elif (\\n+        inspect.isclass(annotation)\\n+        and \\\".\\\" not in annotation.__qualname__\\n+        and callable(getattr(annotation, \\\"to_dict\\\", None))\\n+    ):\\n+        # Note, for Component classes it is actually possible to generate the object schema\\n+        return {\\\"type\\\": \\\"object\\\", \\\"class\\\": annotation.__qualname__}\\n \\n     raise TypeError(f\\\"unsupported type annotation: {annotation}\\\")\\n\",\"diff --git a/chartlets.py/chartlets/channel.py b/chartlets.py/chartlets/channel.py\\nindex e59199b3..7cfc50c2 100644\\n--- a/chartlets.py/chartlets/channel.py\\n+++ b/chartlets.py/chartlets/channel.py\\n@@ -2,7 +2,7 @@\\n from typing import Any\\n \\n from .util.assertions import (\\n-    assert_is_given,\\n+    assert_is_not_empty,\\n     assert_is_instance_of,\\n     assert_is_one_of,\\n )\\n@@ -26,13 +26,13 @@ def to_dict(self) -> dict[str, Any]:\\n             return dict(id=self.id, property=self.property)\\n \\n     def _validate_params(self, id_: Any, property: Any) -> tuple[str, str | None]:\\n-        assert_is_given(\\\"id\\\", id_)\\n+        assert_is_not_empty(\\\"id\\\", id_)\\n         assert_is_instance_of(\\\"id\\\", id_, str)\\n         id: str = id_\\n         if id.startswith(\\\"@\\\"):\\n             # Other states than component states\\n             assert_is_one_of(\\\"id\\\", id, (\\\"@app\\\", \\\"@container\\\"))\\n-            assert_is_given(\\\"property\\\", property)\\n+            assert_is_not_empty(\\\"property\\\", property)\\n             assert_is_instance_of(\\\"property\\\", property, str)\\n         else:\\n             # Component state\\n@@ -44,7 +44,7 @@ def _validate_params(self, id_: Any, property: Any) -> tuple[str, str | None]:\\n                 pass\\n             else:\\n                 # Components must have valid properties\\n-                assert_is_given(\\\"property\\\", property)\\n+                assert_is_not_empty(\\\"property\\\", property)\\n                 assert_is_instance_of(\\\"property\\\", property, str)\\n         return id, property\\n \\n\",\"diff --git a/chartlets.py/chartlets/components/charts/vega.py b/chartlets.py/chartlets/components/charts/vega.py\\nindex 2e746f93..45e6f929 100644\\n--- a/chartlets.py/chartlets/components/charts/vega.py\\n+++ b/chartlets.py/chartlets/components/charts/vega.py\\n@@ -2,17 +2,23 @@\\n from typing import Any\\n import warnings\\n \\n+from chartlets import Component\\n+\\n+\\n # Respect that \\\"altair\\\" is an optional dependency.\\n+class AltairDummy:\\n+    # noinspection PyPep8Naming\\n+    @property\\n+    def Chart(self):\\n+        warnings.warn(\\\"you must install 'altair' to use the VegaChart component\\\")\\n+        return int\\n+\\n+\\n try:\\n     # noinspection PyUnresolvedReferences\\n     import altair\\n-\\n-    AltairChart = altair.Chart\\n except ImportError:\\n-    warnings.warn(\\\"you must install 'altair' to use the VegaChart component\\\")\\n-    AltairChart = type(None)\\n-\\n-from chartlets import Component\\n+    altair = AltairDummy()\\n \\n \\n @dataclass(frozen=True)\\n@@ -27,7 +33,7 @@ class VegaChart(Component):\\n     theme: str | None = None\\n     \\\"\\\"\\\"The name of a [Vega theme](https://vega.github.io/vega-themes/).\\\"\\\"\\\"\\n \\n-    chart: AltairChart | None = None\\n+    chart: altair.Chart | None = None\\n     \\\"\\\"\\\"The [Vega Altair chart](https://altair-viz.github.io/gallery/index.html).\\\"\\\"\\\"\\n \\n     def to_dict(self) -> dict[str, Any]:\\n\",\"diff --git a/chartlets.py/chartlets/contribution.py b/chartlets.py/chartlets/contribution.py\\nindex fa99c1a8..fd547446 100644\\n--- a/chartlets.py/chartlets/contribution.py\\n+++ b/chartlets.py/chartlets/contribution.py\\n@@ -19,7 +19,6 @@ class Contribution(ABC):\\n         initial_state: contribution specific attribute values.\\n     \\\"\\\"\\\"\\n \\n-    # noinspection PyShadowingBuiltins\\n     def __init__(self, name: str, **initial_state: Any):\\n         self.name = name\\n         self.initial_state = initial_state\\n\",\"diff --git a/chartlets.py/chartlets/controllers/_helpers.py b/chartlets.py/chartlets/controllers/_helpers.py\\nnew file mode 100644\\nindex 00000000..b2a6bbe7\\n--- /dev/null\\n+++ b/chartlets.py/chartlets/controllers/_helpers.py\\n@@ -0,0 +1,44 @@\\n+from chartlets import Contribution\\n+from chartlets import ExtensionContext\\n+from chartlets import Response\\n+from chartlets.util.assertions import assert_is_not_empty\\n+from chartlets.util.assertions import assert_is_instance_of\\n+\\n+\\n+def get_contribution(\\n+    ext_ctx: ExtensionContext,\\n+    contrib_point_name: str,\\n+    contrib_index: int,\\n+) -> tuple[Contribution, None] | tuple[None, Response]:\\n+    \\\"\\\"\\\"Get the contribution for given `contrib_point_name` at `contrib_index`.\\n+\\n+    Args:\\n+        ext_ctx: Extension context.\\n+        contrib_point_name: Contribution point name.\\n+        contrib_index: Contribution index.\\n+    Returns:\\n+        A pair comprising an optional `Contribution` and optional `Response` object.\\n+    \\\"\\\"\\\"\\n+    assert_is_instance_of(\\\"ext_ctx\\\", ext_ctx, ExtensionContext)\\n+    assert_is_not_empty(\\\"contrib_point_name\\\", contrib_point_name)\\n+    assert_is_instance_of(\\\"contrib_index\\\", contrib_index, int)\\n+\\n+    try:\\n+        contributions = ext_ctx.contributions[contrib_point_name]\\n+    except KeyError:\\n+        return None, Response.failed(\\n+            404, f\\\"contribution point {contrib_point_name!r} not found\\\"\\n+        )\\n+\\n+    try:\\n+        contribution = contributions[contrib_index]\\n+    except IndexError:\\n+        return None, Response.failed(\\n+            404,\\n+            (\\n+                f\\\"index range of contribution point {contrib_point_name!r} is\\\"\\n+                f\\\" 0 to {len(contributions) - 1}, got {contrib_index}\\\"\\n+            ),\\n+        )\\n+\\n+    return contribution, None\\n\",\"diff --git a/chartlets.py/chartlets/controllers/callback.py b/chartlets.py/chartlets/controllers/callback.py\\nindex 24e92b1b..6f924039 100644\\n--- a/chartlets.py/chartlets/controllers/callback.py\\n+++ b/chartlets.py/chartlets/controllers/callback.py\\n@@ -2,17 +2,17 @@\\n \\n from chartlets.extensioncontext import ExtensionContext\\n from chartlets.response import Response\\n+from chartlets.util.assertions import assert_is_instance_of\\n+from ._helpers import get_contribution\\n \\n \\n-# POST /chartlets/callback\\n def get_callback_results(\\n-    ext_ctx: ExtensionContext | None, data: dict[str, Any]\\n+    ext_ctx: ExtensionContext, data: dict[str, Any]\\n ) -> Response:\\n     \\\"\\\"\\\"Generate the response for the endpoint `POST /chartlets/callback`.\\n \\n     Args:\\n-        ext_ctx: Extension context. If `None`,\\n-            the function returns a 404 error response.\\n+        ext_ctx: Extension context.\\n         data: A dictionary deserialized from a request JSON body\\n             that should contain a key `callbackRequests` of type `list`.\\n     Returns:\\n@@ -20,29 +20,48 @@ def get_callback_results(\\n         On success, the response is a list of state-change requests\\n         grouped by contributions.\\n     \\\"\\\"\\\"\\n-    if ext_ctx is None:\\n-        return Response.failed(404, f\\\"no contributions configured\\\")\\n+    assert_is_instance_of(\\\"ext_ctx\\\", ext_ctx, ExtensionContext)\\n+    assert_is_instance_of(\\\"data\\\", data, dict)\\n \\n     # TODO: validate data\\n     callback_requests: list[dict] = data.get(\\\"callbackRequests\\\") or []\\n \\n-    # TODO: assert correctness, set status code on error\\n-    state_change_requests: list[dict] = []\\n+    state_change_requests: list[dict[str, Any]] = []\\n     for callback_request in callback_requests:\\n         contrib_point_name: str = callback_request[\\\"contribPoint\\\"]\\n         contrib_index: int = callback_request[\\\"contribIndex\\\"]\\n         callback_index: int = callback_request[\\\"callbackIndex\\\"]\\n         input_values: list = callback_request[\\\"inputValues\\\"]\\n \\n-        contributions = ext_ctx.contributions[contrib_point_name]\\n-        contribution = contributions[contrib_index]\\n-        callback = contribution.callbacks[callback_index]\\n+        contribution, response = get_contribution(\\n+            ext_ctx, contrib_point_name, contrib_index\\n+        )\\n+        if response is not None:\\n+            return response\\n+\\n+        callbacks = contribution.callbacks\\n+        if not callbacks:\\n+            return Response.failed(\\n+                400, f\\\"contribution {contribution.name!r} has no callbacks\\\"\\n+            )\\n+\\n+        try:\\n+            callback = callbacks[callback_index]\\n+        except IndexError:\\n+            return Response.failed(\\n+                404,\\n+                (\\n+                    f\\\"index range of callbacks of contribution {contribution.name!r} is\\\"\\n+                    f\\\" 0 to {len(callbacks) - 1}, got {callback_index}\\\"\\n+                ),\\n+            )\\n+\\n         output_values = callback.invoke(ext_ctx.app_ctx, input_values)\\n \\n         if len(callback.outputs) == 1:\\n             output_values = (output_values,)\\n \\n-        state_changes: list[dict] = []\\n+        state_changes: list[dict[str, Any]] = []\\n         for output_index, output in enumerate(callback.outputs):\\n             output_value = output_values[output_index]\\n             state_changes.append(\\n@@ -57,12 +76,27 @@ def get_callback_results(\\n                 }\\n             )\\n \\n-        state_change_requests.append(\\n-            {\\n-                \\\"contribPoint\\\": contrib_point_name,\\n-                \\\"contribIndex\\\": contrib_index,\\n-                \\\"stateChanges\\\": state_changes,\\n-            }\\n-        )\\n+        # find an existing state change request\\n+        existing_scr: dict[str, Any] | None = None\\n+        for scr in state_change_requests:\\n+            if (\\n+                scr[\\\"contribPoint\\\"] == contrib_point_name\\n+                and scr[\\\"contribIndex\\\"] == contrib_index\\n+            ):\\n+                existing_scr = scr\\n+                break\\n+\\n+        if existing_scr is not None:\\n+            # merge with existing state change request\\n+            existing_scr[\\\"stateChanges\\\"].extend(state_changes)\\n+        else:\\n+            # append new state change request\\n+            state_change_requests.append(\\n+                {\\n+                    \\\"contribPoint\\\": contrib_point_name,\\n+                    \\\"contribIndex\\\": contrib_index,\\n+                    \\\"stateChanges\\\": state_changes,\\n+                }\\n+            )\\n \\n     return Response.success(state_change_requests)\\n\",\"diff --git a/chartlets.py/chartlets/controllers/contributions.py b/chartlets.py/chartlets/controllers/contributions.py\\nindex 1cd290e9..e18a3f33 100644\\n--- a/chartlets.py/chartlets/controllers/contributions.py\\n+++ b/chartlets.py/chartlets/controllers/contributions.py\\n@@ -1,21 +1,19 @@\\n from chartlets.extensioncontext import ExtensionContext\\n from chartlets.response import Response\\n+from chartlets.util.assertions import assert_is_instance_of\\n \\n \\n-def get_contributions(ext_ctx: ExtensionContext | None) -> Response:\\n+def get_contributions(ext_ctx: ExtensionContext) -> Response:\\n     \\\"\\\"\\\"Generate the response for the endpoint `GET /chartlets/contributions`.\\n \\n     Args:\\n-        ext_ctx: Extension context. If `None`,\\n-            the function returns a 404 error response.\\n+        ext_ctx: Extension context.\\n     Returns:\\n         A `Response` object.\\n         On success, the response is a dictionary that represents\\n         a JSON-serialized component tree.\\n     \\\"\\\"\\\"\\n-    if ext_ctx is None:\\n-        return Response.failed(404, f\\\"no contributions configured\\\")\\n-\\n+    assert_is_instance_of(\\\"ext_ctx\\\", ext_ctx, ExtensionContext)\\n     extensions = ext_ctx.extensions\\n     contributions = ext_ctx.contributions\\n     return Response.success(\\n\",\"diff --git a/chartlets.py/chartlets/controllers/layout.py b/chartlets.py/chartlets/controllers/layout.py\\nindex 6b95835d..21072b0c 100644\\n--- a/chartlets.py/chartlets/controllers/layout.py\\n+++ b/chartlets.py/chartlets/controllers/layout.py\\n@@ -2,10 +2,12 @@\\n \\n from chartlets.extensioncontext import ExtensionContext\\n from chartlets.response import Response\\n+from chartlets.util.assertions import assert_is_instance_of\\n+from ._helpers import get_contribution\\n \\n \\n def get_layout(\\n-    ext_ctx: ExtensionContext | None,\\n+    ext_ctx: ExtensionContext,\\n     contrib_point_name: str,\\n     contrib_index: int,\\n     data: dict[str, Any],\\n@@ -14,8 +16,7 @@ def get_layout(\\n     `POST /chartlets/layout/{contrib_point_name}/{contrib_index}`.\\n \\n     Args:\\n-        ext_ctx: Extension context. If `None`,\\n-            the function returns a 404 error response.\\n+        ext_ctx: Extension context.\\n         contrib_point_name: Contribution point name.\\n         contrib_index: Contribution index.\\n         data: A dictionary deserialized from a request JSON body\\n@@ -25,29 +26,21 @@ def get_layout(\\n         On success, the response is a dictionary that represents\\n         a JSON-serialized component tree.\\n     \\\"\\\"\\\"\\n-    if ext_ctx is None:\\n-        return Response.failed(404, f\\\"no contributions configured\\\")\\n+    assert_is_instance_of(\\\"ext_ctx\\\", ext_ctx, ExtensionContext)\\n+    assert_is_instance_of(\\\"data\\\", data, dict)\\n \\n     # TODO: validate data\\n     input_values = data.get(\\\"inputValues\\\") or []\\n \\n-    try:\\n-        contributions = ext_ctx.contributions[contrib_point_name]\\n-    except KeyError:\\n-        return Response.failed(\\n-            404, f\\\"contribution point {contrib_point_name!r} not found\\\"\\n-        )\\n-\\n-    contrib_ref = f\\\"{contrib_point_name}[{contrib_index}]\\\"\\n-\\n-    try:\\n-        contribution = contributions[contrib_index]\\n-    except IndexError:\\n-        return Response.failed(404, f\\\"contribution {contrib_ref!r} not found\\\")\\n+    contribution, response = get_contribution(\\n+        ext_ctx, contrib_point_name, contrib_index\\n+    )\\n+    if response is not None:\\n+        return response\\n \\n     callback = contribution.layout_callback\\n     if callback is None:\\n-        return Response.failed(400, f\\\"contribution {contrib_ref!r} has no layout\\\")\\n+        return Response.failed(400, f\\\"contribution {contribution.name!r} has no layout\\\")\\n \\n     component = callback.invoke(ext_ctx.app_ctx, input_values)\\n \\n\",\"diff --git a/chartlets.py/chartlets/extension.py b/chartlets.py/chartlets/extension.py\\nindex aec3af5a..877a0382 100644\\n--- a/chartlets.py/chartlets/extension.py\\n+++ b/chartlets.py/chartlets/extension.py\\n@@ -1,3 +1,4 @@\\n+import inspect\\n from typing import Any\\n \\n from chartlets.contribution import Contribution\\n@@ -18,8 +19,19 @@ def add_contrib_point(cls, name: str, item_type: type[Contribution]):\\n             item_type: The type of items that can be added\\n                 to the new contribution point.\\n         \\\"\\\"\\\"\\n+        if not inspect.isclass(item_type) or not issubclass(item_type, Contribution):\\n+            message = \\\"item_type must be a class derived from chartlets.Contribution\\\"\\n+            raise TypeError(\\n+                f\\\"{message}, but was {item_type.__name__}\\\"\\n+                if hasattr(item_type, \\\"__name__\\\")\\n+                else message\\n+            )\\n         cls._contrib_points[item_type] = name\\n \\n+    @classmethod\\n+    def reset_contrib_points(cls):\\n+        cls._contrib_points = {}\\n+\\n     @classmethod\\n     def get_contrib_point_names(cls) -> tuple[str, ...]:\\n         \\\"\\\"\\\"Get names of all known contribution points added\\n@@ -35,8 +47,7 @@ def get_contrib_point_names(cls) -> tuple[str, ...]:\\n     def __init__(self, name: str, version: str = \\\"0.0.0\\\"):\\n         self.name = name\\n         self.version = version\\n-        for contrib_point_name in self.get_contrib_point_names():\\n-            setattr(self, contrib_point_name, [])\\n+        self._contributions: dict[str, list[Contribution]] = {}\\n \\n     def add(self, contribution: Contribution):\\n         \\\"\\\"\\\"Add a contribution to this extension.\\n@@ -53,8 +64,13 @@ def add(self, contribution: Contribution):\\n                 f\\\"unrecognized contribution of type {contrib_type.__qualname__}\\\"\\n             )\\n         contribution.extension = self.name\\n-        contributions: list[Contribution] = getattr(self, contrib_point_name)\\n-        contributions.append(contribution)\\n+        if contrib_point_name in self._contributions:\\n+            self._contributions[contrib_point_name].append(contribution)\\n+        else:\\n+            self._contributions[contrib_point_name] = [contribution]\\n+\\n+    def get(self, contrib_point_name: str) -> list[Contribution]:\\n+        return self._contributions.get(contrib_point_name, [])\\n \\n     def to_dict(self) -> dict[str, Any]:\\n         \\\"\\\"\\\"Convert this extension into a JSON-serializable dictionary.\\n@@ -64,9 +80,5 @@ def to_dict(self) -> dict[str, Any]:\\n         return dict(\\n             name=self.name,\\n             version=self.version,\\n-            contributes=[\\n-                contrib_point_name\\n-                for contrib_point_name in self.get_contrib_point_names()\\n-                if getattr(self, contrib_point_name)\\n-            ],\\n+            contributes=sorted(self._contributions.keys()),\\n         )\\n\",\"diff --git a/chartlets.py/chartlets/extensioncontext.py b/chartlets.py/chartlets/extensioncontext.py\\nindex 650aa5d5..16bd24bb 100644\\n--- a/chartlets.py/chartlets/extensioncontext.py\\n+++ b/chartlets.py/chartlets/extensioncontext.py\\n@@ -1,8 +1,6 @@\\n import importlib\\n from typing import Any\\n \\n-import sys\\n-\\n from chartlets import Extension, Contribution\\n \\n \\n@@ -15,7 +13,7 @@ def __init__(self, app_ctx: Any, extensions: list[Extension]):\\n             # noinspection PyTypeChecker\\n             contributions: list[Contribution] = []\\n             for extension in extensions:\\n-                contributions.extend(getattr(extension, contrib_point_name))\\n+                contributions.extend(extension.get(contrib_point_name))\\n             # noinspection PyTypeChecker\\n             contributions_map[contrib_point_name] = contributions\\n         self._contributions = contributions_map\\n@@ -52,16 +50,15 @@ def load(\\n         extensions: list[Extension] = []\\n         for ext_ref in extension_refs:\\n             try:\\n-                module_name, attr_name = ext_ref.rsplit(\\\".\\\", maxsplit=2)\\n+                module_name, attr_name = ext_ref.rsplit(\\\".\\\", maxsplit=1)\\n             except (ValueError, AttributeError):\\n-                raise TypeError(f\\\"contribution syntax error: {ext_ref!r}\\\")\\n+                raise ValueError(f\\\"contribution syntax error: {ext_ref!r}\\\")\\n             module = importlib.import_module(module_name)\\n             extension = getattr(module, attr_name)\\n             if not isinstance(extension, Extension):\\n                 raise TypeError(\\n-                    f\\\"extension {ext_ref!r} must refer to an\\\"\\n-                    f\\\" instance of {Extension.__qualname__!r},\\\"\\n-                    f\\\" but was {type(extension).__qualname__!r}\\\"\\n+                    f\\\"extension reference {ext_ref!r} is not referring to an\\\"\\n+                    f\\\" instance of chartlets.Extension\\\"\\n                 )\\n             extensions.append(extension)\\n         return ExtensionContext(app_ctx, extensions)\\n\",\"diff --git a/chartlets.py/chartlets/util/assertions.py b/chartlets.py/chartlets/util/assertions.py\\nindex bb24d0af..5018f1c9 100644\\n--- a/chartlets.py/chartlets/util/assertions.py\\n+++ b/chartlets.py/chartlets/util/assertions.py\\n@@ -1,6 +1,22 @@\\n+from collections.abc import Collection\\n from typing import Any, Container, Type\\n \\n \\n+def assert_is_not_none(name: str, value: Any):\\n+    if value is None:\\n+        raise ValueError(f\\\"value for {name!r} must not be None\\\")\\n+\\n+\\n+def assert_is_not_empty(name: str, value: Any):\\n+    if value is None:\\n+        raise ValueError(f\\\"value for {name!r} must be given\\\")\\n+    try:\\n+        if len(value) == 0:\\n+            raise ValueError(f\\\"value for {name!r} must not be empty\\\")\\n+    except TypeError:\\n+        pass\\n+\\n+\\n def assert_is_one_of(name: str, value: Any, value_set: Container):\\n     if value not in value_set:\\n         raise ValueError(\\n@@ -10,16 +26,10 @@ def assert_is_one_of(name: str, value: Any, value_set: Container):\\n \\n def assert_is_instance_of(name: str, value: Any, type_set: Type | tuple[Type, ...]):\\n     if not isinstance(value, type_set):\\n+        if isinstance(type_set, type):\\n+            type_set = (type_set,)\\n         raise TypeError(\\n-            f\\\"value of {name!r} must be an instance of {type_set!r}, but was {value!r}\\\"\\n+            f\\\"value of {name!r} must be of type\\\"\\n+            f\\\" {\\\" or \\\".join(map(lambda t: t.__name__, type_set))},\\\"\\n+            f\\\" but was {'None' if value is None else type(value).__name__}\\\"\\n         )\\n-\\n-\\n-def assert_is_none(name: str, value: Any):\\n-    if value is not None:\\n-        raise TypeError(f\\\"value of {name!r} must be None, but was {value!r}\\\")\\n-\\n-\\n-def assert_is_given(name: str, value: Any):\\n-    if not value:\\n-        raise ValueError(f\\\"value for {name!r} must be given\\\")\\n\",\"diff --git a/chartlets.py/chartlets/util/logger.py b/chartlets.py/chartlets/util/logger.py\\nnew file mode 100644\\nindex 00000000..67f24fa0\\n--- /dev/null\\n+++ b/chartlets.py/chartlets/util/logger.py\\n@@ -0,0 +1,3 @@\\n+import logging\\n+\\n+LOGGER = logging.getLogger(\\\"chartlets\\\")\\n\"]", "test_patch": "", "hints_text": ""}

{"instance_id": "698630879702882", "repo": "fractal-analytics-platform/fractal-server", "base_commit": "4d2bc93c50e9ea214530d374d7777aca73d3d90d", "problem_statement": "use tmp_path for test db:\\nthis requires that we cook up a fixture with `scope=\"session\" ` temporary paths", "FAIL_TO_PASS": ["tests/test_unit_db_models.py::test_project_workflow_relation", "tests/test_workflow_api.py::test_get_project_workflows", "tests/test_project.py::test_add_dataset", "tests/test_workflow_api.py::test_get_workflow", "tests/test_workflow_api.py::test_delete_task", "tests/test_runner_backends.py::test_runner[parsl]", "tests/test_db.py::test_sync_db", "tests/test_project.py::test_add_dataset_local_path_error", "tests/test_workflow_api.py::test_post_workflow", "tests/test_backend_parsl_executors.py::test_valid_executors", "tests/test_workflow_api.py::test_delete_workflow", "tests/test_project.py::test_delete_project", "tests/test_unit_db_models.py::test_cascade_delete_project", "tests/test_project.py::test_project_get", "tests/test_project.py::test_project_creation", "tests/test_db.py::test_db_connection", "tests/test_workflow_api.py::test_post_newtask", "tests/test_task_api.py::test_task_create", "tests/test_backend_parsl.py::test_unit_serial_task_assembly", "tests/test_alive.py::test_alive", "tests/test_unit_db_models.py::test_cascade_delete_workflow", "tests/test_task_api.py::test_task_get_list", "tests/test_runner_backends.py::test_runner[process]", "tests/test_security.py::test_me", "tests/test_workflow_api.py::test_patch_workflow", "tests/test_project.py::test_delete_dataset", "tests/test_unit_db_models.py::test_project_name_not_unique", "tests/test_unit_db_models.py::test_task_workflow_association", "tests/test_backend_parsl_executors.py::test_invalid_executors", "tests/test_project.py::test_edit_resource", "tests/test_project.py::test_project_creation_name_constraint"], "PASS_TO_PASS": ["tests/test_unit_settings.py::test_settings_injection", "tests/test_backend_parsl.py::test_import_parsl_backend", "tests/test_unit_dummytasks.py::test_dummy_parallel_direct_call", "tests/test_unit_injection.py::test_injection_override", "tests/test_unit_dummytasks.py::test_dummy_fail_process_call", "tests/test_unit_dummytasks.py::test_dummy_direct_call", "tests/test_unit_utils.py::test_timestamp", "tests/test_backend_process.py::test_recursive_parallel_task_submission_step0", "tests/test_db_project.py::test_proejct_membership", "tests/test_backend_process.py::test_command_wrapper", "tests/test_unit_dummytasks.py::test_dummy_parallel_fail_direct_call", "tests/test_unit_injection.py::test_singleton", "tests/test_backend_process.py::test_call_single_task", "tests/test_unit_injection.py::test_injection", "tests/test_backend_process.py::test_recursive_task_submission_inductive_step", "tests/test_unit_dummytasks.py::test_dummy_process_call", "tests/test_unit_dummytasks.py::test_dummy_fail_direct_call", "tests/test_backend_process.py::test_recursive_task_submission_step0", "tests/test_unit_settings.py::test_settings_check[settings0-True]", "tests/test_unit_settings.py::test_settings_check[settings1-False]"], "language": "python", "test_command": "source /saved/ENV || source /saved/*/ENV && pytest --no-header -rA --tb=no -p no:cacheprovider --continue-on-collection-errors", "test_output_parser": "python/parse_log_pytest_v3", "image_storage_uri": "vmvm-registry.fbinfra.net/repomate_image_activ_pytest/fractal-analytics-platform_fractal-server:4d2bc93c50e9ea214530d374d7777aca73d3d90d", "patch": "[\"diff --git a/fractal_server/app/api/v1/__init__.py b/fractal_server/app/api/v1/__init__.py\\nnew file mode 100644\\nindex 0000000..e69de29\\n--- /dev/null\\n+++ b/fractal_server/app/api/v1/__init__.py\\n\",\"diff --git a/fractal_server/app/api/v1/task.py b/fractal_server/app/api/v1/task.py\\nindex 94d9e87..9b8b052 100644\\n--- a/fractal_server/app/api/v1/task.py\\n+++ b/fractal_server/app/api/v1/task.py\\n@@ -1,19 +1,13 @@\\n import asyncio\\n-from collections import Counter\\n from copy import deepcopy\\n-from typing import Any\\n-from typing import Dict\\n from typing import List\\n \\n from fastapi import APIRouter\\n from fastapi import Depends\\n from fastapi import HTTPException\\n from fastapi import status\\n-from sqlalchemy.exc import NoResultFound\\n from sqlmodel import select\\n \\n-from ....tasks import collect_tasks\\n-from ...db import async_session_maker\\n from ...db import AsyncSession\\n from ...db import DBSyncSession\\n from ...db import get_db\\n@@ -28,44 +22,11 @@ from ...security import User\\n router = APIRouter()\\n \\n \\n-async def upsert_task(\\n-    task: Dict[str, Any],\\n-) -> str:\\n-    async with async_session_maker() as db:\\n-        task_obj = TaskCreate(**task)\\n-        try:\\n-            # task already present, update\\n-            stm = select(Task).where(Task.module == task[\\\"module\\\"])\\n-            res = await db.execute(stm)\\n-            this_task = res.scalars().one()\\n-            for key, value in task_obj.dict(exclude={\\\"subtask_list\\\"}).items():\\n-                setattr(this_task, key, value)\\n-            db.add(this_task)\\n-            await db.commit()\\n-            return \\\"updated\\\"\\n-        except NoResultFound:\\n-            # task not present, insert\\n-            task_orm = Task.from_orm(task_obj)\\n-            db.add(task_orm)\\n-            await db.commit()\\n-            return \\\"inserted\\\"\\n-\\n-\\n-async def collect_tasks_headless() -> Dict[str, int]:\\n-    out = dict(inserted=0, updated=0)\\n-    results = await asyncio.gather(\\n-        *[upsert_task(task) for task in collect_tasks()]\\n-    )\\n-    results = sorted(results)\\n-    out.update(dict(Counter(results)))\\n-    return out\\n-\\n-\\n @router.post(\\\"/collect/\\\", status_code=status.HTTP_201_CREATED)\\n async def collect_core_tasks(\\n     user: User = Depends(current_active_user),\\n ):\\n-    return await collect_tasks_headless()\\n+    raise NotImplementedError\\n \\n \\n @router.get(\\\"/\\\", response_model=List[TaskRead])\\n\",\"diff --git a/fractal_server/app/api/v1/workflow.py b/fractal_server/app/api/v1/workflow.py\\nindex e401048..cab2dfb 100644\\n--- a/fractal_server/app/api/v1/workflow.py\\n+++ b/fractal_server/app/api/v1/workflow.py\\n@@ -138,7 +138,7 @@ async def add_task_to_workflow(\\n         db=db,\\n     )\\n \\n-    db.commit()\\n+    await db.commit()\\n     await db.refresh(workflow)\\n \\n     return workflow\\n\",\"diff --git a/fractal_server/app/models/models_utils.py b/fractal_server/app/models/models_utils.py\\ndeleted file mode 100644\\nindex 0a0c8f4..0000000\\n--- a/fractal_server/app/models/models_utils.py\\n+++ /dev/null\\n@@ -1,18 +0,0 @@\\n-from collections.abc import MutableMapping\\n-from datetime import datetime\\n-from datetime import timezone\\n-from typing import Any\\n-\\n-\\n-def get_timestamp() -> datetime:\\n-    return datetime.now(tz=timezone.utc)\\n-\\n-\\n-def popget(d: MutableMapping, key: str, default: Any = None) -> Any:\\n-    \\\"\\\"\\\"\\n-    Pop and return mapping item if possible or return default\\n-    \\\"\\\"\\\"\\n-    try:\\n-        return d.pop(key)\\n-    except KeyError:\\n-        return default\\n\",\"diff --git a/fractal_server/app/models/run.py b/fractal_server/app/models/run.py\\nindex a1b50fe..851e708 100644\\n--- a/fractal_server/app/models/run.py\\n+++ b/fractal_server/app/models/run.py\\n@@ -8,8 +8,8 @@ from sqlmodel import Relationship\\n \\n from ...config import get_settings\\n from ...syringe import Inject\\n+from ...utils import get_timestamp\\n from ..schemas import ApplyWorkflowBase\\n-from .models_utils import get_timestamp\\n from .project import Dataset\\n from .project import Project\\n from .workflow import Workflow\\n\",\"diff --git a/fractal_server/app/models/task.py b/fractal_server/app/models/task.py\\nindex 78fe5bd..6b8adf3 100644\\n--- a/fractal_server/app/models/task.py\\n+++ b/fractal_server/app/models/task.py\\n@@ -13,6 +13,7 @@ class Task(_TaskBase, table=True):  # type: ignore\\n     id: Optional[int] = Field(default=None, primary_key=True)\\n     project_id: Optional[int] = Field(foreign_key=\\\"project.id\\\")\\n     default_args: Dict[str, Any] = Field(sa_column=Column(JSON), default={})\\n+    meta: Dict[str, Any] = Field(sa_column=Column(JSON), default={})\\n \\n     @property\\n     def parallelization_level(self) -> Optional[str]:\\n\",\"diff --git a/fractal_server/app/models/workflow.py b/fractal_server/app/models/workflow.py\\nindex 5a57bb3..fd1ff69 100644\\n--- a/fractal_server/app/models/workflow.py\\n+++ b/fractal_server/app/models/workflow.py\\n@@ -10,10 +10,10 @@ from sqlalchemy.types import JSON\\n from sqlmodel import Field\\n from sqlmodel import Relationship\\n \\n+from ...utils import popget\\n from ..db import AsyncSession\\n from ..schemas.workflow import _WorkflowBase\\n from ..schemas.workflow import _WorkflowTaskBase\\n-from .models_utils import popget\\n from .task import Task\\n \\n \\n\",\"diff --git a/fractal_server/app/schemas/__init__.py b/fractal_server/app/schemas/__init__.py\\nindex 29c1673..4994de9 100644\\n--- a/fractal_server/app/schemas/__init__.py\\n+++ b/fractal_server/app/schemas/__init__.py\\n@@ -3,6 +3,7 @@ from typing import Optional\\n \\n from sqlmodel import SQLModel\\n \\n+from .manifest import *  # noqa: F403\\n from .project import *  # noqa: F403\\n from .task import *  # noqa: F403\\n from .workflow import *  # noqa: F403\\n@@ -17,6 +18,7 @@ __all__ = (\\n     + project.__all__  # noqa: F405\\n     + task.__all__  # noqa: F405\\n     + workflow.__all__  # noqa: F405\\n+    + manifest.__all__  # noqa: F405\\n )\\n \\n \\n\",\"diff --git a/fractal_server/app/schemas/manifest.py b/fractal_server/app/schemas/manifest.py\\nnew file mode 100644\\nindex 0000000..1eaaf23\\n--- /dev/null\\n+++ b/fractal_server/app/schemas/manifest.py\\n@@ -0,0 +1,41 @@\\n+from pathlib import Path\\n+from typing import Any\\n+from typing import Dict\\n+from typing import List\\n+from typing import TypeVar\\n+\\n+from pydantic import BaseModel\\n+from pydantic import validator\\n+\\n+\\n+__all__ = (\\\"TaskManifestV1\\\", \\\"ManifestV1\\\")\\n+\\n+\\n+class _TaskManifestBase(BaseModel):\\n+    name: str\\n+    executable: Path\\n+    input_type: str\\n+    output_type: str\\n+    default_args: Dict[str, Any]\\n+    meta: Dict[str, Any]\\n+\\n+\\n+TaskManifestType = TypeVar(\\\"TaskManifestType\\\", bound=_TaskManifestBase)\\n+\\n+\\n+class _ManifestBase(BaseModel):\\n+    manifest_version: str\\n+    task_list: List[TaskManifestType]  # type: ignore\\n+\\n+\\n+class TaskManifestV1(_TaskManifestBase):\\n+    pass\\n+\\n+\\n+class ManifestV1(_ManifestBase):\\n+    task_list: List[TaskManifestV1]\\n+\\n+    @validator(\\\"manifest_version\\\")\\n+    def manifest_version_1(cls, value):\\n+        if value != \\\"1\\\":\\n+            raise ValueError(\\\"Wrong manifest version\\\")\\n\",\"diff --git a/fractal_server/app/schemas/task.py b/fractal_server/app/schemas/task.py\\nindex 429f000..31d2b74 100644\\n--- a/fractal_server/app/schemas/task.py\\n+++ b/fractal_server/app/schemas/task.py\\n@@ -37,6 +37,7 @@ class _TaskBase(SQLModel):\\n     input_type: str\\n     output_type: str\\n     default_args: Dict[str, Any] = Field(default={})\\n+    meta: Dict[str, Any] = Field(default={})\\n \\n     class Config:\\n         arbitrary_types_allowed = True\\n\",\"diff --git a/fractal_server/config.py b/fractal_server/config.py\\nindex 010f76d..9bb2753 100644\\n--- a/fractal_server/config.py\\n+++ b/fractal_server/config.py\\n@@ -119,6 +119,8 @@ class Settings(BaseSettings):\\n     @property\\n     def DATABASE_URL(self):\\n         if self.DB_ENGINE == \\\"sqlite\\\":\\n+            if not self.SQLITE_PATH:\\n+                raise ValueError(\\\"SQLITE_PATH path cannot be None\\\")\\n             sqlite_path = (\\n                 abspath(self.SQLITE_PATH)\\n                 if self.SQLITE_PATH\\n@@ -137,6 +139,8 @@ class Settings(BaseSettings):\\n     @property\\n     def DATABASE_SYNC_URL(self):\\n         if self.DB_ENGINE == \\\"sqlite\\\":\\n+            if not self.SQLITE_PATH:\\n+                raise ValueError(\\\"SQLITE_PATH path cannot be None\\\")\\n             return self.DATABASE_URL.replace(\\\"aiosqlite\\\", \\\"pysqlite\\\")\\n         elif self.DB_ENGINE == \\\"postgres\\\":\\n             return self.DATABASE_URL.replace(\\\"asyncpg\\\", \\\"psycopg2\\\")\\n@@ -144,7 +148,7 @@ class Settings(BaseSettings):\\n     ###########################################################################\\n     # FRACTAL SPECIFIC\\n     ###########################################################################\\n-    # FRACTAL_ROOT: Path = Path(\\\"FRACTAL_ROOT\\\")\\n+    FRACTAL_ROOT: Optional[Path]  # Path = _DEVNULL\\n     RUNNER_BACKEND: str = \\\"process\\\"\\n     RUNNER_ROOT_DIR: Path = Path(\\\"artifacts\\\")\\n \\n@@ -184,8 +188,10 @@ class Settings(BaseSettings):\\n             elif DB_ENGINE == \\\"sqlite\\\":\\n                 SQLITE_PATH: str\\n \\n+            FRACTAL_ROOT: Path\\n+\\n         StrictSettings(**self.dict())\\n \\n \\n-def get_settings(settings=Settings()):\\n+def get_settings(settings=Settings()) -> Settings:\\n     return settings\\n\",\"diff --git a/fractal_server/tasks/__init__.py b/fractal_server/tasks/__init__.py\\nindex 2d20c8e..e69de29 100644\\n--- a/fractal_server/tasks/__init__.py\\n+++ b/fractal_server/tasks/__init__.py\\n@@ -1 +0,0 @@\\n-from .tasks import *  # noqa F403\\n\",\"diff --git a/fractal_server/tasks/collection.py b/fractal_server/tasks/collection.py\\nnew file mode 100644\\nindex 0000000..0fdc873\\n--- /dev/null\\n+++ b/fractal_server/tasks/collection.py\\n@@ -0,0 +1,180 @@\\n+\\\"\\\"\\\"\\n+Copyright 2022 (C) Friedrich Miescher Institute for Biomedical Research and\\n+University of Zurich\\n+\\n+Original authors:\\n+Jacopo Nespolo <jacopo.nespolo@exact-lab.it>\\n+\\n+This file is part of Fractal and was originally developed by eXact lab S.r.l.\\n+<exact-lab.it> under contract with Liberali Lab from the Friedrich Miescher\\n+Institute for Biomedical Research and Pelkmans Lab from the University of\\n+Zurich.\\n+\\\"\\\"\\\"\\n+import json\\n+from pathlib import Path\\n+from typing import List\\n+from typing import Literal\\n+from typing import Optional\\n+from typing import Tuple\\n+\\n+from ..app.schemas import ManifestV1\\n+from ..app.schemas import TaskCreate\\n+from ..config import get_settings\\n+from ..syringe import Inject\\n+from ..utils import execute_command\\n+\\n+\\n+async def create_package_environment(\\n+    *,\\n+    package: str,\\n+    version: Optional[str],\\n+    user: str = \\\".fractal\\\",\\n+    python_version: str = \\\"3.8\\\",\\n+    env_type: Literal[\\\"venv\\\"] = \\\"venv\\\",\\n+) -> List[TaskCreate]:\\n+    \\\"\\\"\\\"\\n+    Create environment and install package\\n+    \\\"\\\"\\\"\\n+    settings = Inject(get_settings)\\n+    # assemble installation path\\n+    package_dir = f\\\"{package}{version or ''}\\\"\\n+    if settings.FRACTAL_ROOT:\\n+        env_path = settings.FRACTAL_ROOT / user / package_dir\\n+    # TODO check the access right of the env_path and subdirs\\n+    env_path.mkdir(exist_ok=True, parents=True)\\n+\\n+    if env_type == \\\"venv\\\":\\n+        python_bin, package_root = await _create_venv_install_package(\\n+            path=env_path,\\n+            package=package,\\n+            version=version,\\n+            python_version=python_version,\\n+        )\\n+    else:\\n+        raise ValueError(f\\\"Environment type {env_type} not supported\\\")\\n+\\n+    source = f\\\"pypi:{package}=={version}\\\"\\n+    task_list = load_manifest(\\n+        package_root=package_root,\\n+        python_bin=python_bin,\\n+        source=source,\\n+    )\\n+    return task_list\\n+\\n+\\n+def load_manifest(\\n+    package_root: Path,\\n+    python_bin: Path,\\n+    source: str,\\n+) -> List[TaskCreate]:\\n+\\n+    manifest_file = package_root / \\\"__FRACTAL__MANIFEST__.json\\\"\\n+    with manifest_file.open(\\\"r\\\") as f:\\n+        manifest_dict = json.load(f)\\n+\\n+    task_list = []\\n+    if str(manifest_dict[\\\"manifest_version\\\"]) == \\\"1\\\":\\n+        manifest = ManifestV1(**manifest_dict)\\n+\\n+        for t in manifest.task_list:\\n+            task_executable = package_root / t.executable\\n+            if not task_executable.exists():\\n+                raise FileNotFoundError(\\n+                    f\\\"Cannot find executable `{task_executable}` \\\"\\n+                    f\\\"for task `{t.name}`\\\"\\n+                )\\n+            cmd = f\\\"{python_bin.as_posix()} {task_executable.as_posix()}\\\"\\n+            this_task = TaskCreate(**t.dict(), command=cmd, source=source)\\n+            task_list.append(this_task)\\n+    return task_list\\n+\\n+\\n+async def _create_venv_install_package(\\n+    *,\\n+    path: Path,\\n+    package: str,\\n+    version: Optional[str],\\n+    python_version: str,\\n+) -> Tuple[Path, Path]:\\n+    \\\"\\\"\\\"\\n+    Create venv and install package\\n+\\n+    Parameters\\n+    ----------\\n+    path : Path\\n+        the directory in which to create the environment\\n+    package : str\\n+        package name\\n+    version : str, optional\\n+        package version\\n+    python_version : str\\n+        version of the Python interpreter\\n+\\n+    Return\\n+    ------\\n+    python_bin: Path\\n+        path to venv's python interpreter\\n+    package_root : Path\\n+        the location of the package manifest\\n+    \\\"\\\"\\\"\\n+    python_bin = await _init_venv(path=path, python_version=python_version)\\n+    package_root = await _pip_install(\\n+        venv_path=path, package=package, version=version\\n+    )\\n+    return python_bin, package_root\\n+\\n+\\n+async def _init_venv(*, path: Path, python_version: str) -> Path:\\n+    \\\"\\\"\\\"\\n+    Set a virtual environment at `path/venv`\\n+\\n+    Parameters\\n+    ----------\\n+    path : Path\\n+        path to directory in which to set up the virtual environment\\n+    python_version : str, default='3.8'\\n+        Python version the virtual environment will be based upon\\n+\\n+    Return\\n+    ------\\n+    python_bin : Path\\n+        path to python interpreter\\n+    \\\"\\\"\\\"\\n+    interpreter = f\\\"python{python_version}\\\"\\n+    await execute_command(cwd=path, command=f\\\"{interpreter} -m venv venv\\\")\\n+    return path / \\\"venv/bin/python\\\"\\n+\\n+\\n+async def _pip_install(\\n+    venv_path: Path, package: str, version: Optional[str]\\n+) -> Path:\\n+    \\\"\\\"\\\"\\n+    Install package in venv\\n+\\n+    Return\\n+    ------\\n+    package_root : Path\\n+        the location of the package manifest\\n+    \\\"\\\"\\\"\\n+    pip = venv_path / \\\"venv/bin/pip\\\"\\n+    version_string = f\\\"=={version}\\\" if version else \\\"\\\"\\n+\\n+    cmd_install = f\\\"{pip} install {package}{version_string}\\\"\\n+    cmd_inspect = f\\\"{pip} show -f {package}\\\"\\n+\\n+    await execute_command(cwd=venv_path, command=cmd_install)\\n+    stdout_inspect = await execute_command(cwd=venv_path, command=cmd_inspect)\\n+\\n+    location = Path(\\n+        next(\\n+            line.split()[-1]\\n+            for line in stdout_inspect.split(\\\"\\\\n\\\")\\n+            if line.startswith(\\\"Location:\\\")\\n+        )\\n+    )\\n+    package_root = location / package.replace(\\\"-\\\", \\\"_\\\")\\n+    if not package_root.exists():\\n+        raise RuntimeError(\\n+            \\\"Could not determine package installation location.\\\"\\n+        )\\n+    return package_root\\n\",\"diff --git a/fractal_server/tasks/tasks.py b/fractal_server/tasks/tasks.py\\ndeleted file mode 100644\\nindex 6b7aa19..0000000\\n--- a/fractal_server/tasks/tasks.py\\n+++ /dev/null\\n@@ -1,8 +0,0 @@\\n-def collect_tasks():\\n-    from fractal_tasks_core import __FRACTAL_MANIFEST__\\n-\\n-    return (\\n-        task_manifest\\n-        for task_manifest in __FRACTAL_MANIFEST__\\n-        if \\\"task\\\" in task_manifest[\\\"resource_type\\\"]\\n-    )\\n\"]", "test_patch": "[\"diff --git a/fractal_server/app/db/__init__.py b/fractal_server/app/db/__init__.py\\nindex 05085fe..e4f7a91 100644\\n--- a/fractal_server/app/db/__init__.py\\n+++ b/fractal_server/app/db/__init__.py\\n@@ -7,7 +7,7 @@ from sqlalchemy.ext.asyncio import create_async_engine\\n from sqlalchemy.orm import Session as DBSyncSession\\n from sqlalchemy.orm import sessionmaker\\n \\n-from ...config import Settings\\n+from ...config import get_settings\\n from ...syringe import Inject\\n \\n \\\"\\\"\\\"\\n@@ -15,41 +15,55 @@ Losely adapted from https://testdriven.io/blog/fastapi-sqlmodel/#async-sqlmodel\\n \\\"\\\"\\\"\\n \\n \\n-def get_async_engine():\\n-    settings: Settings = Inject(Settings)\\n-    return create_async_engine(\\n-        settings.DATABASE_URL, echo=settings.DB_ECHO, future=True\\n-    )\\n-\\n-\\n-def get_sync_engine():\\n-    settings: Settings = Inject(Settings)\\n-    return create_engine(\\n-        settings.DATABASE_SYNC_URL,\\n-        echo=settings.DB_ECHO,\\n-        future=True,\\n-        connect_args={\\\"check_same_thread\\\": False},\\n-    )\\n-\\n-\\n-engine = get_async_engine()\\n-engine_sync = get_sync_engine()\\n-\\n-async_session_maker = sessionmaker(\\n-    engine, class_=AsyncSession, expire_on_commit=False\\n-)\\n-\\n-\\n-sync_session_maker = sessionmaker(\\n-    bind=engine_sync, autocommit=False, autoflush=False\\n-)\\n-\\n-\\n-async def get_db() -> AsyncGenerator[AsyncSession, None]:\\n-    async with async_session_maker() as async_session:\\n-        yield async_session\\n-\\n-\\n-def get_sync_db() -> Generator[DBSyncSession, None, None]:\\n-    with sync_session_maker() as sync_session:\\n-        yield sync_session\\n+class DB:\\n+    @classmethod\\n+    def engine_async(cls):\\n+        try:\\n+            return cls._engine_async\\n+        except AttributeError:\\n+            cls.set_db()\\n+            return cls._engine_async\\n+\\n+    @classmethod\\n+    def engine_sync(cls):\\n+        try:\\n+            return cls._engine_sync\\n+        except AttributeError:\\n+            cls.set_db()\\n+            return cls._engine_sync\\n+\\n+    @classmethod\\n+    def set_db(cls):\\n+        settings = Inject(get_settings)\\n+\\n+        cls._engine_async = create_async_engine(\\n+            settings.DATABASE_URL, echo=settings.DB_ECHO, future=True\\n+        )\\n+        cls._engine_sync = create_engine(\\n+            settings.DATABASE_SYNC_URL,\\n+            echo=settings.DB_ECHO,\\n+            future=True,\\n+            connect_args={\\\"check_same_thread\\\": False},\\n+        )\\n+\\n+        cls._async_session_maker = sessionmaker(\\n+            cls._engine_async, class_=AsyncSession, expire_on_commit=False\\n+        )\\n+\\n+        cls._sync_session_maker = sessionmaker(\\n+            bind=cls._engine_sync, autocommit=False, autoflush=False\\n+        )\\n+\\n+    @classmethod\\n+    async def get_db(cls) -> AsyncGenerator[AsyncSession, None]:\\n+        async with cls._async_session_maker() as async_session:\\n+            yield async_session\\n+\\n+    @classmethod\\n+    def get_sync_db(cls) -> Generator[DBSyncSession, None, None]:\\n+        with cls._sync_session_maker() as sync_session:\\n+            yield sync_session\\n+\\n+\\n+get_db = DB.get_db\\n+get_sync_db = DB.get_sync_db\\n\",\"diff --git a/fractal_server/utils.py b/fractal_server/utils.py\\nindex 5eba24d..96d4ddc 100644\\n--- a/fractal_server/utils.py\\n+++ b/fractal_server/utils.py\\n@@ -10,16 +10,38 @@ This file is part of Fractal and was originally developed by eXact lab S.r.l.\\n Institute for Biomedical Research and Pelkmans Lab from the University of\\n Zurich.\\n \\\"\\\"\\\"\\n+import asyncio\\n+from collections.abc import MutableMapping\\n+from datetime import datetime\\n+from datetime import timezone\\n+from pathlib import Path\\n+from shlex import split as shlex_split\\n+from typing import Any\\n from warnings import warn as _warn\\n \\n from .config import Settings\\n from .syringe import Inject\\n \\n \\n-def warn(message, settings: Settings = Inject(Settings)):\\n+def get_timestamp() -> datetime:\\n+    return datetime.now(tz=timezone.utc)\\n+\\n+\\n+def popget(d: MutableMapping, key: str, default: Any = None) -> Any:\\n+    \\\"\\\"\\\"\\n+    Pop and return mapping item if possible or return default\\n+    \\\"\\\"\\\"\\n+    try:\\n+        return d.pop(key)\\n+    except KeyError:\\n+        return default\\n+\\n+\\n+def warn(message):\\n     \\\"\\\"\\\"\\n     Make sure that warnings do not make their way to staing and production\\n     \\\"\\\"\\\"\\n+    settings = Inject(Settings)\\n     if settings.DEPLOYMENT_TYPE in [\\\"testing\\\", \\\"development\\\"]:\\n         _warn(message, RuntimeWarning)\\n     else:\\n@@ -28,3 +50,38 @@ def warn(message, settings: Settings = Inject(Settings)):\\n \\n def slugify(value: str):\\n     return value.lower().replace(\\\" \\\", \\\"_\\\")\\n+\\n+\\n+async def execute_command(*, cwd: Path, command: str) -> str:\\n+    \\\"\\\"\\\"\\n+    Execute arbitrary command\\n+\\n+    If the command returns a return code different from zero, a RuntimeError\\n+    containing the stderr is raised.\\n+\\n+    Parameters\\n+    ----------\\n+    cwd : Path\\n+        the working directory for the command execution\\n+    command : str\\n+        the command to execute\\n+\\n+    Return\\n+    ------\\n+    stdout : str\\n+        the stdout from the command execution\\n+    \\\"\\\"\\\"\\n+    command_split = shlex_split(command)\\n+    cmd, *args = command_split\\n+\\n+    proc = await asyncio.create_subprocess_exec(\\n+        cmd,\\n+        *args,\\n+        stdout=asyncio.subprocess.PIPE,\\n+        stderr=asyncio.subprocess.PIPE,\\n+        cwd=cwd,\\n+    )\\n+    stdout, stderr = await proc.communicate()\\n+    if proc.returncode != 0:\\n+        raise RuntimeError(stderr.decode(\\\"utf-8\\\"))\\n+    return stdout.decode(\\\"utf-8\\\")\\n\",\"diff --git a/tests/fixtures_server.py b/tests/fixtures_server.py\\nindex f93f4db..ef70a1e 100644\\n--- a/tests/fixtures_server.py\\n+++ b/tests/fixtures_server.py\\n@@ -13,6 +13,7 @@ Zurich.\\n import asyncio\\n from dataclasses import dataclass\\n from dataclasses import field\\n+from pathlib import Path\\n from typing import Any\\n from typing import AsyncGenerator\\n from typing import List\\n@@ -33,19 +34,25 @@ from fractal_server.config import Settings\\n from fractal_server.syringe import Inject\\n \\n \\n-def get_patched_settings():\\n+def get_patched_settings(temp_path: Path):\\n     settings = Settings()\\n     settings.JWT_SECRET_KEY = \\\"secret_key\\\"\\n     settings.DEPLOYMENT_TYPE = \\\"development\\\"\\n     settings.DB_ENGINE = \\\"sqlite\\\"\\n-    settings.SQLITE_PATH = \\\"_test.db?mode=memory&cache=shared\\\"\\n+    settings.SQLITE_PATH = (\\n+        f\\\"{temp_path.as_posix()}/_test.db?mode=memory&cache=shared\\\"\\n+    )\\n+    settings.FRACTAL_ROOT = temp_path\\n     return settings\\n \\n \\n-@pytest.fixture(scope=\\\"session\\\")\\n-def override_settings():\\n+@pytest.fixture(scope=\\\"session\\\", autouse=True)\\n+def override_settings(tmp_path_factory):\\n+    def _get_settings():\\n+        return get_patched_settings(tmp_path_factory.mktemp(\\\"fractal_root\\\"))\\n+\\n     debug(f\\\"overriding {get_settings} with {get_patched_settings}\\\")\\n-    Inject.override(get_settings, get_patched_settings)\\n+    Inject.override(get_settings, _get_settings)\\n     try:\\n         yield\\n     finally:\\n@@ -88,16 +95,16 @@ def event_loop():\\n \\n @pytest.fixture(scope=\\\"session\\\")\\n async def db_engine(override_settings) -> AsyncGenerator[AsyncEngine, None]:\\n-    from fractal_server.app.db import engine\\n+    from fractal_server.app.db import DB\\n \\n-    yield engine\\n+    yield DB.engine_async()\\n \\n \\n @pytest.fixture(scope=\\\"session\\\")\\n def db_sync_engine(override_settings):\\n-    from fractal_server.app.db import engine_sync\\n+    from fractal_server.app.db import DB\\n \\n-    yield engine_sync\\n+    yield DB.engine_sync()\\n \\n \\n @pytest.fixture\\n\",\"diff --git a/tests/test_db.py b/tests/test_db.py\\nindex b05a03b..9455a27 100644\\n--- a/tests/test_db.py\\n+++ b/tests/test_db.py\\n@@ -6,6 +6,8 @@ async def test_db_connection(db):\\n     assert db.is_active\\n     # test bound\\n     assert db.get_bind()\\n+    debug(db.get_bind().url.database)\\n+    assert db.get_bind().url.database is not None\\n \\n     from sqlmodel import select\\n     from fractal_server.app.models.security import UserOAuth\\n\",\"diff --git a/tests/test_task_api.py b/tests/test_task_api.py\\nindex 8b7ae93..69484b9 100644\\n--- a/tests/test_task_api.py\\n+++ b/tests/test_task_api.py\\n@@ -1,59 +1,6 @@\\n-import pytest\\n from devtools import debug\\n-from sqlmodel import select\\n \\n-from fractal_server.app.models import Task\\n from fractal_server.app.models import TaskCreate\\n-from fractal_server.tasks import collect_tasks\\n-\\n-try:\\n-    from fractal_tasks_core import __FRACTAL_MANIFEST__\\n-\\n-    HAS_TASK_CORE = True\\n-    N_CORE_TASKS = len(__FRACTAL_MANIFEST__)\\n-except ImportError:\\n-    HAS_TASK_CORE = False\\n-\\n-\\n-@pytest.mark.skipif(\\n-    not HAS_TASK_CORE, reason=\\\"fractal-tasks-core not installed\\\"\\n-)\\n-async def test_collection(db, client, MockCurrentUser):\\n-    \\\"\\\"\\\"\\n-    GIVEN a running server\\n-    WHEN the `POST task/collect/` endpoint is called\\n-    THEN the table `Task` is updated accordingly, collecting the available\\n-         tasks\\n-    \\\"\\\"\\\"\\n-    res = await db.execute(select(Task))\\n-    n_tasks = len(res.scalars().all())  # FIXME: run query server side!\\n-    assert n_tasks == 0\\n-\\n-    n_target = len(list(collect_tasks()))\\n-\\n-    async with MockCurrentUser(persist=True):\\n-        res = await client.post(\\\"api/v1/task/collect/\\\")\\n-        assert res.status_code == 201\\n-        data = res.json()\\n-        debug(data)\\n-        assert data[\\\"inserted\\\"] == N_CORE_TASKS\\n-        assert data[\\\"updated\\\"] == 0\\n-\\n-    res = await db.execute(select(Task))\\n-    n_tasks = len(res.scalars().all())  # FIXME: run query server side!\\n-    assert n_tasks == n_target\\n-\\n-    # Check for idempotency\\n-    async with MockCurrentUser(persist=True):\\n-        res = await client.post(\\\"api/v1/task/collect/\\\")\\n-        data = res.json()\\n-        assert res.status_code == 201\\n-        assert data[\\\"inserted\\\"] == 0\\n-        assert data[\\\"updated\\\"] == N_CORE_TASKS\\n-\\n-    res = await db.execute(select(Task))\\n-    n_tasks = len(res.scalars().all())  # FIXME: run query server side!\\n-    assert n_tasks == n_target\\n \\n \\n async def test_task_get_list(db, client, task_factory, MockCurrentUser):\\n\",\"diff --git a/tests/test_task_collection_pypi.py b/tests/test_task_collection_pypi.py\\nnew file mode 100644\\nindex 0000000..cbb9da4\\n--- /dev/null\\n+++ b/tests/test_task_collection_pypi.py\\n@@ -0,0 +1,90 @@\\n+import json\\n+\\n+from devtools import debug\\n+\\n+from fractal_server.tasks.collection import _init_venv\\n+from fractal_server.tasks.collection import _pip_install\\n+from fractal_server.tasks.collection import load_manifest\\n+\\n+\\n+async def test_init_venv(tmp_path):\\n+    \\\"\\\"\\\"\\n+    GIVEN a path and a python version\\n+    WHEN _init_venv() is called\\n+    THEN a python venv is initialised at path\\n+    \\\"\\\"\\\"\\n+    venv_path = tmp_path / \\\"fractal_test\\\"\\n+    venv_path.mkdir(exist_ok=True, parents=True)\\n+\\n+    python_bin = await _init_venv(path=venv_path, python_version=\\\"3.8\\\")\\n+\\n+    assert venv_path.exists()\\n+    assert (venv_path / \\\"venv\\\").exists()\\n+    assert (venv_path / \\\"venv/bin/python\\\").exists()\\n+    assert (venv_path / \\\"venv/bin/pip\\\").exists()\\n+    assert python_bin.exists()\\n+    assert python_bin == venv_path / \\\"venv/bin/python\\\"\\n+\\n+\\n+async def test_pip_install(tmp_path):\\n+    \\\"\\\"\\\"\\n+    GIVEN a package name and version and a path with a venv\\n+    WHEN _pip_install() is called\\n+    THEN the package is installed in the venv and the package installation\\n+         location is returned\\n+    \\\"\\\"\\\"\\n+    PACKAGE = \\\"devtools\\\"\\n+    VERSION = \\\"0.8.0\\\"\\n+    venv_path = tmp_path / \\\"fractal_test\\\" / f\\\"{PACKAGE}{VERSION}\\\"\\n+    venv_path.mkdir(exist_ok=True, parents=True)\\n+\\n+    await _init_venv(path=venv_path, python_version=\\\"3.8\\\")\\n+    location = await _pip_install(\\n+        venv_path=venv_path, package=PACKAGE, version=VERSION\\n+    )\\n+    debug(location)\\n+    assert PACKAGE in location.as_posix()\\n+\\n+\\n+def test_load_manifest(tmp_path):\\n+    TASK_EXECUTABLE = \\\"task0.py\\\"\\n+    __FRACTAL_MANIFEST__ = dict(\\n+        manifest_version=1,\\n+        task_list=[\\n+            dict(\\n+                name=\\\"task0\\\",\\n+                executable=TASK_EXECUTABLE,\\n+                input_type=\\\"Any\\\",\\n+                output_type=\\\"Any\\\",\\n+                default_args=dict(a=1, b=\\\"c\\\"),\\n+                meta=dict(\\n+                    min_memory=\\\"2G\\\", requires_gpu=True, version=\\\"custom\\\"\\n+                ),\\n+            )\\n+        ],\\n+    )\\n+\\n+    package_root = tmp_path / \\\"package\\\"\\n+    package_root.mkdir(exist_ok=True, parents=True)\\n+    manifest_path = package_root / \\\"__FRACTAL__MANIFEST__.json\\\"\\n+    executable_path = package_root / TASK_EXECUTABLE\\n+    python_bin = package_root / \\\"my/custon/python_bin\\\"\\n+    SOURCE = \\\"my:source==123\\\"\\n+\\n+    with executable_path.open(\\\"w\\\") as f:\\n+        f.write(\\\"test_executable\\\")\\n+\\n+    with manifest_path.open(\\\"w\\\") as f:\\n+        json.dump(__FRACTAL_MANIFEST__, f)\\n+\\n+    task_list = load_manifest(\\n+        package_root=package_root,\\n+        python_bin=python_bin,\\n+        source=SOURCE,\\n+    )\\n+\\n+    debug(task_list)\\n+\\n+    assert len(task_list) == 1\\n+    for t in task_list:\\n+        assert t.source == SOURCE\\n\",\"diff --git a/tests/test_unit_settings.py b/tests/test_unit_settings.py\\nindex a4c9dea..5ed62ce 100644\\n--- a/tests/test_unit_settings.py\\n+++ b/tests/test_unit_settings.py\\n@@ -1,3 +1,5 @@\\n+from pathlib import Path\\n+\\n import pytest\\n from devtools import debug\\n from pydantic import ValidationError\\n@@ -26,6 +28,7 @@ def test_settings_injection(override_settings):\\n                 DEPLOYMENT_TYPE=\\\"development\\\",\\n                 JWT_SECRET_KEY=\\\"secret\\\",\\n                 SQLITE_PATH=\\\"path\\\",\\n+                FRACTAL_ROOT=Path(\\\"/tmp\\\"),\\n             ),\\n             False,\\n         ),\\n\",\"diff --git a/tests/test_unit_utils.py b/tests/test_unit_utils.py\\nindex df2c96c..e2442bb 100644\\n--- a/tests/test_unit_utils.py\\n+++ b/tests/test_unit_utils.py\\n@@ -1,8 +1,11 @@\\n from datetime import timezone\\n+from pathlib import Path\\n \\n+import pytest\\n from devtools import debug\\n \\n-from fractal_server.app.models.models_utils import get_timestamp\\n+from fractal_server.utils import execute_command\\n+from fractal_server.utils import get_timestamp\\n \\n \\n def test_timestamp():\\n@@ -15,3 +18,24 @@ def test_timestamp():\\n     debug(ts)\\n     assert ts\\n     assert ts.tzinfo is timezone.utc\\n+\\n+\\n+async def test_execute_command(tmp_path):\\n+    \\\"\\\"\\\"\\n+    GIVEN the `pwd` command and a path\\n+    WHEN executed via _execute_command with the path as working directory\\n+    THEN the command returns the full path\\n+    \\\"\\\"\\\"\\n+    res = await execute_command(cwd=tmp_path, command=\\\"pwd\\\")\\n+    assert res.strip() == tmp_path.as_posix()\\n+\\n+\\n+async def test_execute_command_fail():\\n+    \\\"\\\"\\\"\\n+    GIVEN a unix command that fails\\n+    WHEN the command is executed via _execute_command\\n+    THEN an error is raised\\n+    \\\"\\\"\\\"\\n+    with pytest.raises(RuntimeError) as e:\\n+        await execute_command(cwd=Path(\\\"/tmp\\\"), command=\\\"ls __NOEXIST__\\\")\\n+    debug(e.value)\"]", "hints_text": ""}

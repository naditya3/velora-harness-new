{"instance_id": "1778972493000181", "repo": "unitaryfund/mitiq", "base_commit": "a2964908db14df6e8838ee00a20d7414fedc9d13", "problem_statement": "Support dictionary with counts in the MeasurementResult class:\\n\\r\\n## Issue Description\\r\\n\\r\\nThe [`MeasurementResult`](https://mitiq--1514.org.readthedocs.build/en/1514/_modules/mitiq/_typing.html#MeasurementResult) class in Mitiq represents the measured bitstrings obtained in a quantum computation.\\r\\nAt the moment it can only be initialized with an explicit list of bitstrings (one for each shot).\\r\\n\\r\\nAnother compact way of representing measurement results is via a dictionary of counts.\\r\\nE.g.  `[\"01\", \"11\", \"11\", \"11\"]  ` can be represented as  --->  `{\"01\": 1, \"11\": 3 }`\\r\\nThis method is used by most quantum software libraries.\\r\\n\\r\\n## Proposed Solution\\r\\n\\r\\n- It would be good if the `MeasurementResult` class could be initialized **also** by a dictionary (instead of a list of bitstrings). \\r\\n\\r\\n- It would be good if the `MeasurementResult` class could return results as a dicitonar (e.g. with a `self.as_dict()` method).\\r\\n\\r\\n- It would be good if the `MeasurementResult` class used always a dictionary for storing data independently from the initialization input type. Storing a dictionary is typically more efficient than storing raw bitstrings and, for a large number of shots, it can make a big  difference. \\r\\n", "FAIL_TO_PASS": ["mitiq/tests/test_measurement_result.py::test_measurement_result_with_strings[qubit_indices1]", "mitiq/tests/test_measurement_result.py::test_measurement_result_from_counts[qubit_indices1]", "mitiq/tests/test_measurement_result.py::test_measurement_repr_", "mitiq/tests/test_measurement_result.py::test_measurement_result_to_from_dictionary", "mitiq/tests/test_measurement_result.py::test_measurement_result_not_bits", "mitiq/tests/test_measurement_result.py::test_measurement_result_from_counts[qubit_indices0]", "mitiq/tests/test_measurement_result.py::test_measurement_result_with_strings[qubit_indices0]", "mitiq/tests/test_measurement_result.py::test_filter_qubits", "mitiq/tests/test_measurement_result.py::test_measurement_result_get_counts"], "PASS_TO_PASS": [], "language": "python", "test_command": "source /saved/ENV || source /saved/*/ENV && pytest --no-header -rA --tb=no -p no:cacheprovider --continue-on-collection-errors", "test_output_parser": "python/parse_log_pytest_v3", "image_storage_uri": "vmvm-registry.fbinfra.net/repomate_image_activ_pytest/unitaryfund_mitiq:a2964908db14df6e8838ee00a20d7414fedc9d13", "patch": "[\"diff --git a/docs/source/apidoc.myst b/docs/source/apidoc.myst\\nindex 62e2058..6d6d589 100644\\n--- a/docs/source/apidoc.myst\\n+++ b/docs/source/apidoc.myst\\n@@ -35,6 +35,26 @@\\n    :members:\\n ```\\n \\n+## Circuit types and result types\\n+\\n+```{eval-rst}\\n+.. autoclass:: mitiq.typing.QPROGRAM\\n+```\\n+\\n+```{eval-rst}\\n+.. autoclass:: mitiq.typing.QuantumResult\\n+```\\n+\\n+```{eval-rst}\\n+.. autoclass:: mitiq.typing.Bitstring\\n+```\\n+\\n+```{eval-rst}\\n+.. autoclass:: mitiq.typing.MeasurementResult\\n+   :members:\\n+```\\n+\\n+\\n ## Clifford Data Regression\\n \\n ### Clifford Data Regression (High-Level Tools)\\n@@ -192,12 +212,6 @@ See Ref. :cite:`Czarnik_2021_Quantum` for more details on these methods.\\n \\n ## Readout-Error Mitigation\\n \\n-### Measurement Result\\n-```{eval-rst}\\n-.. autoclass:: mitiq._typing.MeasurementResult\\n-   :members:\\n-```\\n-\\n ### Post-selection\\n ```{eval-rst}\\n .. automodule:: mitiq.rem.post_select\\n\",\"diff --git a/docs/source/guide/frontends-backends.myst b/docs/source/guide/frontends-backends.myst\\nindex dd7e981..6980198 100644\\n--- a/docs/source/guide/frontends-backends.myst\\n+++ b/docs/source/guide/frontends-backends.myst\\n@@ -16,7 +16,7 @@ kernelspec:\\n \\n ## Mitiq-specific types\\n \\n-There are a number of types that are specific to Mitiq defined in `mitiq._typing`, the most important being `mitiq.QPROGRAM` and {class}`.QuantumResult`.\\n+There are a number of types that are specific to Mitiq, the most important being `mitiq.QPROGRAM` and {class}`.QuantumResult`.\\n These types are both unions of a number of other types that make it easier to annotate other functions in Mitiq, independent of the user choice of frameworks.\\n The Mitiq-defined type `mitiq.QPROGRAM` uses any of the program types from the supported platforms that are installed on the system.\\n For example, if you haven't installed PyQuil, then even though Mitiq supports it, you will not be able to use PyQuil programs in Mitiq until it is installed.\\n@@ -25,7 +25,7 @@ For example, if you haven't installed PyQuil, then even though Mitiq supports it\\n Mitiq only supports non-adaptive quantum programs without classical control flow or mid-circuit measurements. This class of programs is more commonly known as _circuits_ by many other tools and frameworks in quantum computing.\\n ```\\n \\n-The Mitiq-defined type {class}`.QuantumResult` is a union of the types defined in `mitiq._typing` that are used to represent the results of running a quantum program.\\n+The Mitiq-defined type {class}`.QuantumResult` is a union of the types defined in `mitiq.typing` that are used to represent the results of running a quantum program.\\n For example, for hardware, the result can be a list of bitstrings (representing raw measurements) or an expectation value expressed as a real number.\\n For simulators, more information can be made available like the resulting density matrix, which is a valid object of the {class}`.QuantumResult` type.\\n \\n\",\"diff --git a/mitiq/__init__.py b/mitiq/__init__.py\\nindex d944c59..934d82d 100644\\n--- a/mitiq/__init__.py\\n+++ b/mitiq/__init__.py\\n@@ -14,11 +14,13 @@\\n # along with this program.  If not, see <https://www.gnu.org/licenses/>.\\n \\n # Quantum computer input/output.\\n-from mitiq._typing import (\\n+from mitiq.typing import (\\n     SUPPORTED_PROGRAM_TYPES,\\n     QPROGRAM,\\n     MeasurementResult,\\n     QuantumResult,\\n+    Bitstring,\\n+    QuantumResult,\\n )\\n \\n # Executors and observables.\\n\",\"diff --git a/mitiq/_typing.py b/mitiq/_typing.py\\ndeleted file mode 100644\\nindex d5ef41a..0000000\\n--- a/mitiq/_typing.py\\n+++ /dev/null\\n@@ -1,134 +0,0 @@\\n-# Copyright (C) 2020 Unitary Fund\\n-#\\n-# This program is free software: you can redistribute it and/or modify\\n-# it under the terms of the GNU General Public License as published by\\n-# the Free Software Foundation, either version 3 of the License, or\\n-# (at your option) any later version.\\n-#\\n-# This program is distributed in the hope that it will be useful,\\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n-# GNU General Public License for more details.\\n-#\\n-# You should have received a copy of the GNU General Public License\\n-# along with this program.  If not, see <https://www.gnu.org/licenses/>.\\n-\\n-\\\"\\\"\\\"Defines input / output types for a quantum computer (simulator):\\n-\\n-  * SUPPORTED_PROGRAM_TYPES: All supported packages / circuits which Mitiq can\\n-       interface with,\\n-  * QPROGRAM: All supported packages / circuits which are installed in the\\n-       environment Mitiq is run in, and\\n-  * QuantumResult: An object returned by a quantum computer (simulator) running\\n-       a quantum program from which expectation values to be mitigated can be\\n-       computed. Note this includes expectation values themselves.\\n-\\\"\\\"\\\"\\n-from dataclasses import dataclass\\n-from typing import cast, Iterable, List, Optional, Tuple, Union\\n-\\n-import numpy as np\\n-import numpy.typing as npt\\n-\\n-from cirq import Circuit as _Circuit\\n-\\n-\\n-# Supported quantum programs.\\n-SUPPORTED_PROGRAM_TYPES = {\\n-    \\\"cirq\\\": \\\"Circuit\\\",\\n-    \\\"pyquil\\\": \\\"Program\\\",\\n-    \\\"qiskit\\\": \\\"QuantumCircuit\\\",\\n-    \\\"braket\\\": \\\"Circuit\\\",\\n-    \\\"pennylane\\\": \\\"QuantumTape\\\",\\n-}\\n-\\n-\\n-try:\\n-    from pyquil import Program as _Program\\n-except ImportError:  # pragma: no cover\\n-    _Program = _Circuit  # type: ignore\\n-\\n-try:\\n-    from qiskit import QuantumCircuit as _QuantumCircuit\\n-except ImportError:  # pragma: no cover\\n-    _QuantumCircuit = _Circuit\\n-\\n-try:\\n-    from braket.circuits import Circuit as _BKCircuit\\n-except ImportError:  # pragma: no cover\\n-    _BKCircuit = _Circuit\\n-\\n-try:\\n-    from pennylane.tape import QuantumTape as _QuantumTape\\n-except ImportError:  # pragma: no cover\\n-    _QuantumTape = _Circuit\\n-\\n-\\n-# Supported + installed quantum programs.\\n-QPROGRAM = Union[_Circuit, _Program, _QuantumCircuit, _BKCircuit, _QuantumTape]\\n-\\n-\\n-# Define MeasurementResult, a result obtained by measuring qubits on a quantum\\n-# computer.\\n-Bitstring = List[int]\\n-\\n-\\n-@dataclass\\n-class MeasurementResult:\\n-    \\\"\\\"\\\"Bitstrings sampled from a quantum computer.\\\"\\\"\\\"\\n-\\n-    result: List[Bitstring]\\n-    qubit_indices: Optional[Tuple[int, ...]] = None\\n-\\n-    def __post_init__(self) -> None:\\n-        if not set(b for bits in self.result for b in bits).issubset({0, 1}):\\n-            raise ValueError(\\n-                \\\"MeasurementResult contains elements which are not (0, 1).\\\"\\n-            )\\n-\\n-        self._bitstrings = np.array(self.result)\\n-        if isinstance(self.result, np.ndarray):\\n-            self.result = cast(List[Bitstring], self.result.tolist())\\n-\\n-        if not self.qubit_indices:\\n-            self.qubit_indices = tuple(range(self.nqubits))\\n-        else:\\n-            if len(self.qubit_indices) != self.nqubits:\\n-                raise ValueError(\\n-                    f\\\"MeasurementResult has {self.nqubits} qubit(s) but there \\\"\\n-                    f\\\"are {len(self.qubit_indices)} `qubit_indices`.\\\"\\n-                )\\n-        self._measurements = dict(zip(self.qubit_indices, self._bitstrings.T))\\n-\\n-    @property\\n-    def shots(self) -> int:\\n-        return self._bitstrings.shape[0]\\n-\\n-    @property\\n-    def nqubits(self) -> int:\\n-        return (\\n-            self._bitstrings.shape[1]\\n-            if len(self._bitstrings.shape) >= 2\\n-            else 0\\n-        )\\n-\\n-    @property\\n-    def asarray(self) -> npt.NDArray[np.int64]:\\n-        return self._bitstrings\\n-\\n-    def __getitem__(self, indices: List[int]) -> npt.NDArray[np.int64]:\\n-        return np.array([self._measurements[i] for i in indices]).T\\n-\\n-    def __iter__(self) -> Iterable[Bitstring]:\\n-        yield from self.result\\n-\\n-\\n-# An `executor` function inputs a quantum program and outputs an object from\\n-# which expectation values can be computed. Explicitly, this object can be one\\n-# of the following types:\\n-QuantumResult = Union[\\n-    float,  # The expectation value itself.\\n-    MeasurementResult,  # Sampled bitstrings.\\n-    np.ndarray,  # Density matrix.\\n-    # TODO: Support the following:\\n-    # Sequence[np.ndarray],  # Wavefunctions sampled via quantum trajectories.\\n-]\\n\",\"diff --git a/mitiq/benchmarks/mirror_circuits.py b/mitiq/benchmarks/mirror_circuits.py\\nindex 2cb1979..d3d126c 100644\\n--- a/mitiq/benchmarks/mirror_circuits.py\\n+++ b/mitiq/benchmarks/mirror_circuits.py\\n@@ -24,8 +24,7 @@ import networkx as nx\\n import cirq\\n from cirq.experiments.qubit_characterizations import _single_qubit_cliffords\\n from mitiq.interface import convert_from_mitiq\\n-from mitiq import QPROGRAM\\n-from mitiq._typing import Bitstring\\n+from mitiq import QPROGRAM, Bitstring\\n \\n \\n single_q_cliffords = _single_qubit_cliffords()\\n\",\"diff --git a/mitiq/benchmarks/quantum_volume_circuits.py b/mitiq/benchmarks/quantum_volume_circuits.py\\nindex 9e7d37f..6f14912 100644\\n--- a/mitiq/benchmarks/quantum_volume_circuits.py\\n+++ b/mitiq/benchmarks/quantum_volume_circuits.py\\n@@ -23,7 +23,7 @@ Cirq implementation of quantum volume circuits:\\n cirq-core/cirq/contrib/quantum_volume/quantum_volume.py\\n \\\"\\\"\\\"\\n \\n-from typing import Optional, List, Tuple\\n+from typing import Optional, Tuple, Sequence\\n \\n from numpy import random\\n \\n@@ -37,7 +37,7 @@ from cirq.value import big_endian_int_to_bits\\n \\n \\n from mitiq import QPROGRAM\\n-from mitiq._typing import Bitstring\\n+from mitiq import Bitstring\\n from mitiq.interface import convert_from_mitiq\\n \\n \\n@@ -47,7 +47,7 @@ def generate_quantum_volume_circuit(\\n     decompose: bool = False,\\n     seed: Optional[int] = None,\\n     return_type: Optional[str] = None,\\n-) -> Tuple[QPROGRAM, List[Bitstring]]:\\n+) -> Tuple[QPROGRAM, Sequence[Bitstring]]:\\n     \\\"\\\"\\\"Generate a quantum volume circuit with the given number of qubits and\\n     depth.\\n \\n@@ -87,7 +87,7 @@ def generate_quantum_volume_circuit(\\n def compute_heavy_bitstrings(\\n     circuit: Circuit,\\n     num_qubits: int,\\n-) -> List[Bitstring]:\\n+) -> Sequence[Bitstring]:\\n     \\\"\\\"\\\"Classically compute the heavy bitstrings of the provided circuit.\\n \\n     The heavy bitstrings are defined as the output bit-strings that have a\\n\",\"diff --git a/mitiq/calibration/calibration.py b/mitiq/calibration/calibration.py\\nindex 6a0e276..0248e6e 100644\\n--- a/mitiq/calibration/calibration.py\\n+++ b/mitiq/calibration/calibration.py\\n@@ -16,7 +16,17 @@\\n from collections import Counter\\n from dataclasses import asdict\\n from math import prod, sqrt\\n-from typing import Any, Callable, Dict, List, Optional, Tuple, Union, cast\\n+from typing import (\\n+    Any,\\n+    Callable,\\n+    Dict,\\n+    List,\\n+    Optional,\\n+    Tuple,\\n+    Union,\\n+    cast,\\n+    Sequence,\\n+)\\n \\n import cirq\\n \\n@@ -161,7 +171,7 @@ class Calibrator:\\n \\n \\n def bitstrings_to_distribution(\\n-    bitstrings: List[List[int]],\\n+    bitstrings: Sequence[List[int]],\\n ) -> Dict[str, float]:\\n     \\\"\\\"\\\"Helper function to convert raw measurement results to probability\\n     distributions.\\\"\\\"\\\"\\n@@ -199,6 +209,7 @@ def convert_to_expval_executor(\\n \\n     def expval_executor(circuit: cirq.Circuit) -> float:\\n         raw = cast(MeasurementResult, ex._run([circuit])[0]).result\\n+        raw = cast(List[List[int]], raw)\\n         bitstring_distribution = bitstrings_to_distribution(raw)\\n         return bitstring_distribution.get(bitstring_to_measure, 0)\\n \\n\",\"diff --git a/mitiq/calibration/settings.py b/mitiq/calibration/settings.py\\nindex 904c40a..2963778 100644\\n--- a/mitiq/calibration/settings.py\\n+++ b/mitiq/calibration/settings.py\\n@@ -21,7 +21,7 @@ from typing import Any, Callable, cast, Iterator, List, Dict, Tuple\\n import networkx as nx\\n import cirq\\n \\n-from mitiq._typing import QuantumResult\\n+from mitiq import QuantumResult\\n from mitiq.benchmarks import (\\n     generate_ghz_circuit,\\n     generate_mirror_circuit,\\n\",\"diff --git a/mitiq/interface/conversions.py b/mitiq/interface/conversions.py\\nindex 9b91d58..e966dd1 100644\\n--- a/mitiq/interface/conversions.py\\n+++ b/mitiq/interface/conversions.py\\n@@ -19,7 +19,7 @@ from typing import Any, Callable, cast, Iterable, Tuple\\n \\n from cirq import Circuit\\n \\n-from mitiq._typing import SUPPORTED_PROGRAM_TYPES, QPROGRAM\\n+from mitiq import SUPPORTED_PROGRAM_TYPES, QPROGRAM\\n \\n \\n class UnsupportedCircuitError(Exception):\\n\",\"diff --git a/mitiq/interface/mitiq_cirq/cirq_utils.py b/mitiq/interface/mitiq_cirq/cirq_utils.py\\nindex 45949dd..174e85e 100644\\n--- a/mitiq/interface/mitiq_cirq/cirq_utils.py\\n+++ b/mitiq/interface/mitiq_cirq/cirq_utils.py\\n@@ -19,7 +19,7 @@ from typing import Tuple\\n import numpy as np\\n import numpy.typing as npt\\n import cirq\\n-from mitiq._typing import MeasurementResult\\n+from mitiq import MeasurementResult\\n \\n \\n # Executors.\\n\",\"diff --git a/mitiq/observable/observable.py b/mitiq/observable/observable.py\\nindex 8357571..7fd4266 100644\\n--- a/mitiq/observable/observable.py\\n+++ b/mitiq/observable/observable.py\\n@@ -21,7 +21,7 @@ import numpy.typing as npt\\n import cirq\\n \\n from mitiq.observable.pauli import PauliString, PauliStringCollection\\n-from mitiq._typing import MeasurementResult, QuantumResult, QPROGRAM\\n+from mitiq import MeasurementResult, QuantumResult, QPROGRAM\\n \\n \\n class Observable:\\n\",\"diff --git a/mitiq/observable/pauli.py b/mitiq/observable/pauli.py\\nindex 2ebf6ab..e6ff687 100644\\n--- a/mitiq/observable/pauli.py\\n+++ b/mitiq/observable/pauli.py\\n@@ -29,7 +29,7 @@ import numpy as np\\n import numpy.typing as npt\\n import cirq\\n \\n-from mitiq._typing import QPROGRAM, MeasurementResult\\n+from mitiq import QPROGRAM, MeasurementResult\\n from mitiq.interface import atomic_converter\\n \\n \\n@@ -282,7 +282,7 @@ class PauliStringCollection:\\n     ) -> float:\\n         total = 0.0\\n         for pauli in self.elements:\\n-            bitstrings = measurements[sorted(pauli.support())]\\n+            bitstrings = measurements.filter_qubits(sorted(pauli.support()))\\n             value = (\\n                 np.average([(-1) ** np.sum(bits) for bits in bitstrings])\\n                 if len(bitstrings) > 0\\n\",\"diff --git a/mitiq/rem/inverse_confusion_matrix.py b/mitiq/rem/inverse_confusion_matrix.py\\nindex 0b02f16..11640bb 100644\\n--- a/mitiq/rem/inverse_confusion_matrix.py\\n+++ b/mitiq/rem/inverse_confusion_matrix.py\\n@@ -14,12 +14,12 @@\\n # along with this program.  If not, see <https://www.gnu.org/licenses/>.\\n \\n from functools import reduce\\n-from typing import List\\n+from typing import List, Sequence\\n import numpy as np\\n import numpy.typing as npt\\n \\n \\n-from mitiq._typing import MeasurementResult, Bitstring\\n+from mitiq import MeasurementResult, Bitstring\\n \\n \\n def sample_probability_vector(\\n@@ -56,7 +56,7 @@ def sample_probability_vector(\\n \\n \\n def bitstrings_to_probability_vector(\\n-    bitstrings: List[Bitstring],\\n+    bitstrings: Sequence[Bitstring],\\n ) -> npt.NDArray[np.float64]:\\n     \\\"\\\"\\\"Converts a list of measured bitstrings to a probability vector estimated\\n     as the empirical frequency of each bitstring (ordered with increasing\\n\",\"diff --git a/mitiq/rem/post_select.py b/mitiq/rem/post_select.py\\nindex bc8b281..e5cb4e0 100644\\n--- a/mitiq/rem/post_select.py\\n+++ b/mitiq/rem/post_select.py\\n@@ -15,7 +15,7 @@\\n \\n from typing import Callable\\n \\n-from mitiq._typing import Bitstring, MeasurementResult\\n+from mitiq import Bitstring, MeasurementResult\\n \\n \\n def post_select(\\n\",\"diff --git a/mitiq/rem/rem.py b/mitiq/rem/rem.py\\nindex d1c2f9a..189c66e 100644\\n--- a/mitiq/rem/rem.py\\n+++ b/mitiq/rem/rem.py\\n@@ -21,7 +21,7 @@ from functools import wraps\\n import numpy as np\\n import numpy.typing as npt\\n \\n-from mitiq._typing import QPROGRAM, MeasurementResult\\n+from mitiq import QPROGRAM, MeasurementResult\\n from mitiq.executor.executor import Executor\\n from mitiq.observable.observable import Observable\\n from mitiq.rem.inverse_confusion_matrix import mitigate_measurements\\n\",\"diff --git a/mitiq/typing.py b/mitiq/typing.py\\nnew file mode 100644\\nindex 0000000..195a374\\n--- /dev/null\\n+++ b/mitiq/typing.py\\n@@ -0,0 +1,189 @@\\n+# Copyright (C) 2020 Unitary Fund\\n+#\\n+# This program is free software: you can redistribute it and/or modify\\n+# it under the terms of the GNU General Public License as published by\\n+# the Free Software Foundation, either version 3 of the License, or\\n+# (at your option) any later version.\\n+#\\n+# This program is distributed in the hope that it will be useful,\\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n+# GNU General Public License for more details.\\n+#\\n+# You should have received a copy of the GNU General Public License\\n+# along with this program.  If not, see <https://www.gnu.org/licenses/>.\\n+\\n+\\\"\\\"\\\"Defines input / output types for a quantum computer (simulator):\\n+\\n+  * SUPPORTED_PROGRAM_TYPES: All supported packages / circuits which Mitiq can\\n+       interface with,\\n+  * QPROGRAM: All supported packages / circuits which are installed in the\\n+       environment Mitiq is run in, and\\n+  * QuantumResult: An object returned by a quantum computer (simulator) running\\n+       a quantum program from which expectation values to be mitigated can be\\n+       computed. Note this includes expectation values themselves.\\n+\\\"\\\"\\\"\\n+from dataclasses import dataclass\\n+from typing import cast, List, Optional, Tuple, Union, Sequence, Dict, Any\\n+\\n+import numpy as np\\n+import numpy.typing as npt\\n+\\n+from cirq import Circuit as _Circuit\\n+\\n+from collections import Counter\\n+\\n+\\n+# Supported quantum programs.\\n+SUPPORTED_PROGRAM_TYPES = {\\n+    \\\"cirq\\\": \\\"Circuit\\\",\\n+    \\\"pyquil\\\": \\\"Program\\\",\\n+    \\\"qiskit\\\": \\\"QuantumCircuit\\\",\\n+    \\\"braket\\\": \\\"Circuit\\\",\\n+    \\\"pennylane\\\": \\\"QuantumTape\\\",\\n+}\\n+\\n+\\n+try:\\n+    from pyquil import Program as _Program\\n+except ImportError:  # pragma: no cover\\n+    _Program = _Circuit  # type: ignore\\n+\\n+try:\\n+    from qiskit import QuantumCircuit as _QuantumCircuit\\n+except ImportError:  # pragma: no cover\\n+    _QuantumCircuit = _Circuit\\n+\\n+try:\\n+    from braket.circuits import Circuit as _BKCircuit\\n+except ImportError:  # pragma: no cover\\n+    _BKCircuit = _Circuit\\n+\\n+try:\\n+    from pennylane.tape import QuantumTape as _QuantumTape\\n+except ImportError:  # pragma: no cover\\n+    _QuantumTape = _Circuit\\n+\\n+\\n+# Supported + installed quantum programs.\\n+QPROGRAM = Union[_Circuit, _Program, _QuantumCircuit, _BKCircuit, _QuantumTape]\\n+\\n+\\n+# Define MeasurementResult, a result obtained by measuring qubits on a quantum\\n+# computer.\\n+Bitstring = Union[str, List[int]]\\n+\\n+\\n+@dataclass\\n+class MeasurementResult:\\n+    \\\"\\\"\\\"Bitstrings sampled from a quantum computer.\\\"\\\"\\\"\\n+\\n+    result: Sequence[Bitstring]\\n+    qubit_indices: Optional[Tuple[int, ...]] = None\\n+\\n+    def __post_init__(self) -> None:\\n+        # Validate arguments\\n+        symbols = set(b for bits in self.result for b in bits)\\n+        if not (symbols.issubset({0, 1}) or symbols.issubset({\\\"0\\\", \\\"1\\\"})):\\n+            raise ValueError(\\\"Bitstrings should look like '011' or [0, 1, 1].\\\")\\n+\\n+        if symbols.issubset({\\\"0\\\", \\\"1\\\"}):\\n+            # Convert to list of integers\\n+            int_result = [[int(b) for b in bits] for bits in self.result]\\n+            self.result: List[List[int]] = list(int_result)\\n+\\n+        if isinstance(self.result, np.ndarray):\\n+            self.result = cast(List[Bitstring], self.result.tolist())\\n+\\n+        self._bitstrings = np.array(self.result)\\n+\\n+        if not self.qubit_indices:\\n+            self.qubit_indices = tuple(range(self.nqubits))\\n+        else:\\n+            if len(self.qubit_indices) != self.nqubits:\\n+                raise ValueError(\\n+                    f\\\"MeasurementResult has {self.nqubits} qubit(s) but there \\\"\\n+                    f\\\"are {len(self.qubit_indices)} `qubit_indices`.\\\"\\n+                )\\n+\\n+        self._measurements = dict(zip(self.qubit_indices, self._bitstrings.T))\\n+\\n+    @property\\n+    def shots(self) -> int:\\n+        return self._bitstrings.shape[0]\\n+\\n+    @property\\n+    def nqubits(self) -> int:\\n+        return (\\n+            self._bitstrings.shape[1]\\n+            if len(self._bitstrings.shape) >= 2\\n+            else 0\\n+        )\\n+\\n+    @property\\n+    def asarray(self) -> npt.NDArray[np.int64]:\\n+        return self._bitstrings\\n+\\n+    @classmethod\\n+    def from_counts(\\n+        cls,\\n+        counts: Dict[str, int],\\n+        qubit_indices: Optional[Tuple[int, ...]] = None,\\n+    ) -> \\\"MeasurementResult\\\":\\n+        \\\"\\\"\\\"Initializes a ``MeasurementResult`` from a dictionary of counts.\\n+\\n+        **Example**::\\n+\\n+            MeasurementResult.from_counts({\\\"00\\\": 175, \\\"11\\\": 177})\\n+        \\\"\\\"\\\"\\n+        counter = Counter(counts)\\n+        return cls(list(counter.elements()), qubit_indices)\\n+\\n+    def get_counts(self) -> Dict[str, int]:\\n+        \\\"\\\"\\\"Returns a Python dictionary whose keys are the measured\\n+        bitstrings and whose values are the counts.\\n+        \\\"\\\"\\\"\\n+        strings = [\\\"\\\".join(map(str, bits)) for bits in self.result]\\n+        return dict(Counter(strings))\\n+\\n+    def to_dict(self) -> Dict[str, Any]:\\n+        \\\"\\\"\\\"Exports data to a Python dictionary.\\n+\\n+        Note: Information about the order measurements is not preserved.\\n+        \\\"\\\"\\\"\\n+\\n+        return {\\n+            \\\"nqubits\\\": self.nqubits,\\n+            \\\"qubit_indices\\\": self.qubit_indices,\\n+            \\\"shots\\\": self.shots,\\n+            \\\"counts\\\": self.get_counts(),\\n+        }\\n+\\n+    @classmethod\\n+    def from_dict(cls, data: Dict[str, Any]) -> \\\"MeasurementResult\\\":\\n+        \\\"\\\"\\\"Loads a ``MeasurementResult`` from a Python dictionary.\\n+\\n+        Note: Only ``data[\\\"counts\\\"]`` and ``data[\\\"qubit_indices\\\"]`` are used\\n+        by this method. Total shots and number of qubits are deduced.\\n+        \\\"\\\"\\\"\\n+        return cls.from_counts(data[\\\"counts\\\"], data[\\\"qubit_indices\\\"])\\n+\\n+    def filter_qubits(self, qubit_indices: List[int]) -> npt.NDArray[np.int64]:\\n+        \\\"\\\"\\\"Returns the bitstrings associated to a subset of qubits.\\\"\\\"\\\"\\n+        return np.array([self._measurements[i] for i in qubit_indices]).T\\n+\\n+    def __repr__(self) -> str:\\n+        # We redefine __repr__ in this way to avoid very long output strings.\\n+        return \\\"MeasurementResult: \\\" + str(self.to_dict())\\n+\\n+\\n+# An `executor` function inputs a quantum program and outputs an object from\\n+# which expectation values can be computed. Explicitly, this object can be one\\n+# of the following types:\\n+QuantumResult = Union[\\n+    float,  # The expectation value itself.\\n+    MeasurementResult,  # Sampled bitstrings.\\n+    np.ndarray,  # Density matrix.\\n+    # TODO: Support the following:\\n+    # Sequence[np.ndarray],  # Wavefunctions sampled via quantum trajectories.\\n+]\\n\",\"diff --git a/mitiq/zne/inference.py b/mitiq/zne/inference.py\\nindex e34f2c9..ebe550f 100644\\n--- a/mitiq/zne/inference.py\\n+++ b/mitiq/zne/inference.py\\n@@ -37,7 +37,7 @@ from numpy.lib.polynomial import RankWarning\\n from scipy.optimize import curve_fit, OptimizeWarning\\n from cirq import Circuit\\n \\n-from mitiq._typing import QPROGRAM, QuantumResult\\n+from mitiq import QPROGRAM, QuantumResult\\n from mitiq.observable import Observable\\n from mitiq.executor import Executor\\n from mitiq.zne.scaling import fold_gates_at_random\\n\"]", "test_patch": "[\"diff --git a/docs/source/guide/rem-1-intro.myst b/docs/source/guide/rem-1-intro.myst\\nindex ad33f2d..1cf583c 100644\\n--- a/docs/source/guide/rem-1-intro.myst\\n+++ b/docs/source/guide/rem-1-intro.myst\\n@@ -60,7 +60,7 @@ from cirq.experiments.single_qubit_readout_calibration_test import (\\n     NoisySingleQubitReadoutSampler,\\n )\\n \\n-from mitiq._typing import MeasurementResult\\n+from mitiq import MeasurementResult\\n \\n def noisy_readout_executor(\\n     circuit, p0: float = 0.01, p1: float = 0.01, shots: int = 8192\\n\",\"diff --git a/mitiq/benchmarks/tests/test_ghz_circuits.py b/mitiq/benchmarks/tests/test_ghz_circuits.py\\nindex d823149..b4caf31 100644\\n--- a/mitiq/benchmarks/tests/test_ghz_circuits.py\\n+++ b/mitiq/benchmarks/tests/test_ghz_circuits.py\\n@@ -19,7 +19,7 @@ import pytest\\n import numpy as np\\n \\n from mitiq.benchmarks import ghz_circuits\\n-from mitiq._typing import SUPPORTED_PROGRAM_TYPES\\n+from mitiq import SUPPORTED_PROGRAM_TYPES\\n \\n \\n @pytest.mark.parametrize(\\\"nqubits\\\", [1, 5])\\n\",\"diff --git a/mitiq/benchmarks/tests/test_mirror_circuits.py b/mitiq/benchmarks/tests/test_mirror_circuits.py\\nindex 1cd00e6..b5b8209 100644\\n--- a/mitiq/benchmarks/tests/test_mirror_circuits.py\\n+++ b/mitiq/benchmarks/tests/test_mirror_circuits.py\\n@@ -16,7 +16,7 @@\\n \\\"\\\"\\\"Tests for mirror circuits.\\\"\\\"\\\"\\n \\n from mitiq.benchmarks import mirror_circuits\\n-from mitiq._typing import SUPPORTED_PROGRAM_TYPES\\n+from mitiq import SUPPORTED_PROGRAM_TYPES\\n from mitiq.utils import _equal\\n from numpy import random\\n import networkx as nx\\n\",\"diff --git a/mitiq/benchmarks/tests/test_quantum_volume_circuits.py b/mitiq/benchmarks/tests/test_quantum_volume_circuits.py\\nindex b202679..29798dd 100644\\n--- a/mitiq/benchmarks/tests/test_quantum_volume_circuits.py\\n+++ b/mitiq/benchmarks/tests/test_quantum_volume_circuits.py\\n@@ -31,7 +31,7 @@ from mitiq.benchmarks.quantum_volume_circuits import (\\n     compute_heavy_bitstrings,\\n )\\n \\n-from mitiq._typing import SUPPORTED_PROGRAM_TYPES\\n+from mitiq import SUPPORTED_PROGRAM_TYPES\\n \\n \\n def test_generate_model_circuit_no_seed():\\n\",\"diff --git a/mitiq/benchmarks/tests/test_randomized_benchmarking.py b/mitiq/benchmarks/tests/test_randomized_benchmarking.py\\nindex 085494e..94a90ac 100644\\n--- a/mitiq/benchmarks/tests/test_randomized_benchmarking.py\\n+++ b/mitiq/benchmarks/tests/test_randomized_benchmarking.py\\n@@ -19,7 +19,7 @@ import pytest\\n import numpy as np\\n \\n from mitiq.benchmarks.randomized_benchmarking import generate_rb_circuits\\n-from mitiq._typing import SUPPORTED_PROGRAM_TYPES\\n+from mitiq import SUPPORTED_PROGRAM_TYPES\\n \\n \\n @pytest.mark.parametrize(\\\"n_qubits\\\", (1, 2))\\n\",\"diff --git a/mitiq/cdr/tests/test_cdr.py b/mitiq/cdr/tests/test_cdr.py\\nindex 66d6f05..65797c0 100644\\n--- a/mitiq/cdr/tests/test_cdr.py\\n+++ b/mitiq/cdr/tests/test_cdr.py\\n@@ -24,7 +24,7 @@ import cirq\\n from cirq import LineQubit\\n \\n from mitiq import PauliString, Observable, QPROGRAM\\n-from mitiq._typing import SUPPORTED_PROGRAM_TYPES\\n+from mitiq import SUPPORTED_PROGRAM_TYPES\\n from mitiq.cdr import (\\n     execute_with_cdr,\\n     linear_fit_function_no_intercept,\\n\",\"diff --git a/mitiq/cdr/tests/test_clifford_training_data.py b/mitiq/cdr/tests/test_clifford_training_data.py\\nindex 1ecb030..15d1540 100644\\n--- a/mitiq/cdr/tests/test_clifford_training_data.py\\n+++ b/mitiq/cdr/tests/test_clifford_training_data.py\\n@@ -20,7 +20,7 @@ import numpy as np\\n import cirq\\n from cirq.circuits import Circuit\\n \\n-from mitiq._typing import SUPPORTED_PROGRAM_TYPES\\n+from mitiq import SUPPORTED_PROGRAM_TYPES\\n from mitiq.interface import convert_from_mitiq\\n from mitiq.cdr.clifford_training_data import (\\n     _select,\\n\",\"diff --git a/mitiq/cdr/tests/test_clifford_utils.py b/mitiq/cdr/tests/test_clifford_utils.py\\nindex b467e02..8b1f219 100644\\n--- a/mitiq/cdr/tests/test_clifford_utils.py\\n+++ b/mitiq/cdr/tests/test_clifford_utils.py\\n@@ -20,7 +20,7 @@ import numpy as np\\n import cirq\\n from cirq.circuits import Circuit\\n \\n-from mitiq._typing import SUPPORTED_PROGRAM_TYPES\\n+from mitiq import SUPPORTED_PROGRAM_TYPES\\n from mitiq.interface import convert_from_mitiq\\n from mitiq.cdr.clifford_utils import (\\n     is_clifford_angle,\\n\",\"diff --git a/mitiq/executor/tests/test_executor.py b/mitiq/executor/tests/test_executor.py\\nindex 9f1314e..1b3ec7f 100644\\n--- a/mitiq/executor/tests/test_executor.py\\n+++ b/mitiq/executor/tests/test_executor.py\\n@@ -23,7 +23,7 @@ import numpy as np\\n import cirq\\n import pyquil\\n \\n-from mitiq._typing import MeasurementResult\\n+from mitiq import MeasurementResult\\n from mitiq.executor.executor import Executor\\n from mitiq.observable import Observable, PauliString\\n from mitiq.interface.mitiq_cirq import (\\n\",\"diff --git a/mitiq/interface/mitiq_cirq/tests/test_cirq_utils.py b/mitiq/interface/mitiq_cirq/tests/test_cirq_utils.py\\nindex 13f90e0..391872a 100644\\n--- a/mitiq/interface/mitiq_cirq/tests/test_cirq_utils.py\\n+++ b/mitiq/interface/mitiq_cirq/tests/test_cirq_utils.py\\n@@ -22,7 +22,7 @@ from mitiq.interface.mitiq_cirq import (\\n     compute_density_matrix,\\n     execute_with_depolarizing_noise,\\n )\\n-from mitiq._typing import MeasurementResult\\n+from mitiq import MeasurementResult\\n \\n \\n def test_sample_bitstrings():\\n\",\"diff --git a/mitiq/observable/tests/test_observable.py b/mitiq/observable/tests/test_observable.py\\nindex ca5e7e2..8cd4d2a 100644\\n--- a/mitiq/observable/tests/test_observable.py\\n+++ b/mitiq/observable/tests/test_observable.py\\n@@ -21,7 +21,7 @@ import cirq\\n \\n from mitiq.observable.observable import Observable\\n from mitiq.observable.pauli import PauliString, PauliStringCollection\\n-from mitiq._typing import MeasurementResult\\n+from mitiq import MeasurementResult\\n from mitiq.interface.mitiq_cirq.cirq_utils import (\\n     sample_bitstrings,\\n     compute_density_matrix,\\n\",\"diff --git a/mitiq/observable/tests/test_pauli.py b/mitiq/observable/tests/test_pauli.py\\nindex 254b96c..9cfa022 100644\\n--- a/mitiq/observable/tests/test_pauli.py\\n+++ b/mitiq/observable/tests/test_pauli.py\\n@@ -21,7 +21,7 @@ import cirq\\n \\n from mitiq.interface import mitiq_qiskit, mitiq_pyquil\\n from mitiq.observable.pauli import PauliString, PauliStringCollection\\n-from mitiq._typing import MeasurementResult\\n+from mitiq import MeasurementResult\\n from mitiq.utils import _equal\\n \\n \\n\",\"diff --git a/mitiq/rem/tests/test_inverse_confusion_matrix.py b/mitiq/rem/tests/test_inverse_confusion_matrix.py\\nindex 06e4b4d..7257b90 100644\\n--- a/mitiq/rem/tests/test_inverse_confusion_matrix.py\\n+++ b/mitiq/rem/tests/test_inverse_confusion_matrix.py\\n@@ -20,7 +20,7 @@ from math import isclose\\n import numpy as np\\n import pytest\\n \\n-from mitiq._typing import MeasurementResult\\n+from mitiq import MeasurementResult\\n from mitiq.rem.inverse_confusion_matrix import (\\n     bitstrings_to_probability_vector,\\n     generate_inverse_confusion_matrix,\\n\",\"diff --git a/mitiq/rem/tests/test_post_select.py b/mitiq/rem/tests/test_post_select.py\\nindex 7bb2bd4..7fc6ac0 100644\\n--- a/mitiq/rem/tests/test_post_select.py\\n+++ b/mitiq/rem/tests/test_post_select.py\\n@@ -17,7 +17,7 @@\\n import pytest\\n \\n from mitiq.rem import post_select\\n-from mitiq._typing import MeasurementResult\\n+from mitiq import MeasurementResult\\n \\n \\n def test_post_select():\\n\",\"diff --git a/mitiq/rem/tests/test_rem.py b/mitiq/rem/tests/test_rem.py\\nindex 4d73b80..0af8343 100644\\n--- a/mitiq/rem/tests/test_rem.py\\n+++ b/mitiq/rem/tests/test_rem.py\\n@@ -25,7 +25,7 @@ import pytest\\n \\n from mitiq.observable.observable import Observable\\n from mitiq.observable.pauli import PauliString\\n-from mitiq._typing import MeasurementResult\\n+from mitiq import MeasurementResult\\n from mitiq.rem.inverse_confusion_matrix import (\\n     generate_inverse_confusion_matrix,\\n )\\n\",\"diff --git a/mitiq/tests/test_conversions.py b/mitiq/tests/test_conversions.py\\nindex 954b5b8..95263ef 100644\\n--- a/mitiq/tests/test_conversions.py\\n+++ b/mitiq/tests/test_conversions.py\\n@@ -29,7 +29,7 @@ from braket.circuits import (\\n )\\n import pennylane as qml\\n \\n-from mitiq._typing import SUPPORTED_PROGRAM_TYPES\\n+from mitiq import SUPPORTED_PROGRAM_TYPES\\n from mitiq.interface import (\\n     convert_to_mitiq,\\n     convert_from_mitiq,\\n\",\"diff --git a/mitiq/tests/test_measurement_result.py b/mitiq/tests/test_measurement_result.py\\nindex 7a4df0a..abdc3ca 100644\\n--- a/mitiq/tests/test_measurement_result.py\\n+++ b/mitiq/tests/test_measurement_result.py\\n@@ -17,7 +17,7 @@\\n import pytest\\n \\n import numpy as np\\n-from mitiq._typing import MeasurementResult\\n+from mitiq import MeasurementResult\\n \\n \\n @pytest.mark.parametrize(\\\"asarray\\\", (True, False))\\n@@ -32,10 +32,6 @@ def test_measurement_result(asarray, qubit_indices):\\n     assert result.qubit_indices == qubit_indices\\n     assert result.shots == 3\\n     assert np.allclose(result.result, bitstrings)\\n-    assert (\\n-        repr(result) == f\\\"MeasurementResult(result=[[0, 0], [0, 1], [1, 0]], \\\"\\n-        f\\\"qubit_indices={qubit_indices})\\\"\\n-    )\\n \\n \\n def test_measurement_result_bad_qubit_indices():\\n@@ -44,22 +40,28 @@ def test_measurement_result_bad_qubit_indices():\\n \\n \\n def test_measurement_result_not_bits():\\n-    with pytest.raises(ValueError, match=\\\"contains elements\\\"):\\n+    with pytest.raises(ValueError, match=\\\"should look like\\\"):\\n         MeasurementResult(result=[[2]])\\n \\n-    with pytest.raises(ValueError, match=\\\"contains elements\\\"):\\n+    with pytest.raises(ValueError, match=\\\"should look like\\\"):\\n         MeasurementResult(result=[[0, 0], [0, 1], [-1, 0]])\\n \\n \\n-def test_getitem():\\n+def test_filter_qubits():\\n     result = MeasurementResult([[0, 0, 1], [0, 1, 0], [1, 0, 0]])\\n-    assert np.allclose(result[[0]], np.array([[0], [0], [1]]))\\n-    assert np.allclose(result[[1]], np.array([[0], [1], [0]]))\\n-    assert np.allclose(result[[2]], np.array([[1], [0], [0]]))\\n+    assert np.allclose(result.filter_qubits([0]), np.array([[0], [0], [1]]))\\n+    assert np.allclose(result.filter_qubits([1]), np.array([[0], [1], [0]]))\\n+    assert np.allclose(result.filter_qubits([2]), np.array([[1], [0], [0]]))\\n \\n-    assert np.allclose(result[[0, 1]], np.array([[0, 0], [0, 1], [1, 0]]))\\n-    assert np.allclose(result[[0, 2]], np.array([[0, 1], [0, 0], [1, 0]]))\\n-    assert np.allclose(result[[1, 2]], np.array([[0, 1], [1, 0], [0, 0]]))\\n+    assert np.allclose(\\n+        result.filter_qubits([0, 1]), np.array([[0, 0], [0, 1], [1, 0]])\\n+    )\\n+    assert np.allclose(\\n+        result.filter_qubits([0, 2]), np.array([[0, 1], [0, 0], [1, 0]])\\n+    )\\n+    assert np.allclose(\\n+        result.filter_qubits([1, 2]), np.array([[0, 1], [1, 0], [0, 0]])\\n+    )\\n \\n \\n def test_empty():\\n@@ -69,16 +71,80 @@ def test_empty():\\n     assert result.result == []\\n \\n \\n-def test_iter():\\n-    bitstrings = [[0, 1, 1], [0, 1, 0], [1, 0, 0]]\\n-\\n-    for m, bits in zip(MeasurementResult(bitstrings), bitstrings):\\n-        assert m == bits\\n-\\n-\\n def test_convert_to_array():\\n     bitstrings = [[0, 0], [0, 1], [1, 0]]\\n     result = MeasurementResult(bitstrings)\\n     assert np.allclose(result.asarray, np.array(bitstrings))\\n \\n     assert np.allclose(MeasurementResult([]).asarray, np.array([]))\\n+\\n+\\n+@pytest.mark.parametrize(\\\"qubit_indices\\\", ((0, 1), (1, 20)))\\n+def test_measurement_result_with_strings(qubit_indices):\\n+    \\\"\\\"\\\"Try using strings instead of lists of integers.\\\"\\\"\\\"\\n+    bitstrings = [\\\"00\\\", \\\"01\\\", \\\"10\\\"]\\n+    int_bitstrings = [[0, 0], [0, 1], [1, 0]]\\n+\\n+    result = MeasurementResult(bitstrings, qubit_indices=qubit_indices)\\n+\\n+    assert result.nqubits == 2\\n+    assert result.qubit_indices == qubit_indices\\n+    assert result.shots == 3\\n+    assert result.result == int_bitstrings\\n+\\n+\\n+@pytest.mark.parametrize(\\\"qubit_indices\\\", ((0, 1), (1, 20)))\\n+def test_measurement_result_from_counts(qubit_indices):\\n+    \\\"\\\"\\\"Test initialization from a dictionary of counts.\\\"\\\"\\\"\\n+    counts = {\\\"00\\\": 1, \\\"01\\\": 2}\\n+    int_bitstrings = [[0, 0], [0, 1], [0, 1]]\\n+\\n+    result = MeasurementResult.from_counts(\\n+        counts=counts,\\n+        qubit_indices=qubit_indices,\\n+    )\\n+    assert result.nqubits == 2\\n+    assert result.qubit_indices == qubit_indices\\n+    assert result.shots == 3\\n+    assert result.result == int_bitstrings\\n+\\n+\\n+def test_measurement_result_get_counts():\\n+    \\\"\\\"\\\"Test initialization from a dictionary of counts.\\\"\\\"\\\"\\n+    counts = {\\\"00\\\": 1, \\\"01\\\": 2}\\n+\\n+    int_bitstrings = [[0, 0], [0, 1], [0, 1]]\\n+    result = MeasurementResult(\\n+        result=int_bitstrings,\\n+        qubit_indices=(1, 20),\\n+    )\\n+    assert result.get_counts() == counts\\n+    # Info about qubit indices is expected to be lost\\n+    new_res = MeasurementResult.from_counts(result.get_counts())\\n+    assert new_res.qubit_indices == (0, 1)  # Default values\\n+\\n+\\n+def test_measurement_result_to_from_dictionary():\\n+    \\\"\\\"\\\"Test initialization from a dictionary of counts.\\\"\\\"\\\"\\n+    data = {\\n+        \\\"counts\\\": {\\\"00\\\": 1, \\\"01\\\": 2},\\n+        \\\"shots\\\": 3,\\n+        \\\"nqubits\\\": 2,\\n+        \\\"qubit_indices\\\": (1, 7),\\n+    }\\n+    assert MeasurementResult.from_dict(data).to_dict() == data\\n+\\n+\\n+def test_measurement_repr_():\\n+    \\\"\\\"\\\"Test string representation and printing.\\\"\\\"\\\"\\n+    counts = {\\\"00\\\": 1000, \\\"01\\\": 200}\\n+    result = MeasurementResult.from_counts(\\n+        counts=counts,\\n+        qubit_indices=(1, 20),\\n+    )\\n+    expected = (\\n+        \\\"MeasurementResult: {'nqubits': 2, 'qubit_indices': (1, 20),\\\"\\n+        \\\" 'shots': 1200, 'counts': {'00': 1000, '01': 200}}\\\"\\n+    )\\n+    assert repr(result) == expected\\n+    assert str(result) == expected\\n\",\"diff --git a/mitiq/zne/tests/test_zne.py b/mitiq/zne/tests/test_zne.py\\nindex ee7ccbd..7978a7b 100644\\n--- a/mitiq/zne/tests/test_zne.py\\n+++ b/mitiq/zne/tests/test_zne.py\\n@@ -41,7 +41,7 @@ from mitiq.zne.scaling import (\\n     fold_gates_at_random,\\n     insert_id_layers,\\n )\\n-from mitiq._typing import QPROGRAM\\n+from mitiq import QPROGRAM, SUPPORTED_PROGRAM_TYPES\\n from mitiq.benchmarks.randomized_benchmarking import generate_rb_circuits\\n \\n from mitiq.interface.mitiq_qiskit import (\\n@@ -49,7 +49,6 @@ from mitiq.interface.mitiq_qiskit import (\\n     initialized_depolarizing_noise,\\n )\\n \\n-from mitiq._typing import SUPPORTED_PROGRAM_TYPES\\n from mitiq.interface import convert_from_mitiq, accept_any_qprogram_as_input\\n from mitiq.interface.mitiq_cirq import (\\n     sample_bitstrings,\"]", "hints_text": ""}

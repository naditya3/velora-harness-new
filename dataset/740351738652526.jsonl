{"instance_id": "740351738652526", "repo": "pytask-dev/pytask", "base_commit": "47d964a278010a455437d79414ec2c2001090de1", "problem_statement": "ENH: Create signatures for nodes.:\\n#### Is your feature request related to a problem?\\r\\n\\r\\npytask uses the name of nodes to uniquely identify them. This leads to problems since the name has to serve two purposes.\\r\\n\\r\\n1. The name needs to uniquely identify a node.\\r\\n2. The name should easy to display, short, and easy to read for users.\\r\\n\\r\\nThose two requirements are at odds which led to the `display_name` attribute on `Task` classes.\\r\\n\\r\\n#### Describe the solution you'd like\\r\\n\\r\\nWhat are signatures made of?\\r\\n\\r\\nTasks\\r\\n- Name of the function or name passed with `@task(name=...)` + optional part added in\\r\\n  parametrizations.\\r\\n- (optional) Path to module.\\r\\n\\r\\nNodes\\r\\n- name of node\\r\\n- (optional) Path of the node.\\r\\n\\r\\n#### API breaking implications\\r\\n\\r\\nProvide a description of how this feature will affect the API.\\r\\n", "FAIL_TO_PASS": ["tests/test_persist.py::test_multiple_runs_with_persist", "tests/test_data_catalog.py::test_data_catalog_collects_nodes", "tests/test_profile.py::test_export_of_profile[csv]", "tests/test_dag.py::test_pytask_dag_create_dag", "tests/test_profile.py::test_duration_is_stored_in_task", "tests/test_dag_utils.py::test_extract_priorities_from_tasks[test", "tests/test_dag_utils.py::test_reset_topological_sorter", "tests/test_console.py::test_format_task_id[format", "tests/test_dag_utils.py::test_raise_if_topological_sorter_is_not_prepared", "tests/test_dag_utils.py::test_ask_for_invalid_number_of_ready_tasks", "tests/test_dag_utils.py::test_raise_error_for_cycle_in_graph", "tests/test_database.py::test_existence_of_hashes_in_db", "tests/test_dag_utils.py::test_extract_priorities_from_tasks[tasks4-expectation4-expected4]", "tests/test_profile.py::test_export_of_profile[json]", "tests/test_data_catalog.py::test_use_data_catalog_in_workflow", "tests/test_dag_utils.py::test_sort_tasks_topologically"], "PASS_TO_PASS": [], "language": "python", "test_command": "source /saved/ENV || source /saved/*/ENV && tox -- --no-header -rA --tb=no -p no:cacheprovider --continue-on-collection-errors", "test_output_parser": "python/parse_log_pytest_v3", "image_storage_uri": "vmvm-registry.fbinfra.net/repomate_image_activ_pytest/pytask-dev_pytask:47d964a278010a455437d79414ec2c2001090de1", "patch": "[\"diff --git a/.pre-commit-config.yaml b/.pre-commit-config.yaml\\nindex 3050284..693b9f2 100644\\n--- a/.pre-commit-config.yaml\\n+++ b/.pre-commit-config.yaml\\n@@ -58,7 +58,7 @@ repos:\\n     -   id: refurb\\n         args: [--ignore, FURB126]\\n -   repo: https://github.com/econchick/interrogate\\n-    rev: 1.5.0\\n+    rev: 3aa94a6\\n     hooks:\\n     -   id: interrogate\\n         args: [-v, --fail-under=75]\\n@@ -142,7 +142,7 @@ repos:\\n     hooks:\\n     -   id: check-manifest\\n         args: [--no-build-isolation]\\n-        additional_dependencies: [setuptools-scm, toml]\\n+        additional_dependencies: [setuptools-scm, toml, wheel]\\n -   repo: meta\\n     hooks:\\n     -   id: check-hooks-apply\\n\",\"diff --git a/docs/source/changes.md b/docs/source/changes.md\\nindex b03b2fc..2c322d1 100644\\n--- a/docs/source/changes.md\\n+++ b/docs/source/changes.md\\n@@ -22,6 +22,7 @@ releases are available on [PyPI](https://pypi.org/project/pytask) and\\n - {pull}`466` implements hashing for files instead of modification timestamps.\\n - {pull}`470` moves `.pytask.sqlite3` to `.pytask`.\\n - {pull}`472` adds `is_product` to {meth}`PNode.load`.\\n+- {pull}`473` adds signatures to nodes which decouples an identifier from a name.\\n - {pull}`477` updates the PyPI action.\\n \\n ## 0.4.1 - 2023-10-11\\n\",\"diff --git a/docs/source/how_to_guides/writing_custom_nodes.md b/docs/source/how_to_guides/writing_custom_nodes.md\\nindex ab93d88..8d1c22a 100644\\n--- a/docs/source/how_to_guides/writing_custom_nodes.md\\n+++ b/docs/source/how_to_guides/writing_custom_nodes.md\\n@@ -104,6 +104,9 @@ Here are some explanations.\\n   - `name` identifies the node in the DAG, so the name must be unique.\\n   - `path` holds the path to the file and identifies the node as a path node that is\\n     handled slightly differently than normal nodes within pytask.\\n+- The node has an additional property that computes the signature of the node. The\\n+  signature is a hash and a unique identifier for the node. For most nodes it will be a\\n+  hash of the path or the name.\\n - The {func}`classmethod` {meth}`PickleNode.from_path` is a convenient method to\\n   instantiate the class.\\n - The method {meth}`PickleNode.state` yields a value that signals the node's state. If\\n\",\"diff --git a/docs_src/how_to_guides/writing_custom_nodes_example_3_py310.py b/docs_src/how_to_guides/writing_custom_nodes_example_3_py310.py\\nindex f79c43e..ff01f49 100644\\n--- a/docs_src/how_to_guides/writing_custom_nodes_example_3_py310.py\\n+++ b/docs_src/how_to_guides/writing_custom_nodes_example_3_py310.py\\n@@ -1,7 +1,10 @@\\n+import hashlib\\n import pickle\\n from pathlib import Path\\n from typing import Any\\n \\n+from pytask import hash_value\\n+\\n \\n class PickleNode:\\n     \\\"\\\"\\\"The class for a node that persists values with pickle to files.\\n@@ -19,6 +22,12 @@ class PickleNode:\\n         self.name = name\\n         self.path = path\\n \\n+    @property\\n+    def signature(self) -> str:\\n+        \\\"\\\"\\\"The unique signature of the node.\\\"\\\"\\\"\\n+        raw_key = str(hash_value(self.path))\\n+        return hashlib.sha256(raw_key.encode()).hexdigest()\\n+\\n     @classmethod\\n     def from_path(cls, path: Path) -> \\\"PickleNode\\\":\\n         \\\"\\\"\\\"Instantiate class from path to file.\\\"\\\"\\\"\\n\",\"diff --git a/docs_src/how_to_guides/writing_custom_nodes_example_3_py38.py b/docs_src/how_to_guides/writing_custom_nodes_example_3_py38.py\\nindex 62c46da..9828137 100644\\n--- a/docs_src/how_to_guides/writing_custom_nodes_example_3_py38.py\\n+++ b/docs_src/how_to_guides/writing_custom_nodes_example_3_py38.py\\n@@ -1,8 +1,11 @@\\n+import hashlib\\n import pickle\\n from pathlib import Path\\n from typing import Any\\n from typing import Optional\\n \\n+from pytask import hash_value\\n+\\n \\n class PickleNode:\\n     \\\"\\\"\\\"The class for a node that persists values with pickle to files.\\n@@ -20,6 +23,12 @@ class PickleNode:\\n         self.name = name\\n         self.path = path\\n \\n+    @property\\n+    def signature(self) -> str:\\n+        \\\"\\\"\\\"The unique signature of the node.\\\"\\\"\\\"\\n+        raw_key = str(hash_value(self.path))\\n+        return hashlib.sha256(raw_key.encode()).hexdigest()\\n+\\n     @classmethod\\n     def from_path(cls, path: Path) -> \\\"PickleNode\\\":\\n         \\\"\\\"\\\"Instantiate class from path to file.\\\"\\\"\\\"\\n\",\"diff --git a/src/_pytask/collect_command.py b/src/_pytask/collect_command.py\\nindex 5537740..70865d8 100644\\n--- a/src/_pytask/collect_command.py\\n+++ b/src/_pytask/collect_command.py\\n@@ -106,12 +106,12 @@ def collect(**raw_config: Any | None) -> NoReturn:\\n \\n def _select_tasks_by_expressions_and_marker(session: Session) -> list[PTask]:\\n     \\\"\\\"\\\"Select tasks by expressions and marker.\\\"\\\"\\\"\\n-    all_tasks = {task.name for task in session.tasks}\\n+    all_tasks = {task.signature for task in session.tasks}\\n     remaining_by_mark = select_by_mark(session, session.dag) or all_tasks\\n     remaining_by_keyword = select_by_keyword(session, session.dag) or all_tasks\\n     remaining = remaining_by_mark & remaining_by_keyword\\n \\n-    return [task for task in session.tasks if task.name in remaining]\\n+    return [task for task in session.tasks if task.signature in remaining]\\n \\n \\n def _find_common_ancestor_of_all_nodes(\\n\",\"diff --git a/src/_pytask/config_utils.py b/src/_pytask/config_utils.py\\nindex 7370c0e..25e92b4 100644\\n--- a/src/_pytask/config_utils.py\\n+++ b/src/_pytask/config_utils.py\\n@@ -5,6 +5,7 @@ import os\\n import sys\\n from pathlib import Path\\n from typing import Any\\n+from typing import Sequence\\n \\n import click\\n from _pytask.shared import parse_paths\\n@@ -62,7 +63,9 @@ def set_defaults_from_config(\\n     return context.params[\\\"config\\\"]\\n \\n \\n-def find_project_root_and_config(paths: list[Path] | None) -> tuple[Path, Path | None]:\\n+def find_project_root_and_config(\\n+    paths: Sequence[Path] | None,\\n+) -> tuple[Path, Path | None]:\\n     \\\"\\\"\\\"Find the project root and configuration file from a list of paths.\\n \\n     The process is as follows:\\n\",\"diff --git a/src/_pytask/console.py b/src/_pytask/console.py\\nindex 327b03d..4210266 100644\\n--- a/src/_pytask/console.py\\n+++ b/src/_pytask/console.py\\n@@ -154,14 +154,13 @@ def format_task_name(task: PTask, editor_url_scheme: str) -> Text:\\n     else:\\n         url_style = create_url_style_for_task(task.function, editor_url_scheme)\\n \\n-    if isinstance(task, PTaskWithPath) and hasattr(task, \\\"display_name\\\"):\\n-        path, task_name = task.display_name.split(\\\"::\\\")\\n+    if isinstance(task, PTaskWithPath):\\n+        path, task_name = task.name.split(\\\"::\\\")\\n         return Text.assemble(\\n             Text(path + \\\"::\\\", style=\\\"dim\\\"), Text(task_name, style=url_style)\\n         )\\n \\n-    name = getattr(task, \\\"display_name\\\", task.name)\\n-    return Text(name, style=url_style)\\n+    return Text(task.name, style=url_style)\\n \\n \\n def format_node_name(node: PNode, paths: Sequence[Path] = ()) -> Text:\\n\",\"diff --git a/src/_pytask/dag.py b/src/_pytask/dag.py\\nindex f51e56d..597ac40 100644\\n--- a/src/_pytask/dag.py\\n+++ b/src/_pytask/dag.py\\n@@ -13,6 +13,7 @@ from _pytask.console import ARROW_DOWN_ICON\\n from _pytask.console import console\\n from _pytask.console import FILE_ICON\\n from _pytask.console import format_node_name\\n+from _pytask.console import format_task_name\\n from _pytask.console import render_to_string\\n from _pytask.console import TASK_ICON\\n from _pytask.dag_utils import node_and_neighbors\\n@@ -24,6 +25,8 @@ from _pytask.exceptions import ResolvingDependenciesError\\n from _pytask.mark import Mark\\n from _pytask.mark_utils import get_marks\\n from _pytask.mark_utils import has_mark\\n+from _pytask.node_protocols import PNode\\n+from _pytask.node_protocols import PTask\\n from _pytask.nodes import PythonNode\\n from _pytask.report import DagReport\\n from _pytask.shared import reduce_names_of_multiple_nodes\\n@@ -34,8 +37,6 @@ from rich.tree import Tree\\n \\n if TYPE_CHECKING:\\n     from _pytask.node_protocols import MetaNode\\n-    from _pytask.node_protocols import PTask\\n-    from _pytask.node_protocols import PNode\\n     from pathlib import Path\\n     from _pytask.session import Session\\n \\n@@ -75,24 +76,24 @@ def pytask_dag_create_dag(tasks: list[PTask]) -> nx.DiGraph:\\n \\n     def _add_dependency(dag: nx.DiGraph, task: PTask, node: PNode) -> None:\\n         \\\"\\\"\\\"Add a dependency to the DAG.\\\"\\\"\\\"\\n-        dag.add_node(node.name, node=node)\\n-        dag.add_edge(node.name, task.name)\\n+        dag.add_node(node.signature, node=node)\\n+        dag.add_edge(node.signature, task.signature)\\n \\n         # If a node is a PythonNode wrapped in another PythonNode, it is a product from\\n         # another task that is a dependency in the current task. Thus, draw an edge\\n         # connecting the two nodes.\\n         if isinstance(node, PythonNode) and isinstance(node.value, PythonNode):\\n-            dag.add_edge(node.value.name, node.name)\\n+            dag.add_edge(node.value.signature, node.signature)\\n \\n     def _add_product(dag: nx.DiGraph, task: PTask, node: PNode) -> None:\\n         \\\"\\\"\\\"Add a product to the DAG.\\\"\\\"\\\"\\n-        dag.add_node(node.name, node=node)\\n-        dag.add_edge(task.name, node.name)\\n+        dag.add_node(node.signature, node=node)\\n+        dag.add_edge(task.signature, node.signature)\\n \\n     dag = nx.DiGraph()\\n \\n     for task in tasks:\\n-        dag.add_node(task.name, task=task)\\n+        dag.add_node(task.signature, task=task)\\n \\n         tree_map(lambda x: _add_dependency(dag, task, x), task.depends_on)\\n         tree_map(lambda x: _add_product(dag, task, x), task.produces)\\n@@ -101,7 +102,7 @@ def pytask_dag_create_dag(tasks: list[PTask]) -> nx.DiGraph:\\n         # another task that is a dependency in the current task. Thus, draw an edge\\n         # connecting the two nodes.\\n         tree_map(\\n-            lambda x: dag.add_edge(x.value.name, x.name)\\n+            lambda x: dag.add_edge(x.value.signature, x.signature)\\n             if isinstance(x, PythonNode) and isinstance(x.value, PythonNode)\\n             else None,\\n             task.depends_on,\\n@@ -118,14 +119,14 @@ def pytask_dag_select_execution_dag(session: Session, dag: nx.DiGraph) -> None:\\n     scheduler = TopologicalSorter.from_dag(dag)\\n     visited_nodes: set[str] = set()\\n \\n-    for task_name in scheduler.static_order():\\n-        if task_name not in visited_nodes:\\n-            task = dag.nodes[task_name][\\\"task\\\"]\\n+    for task_signature in scheduler.static_order():\\n+        if task_signature not in visited_nodes:\\n+            task = dag.nodes[task_signature][\\\"task\\\"]\\n             have_changed = _have_task_or_neighbors_changed(session, dag, task)\\n             if have_changed:\\n-                visited_nodes.update(task_and_descending_tasks(task_name, dag))\\n+                visited_nodes.update(task_and_descending_tasks(task_signature, dag))\\n             else:\\n-                dag.nodes[task_name][\\\"task\\\"].markers.append(\\n+                dag.nodes[task_signature][\\\"task\\\"].markers.append(\\n                     Mark(\\\"skip_unchanged\\\", (), {})\\n                 )\\n \\n@@ -145,15 +146,15 @@ def _have_task_or_neighbors_changed(\\n         session.hook.pytask_dag_has_node_changed(\\n             session=session,\\n             dag=dag,\\n-            task_name=task.name,\\n+            task=task,\\n             node=dag.nodes[node_name].get(\\\"task\\\") or dag.nodes[node_name].get(\\\"node\\\"),\\n         )\\n-        for node_name in node_and_neighbors(dag, task.name)\\n+        for node_name in node_and_neighbors(dag, task.signature)\\n     )\\n \\n \\n @hookimpl(trylast=True)\\n-def pytask_dag_has_node_changed(node: MetaNode, task_name: str) -> bool:\\n+def pytask_dag_has_node_changed(task: PTask, node: MetaNode) -> bool:\\n     \\\"\\\"\\\"Indicate whether a single dependency or product has changed.\\\"\\\"\\\"\\n     # If node does not exist, we receive None.\\n     node_state = node.state()\\n@@ -161,7 +162,7 @@ def pytask_dag_has_node_changed(node: MetaNode, task_name: str) -> bool:\\n         return True\\n \\n     with DatabaseSession() as session:\\n-        db_state = session.get(State, (task_name, node.name))\\n+        db_state = session.get(State, (task.signature, node.signature))\\n \\n     # If the node is not in the database.\\n     if db_state is None:\\n@@ -180,22 +181,29 @@ def _check_if_dag_has_cycles(dag: nx.DiGraph) -> None:\\n         msg = (\\n             f\\\"The DAG contains cycles which means a dependency is directly or \\\"\\n             \\\"indirectly a product of the same task. See the following the path of \\\"\\n-            f\\\"nodes in the graph which forms the cycle.\\\\n\\\\n{_format_cycles(cycles)}\\\"\\n+            \\\"nodes in the graph which forms the cycle.\\\\n\\\\n\\\"\\n+            f\\\"{_format_cycles(dag, cycles)}\\\"\\n         )\\n         raise ResolvingDependenciesError(msg)\\n \\n \\n-def _format_cycles(cycles: list[tuple[str, ...]]) -> str:\\n+def _format_cycles(dag: nx.DiGraph, cycles: list[tuple[str, ...]]) -> str:\\n     \\\"\\\"\\\"Format cycles as a paths connected by arrows.\\\"\\\"\\\"\\n     chain = [\\n         x for i, x in enumerate(itertools.chain.from_iterable(cycles)) if i % 2 == 0\\n     ]\\n     chain += [cycles[-1][1]]\\n \\n-    lines = chain[:1]\\n-    for x in chain[1:]:\\n-        lines.extend((\\\"     \\\" + ARROW_DOWN_ICON, x))\\n-    return \\\"\\\\n\\\".join(lines)\\n+    lines: list[str] = []\\n+    for x in chain:\\n+        node = dag.nodes[x].get(\\\"task\\\") or dag.nodes[x].get(\\\"node\\\")\\n+        if isinstance(node, PTask):\\n+            short_name = format_task_name(node, editor_url_scheme=\\\"no_link\\\").plain\\n+        elif isinstance(node, PNode):\\n+            short_name = node.name\\n+        lines.extend((short_name, \\\"     \\\" + ARROW_DOWN_ICON))\\n+    # Join while removing last arrow.\\n+    return \\\"\\\\n\\\".join(lines[:-1])\\n \\n \\n _TEMPLATE_ERROR: str = (\\n@@ -247,11 +255,14 @@ def _check_if_root_nodes_are_available(dag: nx.DiGraph, paths: Sequence[Path]) -\\n         raise ResolvingDependenciesError(_TEMPLATE_ERROR.format(text)) from None\\n \\n \\n-def _format_exception_from_failed_node_state(node_name: str, dag: nx.DiGraph) -> str:\\n+def _format_exception_from_failed_node_state(\\n+    node_signature: str, dag: nx.DiGraph\\n+) -> str:\\n     \\\"\\\"\\\"Format message when ``node.state()`` threw an exception.\\\"\\\"\\\"\\n-    tasks = [dag.nodes[i][\\\"task\\\"] for i in dag.successors(node_name)]\\n-    names = [getattr(x, \\\"display_name\\\", x.name) for x in tasks]\\n+    tasks = [dag.nodes[i][\\\"task\\\"] for i in dag.successors(node_signature)]\\n+    names = [task.name for task in tasks]\\n     successors = \\\", \\\".join([f\\\"{name!r}\\\" for name in names])\\n+    node_name = dag.nodes[node_signature][\\\"node\\\"].name\\n     return (\\n         f\\\"While checking whether dependency {node_name!r} from task(s) \\\"\\n         f\\\"{successors} exists, an error was raised.\\\"\\n\",\"diff --git a/src/_pytask/dag_utils.py b/src/_pytask/dag_utils.py\\nindex 650cf75..ded08d3 100644\\n--- a/src/_pytask/dag_utils.py\\n+++ b/src/_pytask/dag_utils.py\\n@@ -84,8 +84,10 @@ class TopologicalSorter:\\n         ]\\n         priorities = _extract_priorities_from_tasks(tasks)\\n \\n-        task_names = {task.name for task in tasks}\\n-        task_dict = {name: nx.ancestors(dag, name) & task_names for name in task_names}\\n+        task_signatures = {task.signature for task in tasks}\\n+        task_dict = {\\n+            name: nx.ancestors(dag, name) & task_signatures for name in task_signatures\\n+        }\\n         task_dag = nx.DiGraph(task_dict).reverse()\\n \\n         return cls(dag=task_dag, priorities=priorities, dag_backup=task_dag.copy())\\n@@ -156,7 +158,7 @@ def _extract_priorities_from_tasks(tasks: list[PTask]) -> dict[str, int]:\\n \\n     \\\"\\\"\\\"\\n     priorities = {\\n-        task.name: {\\n+        task.signature: {\\n             \\\"try_first\\\": has_mark(task, \\\"try_first\\\"),\\n             \\\"try_last\\\": has_mark(task, \\\"try_last\\\"),\\n         }\\n@@ -167,7 +169,7 @@ def _extract_priorities_from_tasks(tasks: list[PTask]) -> dict[str, int]:\\n     ]\\n \\n     if tasks_w_mixed_priorities:\\n-        name_to_task = {task.name: task for task in tasks}\\n+        name_to_task = {task.signature: task for task in tasks}\\n         reduced_names = []\\n         for name in tasks_w_mixed_priorities:\\n             reduced_name = format_task_name(name_to_task[name], \\\"no_link\\\")\\n\",\"diff --git a/src/_pytask/data_catalog.py b/src/_pytask/data_catalog.py\\nindex e2ece94..6fdad66 100644\\n--- a/src/_pytask/data_catalog.py\\n+++ b/src/_pytask/data_catalog.py\\n@@ -25,12 +25,6 @@ from attrs import field\\n __all__ = [\\\"DataCatalog\\\"]\\n \\n \\n-def _find_root_path(path: Path) -> Path:\\n-    \\\"\\\"\\\"Find path where data catalog can store its data.\\\"\\\"\\\"\\n-    root_path, _ = find_project_root_and_config([path])\\n-    return root_path.joinpath(\\\".pytask\\\", \\\"data_catalogs\\\")\\n-\\n-\\n def _get_parent_path_of_data_catalog_module(stacklevel: int = 2) -> Path:\\n     \\\"\\\"\\\"Get the parent path of the module where the data catalog is defined.\\\"\\\"\\\"\\n     stack = inspect.stack()\\n@@ -77,9 +71,11 @@ class DataCatalog:\\n     _instance_path: Path = field(factory=_get_parent_path_of_data_catalog_module)\\n \\n     def __attrs_post_init__(self) -> None:\\n+        root_path, _ = find_project_root_and_config((self._instance_path,))\\n+        self._session.config[\\\"paths\\\"] = (root_path,)\\n+\\n         if not self.path:\\n-            root = _find_root_path(self._instance_path)\\n-            self.path = root / self.name\\n+            self.path = root_path / \\\".pytask\\\" / \\\"data_catalogs\\\" / self.name\\n \\n         self.path.mkdir(parents=True, exist_ok=True)\\n \\n\",\"diff --git a/src/_pytask/database_utils.py b/src/_pytask/database_utils.py\\nindex 0fa574e..a0f297b 100644\\n--- a/src/_pytask/database_utils.py\\n+++ b/src/_pytask/database_utils.py\\n@@ -59,9 +59,9 @@ def _create_or_update_state(first_key: str, second_key: str, hash_: str) -> None\\n         session.commit()\\n \\n \\n-def update_states_in_database(session: Session, task_name: str) -> None:\\n+def update_states_in_database(session: Session, task_signature: str) -> None:\\n     \\\"\\\"\\\"Update the state for each node of a task in the database.\\\"\\\"\\\"\\n-    for name in node_and_neighbors(session.dag, task_name):\\n+    for name in node_and_neighbors(session.dag, task_signature):\\n         node = session.dag.nodes[name].get(\\\"task\\\") or session.dag.nodes[name][\\\"node\\\"]\\n         hash_ = node.state()\\n-        _create_or_update_state(task_name, node.name, hash_)\\n+        _create_or_update_state(task_signature, node.signature, hash_)\\n\",\"diff --git a/src/_pytask/execute.py b/src/_pytask/execute.py\\nindex 48e1137..e25d786 100644\\n--- a/src/_pytask/execute.py\\n+++ b/src/_pytask/execute.py\\n@@ -126,7 +126,7 @@ def pytask_execute_task_setup(session: Session, task: PTask) -> None:\\n     2. Create the directory where the product will be placed.\\n \\n     \\\"\\\"\\\"\\n-    for dependency in session.dag.predecessors(task.name):\\n+    for dependency in session.dag.predecessors(task.signature):\\n         node = session.dag.nodes[dependency][\\\"node\\\"]\\n         if not node.state():\\n             msg = f\\\"{node.name} is missing and required for {task.name}.\\\"\\n@@ -134,7 +134,7 @@ def pytask_execute_task_setup(session: Session, task: PTask) -> None:\\n \\n     # Create directory for product if it does not exist. Maybe this should be a `setup`\\n     # method for the node classes.\\n-    for product in session.dag.successors(task.name):\\n+    for product in session.dag.successors(task.signature):\\n         node = session.dag.nodes[product][\\\"node\\\"]\\n         if isinstance(node, PPathNode):\\n             node.path.parent.mkdir(parents=True, exist_ok=True)\\n@@ -148,8 +148,7 @@ def _safe_load(node: PNode, task: PTask, is_product: bool) -> Any:\\n     try:\\n         return node.load(is_product=is_product)\\n     except Exception as e:  # noqa: BLE001\\n-        task_name = getattr(task, \\\"display_name\\\", task.name)\\n-        msg = f\\\"Exception while loading node {node.name!r} of task {task_name!r}\\\"\\n+        msg = f\\\"Exception while loading node {node.name!r} of task {task.name!r}\\\"\\n         raise NodeLoadError(msg) from e\\n \\n \\n@@ -195,7 +194,7 @@ def pytask_execute_task(session: Session, task: PTask) -> bool:\\n def pytask_execute_task_teardown(session: Session, task: PTask) -> None:\\n     \\\"\\\"\\\"Check if :class:`_pytask.nodes.PathNode` are produced by a task.\\\"\\\"\\\"\\n     missing_nodes = []\\n-    for product in session.dag.successors(task.name):\\n+    for product in session.dag.successors(task.signature):\\n         node = session.dag.nodes[product][\\\"node\\\"]\\n         if not node.state():\\n             missing_nodes.append(node)\\n@@ -223,11 +222,11 @@ def pytask_execute_task_process_report(\\n     \\\"\\\"\\\"\\n     task = report.task\\n     if report.outcome == TaskOutcome.SUCCESS:\\n-        update_states_in_database(session, task.name)\\n+        update_states_in_database(session, task.signature)\\n     elif report.exc_info and isinstance(report.exc_info[1], WouldBeExecuted):\\n         report.outcome = TaskOutcome.WOULD_BE_EXECUTED\\n \\n-        for descending_task_name in descending_tasks(task.name, session.dag):\\n+        for descending_task_name in descending_tasks(task.signature, session.dag):\\n             descending_task = session.dag.nodes[descending_task_name][\\\"task\\\"]\\n             descending_task.markers.append(\\n                 Mark(\\n@@ -237,7 +236,7 @@ def pytask_execute_task_process_report(\\n                 )\\n             )\\n     else:\\n-        for descending_task_name in descending_tasks(task.name, session.dag):\\n+        for descending_task_name in descending_tasks(task.signature, session.dag):\\n             descending_task = session.dag.nodes[descending_task_name][\\\"task\\\"]\\n             descending_task.markers.append(\\n                 Mark(\\n\",\"diff --git a/src/_pytask/hookspecs.py b/src/_pytask/hookspecs.py\\nindex b1b3c52..f1c71e7 100644\\n--- a/src/_pytask/hookspecs.py\\n+++ b/src/_pytask/hookspecs.py\\n@@ -267,7 +267,7 @@ def pytask_dag_select_execution_dag(session: Session, dag: nx.DiGraph) -> None:\\n \\n @hookspec(firstresult=True)\\n def pytask_dag_has_node_changed(\\n-    session: Session, dag: nx.DiGraph, node: MetaNode, task_name: str\\n+    session: Session, dag: nx.DiGraph, task: PTask, node: MetaNode\\n ) -> None:\\n     \\\"\\\"\\\"Select the subgraph which needs to be executed.\\n \\n\",\"diff --git a/src/_pytask/live.py b/src/_pytask/live.py\\nindex db5874f..495440c 100644\\n--- a/src/_pytask/live.py\\n+++ b/src/_pytask/live.py\\n@@ -264,7 +264,7 @@ class LiveExecution:\\n         self._running_tasks.pop(new_report.task.name)\\n         self._reports.append(\\n             _ReportEntry(\\n-                name=getattr(new_report.task, \\\"display_name\\\", new_report.task.name),\\n+                name=new_report.task.name,\\n                 outcome=new_report.outcome,\\n                 task=new_report.task,\\n             )\\n\",\"diff --git a/src/_pytask/mark/__init__.py b/src/_pytask/mark/__init__.py\\nindex fb90eb1..7866534 100644\\n--- a/src/_pytask/mark/__init__.py\\n+++ b/src/_pytask/mark/__init__.py\\n@@ -162,7 +162,7 @@ def select_by_keyword(session: Session, dag: nx.DiGraph) -> set[str]:\\n     remaining: set[str] = set()\\n     for task in session.tasks:\\n         if keywordexpr and expression.evaluate(KeywordMatcher.from_task(task)):\\n-            remaining.update(task_and_preceding_tasks(task.name, dag))\\n+            remaining.update(task_and_preceding_tasks(task.signature, dag))\\n \\n     return remaining\\n \\n@@ -201,7 +201,7 @@ def select_by_mark(session: Session, dag: nx.DiGraph) -> set[str]:\\n     remaining: set[str] = set()\\n     for task in session.tasks:\\n         if expression.evaluate(MarkMatcher.from_task(task)):\\n-            remaining.update(task_and_preceding_tasks(task.name, dag))\\n+            remaining.update(task_and_preceding_tasks(task.signature, dag))\\n \\n     return remaining\\n \\n@@ -211,7 +211,7 @@ def _deselect_others_with_mark(\\n ) -> None:\\n     \\\"\\\"\\\"Deselect tasks.\\\"\\\"\\\"\\n     for task in session.tasks:\\n-        if task.name not in remaining:\\n+        if task.signature not in remaining:\\n             task.markers.append(mark)\\n \\n \\n\",\"diff --git a/src/_pytask/node_protocols.py b/src/_pytask/node_protocols.py\\nindex dec5f59..4a3f444 100644\\n--- a/src/_pytask/node_protocols.py\\n+++ b/src/_pytask/node_protocols.py\\n@@ -22,7 +22,11 @@ class MetaNode(Protocol):\\n     \\\"\\\"\\\"Protocol for an intersection between nodes and tasks.\\\"\\\"\\\"\\n \\n     name: str\\n-    \\\"\\\"\\\"Name of the node that must be unique.\\\"\\\"\\\"\\n+\\n+    @property\\n+    def signature(self) -> str:\\n+        \\\"\\\"\\\"Return the signature of the node.\\\"\\\"\\\"\\n+        ...\\n \\n     @abstractmethod\\n     def state(self) -> str | None:\\n@@ -73,7 +77,6 @@ class PPathNode(PNode, Protocol):\\n class PTask(MetaNode, Protocol):\\n     \\\"\\\"\\\"Protocol for nodes.\\\"\\\"\\\"\\n \\n-    name: str\\n     depends_on: dict[str, PyTree[PNode]]\\n     produces: dict[str, PyTree[PNode]]\\n     markers: list[Mark]\\n\",\"diff --git a/src/_pytask/persist.py b/src/_pytask/persist.py\\nindex 6e5915a..6d32388 100644\\n--- a/src/_pytask/persist.py\\n+++ b/src/_pytask/persist.py\\n@@ -42,7 +42,7 @@ def pytask_execute_task_setup(session: Session, task: PTask) -> None:\\n             (\\n                 session.dag.nodes[name].get(\\\"task\\\") or session.dag.nodes[name][\\\"node\\\"]\\n             ).state()\\n-            for name in node_and_neighbors(session.dag, task.name)\\n+            for name in node_and_neighbors(session.dag, task.signature)\\n         )\\n \\n         if all_nodes_exist:\\n@@ -60,6 +60,6 @@ def pytask_execute_task_process_report(\\n     \\\"\\\"\\\"\\n     if report.exc_info and isinstance(report.exc_info[1], Persisted):\\n         report.outcome = TaskOutcome.PERSISTENCE\\n-        update_states_in_database(session, report.task.name)\\n+        update_states_in_database(session, report.task.signature)\\n         return True\\n     return None\\n\",\"diff --git a/src/_pytask/profile.py b/src/_pytask/profile.py\\nindex 836f78f..f0fc805 100644\\n--- a/src/_pytask/profile.py\\n+++ b/src/_pytask/profile.py\\n@@ -7,7 +7,6 @@ import json\\n import sys\\n import time\\n from contextlib import suppress\\n-from pathlib import Path\\n from typing import Any\\n from typing import Generator\\n from typing import TYPE_CHECKING\\n@@ -36,6 +35,7 @@ from sqlalchemy import String\\n \\n \\n if TYPE_CHECKING:\\n+    from pathlib import Path\\n     from _pytask.report import ExecutionReport\\n     from typing import NoReturn\\n \\n@@ -85,16 +85,16 @@ def pytask_execute_task_process_report(report: ExecutionReport) -> None:\\n     task = report.task\\n     duration = task.attributes.get(\\\"duration\\\")\\n     if report.outcome == TaskOutcome.SUCCESS and duration is not None:\\n-        _create_or_update_runtime(task.name, *duration)\\n+        _create_or_update_runtime(task.signature, *duration)\\n \\n \\n-def _create_or_update_runtime(task_name: str, start: float, end: float) -> None:\\n+def _create_or_update_runtime(task_signature: str, start: float, end: float) -> None:\\n     \\\"\\\"\\\"Create or update a runtime entry.\\\"\\\"\\\"\\n     with DatabaseSession() as session:\\n-        runtime = session.get(Runtime, task_name)\\n+        runtime = session.get(Runtime, task_signature)\\n \\n         if not runtime:\\n-            session.add(Runtime(task=task_name, date=start, duration=end - start))\\n+            session.add(Runtime(task=task_signature, date=start, duration=end - start))\\n         else:\\n             for attr, val in ((\\\"date\\\", start), (\\\"duration\\\", end - start)):\\n                 setattr(runtime, attr, val)\\n@@ -190,16 +190,16 @@ class DurationNameSpace:\\n         tasks: list[PTask], profile: dict[str, dict[str, Any]]\\n     ) -> None:\\n         \\\"\\\"\\\"Add the runtime for tasks to the profile.\\\"\\\"\\\"\\n-        runtimes = _collect_runtimes([task.name for task in tasks])\\n+        runtimes = _collect_runtimes(tasks)\\n         for name, duration in runtimes.items():\\n             profile[name][\\\"Duration (in s)\\\"] = round(duration, 2)\\n \\n \\n-def _collect_runtimes(task_names: list[str]) -> dict[str, float]:\\n+def _collect_runtimes(tasks: list[PTask]) -> dict[str, float]:\\n     \\\"\\\"\\\"Collect runtimes.\\\"\\\"\\\"\\n     with DatabaseSession() as session:\\n-        runtimes = [session.get(Runtime, task_name) for task_name in task_names]\\n-    return {r.task: r.duration for r in runtimes if r}  # type: ignore[misc]\\n+        runtimes = [session.get(Runtime, task.signature) for task in tasks]\\n+    return {task.name: r.duration for task, r in zip(tasks, runtimes) if r}  # type: ignore[misc]\\n \\n \\n class FileSizeNameSpace:\\n@@ -212,7 +212,7 @@ class FileSizeNameSpace:\\n     ) -> None:\\n         \\\"\\\"\\\"Add the total file size of all products for a task.\\\"\\\"\\\"\\n         for task in tasks:\\n-            successors = list(session.dag.successors(task.name))\\n+            successors = list(session.dag.successors(task.signature))\\n             if successors:\\n                 sum_bytes = 0\\n                 for successor in successors:\\n@@ -264,9 +264,9 @@ class ExportNameSpace:\\n         export = session.config[\\\"export\\\"]\\n \\n         if export == _ExportFormats.CSV:\\n-            _export_to_csv(profile)\\n+            _export_to_csv(profile, session.config[\\\"root\\\"])\\n         elif export == _ExportFormats.JSON:\\n-            _export_to_json(profile)\\n+            _export_to_json(profile, session.config[\\\"root\\\"])\\n         elif export == _ExportFormats.NO:\\n             pass\\n         else:  # pragma: no cover\\n@@ -274,10 +274,10 @@ class ExportNameSpace:\\n             raise ValueError(msg)\\n \\n \\n-def _export_to_csv(profile: dict[str, dict[str, Any]]) -> None:\\n+def _export_to_csv(profile: dict[str, dict[str, Any]], root: Path) -> None:\\n     \\\"\\\"\\\"Export profile to csv.\\\"\\\"\\\"\\n     info_names = _get_info_names(profile)\\n-    path = Path.cwd().joinpath(\\\"profile.csv\\\")\\n+    path = root.joinpath(\\\"profile.csv\\\")\\n \\n     with path.open(\\\"w\\\", newline=\\\"\\\") as file:\\n         writer = csv.writer(file)\\n@@ -286,10 +286,10 @@ def _export_to_csv(profile: dict[str, dict[str, Any]]) -> None:\\n             writer.writerow((task_name, *info.values()))\\n \\n \\n-def _export_to_json(profile: dict[str, dict[str, Any]]) -> None:\\n+def _export_to_json(profile: dict[str, dict[str, Any]], root: Path) -> None:\\n     \\\"\\\"\\\"Export profile to json.\\\"\\\"\\\"\\n     json_ = json.dumps(profile)\\n-    path = Path.cwd().joinpath(\\\"profile.json\\\")\\n+    path = root.joinpath(\\\"profile.json\\\")\\n     path.write_text(json_)\\n \\n \\n\",\"diff --git a/src/_pytask/skipping.py b/src/_pytask/skipping.py\\nindex 8f83727..ab7b28f 100644\\n--- a/src/_pytask/skipping.py\\n+++ b/src/_pytask/skipping.py\\n@@ -94,7 +94,7 @@ def pytask_execute_task_process_report(\\n         elif isinstance(report.exc_info[1], Skipped):\\n             report.outcome = TaskOutcome.SKIP\\n \\n-            for descending_task_name in descending_tasks(task.name, session.dag):\\n+            for descending_task_name in descending_tasks(task.signature, session.dag):\\n                 descending_task = session.dag.nodes[descending_task_name][\\\"task\\\"]\\n                 descending_task.markers.append(\\n                     Mark(\\n\",\"diff --git a/src/_pytask/warnings_utils.py b/src/_pytask/warnings_utils.py\\nindex 4d0292e..14db138 100644\\n--- a/src/_pytask/warnings_utils.py\\n+++ b/src/_pytask/warnings_utils.py\\n@@ -175,7 +175,7 @@ def catch_warnings_for_item(\\n \\n         yield\\n \\n-        id_ = getattr(task, \\\"display_name\\\", task.name) if task is not None else when\\n+        id_ = task.name if task is not None else when\\n \\n         for warning_message in log:\\n             fs_location = warning_message.filename, warning_message.lineno\\n\",\"diff --git a/src/pytask/__init__.py b/src/pytask/__init__.py\\nindex af056ea..35c448c 100644\\n--- a/src/pytask/__init__.py\\n+++ b/src/pytask/__init__.py\\n@@ -2,6 +2,7 @@\\n from __future__ import annotations\\n \\n from _pytask import __version__\\n+from _pytask._hashlib import hash_value\\n from _pytask.build import build\\n from _pytask.click import ColoredCommand\\n from _pytask.click import ColoredGroup\\n@@ -136,6 +137,7 @@ __all__ = [\\n     \\\"get_all_marks\\\",\\n     \\\"get_marks\\\",\\n     \\\"has_mark\\\",\\n+    \\\"hash_value\\\",\\n     \\\"hookimpl\\\",\\n     \\\"import_optional_dependency\\\",\\n     \\\"is_task_function\\\",\\n\"]", "test_patch": "[\"diff --git a/environment.yml b/environment.yml\\nindex 7cb2c23..af664d1 100644\\n--- a/environment.yml\\n+++ b/environment.yml\\n@@ -33,6 +33,7 @@ dependencies:\\n   - pygraphviz\\n   - pytest\\n   - pytest-cov\\n+  - pytest-env\\n   - pytest-xdist\\n   - tabulate\\n   - tox\\n\",\"diff --git a/pyproject.toml b/pyproject.toml\\nindex 50227d0..eaf21b7 100644\\n--- a/pyproject.toml\\n+++ b/pyproject.toml\\n@@ -155,7 +155,11 @@ markers = [\\n     \\\"end_to_end: Flag for tests that cover the whole program.\\\",\\n ]\\n norecursedirs = [\\\".idea\\\", \\\".tox\\\"]\\n-filterwarnings = [\\\"ignore:'@pytask.mark.*. is deprecated:FutureWarning\\\"]\\n+filterwarnings = [\\n+    \\\"ignore:'@pytask.mark.*. is deprecated:FutureWarning\\\",\\n+    \\\"ignore:The --rsyncdir command line argument:DeprecationWarning\\\",\\n+]\\n+env = [\\\"PYDEVD_DISABLE_FILE_VALIDATION=1\\\"]\\n \\n [tool.mypy]\\n files = [\\\"src\\\", \\\"tests\\\"]\\n\",\"diff --git a/src/_pytask/collect.py b/src/_pytask/collect.py\\nindex 501bfd2..1f739a7 100644\\n--- a/src/_pytask/collect.py\\n+++ b/src/_pytask/collect.py\\n@@ -37,6 +37,7 @@ from _pytask.outcomes import CollectionOutcome\\n from _pytask.outcomes import count_outcomes\\n from _pytask.path import find_case_sensitive_path\\n from _pytask.path import import_path\\n+from _pytask.path import shorten_path\\n from _pytask.report import CollectionReport\\n from _pytask.shared import find_duplicates\\n from _pytask.task_utils import task as task_decorator\\n@@ -163,7 +164,8 @@ def pytask_collect_file_protocol(\\n         )\\n         flat_reports = list(itertools.chain.from_iterable(new_reports))\\n     except Exception:  # noqa: BLE001\\n-        node = PathNode.from_path(path)\\n+        name = shorten_path(path, session.config[\\\"paths\\\"])\\n+        node = PathNode(name=name, path=path)\\n         flat_reports = [\\n             CollectionReport.from_exception(\\n                 outcome=CollectionOutcome.FAIL, node=node, exc_info=sys.exc_info()\\n@@ -339,6 +341,14 @@ def pytask_collect_node(session: Session, path: Path, node_info: NodeInfo) -> PN\\n             node.path, session.config[\\\"check_casing_of_paths\\\"]\\n         )\\n \\n+    if isinstance(node, PathNode) and (\\n+        not node.name or node.name == node.path.as_posix()\\n+    ):\\n+        # Shorten name of PathNodes.\\n+        node.name = shorten_path(\\n+            node.path, session.config[\\\"paths\\\"] or (session.config[\\\"root\\\"],)\\n+        )\\n+\\n     if isinstance(node, PNode):\\n         return node\\n \\n@@ -352,7 +362,8 @@ def pytask_collect_node(session: Session, path: Path, node_info: NodeInfo) -> PN\\n         _raise_error_if_casing_of_path_is_wrong(\\n             node, session.config[\\\"check_casing_of_paths\\\"]\\n         )\\n-        return PathNode.from_path(node)\\n+        name = shorten_path(node, session.config[\\\"paths\\\"] or (session.config[\\\"root\\\"],))\\n+        return PathNode(name=name, path=node)\\n \\n     node_name = create_name_of_python_node(node_info)\\n     return PythonNode(value=node, name=node_name)\\n@@ -397,7 +408,7 @@ def pytask_collect_modify_tasks(tasks: list[PTask]) -> None:\\n     id_to_short_id = _find_shortest_uniquely_identifiable_name_for_tasks(tasks)\\n     for task in tasks:\\n         if task.name in id_to_short_id and isinstance(task, Task):\\n-            task.display_name = id_to_short_id[task.name]\\n+            task.name = id_to_short_id[task.name]\\n \\n \\n def _find_shortest_uniquely_identifiable_name_for_tasks(\\n\",\"diff --git a/src/_pytask/nodes.py b/src/_pytask/nodes.py\\nindex 27a2acb..9e135a9 100644\\n--- a/src/_pytask/nodes.py\\n+++ b/src/_pytask/nodes.py\\n@@ -1,7 +1,6 @@\\n \\\"\\\"\\\"Contains implementations of tasks and nodes following the node protocols.\\\"\\\"\\\"\\n from __future__ import annotations\\n \\n-import functools\\n import hashlib\\n import inspect\\n import pickle\\n@@ -65,6 +64,11 @@ class TaskWithoutPath(PTask):\\n     report_sections: list[tuple[str, str, str]] = field(factory=list)\\n     attributes: dict[Any, Any] = field(factory=dict)\\n \\n+    @property\\n+    def signature(self) -> str:\\n+        raw_key = str(hash_value(self.name))\\n+        return hashlib.sha256(raw_key.encode()).hexdigest()\\n+\\n     def state(self) -> str | None:\\n         \\\"\\\"\\\"Return the state of the node.\\\"\\\"\\\"\\n         try:\\n@@ -93,8 +97,6 @@ class Task(PTaskWithPath):\\n         The task function.\\n     name\\n         The name of the task.\\n-    display_name\\n-        The shortest uniquely identifiable name for task for display.\\n     depends_on\\n         A list of dependencies of task.\\n     produces\\n@@ -112,7 +114,6 @@ class Task(PTaskWithPath):\\n     path: Path\\n     function: Callable[..., Any]\\n     name: str = field(default=\\\"\\\", init=False)\\n-    display_name: str = field(default=\\\"\\\", init=False)\\n     depends_on: dict[str, PyTree[PNode]] = field(factory=dict)\\n     produces: dict[str, PyTree[PNode]] = field(factory=dict)\\n     markers: list[Mark] = field(factory=list)\\n@@ -124,8 +125,11 @@ class Task(PTaskWithPath):\\n         if not self.name:\\n             self.name = self.path.as_posix() + \\\"::\\\" + self.base_name\\n \\n-        if not self.display_name:\\n-            self.display_name = self.name\\n+    @property\\n+    def signature(self) -> str:\\n+        \\\"\\\"\\\"The unique signature of the node.\\\"\\\"\\\"\\n+        raw_key = \\\"\\\".join(str(hash_value(arg)) for arg in (self.base_name, self.path))\\n+        return hashlib.sha256(raw_key.encode()).hexdigest()\\n \\n     def state(self) -> str | None:\\n         \\\"\\\"\\\"Return the state of the node.\\\"\\\"\\\"\\n@@ -155,17 +159,15 @@ class PathNode(PPathNode):\\n     name: str\\n     path: Path\\n \\n+    @property\\n+    def signature(self) -> str:\\n+        \\\"\\\"\\\"The unique signature of the node.\\\"\\\"\\\"\\n+        raw_key = str(hash_value(self.path))\\n+        return hashlib.sha256(raw_key.encode()).hexdigest()\\n+\\n     @classmethod\\n-    @functools.lru_cache\\n     def from_path(cls, path: Path) -> PathNode:\\n-        \\\"\\\"\\\"Instantiate class from path to file.\\n-\\n-        The `lru_cache` decorator ensures that the same object is not collected twice.\\n-\\n-        \\\"\\\"\\\"\\n-        if not path.is_absolute():\\n-            msg = \\\"Node must be instantiated from absolute path.\\\"\\n-            raise ValueError(msg)\\n+        \\\"\\\"\\\"Instantiate class from path to file.\\\"\\\"\\\"\\n         return cls(name=path.as_posix(), path=path)\\n \\n     def state(self) -> str | None:\\n@@ -209,6 +211,8 @@ class PythonNode(PNode):\\n         objects that are hashable like strings and tuples. For dictionaries and other\\n         non-hashable objects, you need to provide a function that can hash these\\n         objects.\\n+    signature\\n+        The signature of the node.\\n \\n     Examples\\n     --------\\n@@ -226,6 +230,12 @@ class PythonNode(PNode):\\n     value: Any | NoDefault = no_default\\n     hash: bool | Callable[[Any], bool] = False  # noqa: A003\\n \\n+    @property\\n+    def signature(self) -> str:\\n+        \\\"\\\"\\\"The unique signature of the node.\\\"\\\"\\\"\\n+        raw_key = str(hash_value(self.name))\\n+        return hashlib.sha256(raw_key.encode()).hexdigest()\\n+\\n     def load(self, is_product: bool = False) -> Any:\\n         \\\"\\\"\\\"Load the value.\\\"\\\"\\\"\\n         if is_product:\\n@@ -280,6 +290,12 @@ class PickleNode:\\n     name: str\\n     path: Path\\n \\n+    @property\\n+    def signature(self) -> str:\\n+        \\\"\\\"\\\"The unique signature of the node.\\\"\\\"\\\"\\n+        raw_key = str(hash_value(self.path))\\n+        return hashlib.sha256(raw_key.encode()).hexdigest()\\n+\\n     @classmethod\\n     def from_path(cls, path: Path) -> PickleNode:\\n         \\\"\\\"\\\"Instantiate class from path to file.\\\"\\\"\\\"\\n\",\"diff --git a/tests/test_collect.py b/tests/test_collect.py\\nindex 28a140e..654e63a 100644\\n--- a/tests/test_collect.py\\n+++ b/tests/test_collect.py\\n@@ -156,7 +156,9 @@ def test_collect_files_w_custom_file_name_pattern(\\n     (\\\"session\\\", \\\"path\\\", \\\"node_info\\\", \\\"expected\\\"),\\n     [\\n         pytest.param(\\n-            Session.from_config({\\\"check_casing_of_paths\\\": False}),\\n+            Session.from_config(\\n+                {\\\"check_casing_of_paths\\\": False, \\\"paths\\\": (Path.cwd(),)}\\n+            ),\\n             Path(),\\n             NodeInfo(\\n                 arg_name=\\\"\\\",\\n@@ -169,7 +171,9 @@ def test_collect_files_w_custom_file_name_pattern(\\n             id=\\\"test with absolute string path\\\",\\n         ),\\n         pytest.param(\\n-            Session.from_config({\\\"check_casing_of_paths\\\": False}),\\n+            Session.from_config(\\n+                {\\\"check_casing_of_paths\\\": False, \\\"paths\\\": (Path.cwd(),)}\\n+            ),\\n             Path(),\\n             NodeInfo(\\n                 arg_name=\\\"\\\",\\n@@ -220,7 +224,7 @@ def test_pytask_collect_node_raises_error_if_path_is_not_correctly_cased(tmp_pat\\n def test_pytask_collect_node_does_not_raise_error_if_path_is_not_normalized(\\n     tmp_path, is_absolute\\n ):\\n-    session = Session.from_config({\\\"check_casing_of_paths\\\": True})\\n+    session = Session.from_config({\\\"check_casing_of_paths\\\": True, \\\"paths\\\": (tmp_path,)})\\n     real_node = tmp_path / \\\"text.txt\\\"\\n \\n     collected_node = Path(\\\"..\\\", tmp_path.name, \\\"text.txt\\\")\\n\",\"diff --git a/tests/test_collect_command.py b/tests/test_collect_command.py\\nindex 9e8debd..9f0f76a 100644\\n--- a/tests/test_collect_command.py\\n+++ b/tests/test_collect_command.py\\n@@ -524,6 +524,7 @@ def test_node_protocol_for_custom_nodes(runner, tmp_path):\\n     class CustomNode:\\n         name: str\\n         value: str\\n+        signature: str = \\\"id\\\"\\n \\n         def state(self):\\n             return self.value\\n@@ -557,6 +558,7 @@ def test_node_protocol_for_custom_nodes_with_paths(runner, tmp_path):\\n     class PickleFile:\\n         name: str\\n         path: Path\\n+        signature: str = \\\"id\\\"\\n \\n         def state(self):\\n             return str(self.path.stat().st_mtime)\\n\",\"diff --git a/tests/test_console.py b/tests/test_console.py\\nindex 1251c08..a0a0947 100644\\n--- a/tests/test_console.py\\n+++ b/tests/test_console.py\\n@@ -116,14 +116,12 @@ _THIS_FILE = Path(__file__)\\n @pytest.mark.parametrize(\\n     (\\n         \\\"base_name\\\",\\n-        \\\"short_name\\\",\\n         \\\"editor_url_scheme\\\",\\n         \\\"expected\\\",\\n     ),\\n     [\\n         pytest.param(\\n             \\\"task_a\\\",\\n-            None,\\n             \\\"no_link\\\",\\n             Text(\\n                 _THIS_FILE.as_posix() + \\\"::task_a\\\",\\n@@ -135,16 +133,12 @@ _THIS_FILE = Path(__file__)\\n )\\n def test_format_task_id(\\n     base_name,\\n-    short_name,\\n     editor_url_scheme,\\n     expected,\\n ):\\n     path = _THIS_FILE\\n \\n     task = Task(base_name=base_name, path=path, function=task_func)\\n-    if short_name is not None:\\n-        task.display_name = short_name\\n-\\n     result = format_task_name(task, editor_url_scheme)\\n     assert result == expected\\n \\n\",\"diff --git a/tests/test_dag.py b/tests/test_dag.py\\nindex af12071..44c1fc3 100644\\n--- a/tests/test_dag.py\\n+++ b/tests/test_dag.py\\n@@ -1,5 +1,6 @@\\n from __future__ import annotations\\n \\n+import sys\\n import textwrap\\n from pathlib import Path\\n \\n@@ -24,8 +25,9 @@ class Node(PathNode):\\n \\n \\n @pytest.mark.unit()\\n+@pytest.mark.skipif(sys.platform == \\\"win32\\\", reason=\\\"Hashes match only on unix.\\\")\\n def test_pytask_dag_create_dag():\\n-    root = Path.cwd() / \\\"src\\\"\\n+    root = Path(\\\"src\\\")\\n     task = Task(\\n         base_name=\\\"task_dummy\\\",\\n         path=root,\\n@@ -38,9 +40,12 @@ def test_pytask_dag_create_dag():\\n \\n     dag = pytask_dag_create_dag([task])\\n \\n-    assert all(\\n-        any(i in node for i in (\\\"node_1\\\", \\\"node_2\\\", \\\"task\\\")) for node in dag.nodes\\n-    )\\n+    for signature in (\\n+        \\\"90bb899a1b60da28ff70352cfb9f34a8bed485597c7f40eed9bd4c6449147525\\\",\\n+        \\\"59e9f20637ce34e9bcecc7bafffb5c593bac9388ac3a60d7ed0210444146c705\\\",\\n+        \\\"638a01e495bb8e263036ef2b3009795bb118926cc7f20f005a64c351d820a669\\\",\\n+    ):\\n+        assert signature in dag.nodes\\n \\n \\n @pytest.mark.end_to_end()\\n@@ -149,6 +154,8 @@ def test_cycle_in_dag(tmp_path, runner):\\n     assert result.exit_code == ExitCode.DAG_FAILED\\n     assert \\\"Failures during resolving dependencies\\\" in result.output\\n     assert \\\"The DAG contains cycles which means a dependency\\\" in result.output\\n+    assert \\\"task_1\\\" in result.output\\n+    assert \\\"task_2\\\" in result.output\\n \\n \\n @pytest.mark.end_to_end()\\n\",\"diff --git a/tests/test_dag_utils.py b/tests/test_dag_utils.py\\nindex 3b25a8f..f6c685d 100644\\n--- a/tests/test_dag_utils.py\\n+++ b/tests/test_dag_utils.py\\n@@ -18,11 +18,11 @@ from pytask import Task\\n def dag():\\n     dag = nx.DiGraph()\\n     for i in range(4):\\n-        dag.add_node(f\\\".::{i}\\\", task=Task(base_name=str(i), path=Path(), function=None))\\n-        dag.add_node(\\n-            f\\\".::{i + 1}\\\", task=Task(base_name=str(i + 1), path=Path(), function=None)\\n-        )\\n-        dag.add_edge(f\\\".::{i}\\\", f\\\".::{i + 1}\\\")\\n+        task = Task(base_name=str(i), path=Path(), function=None)\\n+        next_task = Task(base_name=str(i + 1), path=Path(), function=None)\\n+        dag.add_node(task.signature, task=task)\\n+        dag.add_node(next_task.signature, task=next_task)\\n+        dag.add_edge(task.signature, next_task.signature)\\n \\n     return dag\\n \\n@@ -30,28 +30,47 @@ def dag():\\n @pytest.mark.unit()\\n def test_sort_tasks_topologically(dag):\\n     topo_ordering = list(TopologicalSorter.from_dag(dag).static_order())\\n-    assert topo_ordering == [f\\\".::{i}\\\" for i in range(5)]\\n+    topo_names = [dag.nodes[sig][\\\"task\\\"].name for sig in topo_ordering]\\n+    assert topo_names == [f\\\".::{i}\\\" for i in range(5)]\\n \\n \\n @pytest.mark.unit()\\n def test_descending_tasks(dag):\\n     for i in range(5):\\n-        descendants = sorted(descending_tasks(f\\\".::{i}\\\", dag))\\n-        assert descendants == [f\\\".::{i}\\\" for i in range(i + 1, 5)]\\n+        task = next(\\n+            dag.nodes[sig][\\\"task\\\"]\\n+            for sig in dag.nodes\\n+            if dag.nodes[sig][\\\"task\\\"].name == f\\\".::{i}\\\"\\n+        )\\n+        descendants = descending_tasks(task.signature, dag)\\n+        descendant_names = sorted(dag.nodes[sig][\\\"task\\\"].name for sig in descendants)\\n+        assert descendant_names == [f\\\".::{i}\\\" for i in range(i + 1, 5)]\\n \\n \\n @pytest.mark.unit()\\n def test_task_and_descending_tasks(dag):\\n     for i in range(5):\\n-        descendants = sorted(task_and_descending_tasks(f\\\".::{i}\\\", dag))\\n-        assert descendants == [f\\\".::{i}\\\" for i in range(i, 5)]\\n+        task = next(\\n+            dag.nodes[sig][\\\"task\\\"]\\n+            for sig in dag.nodes\\n+            if dag.nodes[sig][\\\"task\\\"].name == f\\\".::{i}\\\"\\n+        )\\n+        descendants = task_and_descending_tasks(task.signature, dag)\\n+        descendant_names = sorted(dag.nodes[sig][\\\"task\\\"].name for sig in descendants)\\n+        assert descendant_names == [f\\\".::{i}\\\" for i in range(i, 5)]\\n \\n \\n @pytest.mark.unit()\\n def test_node_and_neighbors(dag):\\n     for i in range(1, 4):\\n-        nodes = sorted(node_and_neighbors(dag, f\\\".::{i}\\\"))\\n-        assert nodes == [f\\\".::{j}\\\" for j in range(i - 1, i + 2)]\\n+        task = next(\\n+            dag.nodes[sig][\\\"task\\\"]\\n+            for sig in dag.nodes\\n+            if dag.nodes[sig][\\\"task\\\"].name == f\\\".::{i}\\\"\\n+        )\\n+        nodes = node_and_neighbors(dag, task.signature)\\n+        node_names = sorted(dag.nodes[sig][\\\"task\\\"].name for sig in nodes)\\n+        assert node_names == [f\\\".::{j}\\\" for j in range(i - 1, i + 2)]\\n \\n \\n @pytest.mark.unit()\\n@@ -68,7 +87,7 @@ def test_node_and_neighbors(dag):\\n                 )\\n             ],\\n             does_not_raise(),\\n-            {\\\".::1\\\": -1},\\n+            {\\\"c12d8d4f7e2e3128d27878d1fb3d8e3583e90e68000a13634dfbf21f4d1456f3\\\": -1},\\n             id=\\\"test try_last\\\",\\n         ),\\n         pytest.param(\\n@@ -81,13 +100,13 @@ def test_node_and_neighbors(dag):\\n                 )\\n             ],\\n             does_not_raise(),\\n-            {\\\".::1\\\": 1},\\n+            {\\\"c12d8d4f7e2e3128d27878d1fb3d8e3583e90e68000a13634dfbf21f4d1456f3\\\": 1},\\n             id=\\\"test try_first\\\",\\n         ),\\n         pytest.param(\\n             [Task(base_name=\\\"1\\\", path=Path(), function=None, markers=[])],\\n             does_not_raise(),\\n-            {\\\".::1\\\": 0},\\n+            {\\\"c12d8d4f7e2e3128d27878d1fb3d8e3583e90e68000a13634dfbf21f4d1456f3\\\": 0},\\n             id=\\\"test no priority\\\",\\n         ),\\n         pytest.param(\\n@@ -120,7 +139,11 @@ def test_node_and_neighbors(dag):\\n                 ),\\n             ],\\n             does_not_raise(),\\n-            {\\\".::1\\\": 1, \\\".::2\\\": 0, \\\".::3\\\": -1},\\n+            {\\n+                \\\"c12d8d4f7e2e3128d27878d1fb3d8e3583e90e68000a13634dfbf21f4d1456f3\\\": 1,\\n+                \\\"c5f667e69824043475b1283ed8920e513cb4343ec7077f71a3d9f5972f5204b9\\\": 0,\\n+                \\\"dca295f815f54d282b33e8d9398cea4962d0dfbe881d2ab28fc48ff9e060203a\\\": -1,\\n+            },\\n         ),\\n     ],\\n )\\n@@ -139,7 +162,10 @@ def test_raise_error_for_undirected_graphs(dag):\\n \\n @pytest.mark.unit()\\n def test_raise_error_for_cycle_in_graph(dag):\\n-    dag.add_edge(\\\".::4\\\", \\\".::1\\\")\\n+    dag.add_edge(\\n+        \\\"115f685b0af2aef0c7317a0b48562f34cfb7a622549562bd3d34d4d948b4fdab\\\",\\n+        \\\"55c6cef62d3e62d5f8fc65bb846e66d8d0d3ca60608c04f6f7b095ea073a7dcf\\\",\\n+    )\\n     scheduler = TopologicalSorter.from_dag(dag)\\n     with pytest.raises(ValueError, match=\\\"The DAG contains cycles.\\\"):\\n         scheduler.prepare()\\n\",\"diff --git a/tests/test_database.py b/tests/test_database.py\\nindex 516ba58..5c4fd5c 100644\\n--- a/tests/test_database.py\\n+++ b/tests/test_database.py\\n@@ -6,14 +6,15 @@ import pytest\\n from _pytask.database_utils import create_database\\n from _pytask.database_utils import DatabaseSession\\n from _pytask.database_utils import State\\n-from _pytask.path import hash_path\\n+from pytask import build\\n from pytask import cli\\n from pytask import ExitCode\\n+from pytask.path import hash_path\\n from sqlalchemy.engine import make_url\\n \\n \\n @pytest.mark.end_to_end()\\n-def test_existence_of_hashes_in_db(tmp_path, runner):\\n+def test_existence_of_hashes_in_db(tmp_path):\\n     \\\"\\\"\\\"Modification dates of input and output files are stored in database.\\\"\\\"\\\"\\n     source = \\\"\\\"\\\"\\n     import pytask\\n@@ -28,9 +29,9 @@ def test_existence_of_hashes_in_db(tmp_path, runner):\\n     in_path = tmp_path.joinpath(\\\"in.txt\\\")\\n     in_path.touch()\\n \\n-    result = runner.invoke(cli, [tmp_path.as_posix()])\\n+    session = build(paths=tmp_path)\\n \\n-    assert result.exit_code == ExitCode.OK\\n+    assert session.exit_code == ExitCode.OK\\n \\n     create_database(\\n         make_url(\\n@@ -38,16 +39,18 @@ def test_existence_of_hashes_in_db(tmp_path, runner):\\n         )\\n     )\\n \\n-    with DatabaseSession() as session:\\n-        task_id = task_path.as_posix() + \\\"::task_write\\\"\\n+    with DatabaseSession() as db_session:\\n+        task_id = session.tasks[0].signature\\n         out_path = tmp_path.joinpath(\\\"out.txt\\\")\\n+        in_id = session.tasks[0].depends_on[\\\"depends_on\\\"].signature\\n+        out_id = session.tasks[0].produces[\\\"produces\\\"].signature\\n \\n         for id_, path in (\\n             (task_id, task_path),\\n-            (in_path.as_posix(), in_path),\\n-            (out_path.as_posix(), out_path),\\n+            (in_id, in_path),\\n+            (out_id, out_path),\\n         ):\\n-            hash_ = session.get(State, (task_id, id_)).hash_\\n+            hash_ = db_session.get(State, (task_id, id_)).hash_\\n             assert hash_ == hash_path(path, path.stat().st_mtime)\\n \\n \\n\",\"diff --git a/tests/test_execute.py b/tests/test_execute.py\\nindex b672efe..c3c20c2 100644\\n--- a/tests/test_execute.py\\n+++ b/tests/test_execute.py\\n@@ -621,6 +621,7 @@ def test_return_with_custom_node_and_return_annotation(runner, tmp_path):\\n     class PickleNode:\\n         name: str\\n         path: Path\\n+        signature: str = \\\"id\\\"\\n \\n         def state(self) -> str | None:\\n             if self.path.exists():\\n@@ -659,12 +660,19 @@ def test_return_with_custom_node_with_product_annotation(runner, tmp_path):\\n     from typing_extensions import Annotated\\n     import attrs\\n     from pytask import Product\\n+    from _pytask._hashlib import hash_value\\n+    import hashlib\\n \\n     @attrs.define\\n     class PickleNode:\\n         name: str\\n         path: Path\\n \\n+        @property\\n+        def signature(self) -> str:\\n+            raw_key = \\\"\\\".join(str(hash_value(arg)) for arg in (self.name, self.path))\\n+            return hashlib.sha256(raw_key.encode()).hexdigest()\\n+\\n         def state(self) -> str | None:\\n             if self.path.exists():\\n                 return str(self.path.stat().st_mtime)\\n@@ -855,6 +863,7 @@ def test_errors_during_loading_nodes_have_info(runner, tmp_path):\\n     class PickleNode:\\n         name: str\\n         path: Path\\n+        signature: str = \\\"id\\\"\\n \\n         def state(self) -> str | None:\\n             if self.path.exists():\\n@@ -933,7 +942,7 @@ def test_pickle_node_as_product_with_product_annotation(runner, tmp_path):\\n     from pytask import Product, PickleNode\\n     from pathlib import Path\\n \\n-    node = PickleNode(name=\\\"node\\\", path=Path(__file__).parent / \\\"file.txt\\\")\\n+    node = PickleNode(name=\\\"node\\\", path=Path(__file__).parent / \\\"file.pkl\\\")\\n \\n     def task_create_string(node: Annotated[PickleNode, node, Product]) -> None:\\n         node.save(\\\"Hello, World!\\\")\\n\",\"diff --git a/tests/test_live.py b/tests/test_live.py\\nindex 626dbac..bf88746 100644\\n--- a/tests/test_live.py\\n+++ b/tests/test_live.py\\n@@ -30,7 +30,7 @@ def test_verbose_mode_execution(tmp_path, runner, verbose):\\n def test_live_execution_sequentially(capsys, tmp_path):\\n     path = tmp_path.joinpath(\\\"task_module.py\\\")\\n     task = Task(base_name=\\\"task_example\\\", path=path, function=lambda x: x)\\n-    task.display_name = \\\"task_module.py::task_example\\\"\\n+    task.name = \\\"task_module.py::task_example\\\"\\n \\n     live_manager = LiveManager()\\n     live = LiveExecution(\\n@@ -88,7 +88,7 @@ def test_live_execution_sequentially(capsys, tmp_path):\\n def test_live_execution_displays_skips_and_persists(capsys, tmp_path, verbose, outcome):\\n     path = tmp_path.joinpath(\\\"task_module.py\\\")\\n     task = Task(base_name=\\\"task_example\\\", path=path, function=lambda x: x)\\n-    task.display_name = \\\"task_module.py::task_example\\\"\\n+    task.name = \\\"task_module.py::task_example\\\"\\n \\n     live_manager = LiveManager()\\n     live = LiveExecution(\\n@@ -137,7 +137,7 @@ def test_live_execution_displays_skips_and_persists(capsys, tmp_path, verbose, o\\n def test_live_execution_displays_subset_of_table(capsys, tmp_path, n_entries_in_table):\\n     path = tmp_path.joinpath(\\\"task_module.py\\\")\\n     running_task = Task(base_name=\\\"task_running\\\", path=path, function=lambda x: x)\\n-    running_task.display_name = \\\"task_module.py::task_running\\\"\\n+    running_task.name = \\\"task_module.py::task_running\\\"\\n \\n     live_manager = LiveManager()\\n     live = LiveExecution(\\n@@ -160,7 +160,7 @@ def test_live_execution_displays_subset_of_table(capsys, tmp_path, n_entries_in_\\n     assert \\\"Completed: 0/2\\\" in captured.out\\n \\n     completed_task = Task(base_name=\\\"task_completed\\\", path=path, function=lambda x: x)\\n-    completed_task.display_name = \\\"task_module.py::task_completed\\\"\\n+    completed_task.name = \\\"task_module.py::task_completed\\\"\\n     live.update_running_tasks(completed_task)\\n     report = ExecutionReport(\\n         task=completed_task, outcome=TaskOutcome.SUCCESS, exc_info=None\\n@@ -191,7 +191,7 @@ def test_live_execution_displays_subset_of_table(capsys, tmp_path, n_entries_in_\\n def test_live_execution_skips_do_not_crowd_out_displayed_tasks(capsys, tmp_path):\\n     path = tmp_path.joinpath(\\\"task_module.py\\\")\\n     task = Task(base_name=\\\"task_example\\\", path=path, function=lambda x: x)\\n-    task.display_name = \\\"task_module.py::task_example\\\"\\n+    task.name = \\\"task_module.py::task_example\\\"\\n \\n     live_manager = LiveManager()\\n     live = LiveExecution(\\n@@ -215,12 +215,12 @@ def test_live_execution_skips_do_not_crowd_out_displayed_tasks(capsys, tmp_path)\\n     # Add one displayed reports and many more not displayed reports to crowd out the\\n     # valid one.\\n     successful_task = Task(base_name=\\\"task_success\\\", path=path, function=lambda x: x)\\n-    successful_task.display_name = \\\"task_module.py::task_success\\\"\\n+    successful_task.name = \\\"task_module.py::task_success\\\"\\n \\n     tasks = []\\n     for i in range(25):\\n         skipped_task = Task(base_name=f\\\"task_skip_{i}\\\", path=path, function=lambda x: x)\\n-        skipped_task.display_name = f\\\"task_module.py::task_skip_{i}\\\"\\n+        skipped_task.name = f\\\"task_module.py::task_skip_{i}\\\"\\n         tasks.append(skipped_task)\\n \\n     live_manager.start()\\n\",\"diff --git a/tests/test_node_protocols.py b/tests/test_node_protocols.py\\nindex d3e9db1..9677f36 100644\\n--- a/tests/test_node_protocols.py\\n+++ b/tests/test_node_protocols.py\\n@@ -20,6 +20,7 @@ def test_node_protocol_for_custom_nodes(runner, tmp_path):\\n     class CustomNode:\\n         name: str\\n         value: str\\n+        signature: str = \\\"id\\\"\\n \\n         def state(self):\\n             return self.value\\n@@ -57,6 +58,7 @@ def test_node_protocol_for_custom_nodes_with_paths(runner, tmp_path):\\n         name: str\\n         path: Path\\n         value: Path\\n+        signature: str = \\\"id\\\"\\n \\n         def state(self):\\n             return str(self.path.stat().st_mtime)\\n\",\"diff --git a/tests/test_nodes.py b/tests/test_nodes.py\\nindex 612528d..4920184 100644\\n--- a/tests/test_nodes.py\\n+++ b/tests/test_nodes.py\\n@@ -1,6 +1,7 @@\\n from __future__ import annotations\\n \\n import pickle\\n+from pathlib import Path\\n \\n import pytest\\n from pytask import PathNode\\n@@ -8,6 +9,8 @@ from pytask import PickleNode\\n from pytask import PNode\\n from pytask import PPathNode\\n from pytask import PythonNode\\n+from pytask import Task\\n+from pytask import TaskWithoutPath\\n \\n \\n @pytest.mark.unit()\\n@@ -27,6 +30,31 @@ def test_hash_of_python_node(value, hash_, expected):\\n     assert state == expected\\n \\n \\n+@pytest.mark.parametrize(\\n+    (\\\"node\\\", \\\"expected\\\"),\\n+    [\\n+        (\\n+            PathNode(name=\\\"pathnode\\\", path=Path(\\\"file.txt\\\")),\\n+            \\\"66e5d35cb2f9f892935ed00fb2a639172c9078ce81e0e9e3bdab19d2f212ef50\\\",\\n+        ),\\n+        (\\n+            PythonNode(name=\\\"name\\\", value=None),\\n+            \\\"c8265d64828f9e007a9108251883a2b63954c326c678fca23c49a0b08ea7c925\\\",\\n+        ),\\n+        (\\n+            Task(base_name=\\\"task\\\", path=Path(\\\"task.py\\\"), function=None),\\n+            \\\"4c96feb6042210c859938d4f6fc835ac1bde64960aeda101d2e2367644f9c22b\\\",\\n+        ),\\n+        (\\n+            TaskWithoutPath(name=\\\"task\\\", function=None),\\n+            \\\"ac80b202671ece4c139a9b2d6e03a499c8b6e016dcd2022ac580fbf1c64fc63b\\\",\\n+        ),\\n+    ],\\n+)\\n+def test_signature(node, expected):\\n+    assert node.signature == expected\\n+\\n+\\n @pytest.mark.unit()\\n @pytest.mark.parametrize(\\n     (\\\"value\\\", \\\"exists\\\", \\\"expected\\\"),\\n\",\"diff --git a/tests/test_persist.py b/tests/test_persist.py\\nindex 0552957..75b2510 100644\\n--- a/tests/test_persist.py\\n+++ b/tests/test_persist.py\\n@@ -71,11 +71,11 @@ def test_multiple_runs_with_persist(tmp_path):\\n         \\\"sqlite:///\\\" + tmp_path.joinpath(\\\".pytask\\\", \\\"pytask.sqlite3\\\").as_posix()\\n     )\\n \\n-    with DatabaseSession() as session:\\n-        task_id = tmp_path.joinpath(\\\"task_module.py\\\").as_posix() + \\\"::task_dummy\\\"\\n-        node_id = tmp_path.joinpath(\\\"out.txt\\\").as_posix()\\n+    with DatabaseSession() as db_session:\\n+        task_id = session.tasks[0].signature\\n+        node_id = session.tasks[0].produces[\\\"produces\\\"].signature\\n \\n-        hash_ = session.get(State, (task_id, node_id)).hash_\\n+        hash_ = db_session.get(State, (task_id, node_id)).hash_\\n         path = tmp_path.joinpath(\\\"out.txt\\\")\\n         assert hash_ == hash_path(path, path.stat().st_mtime)\\n \\n@@ -128,6 +128,7 @@ def test_pytask_execute_task_process_report(monkeypatch, exc_info, expected):\\n \\n     task = DummyClass()\\n     task.name = None\\n+    task.signature = \\\"id\\\"\\n \\n     session = DummyClass()\\n     session.dag = None\\n\",\"diff --git a/tests/test_profile.py b/tests/test_profile.py\\nindex 32f8e7c..41ee233 100644\\n--- a/tests/test_profile.py\\n+++ b/tests/test_profile.py\\n@@ -1,8 +1,6 @@\\n from __future__ import annotations\\n \\n-import os\\n import textwrap\\n-from pathlib import Path\\n \\n import pytest\\n from _pytask.cli import cli\\n@@ -35,9 +33,7 @@ def test_duration_is_stored_in_task(tmp_path):\\n     )\\n \\n     with DatabaseSession() as session:\\n-        task_name = tmp_path.joinpath(\\\"task_example.py\\\").as_posix() + \\\"::task_example\\\"\\n-\\n-        runtime = session.get(Runtime, task_name)\\n+        runtime = session.get(Runtime, task.signature)\\n         assert runtime.duration > 2\\n \\n \\n@@ -78,7 +74,6 @@ def test_profile_if_there_is_information_on_collected_tasks(tmp_path, runner):\\n     tmp_path.joinpath(\\\"task_example.py\\\").write_text(textwrap.dedent(source))\\n \\n     result = runner.invoke(cli, [tmp_path.as_posix()])\\n-\\n     result = runner.invoke(cli, [\\\"profile\\\", tmp_path.as_posix()])\\n \\n     assert result.exit_code == ExitCode.OK\\n@@ -99,11 +94,7 @@ def test_export_of_profile(tmp_path, runner, export):\\n     tmp_path.joinpath(\\\"task_example.py\\\").write_text(textwrap.dedent(source))\\n \\n     result = runner.invoke(cli, [tmp_path.as_posix()])\\n-\\n-    cwd = Path.cwd()\\n-    os.chdir(tmp_path)\\n     result = runner.invoke(cli, [\\\"profile\\\", tmp_path.as_posix(), \\\"--export\\\", export])\\n-    os.chdir(cwd)\\n \\n     assert result.exit_code == ExitCode.OK\\n     assert \\\"Collected 1 task.\\\" in result.output\\n\",\"diff --git a/tox.ini b/tox.ini\\nindex 99ab2a2..9d9c197 100644\\n--- a/tox.ini\\n+++ b/tox.ini\\n@@ -13,6 +13,7 @@ deps =\\n     # pytest\\n     pytest\\n     pytest-cov\\n+    pytest-env\\n     pytest-xdist\\n     coverage\\n \"]", "hints_text": ""}

{"instance_id": "1447151963099897", "repo": "incatools/ontology-access-kit", "base_commit": "e80e979b648903ef300090318d89279a775a5bdb", "problem_statement": "Provide method to convert obographs-json to RDFXML:\\nRight now we have no way to go from OBOGraphs Json back to RDF. In the absence of having anything in ROBOT, it would be great if we had something in OAK.", "FAIL_TO_PASS": ["tests/test_parsers/test_obojson_parser.py::OboJsonParserTest::test_parser"], "PASS_TO_PASS": ["tests/test_datamodels/test_ontology_metadata_datamodel.py::TestOntologyMetadataDatamodel::test_introspect", "tests/test_datamodels/test_ontology_metadata_datamodel.py::TestOntologyMetadataDatamodel::test_create", "tests/test_datamodels/test_text_annotator_datamodel.py::TestTextAnnotatorDatamodel::test_create", "tests/test_datamodels/test_search_datamodel.py::TestSearchDatamodel::test_create", "tests/test_datamodels/test_search_datamodel.py::TestSearchDatamodel::test_introspect", "tests/test_datamodels/test_text_annotator_datamodel.py::TestTextAnnotatorDatamodel::test_introspect", "tests/test_utilities/test_chunker.py::TestChunker::test_chunker"], "language": "python", "test_command": "source /saved/ENV || source /saved/*/ENV && pytest --no-header -rA --tb=no -p no:cacheprovider --continue-on-collection-errors", "test_output_parser": "python/parse_log_pytest_v3", "image_storage_uri": "vmvm-registry.fbinfra.net/repomate_image_activ_pytest/incatools_ontology-access-kit:e80e979b648903ef300090318d89279a775a5bdb", "patch": "", "test_patch": "[\"diff --git a/tests/test_converters/__init__.py b/tests/test_converters/__init__.py\\nnew file mode 100644\\nindex 000000000..e69de29bb\\n\",\"diff --git a/tests/test_converters/test_obo_graph_to_rdf_owl_converter.py b/tests/test_converters/test_obo_graph_to_rdf_owl_converter.py\\nnew file mode 100644\\nindex 000000000..9397ee0d7\\n--- /dev/null\\n+++ b/tests/test_converters/test_obo_graph_to_rdf_owl_converter.py\\n@@ -0,0 +1,34 @@\\n+import unittest\\n+\\n+from linkml_runtime.loaders import json_loader\\n+\\n+from oaklib import OntologyResource\\n+from oaklib.converters.obo_graph_to_rdf_owl_converter import OboGraphToRdfOwlConverter\\n+from oaklib.datamodels.obograph import GraphDocument\\n+from oaklib.implementations import SparqlImplementation\\n+from tests import INPUT_DIR, OUTPUT_DIR\\n+from tests.test_implementations import ComplianceTester\\n+\\n+ONT = INPUT_DIR / \\\"go-nucleus.json\\\"\\n+OUT = OUTPUT_DIR / \\\"go-nucleus.ttl\\\"\\n+\\n+\\n+class OboGraphToRdfOwlConverterTest(unittest.TestCase):\\n+    \\\"\\\"\\\"Tests OBO JSON -> RDF/OWL.\\\"\\\"\\\"\\n+\\n+    def setUp(self):\\n+        self.converter = OboGraphToRdfOwlConverter()\\n+        self.compliance_tester = ComplianceTester(self)\\n+\\n+    def test_convert(self):\\n+        \\\"\\\"\\\"Tests parsing then converting to rdflib Graph.\\\"\\\"\\\"\\n+        gd: GraphDocument = json_loader.load(str(ONT), target_class=GraphDocument)\\n+        g = self.converter.convert(gd)\\n+        g.serialize(OUT)\\n+        oi = SparqlImplementation(OntologyResource(OUT))\\n+        # for r in oi.relationships([\\\"GO:0005773\\\"]):\\n+        #    print(r)\\n+        self.compliance_tester.test_synonyms(oi)\\n+        self.compliance_tester.test_definitions(oi)\\n+        self.compliance_tester.test_sssom_mappings(oi)\\n+        self.compliance_tester.test_relationships(oi)\\n\",\"diff --git a/tests/test_implementations/__init__.py b/tests/test_implementations/__init__.py\\nindex ec8563742..062712535 100644\\n--- a/tests/test_implementations/__init__.py\\n+++ b/tests/test_implementations/__init__.py\\n@@ -24,6 +24,7 @@\\n     OWL_THING,\\n     PART_OF,\\n )\\n+from oaklib.interfaces import MappingProviderInterface\\n from oaklib.interfaces.association_provider_interface import (\\n     AssociationProviderInterface,\\n     associations_subjects,\\n@@ -88,6 +89,75 @@ class ComplianceTester:\\n     test: unittest.TestCase\\n     \\\"\\\"\\\"Link back to implementation-specific unit test.\\\"\\\"\\\"\\n \\n+    def test_definitions(self, oi: BasicOntologyInterface):\\n+        test = self.test\\n+        tdef = oi.definition(NUCLEUS)\\n+        test.assertTrue(tdef.startswith(\\\"A membrane-bounded organelle of eukaryotic cells\\\"))\\n+\\n+    def test_synonyms(self, oi: BasicOntologyInterface):\\n+        test = self.test\\n+        syns = oi.entity_aliases(\\\"GO:0005575\\\")\\n+        # logging.info(syns)\\n+        test.assertCountEqual(\\n+            syns,\\n+            [\\n+                \\\"cellular_component\\\",\\n+                \\\"cellular component\\\",\\n+                \\\"cell or subcellular entity\\\",\\n+                \\\"subcellular entity\\\",\\n+            ],\\n+        )\\n+        syns = oi.entity_aliases(NUCLEUS)\\n+        logging.info(syns)\\n+        test.assertCountEqual(syns, [\\\"nucleus\\\", \\\"cell nucleus\\\", \\\"horsetail nucleus\\\"])\\n+        syn_pairs = list(oi.entity_alias_map(NUCLEUS).items())\\n+        test.assertCountEqual(\\n+            syn_pairs,\\n+            [\\n+                (\\\"oio:hasExactSynonym\\\", [\\\"cell nucleus\\\"]),\\n+                (\\\"oio:hasNarrowSynonym\\\", [\\\"horsetail nucleus\\\"]),\\n+                (\\\"rdfs:label\\\", [\\\"nucleus\\\"]),\\n+            ],\\n+        )\\n+\\n+    def test_sssom_mappings(self, oi: MappingProviderInterface):\\n+        \\\"\\\"\\\"\\n+        Tests conformance of MappingProviderInterface.\\n+\\n+        Also as a side-effect tests simple mapping retrieval from the BasicOntologyInterface\\n+\\n+        - Tests retrieval in both directions (subject as query vs object as query)\\n+\\n+        TODO: the test ontology does not yet include an example of using skos annotations\\n+\\n+        :param oi:\\n+        :return:\\n+        \\\"\\\"\\\"\\n+        test = self.test\\n+        cases = [\\n+            (NUCLEUS, [\\\"Wikipedia:Cell_nucleus\\\", \\\"NIF_Subcellular:sao1702920020\\\"]),\\n+            (VACUOLE, [\\\"Wikipedia:Vacuole\\\"]),\\n+            (MAMMALIA, []),\\n+        ]\\n+        for curie, expected_mappings in cases:\\n+            mappings = list(oi.sssom_mappings(curie))\\n+            mapping_objects = [m.object_id for m in mappings]\\n+            test.assertCountEqual(\\n+                expected_mappings,\\n+                mapping_objects,\\n+                f\\\"expected mappings({curie}) = {expected_mappings} got {mapping_objects}\\\",\\n+            )\\n+            mapping_objects = [m[2] for m in oi.simple_mappings([curie])]\\n+            test.assertCountEqual(\\n+                expected_mappings,\\n+                mapping_objects,\\n+                f\\\"expected simple mappings({curie}) = {expected_mappings} got {mapping_objects}\\\",\\n+            )\\n+            for m in mappings:\\n+                reverse_mappings = list(oi.get_sssom_mappings_by_curie(m.object_id))\\n+                reverse_subject_ids = [m.subject_id for m in reverse_mappings]\\n+                test.assertIn(curie, reverse_subject_ids)\\n+\\n     def test_relationships(self, oi: BasicOntologyInterface, ignore_annotation_edges=False):\\n         \\\"\\\"\\\"\\n         Tests relationship methods for compliance.\\n\",\"diff --git a/tests/test_implementations/test_obograph.py b/tests/test_implementations/test_obograph.py\\nnew file mode 100644\\nindex 000000000..af27f1599\\n--- /dev/null\\n+++ b/tests/test_implementations/test_obograph.py\\n@@ -0,0 +1,377 @@\\n+import logging\\n+import unittest\\n+from copy import deepcopy\\n+\\n+from kgcl_schema.datamodel import kgcl\\n+\\n+from oaklib.datamodels import obograph\\n+from oaklib.datamodels.search import SearchConfiguration\\n+from oaklib.datamodels.search_datamodel import SearchProperty, SearchTermSyntax\\n+from oaklib.datamodels.vocabulary import HAS_PART, IS_A, ONLY_IN_TAXON, PART_OF\\n+from oaklib.implementations.obograph.obograph_implementation import (\\n+    OboGraphImplementation,\\n+)\\n+from oaklib.implementations.simpleobo.simple_obo_implementation import (\\n+    SimpleOboImplementation,\\n+)\\n+from oaklib.resource import OntologyResource\\n+from oaklib.utilities.kgcl_utilities import generate_change_id\\n+from oaklib.utilities.obograph_utils import (\\n+    graph_as_dict,\\n+    index_graph_edges_by_object,\\n+    index_graph_edges_by_predicate,\\n+    index_graph_edges_by_subject,\\n+    index_graph_nodes,\\n+)\\n+from tests import (\\n+    CELL,\\n+    CELLULAR_COMPONENT,\\n+    CELLULAR_ORGANISMS,\\n+    CYTOPLASM,\\n+    FAKE_ID,\\n+    FAKE_PREDICATE,\\n+    HUMAN,\\n+    INPUT_DIR,\\n+    NUCLEAR_MEMBRANE,\\n+    NUCLEUS,\\n+    OUTPUT_DIR,\\n+    VACUOLE,\\n+)\\n+from tests.test_implementations import ComplianceTester\\n+\\n+TEST_ONT = INPUT_DIR / \\\"go-nucleus.obo\\\"\\n+TEST_SIMPLE_ONT = INPUT_DIR / \\\"go-nucleus-simple.obo\\\"\\n+TEST_ONT_COPY = OUTPUT_DIR / \\\"go-nucleus.copy.obo\\\"\\n+TEST_SUBGRAPH_OUT = OUTPUT_DIR / \\\"vacuole.obo\\\"\\n+\\n+\\n+class TestOboGraphImplementation(unittest.TestCase):\\n+    def setUp(self) -> None:\\n+        resource = OntologyResource(slug=\\\"go-nucleus.json\\\", directory=INPUT_DIR, local=True)\\n+        oi = OboGraphImplementation(resource)\\n+        self.oi = oi\\n+        self.compliance_tester = ComplianceTester(self)\\n+\\n+    def test_relationships_extra(self):\\n+        oi = self.oi\\n+        rels = oi.outgoing_relationship_map(\\\"GO:0005773\\\")\\n+        for k, v in rels.items():\\n+            logging.info(f\\\"{k} = {v}\\\")\\n+        self.assertCountEqual(rels[IS_A], [\\\"GO:0043231\\\"])\\n+        self.assertCountEqual(rels[PART_OF], [CYTOPLASM])\\n+\\n+    def test_relationships(self):\\n+        self.compliance_tester.test_relationships(self.oi)\\n+\\n+    def test_equiv_relationships(self):\\n+        self.compliance_tester.test_equiv_relationships(self.oi)\\n+\\n+    @unittest.skip(\\\"TODO\\\")\\n+    def test_gci_relationships(self):\\n+        oi = self.oi\\n+        rels = oi.outgoing_relationship_map(CELL)\\n+        self.assertCountEqual(rels[IS_A], [\\\"CARO:0000003\\\"])\\n+        self.assertCountEqual(rels[ONLY_IN_TAXON], [CELLULAR_ORGANISMS])\\n+        self.assertNotIn(PART_OF, rels)  # GCI relations excluded\\n+\\n+    def test_incoming_relationships(self):\\n+        oi = self.oi\\n+        rels = oi.incoming_relationship_map(CYTOPLASM)\\n+        for k, v in rels.items():\\n+            logging.info(f\\\"{k} = {v}\\\")\\n+        self.assertCountEqual(rels[IS_A], [\\\"GO:0005938\\\", \\\"GO:0099568\\\"])\\n+        self.assertCountEqual(rels[PART_OF], [\\\"GO:0005773\\\", \\\"GO:0099568\\\"])\\n+\\n+    def test_all_terms(self):\\n+        entities = list(self.oi.entities())\\n+        self.assertIn(NUCLEUS, entities)\\n+        self.assertIn(CELLULAR_COMPONENT, entities)\\n+        self.assertIn(PART_OF, entities)\\n+\\n+    @unittest.skip(\\\"TODO\\\")\\n+    def test_relations(self):\\n+        oi = self.oi\\n+        label = oi.label(PART_OF)\\n+        assert label.startswith(\\\"part\\\")\\n+        t = self.oi.node(PART_OF)\\n+        assert t.id == PART_OF\\n+        assert t.lbl.startswith(\\\"part\\\")\\n+\\n+    @unittest.skip(\\\"TODO\\\")\\n+    def test_metadata(self):\\n+        for curie in self.oi.entities():\\n+            m = self.oi.entity_metadata_map(curie)\\n+            logging.info(f\\\"{curie} {m}\\\")\\n+        m = self.oi.entity_metadata_map(\\\"GO:0005622\\\")\\n+        assert \\\"term_tracker_item\\\" in m.keys()\\n+        assert \\\"https://github.com/geneontology/go-ontology/issues/17776\\\" in m[\\\"term_tracker_item\\\"]\\n+\\n+    def test_labels(self):\\n+        \\\"\\\"\\\"\\n+        Tests labels can be retrieved, and no label is retrieved when a term does not exist\\n+        \\\"\\\"\\\"\\n+        oi = self.oi\\n+        label = oi.label(VACUOLE)\\n+        self.assertEqual(str, type(label))\\n+        self.assertEqual(label, \\\"vacuole\\\")\\n+        lbls = list(oi.labels([VACUOLE, NUCLEUS]))\\n+        self.assertCountEqual([(VACUOLE, \\\"vacuole\\\"), (NUCLEUS, \\\"nucleus\\\")], lbls)\\n+        label = oi.label(\\\"FOOBAR:123\\\")\\n+        self.assertIsNone(label)\\n+        # TODO: test strict mode\\n+        label = oi.label(IS_A)\\n+        self.assertIsNotNone(label)\\n+\\n+    def test_synonyms(self):\\n+        syns = self.oi.entity_aliases(\\\"GO:0005575\\\")\\n+        print(syns)\\n+        # logging.info(syns)\\n+        self.assertCountEqual(\\n+            syns,\\n+            [\\n+                \\\"cellular_component\\\",\\n+                \\\"cellular component\\\",\\n+                \\\"cell or subcellular entity\\\",\\n+                \\\"subcellular entity\\\",\\n+            ],\\n+        )\\n+        syns = self.oi.entity_aliases(NUCLEUS)\\n+        logging.info(syns)\\n+        self.assertCountEqual(syns, [\\\"nucleus\\\", \\\"cell nucleus\\\", \\\"horsetail nucleus\\\"])\\n+        syn_pairs = list(self.oi.entity_alias_map(NUCLEUS).items())\\n+        self.assertCountEqual(\\n+            syn_pairs,\\n+            [\\n+                (\\\"oio:hasExactSynonym\\\", [\\\"cell nucleus\\\"]),\\n+                (\\\"oio:hasNarrowSynonym\\\", [\\\"horsetail nucleus\\\"]),\\n+                (\\\"rdfs:label\\\", [\\\"nucleus\\\"]),\\n+            ],\\n+        )\\n+\\n+    @unittest.skip(\\\"TODO\\\")\\n+    def test_mappings(self):\\n+        oi = self.oi\\n+        mappings = list(oi.get_sssom_mappings_by_curie(NUCLEUS))\\n+        assert any(m for m in mappings if m.object_id == \\\"Wikipedia:Cell_nucleus\\\")\\n+        self.assertEqual(len(mappings), 2)\\n+        for m in mappings:\\n+            logging.info(f\\\"GETTING {m.object_id}\\\")\\n+            reverse_mappings = list(oi.get_sssom_mappings_by_curie(m.object_id))\\n+            reverse_subject_ids = [m.subject_id for m in reverse_mappings]\\n+            self.assertEqual(reverse_subject_ids, [NUCLEUS])\\n+\\n+    @unittest.skip(\\\"TODO\\\")\\n+    def test_subsets(self):\\n+        oi = self.oi\\n+        subsets = list(oi.subsets())\\n+        self.assertIn(\\\"goslim_aspergillus\\\", subsets)\\n+        self.assertIn(\\\"GO:0003674\\\", oi.subset_members(\\\"goslim_generic\\\"))\\n+        self.assertNotIn(\\\"GO:0003674\\\", oi.subset_members(\\\"gocheck_do_not_manually_annotate\\\"))\\n+\\n+    # @unittest.skip(\\\"TODO\\\")\\n+    def test_save(self):\\n+        oi = SimpleOboImplementation()\\n+        OUTPUT_DIR.mkdir(exist_ok=True)\\n+        oi.create_entity(\\n+            \\\"FOO:1\\\", label=\\\"foo\\\", relationships={IS_A: [\\\"FOO:2\\\"], \\\"part_of\\\": [\\\"FOO:3\\\"]}\\n+        )\\n+        oi.store(\\n+            OntologyResource(\\n+                slug=\\\"go-nucleus.saved.obo\\\", directory=OUTPUT_DIR, local=True, format=\\\"obo\\\"\\n+            )\\n+        )\\n+\\n+    @unittest.skip(\\\"TODO\\\")\\n+    def test_qc(self):\\n+        oi = self.oi\\n+        for t in oi.term_curies_without_definitions():\\n+            logging.info(t)\\n+        self.assertIn(\\\"CARO:0000003\\\", oi.term_curies_without_definitions())\\n+\\n+    @unittest.skip(\\\"TODO\\\")\\n+    def test_walk_up(self):\\n+        oi = self.oi\\n+        rels = list(oi.walk_up_relationship_graph(\\\"GO:0005773\\\"))\\n+        logging.info(\\\"ALL\\\")\\n+        for rel in rels:\\n+            logging.info(rel)\\n+        assert (\\\"GO:0043227\\\", HAS_PART, \\\"GO:0016020\\\") in rels\\n+        logging.info(\\\"**IS_A\\\")\\n+        rels = list(oi.walk_up_relationship_graph(\\\"GO:0005773\\\", predicates=[IS_A]))\\n+        for rel in rels:\\n+            logging.info(rel)\\n+            self.assertEqual(rel[1], IS_A)\\n+        assert (\\\"GO:0043227\\\", HAS_PART, \\\"GO:0016020\\\") not in rels\\n+        assert (\\\"GO:0110165\\\", IS_A, \\\"CARO:0000000\\\") in rels\\n+\\n+    @unittest.skip(\\\"TODO\\\")\\n+    def test_ancestors(self):\\n+        oi = self.oi\\n+        ancs = list(oi.ancestors(\\\"GO:0005773\\\"))\\n+        for a in ancs:\\n+            logging.info(a)\\n+        assert \\\"NCBITaxon:1\\\" in ancs\\n+        assert \\\"GO:0005773\\\" in ancs  # reflexive\\n+        ancs = list(oi.ancestors(\\\"GO:0005773\\\", predicates=[IS_A]))\\n+        for a in ancs:\\n+            logging.info(a)\\n+        assert \\\"NCBITaxon:1\\\" not in ancs\\n+        assert \\\"GO:0005773\\\" in ancs  # reflexive\\n+        assert \\\"GO:0043231\\\" in ancs  # reflexive\\n+\\n+    @unittest.skip(\\\"TODO\\\")\\n+    def test_obograph(self):\\n+        g = self.oi.ancestor_graph(VACUOLE)\\n+        nix = index_graph_nodes(g)\\n+        self.assertEqual(nix[VACUOLE].lbl, \\\"vacuole\\\")\\n+        v2c = obograph.Edge(sub=VACUOLE, pred=PART_OF, obj=CYTOPLASM)\\n+        six = index_graph_edges_by_subject(g)\\n+        self.assertIn(v2c, six[VACUOLE])\\n+        self.assertNotIn(v2c, six[CYTOPLASM])\\n+        oix = index_graph_edges_by_object(g)\\n+        self.assertIn(v2c, oix[CYTOPLASM])\\n+        self.assertNotIn(v2c, oix[VACUOLE])\\n+        pix = index_graph_edges_by_predicate(g)\\n+        self.assertIn(v2c, pix[PART_OF])\\n+        self.assertNotIn(v2c, pix[IS_A])\\n+        graph_as_dict(g)\\n+        assert \\\"nodes\\\" in g\\n+        assert \\\"edges\\\" in g\\n+        # check is reflexive\\n+        self.assertEqual(1, len([n for n in g.nodes if n.id == VACUOLE]))\\n+        ancs = list(self.oi.ancestors(VACUOLE, predicates=[IS_A, PART_OF]))\\n+        assert VACUOLE in ancs\\n+        assert CYTOPLASM in ancs\\n+        descs = list(self.oi.descendants(CYTOPLASM, predicates=[IS_A, PART_OF]))\\n+        assert VACUOLE in descs\\n+        assert CYTOPLASM in descs\\n+        g = self.oi.ancestor_graph(CYTOPLASM)\\n+        # check is reflexive\\n+        self.assertEqual(1, len([n for n in g.nodes if n.id == CYTOPLASM]))\\n+\\n+    @unittest.skip(\\\"TODO\\\")\\n+    def test_search_aliases(self):\\n+        config = SearchConfiguration(properties=[SearchProperty.ALIAS])\\n+        curies = list(self.oi.basic_search(\\\"enzyme activity\\\", config=config))\\n+        self.assertEqual(curies, [\\\"GO:0003824\\\"])\\n+        config = SearchConfiguration()\\n+        curies = list(self.oi.basic_search(\\\"enzyme activity\\\", config=config))\\n+        self.assertEqual(curies, [])\\n+\\n+    @unittest.skip(\\\"TODO\\\")\\n+    def test_search_exact(self):\\n+        config = SearchConfiguration(is_partial=False)\\n+        curies = list(self.oi.basic_search(\\\"cytoplasm\\\", config=config))\\n+        # logging.info(curies)\\n+        assert CYTOPLASM in curies\\n+\\n+    @unittest.skip(\\\"TODO\\\")\\n+    def test_search_partial(self):\\n+        config = SearchConfiguration(is_partial=True)\\n+        curies = list(self.oi.basic_search(\\\"nucl\\\", config=config))\\n+        # logging.info(curies)\\n+        assert NUCLEUS in curies\\n+        self.assertGreater(len(curies), 5)\\n+\\n+    @unittest.skip(\\\"TODO\\\")\\n+    def test_search_starts_with(self):\\n+        config = SearchConfiguration(syntax=SearchTermSyntax.STARTS_WITH)\\n+        curies = list(self.oi.basic_search(\\\"nucl\\\", config=config))\\n+        # logging.info(curies)\\n+        assert NUCLEUS in curies\\n+        self.assertGreater(len(curies), 5)\\n+\\n+    @unittest.skip(\\\"TODO\\\")\\n+    def test_search_regex(self):\\n+        config = SearchConfiguration(syntax=SearchTermSyntax.REGULAR_EXPRESSION)\\n+        curies = list(self.oi.basic_search(\\\"^nucl\\\", config=config))\\n+        logging.info(curies)\\n+        assert NUCLEUS in curies\\n+        self.assertGreater(len(curies), 5)\\n+\\n+    def test_dump(self):\\n+        copy = \\\"go-nucleus.copy.obo\\\"\\n+        OUTPUT_DIR.mkdir(exist_ok=True)\\n+        self.oi.dump(str(OUTPUT_DIR / copy), syntax=\\\"obo\\\")\\n+\\n+    @unittest.skip(\\\"TODO\\\")\\n+    def test_patcher(self):\\n+        resource = OntologyResource(slug=TEST_ONT, local=True)\\n+        oi = SimpleOboImplementation(resource)\\n+        original_oi = deepcopy(oi)\\n+\\n+        def roundtrip(oi_in: OntologyResource):\\n+            out_file = str(OUTPUT_DIR / \\\"post-kgcl.obo\\\")\\n+            oi_in.dump(out_file, syntax=\\\"obo\\\")\\n+            resource2 = OntologyResource(slug=out_file, local=True)\\n+            return SimpleOboImplementation(resource2)\\n+\\n+        self.compliance_tester.test_patcher(\\n+            self.oi, original_oi=original_oi, roundtrip_function=roundtrip\\n+        )\\n+\\n+    def test_patcher2(self):\\n+        resource = OntologyResource(slug=TEST_ONT, local=True)\\n+        oi = SimpleOboImplementation(resource)\\n+        oi.apply_patch(\\n+            kgcl.NodeRename(id=generate_change_id(), about_node=VACUOLE, new_value=\\\"VaCuOlE\\\")\\n+        )\\n+        oi.apply_patch(kgcl.NodeObsoletion(id=generate_change_id(), about_node=NUCLEUS))\\n+        with self.assertRaises(ValueError):\\n+            oi.apply_patch(kgcl.NodeObsoletion(id=\\\"x\\\", about_node=\\\"NO SUCH TERM\\\"))\\n+        # oi.apply_patch(kgcl.NodeDeletion(id=generate_change_id(), about_node=NUCLEAR_ENVELOPE))\\n+        oi.apply_patch(\\n+            kgcl.SynonymReplacement(\\n+                id=\\\"x\\\",\\n+                about_node=CELLULAR_COMPONENT,\\n+                old_value=\\\"subcellular entity\\\",\\n+                new_value=\\\"foo bar\\\",\\n+            )\\n+        )\\n+        oi.apply_patch(\\n+            kgcl.NewSynonym(id=generate_change_id(), about_node=HUMAN, new_value=\\\"people\\\")\\n+        )\\n+        out_file = str(OUTPUT_DIR / \\\"post-kgcl.obo\\\")\\n+        oi.dump(out_file, syntax=\\\"obo\\\")\\n+        resource = OntologyResource(slug=out_file, local=True)\\n+        oi2 = SimpleOboImplementation(resource)\\n+        self.assertCountEqual(\\n+            [\\\"cell or subcellular entity\\\", \\\"cellular component\\\", \\\"cellular_component\\\", \\\"foo bar\\\"],\\n+            oi2.entity_aliases(CELLULAR_COMPONENT),\\n+        )\\n+        self.assertCountEqual(\\n+            [\\\"people\\\", \\\"Homo sapiens\\\"],\\n+            oi2.entity_aliases(HUMAN),\\n+        )\\n+\\n+    @unittest.skip(\\\"TODO\\\")\\n+    def test_migrate_curies(self):\\n+        \\\"\\\"\\\"\\n+        Tests migrate_curies operations works on a simple obo backend\\n+\\n+        This test is a mutation test, so a copy of the test database will be made\\n+        \\\"\\\"\\\"\\n+        oi = self.oi\\n+        label = oi.label(NUCLEUS)\\n+        preds = [IS_A, PART_OF]\\n+        preds_rewired = [IS_A, FAKE_PREDICATE]\\n+        expected_ancs = list(oi.ancestors(NUCLEUS, predicates=preds, reflexive=False))\\n+        expected_descs = list(oi.descendants(NUCLEUS, predicates=preds, reflexive=False))\\n+        oi.migrate_curies({NUCLEUS: FAKE_ID, PART_OF: FAKE_PREDICATE})\\n+        out_file = str(OUTPUT_DIR / \\\"post-migrate.obo\\\")\\n+        oi.dump(out_file, syntax=\\\"obo\\\")\\n+        self.assertEqual(label, oi.label(FAKE_ID))\\n+        self.assertIsNone(oi.label(NUCLEUS))\\n+        self.assertEqual([FAKE_ID], oi.curies_by_label(\\\"nucleus\\\"))\\n+        # query with rewired preds should be the same\\n+        self.assertCountEqual(\\n+            expected_ancs, list(oi.ancestors(FAKE_ID, predicates=preds_rewired, reflexive=False))\\n+        )\\n+        # query with UNrewired preds should be incomplete\\n+        self.assertNotIn(CELL, oi.ancestors(NUCLEUS, predicates=preds, reflexive=False))\\n+        # query with rewired preds should be the same\\n+        self.assertCountEqual(\\n+            expected_descs, list(oi.descendants(FAKE_ID, predicates=preds_rewired, reflexive=False))\\n+        )\\n+        # query with UNrewired preds should be incomplete\\n+        self.assertNotIn(NUCLEAR_MEMBRANE, oi.ancestors(NUCLEUS, predicates=preds, reflexive=False))\\n\",\"diff --git a/tests/test_implementations/test_pronto.py b/tests/test_implementations/test_pronto.py\\nindex a8b7453f2..ce7c06edf 100644\\n--- a/tests/test_implementations/test_pronto.py\\n+++ b/tests/test_implementations/test_pronto.py\\n@@ -124,40 +124,10 @@ def test_labels(self):\\n         self.assertIsNotNone(label)\\n \\n     def test_synonyms(self):\\n-        syns = self.oi.entity_aliases(\\\"GO:0005575\\\")\\n-        # logging.info(syns)\\n-        self.assertCountEqual(\\n-            syns,\\n-            [\\n-                \\\"cellular_component\\\",\\n-                \\\"cellular component\\\",\\n-                \\\"cell or subcellular entity\\\",\\n-                \\\"subcellular entity\\\",\\n-            ],\\n-        )\\n-        syns = self.oi.entity_aliases(NUCLEUS)\\n-        logging.info(syns)\\n-        self.assertCountEqual(syns, [\\\"nucleus\\\", \\\"cell nucleus\\\", \\\"horsetail nucleus\\\"])\\n-        syn_pairs = list(self.oi.entity_alias_map(NUCLEUS).items())\\n-        self.assertCountEqual(\\n-            syn_pairs,\\n-            [\\n-                (\\\"oio:hasExactSynonym\\\", [\\\"cell nucleus\\\"]),\\n-                (\\\"oio:hasNarrowSynonym\\\", [\\\"horsetail nucleus\\\"]),\\n-                (\\\"rdfs:label\\\", [\\\"nucleus\\\"]),\\n-            ],\\n-        )\\n+        self.compliance_tester.test_synonyms(self.oi)\\n \\n-    def test_mappings(self):\\n-        oi = self.oi\\n-        mappings = list(oi.get_sssom_mappings_by_curie(NUCLEUS))\\n-        assert any(m for m in mappings if m.object_id == \\\"Wikipedia:Cell_nucleus\\\")\\n-        self.assertEqual(len(mappings), 2)\\n-        for m in mappings:\\n-            logging.info(f\\\"GETTING {m.object_id}\\\")\\n-            reverse_mappings = list(oi.get_sssom_mappings_by_curie(m.object_id))\\n-            reverse_subject_ids = [m.subject_id for m in reverse_mappings]\\n-            self.assertEqual(reverse_subject_ids, [NUCLEUS])\\n+    def test_sssom_mappings(self):\\n+        self.compliance_tester.test_sssom_mappings(self.oi)\\n \\n     def test_subsets(self):\\n         oi = self.oi\\n@@ -231,6 +201,9 @@ def test_subontology(self):\\n             )\\n         )\\n \\n+    def test_definitions(self):\\n+        self.compliance_tester.test_definitions(self.oi)\\n+\\n     def test_store_associations(self):\\n         self.compliance_tester.test_store_associations(self.oi)\\n \\n\",\"diff --git a/tests/test_implementations/test_sparql.py b/tests/test_implementations/test_sparql.py\\nindex 00d4db873..c12626052 100644\\n--- a/tests/test_implementations/test_sparql.py\\n+++ b/tests/test_implementations/test_sparql.py\\n@@ -47,6 +47,9 @@ def setUp(self) -> None:\\n     def test_relationships(self):\\n         self.compliance_tester.test_relationships(self.oi, ignore_annotation_edges=True)\\n \\n+    def test_sssom_mappings(self):\\n+        self.compliance_tester.test_sssom_mappings(self.oi)\\n+\\n     def test_relationships_extra(self):\\n         oi = self.oi\\n         self.assertIsNotNone(oi.graph)\\n\",\"diff --git a/tests/test_implementations/test_sqldb.py b/tests/test_implementations/test_sqldb.py\\nindex ea4894d48..d65d4b41e 100644\\n--- a/tests/test_implementations/test_sqldb.py\\n+++ b/tests/test_implementations/test_sqldb.py\\n@@ -153,6 +153,9 @@ def test_labels(self):\\n         label = self.oi.label(VACUOLE)\\n         self.assertEqual(label, \\\"vacuole\\\")\\n \\n+    def test_definitions(self):\\n+        self.compliance_tester.test_definitions(self.oi)\\n+\\n     def test_get_labels_for_curies(self):\\n         oi = self.oi\\n         curies = oi.subset_members(\\\"goslim_generic\\\")\\n@@ -164,20 +167,10 @@ def test_get_labels_for_curies(self):\\n         self.assertEqual(11, len(tups))\\n \\n     def test_synonyms(self):\\n-        syns = self.oi.entity_aliases(CELLULAR_COMPONENT)\\n-        logging.info(syns)\\n-        assert \\\"cellular component\\\" in syns\\n-\\n-    def test_mappings(self):\\n-        mappings = list(self.oi.get_sssom_mappings_by_curie(NUCLEUS))\\n-        # for m in mappings:\\n-        #    logging.info(yaml_dumper.dumps(m))\\n-        assert any(m for m in mappings if m.object_id == \\\"Wikipedia:Cell_nucleus\\\")\\n-        self.assertEqual(len(mappings), 2)\\n-        for m in mappings:\\n-            reverse_mappings = list(self.oi.get_sssom_mappings_by_curie(m.object_id))\\n-            reverse_subject_ids = [m.subject_id for m in reverse_mappings]\\n-            self.assertEqual(reverse_subject_ids, [NUCLEUS])\\n+        self.compliance_tester.test_synonyms(self.oi)\\n+\\n+    def test_sssom_mappings(self):\\n+        self.compliance_tester.test_sssom_mappings(self.oi)\\n \\n     def test_relation_graph(self):\\n         oi = self.oi\\n\",\"diff --git a/tests/test_parsers/test_obojson_parser.py b/tests/test_parsers/test_obojson_parser.py\\nnew file mode 100644\\nindex 000000000..a5da40fac\\n--- /dev/null\\n+++ b/tests/test_parsers/test_obojson_parser.py\\n@@ -0,0 +1,20 @@\\n+import unittest\\n+\\n+from linkml_runtime.loaders import json_loader\\n+\\n+from oaklib.datamodels.obograph import GraphDocument\\n+from tests import INPUT_DIR\\n+\\n+ONT = INPUT_DIR / \\\"go-nucleus.json\\\"\\n+\\n+\\n+class OboJsonParserTest(unittest.TestCase):\\n+    \\\"\\\"\\\"Tests parsing OBO JSON directly.\\\"\\\"\\\"\\n+\\n+    def test_parser(self):\\n+        \\\"\\\"\\\"Tests parsing obojson.\\\"\\\"\\\"\\n+        gd: GraphDocument = json_loader.load(str(ONT), target_class=GraphDocument)\\n+        g = gd.graphs[0]\\n+        lbls = [n.lbl for n in g.nodes]\\n+        self.assertIn(\\\"cytoplasm\\\", lbls)\\n+        self.assertIn(\\\"cell periphery\\\", lbls)\"]", "hints_text": ""}

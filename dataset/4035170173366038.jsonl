{"instance_id": "4035170173366038", "repo": "waltsims/k-wave-python", "base_commit": "66a0d99ad661150b9b610c39803b7fa315d49701", "problem_statement": "`kspaceFirstOrder3D` always run on GPU, even when `kspaceFirstOrder3DC` is called:\\nThanks for this Python re-implementation of the k-wave interface! I noticed that the code always calls k-wave's GPU binary regardless of whether `kspaceFirstOrder3DC` or `kspaceFirstOrder3DG` is used. This is due to the below line in `kspaceFirstOrder3D`. Is this expected behavior?\\r\\n\\r\\nhttps://github.com/waltsims/k-wave-python/blob/d9558440eba825fc1e79e51d3e78b2a562e2c352/kwave/kspaceFirstOrder3D.py#L464\\nHomogeneous_medium_for sensor only receive signal:\\nHi Walter,\\r\\n     Sorry to bother you again.\\r\\n     I would like to implement a project that only include  k-wave simulation about the transducer/sensor receive the acoustic signal from source.\\r\\n     BTW, is this the definition of transducer in your code is the device can transmmit signal and sensor : the device only receive signal?\\r\\n     When  I try to **save the sensor_data in a similar way as your example in your 'bmode_reconstruction_example.py'** \\r\\n      Some error retruns about 'kSensor' object has no attribute 'combine_sensor_data'\\r\\n\\r\\nCode info:\\r\\n`\\r\\nimport os\\r\\nfrom tempfile import gettempdir\\r\\n\\r\\nfrom kwave.ksource import kSource\\r\\nfrom kwave.kspaceFirstOrder2D import kspaceFirstOrder2DC\\r\\nfrom kwave.kspaceFirstOrder2D import kspaceFirstOrder2DG\\r\\nfrom kwave.utils.maputils import makeDisc, makeCartCircle\\r\\nfrom kwave.utils import dotdict\\r\\nfrom kwave.ktransducer import *\\r\\nfrom kwave.kmedium import kWaveMedium\\r\\nfrom copy import deepcopy\\r\\n\\r\\n\\r\\npathname = '/home/wx/hdd1/k-wave-python/examples'\\r\\n\\r\\n\\r\\nNx = 128           # number of grid points in the x (row) direction\\r\\nNy = 128           # number of grid points in the y (column) direction\\r\\ndx = 0.1e-3        # grid point spacing in the x direction [m]\\r\\ndy = 0.1e-3        # grid point spacing in the y direction [m]\\r\\nkgrid = kWaveGrid([Nx, Ny], [dx, dy])\\r\\n\\r\\nt_end = (Nx * dx) * 2.2 / 1500   # [s]\\r\\nkgrid.makeTime(1500, t_end=t_end)\\r\\n\\r\\n\\r\\nmedium = kWaveMedium(sound_speed=1500, alpha_coeff=0.75, alpha_power=1.5)\\r\\n\\r\\n\\r\\ndisc_magnitude = 5 # [Pa]\\r\\ndisc_x_pos = 50    # [grid points]\\r\\ndisc_y_pos = 50    # [grid points]\\r\\ndisc_radius = 8    # [grid points]\\r\\ndisc_1 = disc_magnitude * makeDisc(Nx, Ny, disc_x_pos, disc_y_pos, disc_radius)\\r\\n\\r\\ndisc_magnitude = 3 # [Pa]\\r\\ndisc_x_pos = 80    # [grid points]\\r\\ndisc_y_pos = 60    # [grid points]\\r\\ndisc_radius = 5    # [grid points]\\r\\ndisc_2 = disc_magnitude * makeDisc(Nx, Ny, disc_x_pos, disc_y_pos, disc_radius)\\r\\n\\r\\nsource = kSource()\\r\\nsource.p0 = disc_1 + disc_2\\r\\n\\r\\n\\r\\nsensor_radius = 4e-3   # [m]\\r\\nnum_sensor_points = 50\\r\\nsensor_mask = makeCartCircle(sensor_radius, num_sensor_points)\\r\\nsensor = kSensor(sensor_mask)\\r\\ninput_filename  = f'example_input.h5'\\r\\ninput_file_full_path = os.path.join(pathname, input_filename)\\r\\nprint(input_file_full_path)\\r\\n\\r\\ninput_args = {\\r\\n    'SaveToDisk':input_file_full_path,\\r\\n    'SaveToDiskExit': False\\r\\n}\\r\\nsensor_data = kspaceFirstOrder2DG(**{\\r\\n    'medium': medium,\\r\\n    'kgrid': kgrid,\\r\\n    'source': source,\\r\\n    'sensor': sensor,\\r\\n    **input_args\\r\\n})\\r\\n`\\r\\nError info:\\r\\n`  File \"/home/wx/anaconda3/envs/py39k-wave/lib/python3.9/site-packages/kwave/kspaceFirstOrder2D.py\", line 386, in kspaceFirstOrder2D\\r\\nreturn k_sim.sensor.combine_sensor_data(sensor_data)\\r\\nAttributeError: 'kSensor' object has no attribute 'combine_sensor_data'`\\r\\n\\r\\nThanks for you help again, and  I would like to become the beta tester of windows. Thank you agagin.\\r\\n\\r\\nBest Regards\\r\\nChenzhe Li\\r\\n\\r\\n \\r\\n\\nUpdate executable path in executor from execution options. Change signature to no longer accept device. Logic can be removed?:\\n\\nv1.4.0 Example: Modelling A Linear Array Transducer:\\n\\nAdd make_cart_disc and other missing methods to k-wave-array imports and clean up repeated global golden ratios.:\\n\\nTime reversal example:\\nHi Walter,\\r\\nThank you for your fascinating work on implying k-wave in python.  \\r\\nBut when i want to use k-wave-python to produce some images, I found it is not esay. The examples of k-wave in matlab can't be applied directly in your project. Because there are much difference between your work and k-wave in matlab. \\r\\nSo I expect that your could **add complete examples**, not only a part. Especially, 2D  photoacoustic reconstrction.\\r\\nThanks a lot!", "FAIL_TO_PASS": ["tests/test_kutils.py::test_make_time"], "PASS_TO_PASS": ["tests/test_utils.py::test_apply_filter_highpass", "tests/test_kutils.py::test_get_alpha_filters_2d", "tests/test_utils.py::test_trim_zeros", "tests/test_misc.py::test_find_closest", "tests/test_water.py::test_water_sound_speed", "tests/test_kutils.py::test_check_stability", "tests/test_water.py::test_water_absorption", "tests/test_kutils.py::test_prime_factors", "tests/test_utils.py::test_nepers2db", "tests/test_utils.py::test_gradient_spacing_ndim", "tests/test_filterutils.py::test_fwhm", "tests/test_binary_present.py::test_linux_cuda_binaries_present", "tests/test_utils.py::test_resize_2D_nearest_smaller", "tests/test_binary_present.py::test_linux_omp_binaries_present", "tests/test_utils.py::test_apply_filter_lowpass", "tests/test_utils.py::test_gradient_spect_1D", "tests/test_utils.py::test_resize_2D_linear_larger", "tests/test_utils.py::test_get_bli", "tests/test_kutils.py::test_focus", "tests/test_utils.py::test_fit_power_law_params", "tests/test_utils.py::test_power_kramers_kronig", "tests/test_utils.py::test_gradient_FD", "tests/test_reconstruction.py::test_log_compression", "tests/test_utils.py::test_gradient_FD_2D", "tests/test_water.py::test_water_non_linearity", "tests/test_utils.py::test_gradeint_spacing_uneven", "tests/test_utils.py::test_resize_2D_splinef2d", "tests/test_misc.py::test_round_odd_down", "tests/test_utils.py::test_signal_offset", "tests/test_water.py::test_water_density", "tests/test_pmlutils.py::test_get_optimal_pml_size_3D", "tests/test_utils.py::test_num_dim", "tests/test_utils.py::test_gradient_spacing", "tests/test_utils.py::test_db2nepers", "tests/test_misc.py::test_round_even_up", "tests/test_pmlutils.py::test_get_optimal_pml_size_2D", "tests/test_utils.py::test_signal_length", "tests/test_misc.py::test_round_odd_up", "tests/test_misc.py::test_round_even_down", "tests/test_utils.py::test_add_noise", "tests/test_utils.py::test_extract_amp_phase", "tests/test_kutils.py::test_get_alpha_filters_1D", "tests/test_utils.py::test_resize_2D_nearest_larger", "tests/test_utils.py::test_tone_error", "tests/test_utils.py::test_spect", "tests/test_filterutils.py::test_envelope_detection", "tests/test_utils.py::test_resize_2D_linear_smaller", "tests/test_utils.py::test_apply_filter_bandpass", "tests/test_pmlutils.py::test_get_optimal_pml_size_1d"], "language": "python", "test_command": "source /saved/ENV || source /saved/*/ENV && pytest --no-header -rA --tb=no -p no:cacheprovider --continue-on-collection-errors", "test_output_parser": "python/parse_log_pytest_v3", "image_storage_uri": "vmvm-registry.fbinfra.net/repomate_image_activ_pytest/waltsims_k-wave-python:66a0d99ad661150b9b610c39803b7fa315d49701", "patch": "[\"diff --git a/.gitignore b/.gitignore\\nindex d8bf403..2094dd9 100644\\n--- a/.gitignore\\n+++ b/.gitignore\\n@@ -17,4 +17,7 @@ src/\\n .vscode/\\n *.asv\\n *.h5\\n+*.tar.gz\\n+*.whl\\n+*.png\\n *.pyc\\n\",\"diff --git a/examples/bmode_reconstruction_example.py b/examples/bmode_reconstruction_example.py\\nindex 3f40242..848e231 100644\\n--- a/examples/bmode_reconstruction_example.py\\n+++ b/examples/bmode_reconstruction_example.py\\n@@ -4,14 +4,14 @@ from tempfile import gettempdir\\n import numpy as np\\n import scipy.io\\n \\n-from kwave.data import Vector\\n-from kwave.options import SimulationOptions, SimulationExecutionOptions\\n-\\n from example_utils import download_from_gdrive_if_does_not_exist\\n+from kwave.data import Vector\\n from kwave.kgrid import kWaveGrid\\n from kwave.kmedium import kWaveMedium\\n-from kwave.kspaceFirstOrder3D import kspaceFirstOrder3DC\\n+from kwave.kspaceFirstOrder3D import kspaceFirstOrder3D\\n from kwave.ktransducer import NotATransducer, kWaveTransducerSimple\\n+from kwave.options.simulation_execution_options import SimulationExecutionOptions\\n+from kwave.options.simulation_options import SimulationOptions\\n from kwave.reconstruction.beamform import beamform\\n from kwave.reconstruction.converter import build_channel_data\\n from kwave.utils.dotdictionary import dotdict\\n@@ -20,72 +20,38 @@ from kwave.utils.signals import tone_burst\\n if __name__ == '__main__':\\n     # pathname for the input and output files\\n     pathname = gettempdir()\\n+    phantom_data_path = 'phantom_data.mat'\\n+    PHANTOM_DATA_GDRIVE_ID = '1ZfSdJPe8nufZHz0U9IuwHR4chaOGAWO4'\\n \\n     # simulation settings\\n     DATA_CAST = 'single'\\n     RUN_SIMULATION = False\\n \\n-    # =========================================================================\\n-    # DEFINE THE K-WAVE GRID\\n-    # =========================================================================\\n-    print(\\\"Setting up the k-wave grid...\\\")\\n-\\n-    # set the size of the perfectly matched layer (PML)\\n     pml_size_points = Vector([20, 10, 10])  # [grid points]\\n-\\n-    # set total number of grid points not including the PML\\n     grid_size_points = Vector([256, 128, 128]) - 2 * pml_size_points  # [grid points]\\n-\\n-    # set desired grid size in the x-direction not including the PML\\n     grid_size_meters = 40e-3  # [m]\\n-\\n-    # calculate the spacing between the grid points\\n     grid_spacing_meters = grid_size_meters / Vector([grid_size_points.x, grid_size_points.x, grid_size_points.x])\\n \\n-    # create the k-space grid\\n-    kgrid = kWaveGrid(grid_size_points, grid_spacing_meters)\\n-\\n-    # =========================================================================\\n-    # DEFINE THE MEDIUM PARAMETERS\\n-    # =========================================================================\\n-    # define the properties of the propagation medium\\n     c0 = 1540\\n     rho0 = 1000\\n-\\n-    medium = kWaveMedium(\\n-        sound_speed=None,  # will be set later\\n-        alpha_coeff=0.75,\\n-        alpha_power=1.5,\\n-        BonA=6\\n-    )\\n-\\n-    # create the time array\\n-    t_end = (grid_size_points.x * grid_spacing_meters.x) * 2.2 / c0  # [s]\\n-    kgrid.makeTime(c0, t_end=t_end)\\n-\\n-    # =========================================================================\\n-    # DEFINE THE INPUT SIGNAL\\n-    # =========================================================================\\n-    print(\\\"Defining the input signal...\\\")\\n-\\n-    # define properties of the input signal\\n     source_strength = 1e6  # [Pa]\\n     tone_burst_freq = 1.5e6  # [Hz]\\n     tone_burst_cycles = 4\\n \\n-    # create the input signal using tone_burst\\n-    input_signal = tone_burst(1 / kgrid.dt, tone_burst_freq, tone_burst_cycles)\\n+    kgrid = kWaveGrid(grid_size_points, grid_spacing_meters)\\n+    t_end = (grid_size_points.x * grid_spacing_meters.x) * 2.2 / c0  # [s]\\n+    kgrid.makeTime(c0, t_end=t_end)\\n \\n-    # scale the source magnitude by the source_strength divided by the\\n-    # impedance (the source is assigned to the particle velocity)\\n+    input_signal = tone_burst(1 / kgrid.dt, tone_burst_freq, tone_burst_cycles)\\n     input_signal = (source_strength / (c0 * rho0)) * input_signal\\n \\n-    # =========================================================================\\n-    # DEFINE THE ULTRASOUND TRANSDUCER\\n-    # =========================================================================\\n-    print(\\\"Setting up the transducer configuration...\\\")\\n+    medium = kWaveMedium(\\n+        sound_speed=None,  # will be set later\\n+        alpha_coeff=0.75,\\n+        alpha_power=1.5,\\n+        BonA=6\\n+    )\\n \\n-    # physical properties of the transducer\\n     transducer = dotdict()\\n     transducer.number_elements = 32  # total number of transducer elements\\n     transducer.element_width = 2  # width of each element [grid points/voxels]\\n@@ -95,7 +61,7 @@ if __name__ == '__main__':\\n \\n     # calculate the width of the transducer in grid points\\n     transducer_width = transducer.number_elements * transducer.element_width + (\\n-                transducer.number_elements - 1) * transducer.element_spacing\\n+            transducer.number_elements - 1) * transducer.element_spacing\\n \\n     # use this to position the transducer in the middle of the computational grid\\n     transducer.position = np.round([\\n@@ -104,61 +70,41 @@ if __name__ == '__main__':\\n         grid_size_points.z / 2 - transducer.element_length / 2\\n     ])\\n \\n+    transducer = kWaveTransducerSimple(kgrid, **transducer)\\n+\\n     # properties used to derive the beamforming delays\\n     not_transducer = dotdict()\\n     not_transducer.sound_speed = c0  # sound speed [m/s]\\n     not_transducer.focus_distance = 20e-3  # focus distance [m]\\n     not_transducer.elevation_focus_distance = 19e-3  # focus distance in the elevation plane [m]\\n     not_transducer.steering_angle = 0  # steering angle [degrees]\\n-\\n-    # apodization\\n     not_transducer.transmit_apodization = 'Hanning'\\n     not_transducer.receive_apodization = 'Rectangular'\\n-\\n-    # define the transducer elements that are currently active\\n     not_transducer.active_elements = np.ones((transducer.number_elements, 1))\\n-\\n-    # append input signal used to drive the transducer\\n     not_transducer.input_signal = input_signal\\n \\n-    # create the transducer using the defined settings\\n-    transducer = kWaveTransducerSimple(kgrid, **transducer)\\n     not_transducer = NotATransducer(transducer, kgrid, **not_transducer)\\n \\n-    # =========================================================================\\n-    # DEFINE THE MEDIUM PROPERTIES\\n-    # =========================================================================\\n-    # define a large image size to move across\\n     number_scan_lines = 96\\n \\n     print(\\\"Fetching phantom data...\\\")\\n-    phantom_data_path = 'phantom_data.mat'\\n-    PHANTOM_DATA_GDRIVE_ID = '1ZfSdJPe8nufZHz0U9IuwHR4chaOGAWO4'\\n     download_from_gdrive_if_does_not_exist(PHANTOM_DATA_GDRIVE_ID, phantom_data_path)\\n \\n     phantom = scipy.io.loadmat(phantom_data_path)\\n     sound_speed_map = phantom['sound_speed_map']\\n     density_map = phantom['density_map']\\n \\n-    # =========================================================================\\n-    # RUN THE SIMULATION\\n-    # =========================================================================\\n     print(f\\\"RUN_SIMULATION set to {RUN_SIMULATION}\\\")\\n-    # run the simulation if set to true, otherwise, load previous results from disk\\n \\n-    # set medium position\\n+    # preallocate the storage set medium position\\n+    scan_lines = np.zeros((number_scan_lines, not_transducer.number_active_elements, kgrid.Nt))\\n     medium_position = 0\\n \\n-    # preallocate the storage\\n-    simulation_data = []\\n-\\n-    # loop through the scan lines\\n-    for scan_line_index in range(1, number_scan_lines + 1):\\n-        # for scan_line_index in range(1, 10):\\n-        # update the command line status\\n+    for scan_line_index in range(0, number_scan_lines):\\n \\n         # load the current section of the medium\\n-        medium.sound_speed = sound_speed_map[:, medium_position:medium_position + grid_size_points.y, :]\\n+        medium.sound_speed = \\\\\\n+            sound_speed_map[:, medium_position:medium_position + grid_size_points.y, :]\\n         medium.density = density_map[:, medium_position:medium_position + grid_size_points.y, :]\\n \\n         # set the input settings\\n@@ -176,20 +122,22 @@ if __name__ == '__main__':\\n         )\\n         # run the simulation\\n         if RUN_SIMULATION:\\n-            sensor_data = kspaceFirstOrder3DC(\\n+            sensor_data = kspaceFirstOrder3D(\\n                 medium=medium,\\n                 kgrid=kgrid,\\n                 source=not_transducer,\\n                 sensor=not_transducer,\\n                 simulation_options=simulation_options,\\n-                execution_options=SimulationExecutionOptions()\\n+                execution_options=SimulationExecutionOptions(is_gpu_simulation=True)\\n             )\\n \\n+            scan_lines[scan_line_index, :] = not_transducer.combine_sensor_data(sensor_data['p'].T)\\n+\\n         # update medium position\\n         medium_position = medium_position + transducer.element_width\\n \\n     if RUN_SIMULATION:\\n-        simulation_data = np.stack(simulation_data, axis=0)\\n+        simulation_data = scan_lines\\n         # scipy.io.savemat('sensor_data.mat', {'sensor_data_all_lines': simulation_data})\\n \\n     else:\\n\",\"diff --git a/examples/example_at_linear_array_transducer.py b/examples/example_at_linear_array_transducer.py\\nnew file mode 100644\\nindex 0000000..20c06fb\\n--- /dev/null\\n+++ b/examples/example_at_linear_array_transducer.py\\n@@ -0,0 +1,97 @@\\n+import matplotlib.pyplot as plt\\n+import numpy as np\\n+\\n+import kwave.data\\n+from kwave import kWaveGrid, SimulationOptions, kWaveMedium\\n+from kwave.ksensor import kSensor\\n+from kwave.ksource import kSource\\n+from kwave.kspaceFirstOrder3D import kspaceFirstOrder3DC\\n+from kwave.options.simulation_execution_options import SimulationExecutionOptions\\n+from kwave.utils.kwave_array import kWaveArray\\n+from kwave.utils.plot import voxel_plot\\n+from kwave.utils.signals import tone_burst\\n+\\n+# DEFINE LITERALS\\n+model = 1\\n+c0 = 1500\\n+rho0 = 1000\\n+source_f0 = 1e6\\n+source_amp = 1e6\\n+source_cycles = 5\\n+source_focus = 20e-3\\n+element_num = 15\\n+element_width = 1e-3\\n+element_length = 10e-3\\n+element_pitch = 2e-3\\n+translation = kwave.data.Vector([5e-3, 0, 8e-3])\\n+rotation = kwave.data.Vector([0, 20, 0])\\n+grid_size_x = 40e-3\\n+grid_size_y = 20e-3\\n+grid_size_z = 40e-3\\n+ppw = 3\\n+t_end = 35e-6\\n+cfl = 0.5\\n+\\n+# GRID\\n+dx = c0 / (ppw * source_f0)\\n+Nx = round(grid_size_x / dx)\\n+Ny = round(grid_size_y / dx)\\n+Nz = round(grid_size_z / dx)\\n+kgrid = kWaveGrid([Nx, Ny, Nz], [dx, dx, dx])\\n+kgrid.makeTime(c0, cfl, t_end)\\n+\\n+# SOURCE\\n+if element_num % 2 != 0:\\n+    ids = np.arange(1, element_num + 1) - np.ceil(element_num / 2)\\n+else:\\n+    ids = np.arange(1, element_num + 1) - (element_num + 1) / 2\\n+\\n+time_delays = -(np.sqrt((ids * element_pitch) ** 2 + source_focus ** 2) - source_focus) / c0\\n+time_delays = time_delays - min(time_delays)\\n+\\n+source_sig = source_amp * tone_burst(1 / kgrid.dt, source_f0, source_cycles,\\n+                                     signal_offset=np.round(time_delays / kgrid.dt).astype(int))\\n+karray = kWaveArray(bli_tolerance=0.05, upsampling_rate=10)\\n+\\n+for ind in range(1, element_num + 1):\\n+    x_pos = 0 - (element_num * element_pitch / 2 - element_pitch / 2) + (ind - 1) * element_pitch\\n+    karray.add_rect_element([x_pos, 0, kgrid.z_vec[0]], element_width, element_length, rotation)\\n+\\n+karray.set_array_position(translation, rotation)\\n+source = kSource()\\n+source.p_mask = karray.get_array_binary_mask(kgrid)\\n+voxel_plot(np.single(source.p_mask))\\n+source.p = karray.get_distributed_source_signal(kgrid, source_sig)\\n+# MEDIUM\\n+\\n+medium = kWaveMedium(sound_speed=c0, density=rho0)\\n+\\n+# SENSOR\\n+sensor_mask = np.zeros((Nx, Ny, Nz))\\n+sensor_mask[:, Ny // 2, :] = 1\\n+sensor = kSensor(sensor_mask, record=['p_max'])\\n+\\n+# SIMULATION\\n+simulation_options = SimulationOptions(\\n+    pml_auto=True,\\n+    pml_inside=False,\\n+    save_to_disk=True,\\n+    data_cast='single',\\n+)\\n+\\n+execution_options = SimulationExecutionOptions(is_gpu_simulation=True)\\n+\\n+sensor_data = kspaceFirstOrder3DC(kgrid=kgrid, medium=medium, source=source, sensor=sensor,\\n+                                  simulation_options=simulation_options, execution_options=execution_options)\\n+\\n+p_max = np.reshape(sensor_data['p_max'], (Nx, Nz), order='F')\\n+\\n+# VISUALISATION\\n+plt.figure()\\n+plt.imshow(1e-6 * p_max, extent=[1e3 * kgrid.x_vec[0][0], 1e3 * kgrid.x_vec[-1][0], 1e3 * kgrid.z_vec[0][0],\\n+                                 1e3 * kgrid.z_vec[-1][0]], aspect='auto')\\n+plt.xlabel('z-position [mm]')\\n+plt.ylabel('x-position [mm]')\\n+plt.title('Pressure Field')\\n+plt.colorbar(label='[MPa]')\\n+plt.show()\\n\",\"diff --git a/kwave/kWaveSimulation_helper/display_simulation_params.py b/kwave/kWaveSimulation_helper/display_simulation_params.py\\nindex e6269f4..4034b31 100644\\n--- a/kwave/kWaveSimulation_helper/display_simulation_params.py\\n+++ b/kwave/kWaveSimulation_helper/display_simulation_params.py\\n@@ -12,7 +12,7 @@ def display_simulation_params(kgrid: kWaveGrid, medium: kWaveMedium, elastic_cod\\n     k_size = kgrid.size\\n \\n     # display time step information\\n-    print('  dt: ', f'{scale_SI(dt)[0]}s', f', t_end: {scale_SI(t_array_end)[0]}s', ', time steps:', Nt)\\n+    print('  dt: ', f'{scale_SI(dt)[0]}s, t_end: {scale_SI(t_array_end)[0]}s, time steps:', Nt)\\n \\n     c_min, c_min_comp, c_min_shear = get_min_sound_speed(medium, elastic_code)\\n \\n\",\"diff --git a/kwave/kgrid.py b/kwave/kgrid.py\\nindex 1ba6e06..9da1d55 100644\\n--- a/kwave/kgrid.py\\n+++ b/kwave/kgrid.py\\n@@ -6,6 +6,7 @@ import numpy as np\\n \\n from kwave.data import Vector, FlexibleVector\\n from kwave.enums import DiscreteCosine, DiscreteSine\\n+from kwave.utils import matlab\\n from kwave.utils.math import largest_prime_factor\\n \\n \\n@@ -344,6 +345,13 @@ class kWaveGrid(object):\\n             return np.nan\\n \\n     @property\\n+    def x_size(self):\\n+        \\\"\\\"\\\"\\n+        Size of grid in the x-direction [m]\\n+        \\\"\\\"\\\"\\n+        return self.Nx * self.dx\\n+\\n+    @property\\n     def y_size(self):\\n         \\\"\\\"\\\"\\n         Size of grid in the y-direction [m]\\n@@ -453,16 +461,16 @@ class kWaveGrid(object):\\n         based on the minimum value.\\n \\n         Args:\\n-            c:\\n-            cfl:\\n-            t_end:\\n+            c: sound speed\\n+            cfl: convergence condition by Courant–Friedrichs–Lewy\\n+            t_end: final time step\\n \\n         Returns:\\n             Nothing\\n         \\\"\\\"\\\"\\n         # if c is a matrix, find the minimum and maximum values\\n         c = np.array(c)\\n-        c_min, c_max = c.min(), c.max()\\n+        c_min, c_max = np.min(c), np.max(c)\\n \\n         # check for user define t_end, otherwise set the simulation\\n         # length based on the size of the grid diagonal and the maximum\\n@@ -471,16 +479,16 @@ class kWaveGrid(object):\\n             t_end = np.linalg.norm(self.size, ord=2) / c_min\\n \\n         # extract the smallest grid spacing\\n-        min_grid_dim = self.spacing.min()\\n+        min_grid_dim = np.min(self.spacing)\\n \\n         # assign time step based on CFL stability criterion\\n         self.dt = cfl * min_grid_dim / c_max\\n \\n         # assign number of time steps based on t_end\\n-        self.Nt = int(t_end / self.dt) + 1\\n+        self.Nt = int(np.floor(t_end / self.dt) + 1)\\n \\n-        # catch case were dt is a recurring number\\n-        if (int(t_end / self.dt) != math.ceil(t_end / self.dt)) and (t_end % self.dt == 0):\\n+        # catch case where dt is a recurring number\\n+        if (np.floor(t_end / self.dt) != np.ceil(t_end / self.dt)) and (matlab.rem(t_end, self.dt) == 0):\\n             self.Nt = self.Nt + 1\\n \\n         return self.t_array, self.dt\\n\",\"diff --git a/kwave/kspaceFirstOrder2D.py b/kwave/kspaceFirstOrder2D.py\\nindex af26488..c77d35f 100644\\n--- a/kwave/kspaceFirstOrder2D.py\\n+++ b/kwave/kspaceFirstOrder2D.py\\n@@ -1,22 +1,17 @@\\n-import os\\n-import tempfile\\n from typing import Union\\n \\n import numpy as np\\n \\n-from kwave.kmedium import kWaveMedium\\n-from kwave.ksensor import kSensor\\n-\\n-from kwave.ktransducer import NotATransducer\\n-\\n-from kwave.kgrid import kWaveGrid\\n-\\n from kwave.executor import Executor\\n from kwave.kWaveSimulation import kWaveSimulation\\n from kwave.kWaveSimulation_helper import retract_transducer_grid_size, save_to_disk_func\\n+from kwave.kgrid import kWaveGrid\\n+from kwave.kmedium import kWaveMedium\\n+from kwave.ksensor import kSensor\\n from kwave.ksource import kSource\\n-from kwave.options.simulation_options import SimulationOptions\\n+from kwave.ktransducer import NotATransducer\\n from kwave.options.simulation_execution_options import SimulationExecutionOptions\\n+from kwave.options.simulation_options import SimulationOptions\\n from kwave.utils.dotdictionary import dotdict\\n from kwave.utils.interp import interpolate2d\\n from kwave.utils.pml import get_pml\\n@@ -59,7 +54,7 @@ def kspace_first_order_2d_gpu(\\n     of kspaceFirstOrder3DC by replacing the binary name with the name of the\\n     GPU binary.\\n     \\\"\\\"\\\"\\n-    assert execution_options.is_gpu_simulation, 'kspaceFirstOrder2DG can only be used for GPU simulations'\\n+    execution_options.is_gpu_simulation = True  # force to GPU\\n     sensor_data = kspaceFirstOrder2DC(\\n         kgrid=kgrid,\\n         source=source,\\n@@ -126,6 +121,7 @@ def kspaceFirstOrder2DC(\\n     Returns:\\n         Sensor data as a numpy array\\n     \\\"\\\"\\\"\\n+    execution_options.is_gpu_simulation = False  # force to CPU\\n     # generate the input file and save to disk\\n     sensor_data = kspaceFirstOrder2D(\\n         kgrid=kgrid,\\n@@ -286,7 +282,6 @@ def kspaceFirstOrder2D(\\n         medium: kWaveMedium instance\\n         source: kWaveSource instance\\n         sensor: kWaveSensor instance\\n-        **kwargs:\\n \\n     Returns:\\n \\n@@ -438,10 +433,8 @@ def kspaceFirstOrder2D(\\n         if options.save_to_disk_exit:\\n             return\\n \\n-        input_filename = k_sim.options.save_to_disk\\n-        output_filename = os.path.join(tempfile.gettempdir(), 'output.h5')\\n-\\n-        executor = Executor(device='gpu')\\n+        executor = Executor(simulation_options=simulation_options, execution_options=execution_options)\\n         executor_options = execution_options.get_options_string(sensor=k_sim.sensor)\\n-        sensor_data = executor.run_simulation(input_filename, output_filename, options=executor_options)\\n-        return k_sim.sensor.combine_sensor_data(sensor_data)\\n+        sensor_data = executor.run_simulation(k_sim.options.input_filename, k_sim.options.output_filename,\\n+                                              options=executor_options)\\n+        return sensor_data\\n\",\"diff --git a/kwave/kspaceFirstOrder3D.py b/kwave/kspaceFirstOrder3D.py\\nindex 8d2ae5f..b4a51a1 100644\\n--- a/kwave/kspaceFirstOrder3D.py\\n+++ b/kwave/kspaceFirstOrder3D.py\\n@@ -62,8 +62,9 @@ def kspaceFirstOrder3DG(\\n     Returns:\\n \\n     \\\"\\\"\\\"\\n+    execution_options.is_gpu_simulation = True\\n     assert execution_options.is_gpu_simulation, 'kspaceFirstOrder2DG can only be used for GPU simulations'\\n-    sensor_data = kspaceFirstOrder3DC(\\n+    sensor_data = kspaceFirstOrder3D(\\n         kgrid=kgrid,\\n         source=source,\\n         sensor=sensor,\\n@@ -119,6 +120,7 @@ def kspaceFirstOrder3DC(\\n     Returns:\\n \\n     \\\"\\\"\\\"\\n+    execution_options.is_gpu_simulation = False\\n     # generate the input file and save to disk\\n     sensor_data = kspaceFirstOrder3D(\\n         kgrid=kgrid,\\n@@ -459,8 +461,8 @@ def kspaceFirstOrder3D(\\n         if options.save_to_disk_exit:\\n             return\\n \\n-        executor = Executor(device='gpu')\\n+        executor = Executor(simulation_options=simulation_options, execution_options=execution_options)\\n         executor_options = execution_options.get_options_string(sensor=k_sim.sensor)\\n         sensor_data = executor.run_simulation(k_sim.options.input_filename, k_sim.options.output_filename,\\n                                               options=executor_options)\\n-        return k_sim.sensor.combine_sensor_data(sensor_data)\\n+        return sensor_data\\n\",\"diff --git a/kwave/kspaceFirstOrderAS.py b/kwave/kspaceFirstOrderAS.py\\nindex 269a91d..2f6223b 100644\\n--- a/kwave/kspaceFirstOrderAS.py\\n+++ b/kwave/kspaceFirstOrderAS.py\\n@@ -1,13 +1,6 @@\\n-import os\\n-import tempfile\\n from typing import Union\\n \\n import numpy as np\\n-\\n-from kwave.kmedium import kWaveMedium\\n-from kwave.ksensor import kSensor\\n-\\n-from kwave.ktransducer import NotATransducer\\n from numpy.fft import ifftshift\\n \\n from kwave.kgrid import kWaveGrid\\n@@ -15,9 +8,12 @@ from kwave.enums import DiscreteCosine\\n from kwave.executor import Executor\\n from kwave.kWaveSimulation import kWaveSimulation\\n from kwave.kWaveSimulation_helper import retract_transducer_grid_size, save_to_disk_func\\n+from kwave.kmedium import kWaveMedium\\n+from kwave.ksensor import kSensor\\n from kwave.ksource import kSource\\n-from kwave.options.simulation_options import SimulationOptions, SimulationType\\n+from kwave.ktransducer import NotATransducer\\n from kwave.options.simulation_execution_options import SimulationExecutionOptions\\n+from kwave.options.simulation_options import SimulationOptions, SimulationType\\n from kwave.utils.dotdictionary import dotdict\\n from kwave.utils.interp import interpolate2d\\n from kwave.utils.math import sinc\\n@@ -365,10 +361,8 @@ def kspaceFirstOrderAS(\\n         if options.save_to_disk_exit:\\n             return\\n \\n-        input_filename = k_sim.options.save_to_disk\\n-        output_filename = os.path.join(tempfile.gettempdir(), 'output.h5')\\n-\\n-        executor = Executor(device='gpu')\\n+        executor = Executor(simulation_options=simulation_options, execution_options=execution_options)\\n         executor_options = execution_options.get_options_string(sensor=k_sim.sensor)\\n-        sensor_data = executor.run_simulation(input_filename, output_filename, options=executor_options)\\n-        return k_sim.sensor.combine_sensor_data(sensor_data)\\n+        sensor_data = executor.run_simulation(k_sim.options.input_filename, k_sim.options.output_filename,\\n+                                              options=executor_options)\\n+        return sensor_data\\n\",\"diff --git a/kwave/ktransducer.py b/kwave/ktransducer.py\\nindex 426a9f0..5cfd8af 100644\\n--- a/kwave/ktransducer.py\\n+++ b/kwave/ktransducer.py\\n@@ -466,7 +466,7 @@ class NotATransducer(kSensor):\\n \\n     @property\\n     def number_active_elements(self):\\n-        return self.active_elements.sum()\\n+        return int(self.active_elements.sum())\\n \\n     @property\\n     def appended_zeros(self):\\n\",\"diff --git a/kwave/options/__init__.py b/kwave/options/__init__.py\\nindex 729f693..e69de29 100644\\n--- a/kwave/options/__init__.py\\n+++ b/kwave/options/__init__.py\\n@@ -1,2 +0,0 @@\\n-from kwave.options.simulation_options import SimulationOptions\\n-from kwave.options.simulation_execution_options import SimulationExecutionOptions\\n\",\"diff --git a/kwave/options/simulation_execution_options.py b/kwave/options/simulation_execution_options.py\\nindex 80c186d..ee1113f 100644\\n--- a/kwave/options/simulation_execution_options.py\\n+++ b/kwave/options/simulation_execution_options.py\\n@@ -1,5 +1,7 @@\\n import os\\n+import sys\\n from dataclasses import dataclass\\n+from pathlib import Path\\n from typing import Optional, Union\\n \\n from kwave.ksensor import kSensor\\n@@ -35,20 +37,33 @@ class SimulationExecutionOptions:\\n     def __post_init__(self):\\n         self.validate()\\n \\n-        if (self.binary_path is not None) and (not self.binary_path.endswith(os.path.sep)):\\n-            self.binary_path = self.binary_path + os.path.sep\\n-\\n         if self.binary_name is None:\\n             if self.is_gpu_simulation:\\n                 self.binary_name = 'kspaceFirstOrder-CUDA' if is_unix() else 'kspaceFirstOrder-CUDA.exe'\\n             else:\\n                 self.binary_name = 'kspaceFirstOrder-OMP' if is_unix() else 'kspaceFirstOrder-OMP.exe'\\n \\n+        self._is_linux = True  # sys.platform.startswith('linux')\\n+        self._is_windows = sys.platform.startswith(('win', 'cygwin'))\\n+        self._is_darwin = sys.platform.startswith('darwin')\\n+\\n+        if self._is_linux:\\n+            binary_folder = 'linux'\\n+        elif self._is_windows:\\n+            binary_folder = 'windows'\\n+            self.binary_name += '.exe'\\n+        elif self._is_darwin:\\n+            raise NotImplementedError('k-wave-python is currently unsupported on MacOS.')\\n+\\n+        path_to_kwave = Path(__file__).parent.parent.resolve()\\n+        self.binary_path = path_to_kwave / 'bin' / binary_folder / self.binary_name\\n+\\n     def validate(self):\\n         if isinstance(self.num_threads, int):\\n             assert self.num_threads > 0 and self.num_threads != float('inf')\\n         else:\\n             assert self.num_threads == 'all'\\n+            self.num_threads = None\\n \\n         assert isinstance(self.verbose_level, int) and 0 <= self.verbose_level <= 2\\n \\n\",\"diff --git a/kwave/options/simulation_options.py b/kwave/options/simulation_options.py\\nindex e476db1..5be3d8d 100644\\n--- a/kwave/options/simulation_options.py\\n+++ b/kwave/options/simulation_options.py\\n@@ -1,4 +1,5 @@\\n from __future__ import annotations\\n+\\n import os\\n from dataclasses import dataclass, field\\n from enum import Enum\\n@@ -87,7 +88,7 @@ class SimulationOptions(object):\\n     pml_inside: bool = True\\n     pml_alpha: float = 2.0\\n     save_to_disk: bool = False\\n-    save_to_disk_exit: bool = True\\n+    save_to_disk_exit: bool = False\\n     scale_source_terms: bool = True\\n     smooth_c0: bool = False\\n     smooth_rho0: bool = False\\n@@ -324,7 +325,10 @@ class SimulationOptions(object):\\n                 \\\"Optional input ''use_fd'' only supported in 1D.\\\"\\n         # get optimal pml size\\n         if options.simulation_type.is_axisymmetric() or options.pml_auto:\\n-            pml_size_temp = get_optimal_pml_size(kgrid, options.pml_search_range, options.radial_symmetry[:4])\\n+            if options.simulation_type.is_axisymmetric():\\n+                pml_size_temp = get_optimal_pml_size(kgrid, options.pml_search_range, options.radial_symmetry[:4])\\n+            else:\\n+                pml_size_temp = get_optimal_pml_size(kgrid, options.pml_search_range)\\n \\n             # assign to individual variables\\n             if kgrid.dim == 1:\\n\",\"diff --git a/kwave/utils/angular_spectrum.py b/kwave/utils/angular_spectrum.py\\nindex 5c54e43..6d48673 100644\\n--- a/kwave/utils/angular_spectrum.py\\n+++ b/kwave/utils/angular_spectrum.py\\n@@ -127,7 +127,6 @@ def angular_spectrum(\\n             absorbing = True\\n \\n     else:\\n-\\n         # assign the sound speed\\n         c0 = medium\\n \\n\",\"diff --git a/kwave/utils/kwave_array.py b/kwave/utils/kwave_array.py\\nindex f1eb641..678fdaf 100644\\n--- a/kwave/utils/kwave_array.py\\n+++ b/kwave/utils/kwave_array.py\\n@@ -1,17 +1,18 @@\\n import time\\n from dataclasses import dataclass\\n+from math import ceil\\n from typing import Optional\\n \\n import numpy as np\\n-from kwave.kgrid import kWaveGrid\\n from numpy import arcsin, pi, cos, size, array\\n from numpy.linalg import linalg\\n-from math import ceil\\n \\n+import kwave\\n+from kwave.kgrid import kWaveGrid\\n from kwave.utils.conversion import tol_star\\n from kwave.utils.interp import get_delta_bli\\n-from kwave.utils.mapgen import trim_cart_points, make_cart_rect, make_cart_arc, make_cart_bowl, \\\\\\n-    make_cart_spherical_segment, make_cart_disc\\n+from kwave.utils.mapgen import trim_cart_points, make_cart_rect, make_cart_arc, make_cart_bowl, make_cart_disc, \\\\\\n+    make_cart_spherical_segment\\n from kwave.utils.math import sinc, get_affine_matrix\\n from kwave.utils.matlab import matlab_assign, matlab_mask, matlab_find\\n \\n@@ -232,7 +233,8 @@ class kWaveArray(object):\\n                 \\\"Input position for rectangular element must be specified as a 2 (2D) or 3 (3D) element array.\\\")\\n \\n         if coord_dim == 3:\\n-            assert isinstance(theta, (list, tuple)) and len(theta) == 3, \\\"'theta' must be a list or tuple of length 3\\\"\\n+            assert isinstance(theta, (kwave.data.Vector, list, tuple)) and len(\\n+                theta) == 3, \\\"'theta' must be a list or tuple of length 3\\\"\\n         else:\\n             assert isinstance(theta, (int, float)), \\\"'theta' must be an integer or float\\\"\\n \\n@@ -413,7 +415,7 @@ class kWaveArray(object):\\n         # apply transformation\\n         vec = np.append(vec, [1])\\n         vec = np.matmul(self.array_transformation, vec)\\n-        return vec\\n+        return vec[:-1]\\n \\n     def get_off_grid_points(self, kgrid, element_num, mask_only):\\n \\n@@ -569,13 +571,13 @@ class kWaveArray(object):\\n             data_type = 'float64'\\n             sz_bytes = num_source_points * Nt * 8\\n \\n-        sz_ind = 0\\n+        sz_ind = 1\\n         while sz_bytes > 1024:\\n             sz_bytes = sz_bytes / 1024\\n             sz_ind += 1\\n \\n         prefixes = ['', 'K', 'M', 'G', 'T']\\n-        sz_bytes = round(sz_bytes, 2)\\n+        sz_bytes = np.round(sz_bytes, 2)  # TODO: should round to significant to map matlab functionality\\n         print(f'approximate size of source matrix: {str(sz_bytes)} {prefixes[sz_ind]} B ( {data_type} precision)')\\n \\n         source_signal = source_signal.astype(data_type)\\n\",\"diff --git a/kwave/utils/matlab.py b/kwave/utils/matlab.py\\nindex 8b889b8..2e04015 100644\\n--- a/kwave/utils/matlab.py\\n+++ b/kwave/utils/matlab.py\\n@@ -3,6 +3,35 @@ from typing import Tuple, Union, Optional, List\\n import numpy as np\\n \\n \\n+def rem(x, y, rtol=1e-05, atol=1e-08):\\n+    \\\"\\\"\\\"\\n+    Returns the remainder after division of x by y, taking into account the floating point precision.\\n+    x and y must be real and have compatible sizes.\\n+    This function should be equivalent to the MATLAB rem function.\\n+\\n+    Args:\\n+        x (float, list, or ndarray): The dividend(s).\\n+        y (float, list, or ndarray): The divisor(s).\\n+        rtol (float): The relative tolerance parameter (see numpy.isclose).\\n+        atol (float): The absolute tolerance parameter (see numpy.isclose).\\n+\\n+    Returns:\\n+        float or ndarray: The remainder after division.\\n+    \\\"\\\"\\\"\\n+    if np.any(y == 0):\\n+        return np.nan\\n+\\n+    quotient = x / y\\n+    closest_int = np.round(quotient)\\n+\\n+    # check if quotient is close to an integer value\\n+    if np.isclose(quotient, closest_int, rtol=rtol, atol=atol).all():\\n+        return np.zeros_like(x)\\n+\\n+    remainder = x - np.fix(quotient) * y\\n+\\n+    return remainder\\n+\\n def matlab_assign(matrix: np.ndarray, indices: Union[int, np.ndarray],\\n                   values: Union[int, float, np.ndarray]) -> np.ndarray:\\n     \\\"\\\"\\\"\\n\",\"diff --git a/kwave/utils/plot.py b/kwave/utils/plot.py\\nnew file mode 100644\\nindex 0000000..77cd53e\\n--- /dev/null\\n+++ b/kwave/utils/plot.py\\n@@ -0,0 +1,43 @@\\n+import matplotlib.pyplot as plt\\n+import numpy as np\\n+\\n+\\n+def voxel_plot(mat, axis_tight=False, color=(1, 1, 0.4), transparency=0.8):\\n+    \\\"\\\"\\\"\\n+    Generates a 3D voxel plot of a binary matrix.\\n+\\n+    Args:\\n+        mat (numpy.ndarray): Input 3D matrix in single or double precision.\\n+        axis_tight (bool): Whether axis limits are set to only display the filled voxels (default = False).\\n+        color (tuple): Three-element tuple specifying RGB color (default = (1, 1, 0.4)).\\n+        transparency (float): Value between 0 and 1 specifying transparency where 1 gives no transparency (default = 0.8).\\n+\\n+    Returns:\\n+        None\\n+    \\\"\\\"\\\"\\n+    # Check input matrix is 3D and single or double precision\\n+    if len(mat.shape) != 3 or not np.issubdtype(mat.dtype, np.floating):\\n+        raise ValueError('Input must be a 3D matrix in single or double precision.')\\n+\\n+    # Normalize the matrix\\n+    mat = mat / np.max(mat)\\n+\\n+    # Create 3D figure\\n+    fig = plt.figure()\\n+    ax = fig.add_subplot(111, projection='3d')\\n+    ax.voxels(mat, facecolors=color, alpha=transparency, edgecolors=(0.5, 0.5, 0.5, 0.5))\\n+\\n+    # Set the axes properties and labels\\n+    ax.view_init(elev=35, azim=-35)  # Adjust viewing angles here\\n+    ax.set_xlabel('x [voxels]')\\n+    ax.set_ylabel('y [voxels]')\\n+    ax.set_zlabel('z [voxels]')\\n+\\n+    if not axis_tight:\\n+        sz = mat.shape\\n+        ax.set_xlim([0.5, sz[2] + 0.5])\\n+        ax.set_ylim([0.5, sz[1] + 0.5])\\n+        ax.set_zlim([0.5, sz[0] + 0.5])\\n+\\n+    # Show the plot\\n+    plt.show()\\n\",\"diff --git a/kwave/utils/signals.py b/kwave/utils/signals.py\\nindex 267013d..b36118b 100644\\n--- a/kwave/utils/signals.py\\n+++ b/kwave/utils/signals.py\\n@@ -333,7 +333,8 @@ def tone_burst(sample_freq, signal_freq, num_cycles, envelope='Gaussian', plot_s\\n         created tone burst\\n \\n     \\\"\\\"\\\"\\n-    assert isinstance(signal_offset, int), \\\"signal_offset must be integer\\\"\\n+    assert isinstance(signal_offset, int) or isinstance(signal_offset,\\n+                                                        np.ndarray), \\\"signal_offset must be integer or array of integers\\\"\\n     assert isinstance(signal_length, int), \\\"signal_length must be integer\\\"\\n \\n     # calculate the temporal spacing\\n@@ -348,7 +349,7 @@ def tone_burst(sample_freq, signal_freq, num_cycles, envelope='Gaussian', plot_s\\n         tone_t = np.arange(0, tone_length, dt)\\n \\n     tone_burst = np.sin(2 * np.pi * signal_freq * tone_t)\\n-    tone_index = round(signal_offset)\\n+    tone_index = np.round(signal_offset)\\n \\n     # check for ring up and ring down input\\n     if isinstance(envelope, list) or isinstance(envelope, np.ndarray):  # and envelope.size == 2:\\n@@ -404,7 +405,6 @@ def tone_burst(sample_freq, signal_freq, num_cycles, envelope='Gaussian', plot_s\\n     # fw = 2 * sqrt(2 * log(2) * w_var)\\n \\n     # Convert tone_index and signal_offset to numpy arrays\\n-    tone_index = np.array([tone_index])\\n     signal_offset = np.array(signal_offset)\\n \\n     # Determine the length of the signal array\\n@@ -414,8 +414,14 @@ def tone_burst(sample_freq, signal_freq, num_cycles, envelope='Gaussian', plot_s\\n     signal = np.zeros((tone_index.size, signal_length))\\n \\n     # Add the tone burst to the signal array\\n-    signal[:, tone_index[0]:tone_index[0] + len(tone_burst)] = tone_burst.T\\n+    # Add the tone burst to the signal array\\n+    tone_index = np.atleast_1d(tone_index)\\n \\n+    if tone_index.size == 1:\\n+        signal[:, int(tone_index):int(tone_index) + len(tone_burst)] = tone_burst.T\\n+    else:\\n+        for offset, tone_idx in enumerate(tone_index):\\n+            signal[offset, int(tone_idx):int(tone_idx) + len(tone_burst)] = tone_burst.T\\n     # plot the signal if required\\n     if plot_signal:\\n         raise NotImplementedError\\n\"]", "test_patch": "", "hints_text": ""}

{"instance_id": "676557005248628", "repo": "adtzlr/felupe", "base_commit": "9a9b2b72054949276f72e001bd17136829321cb3", "problem_statement": "Enhance Mesh-Tools:\\nIntroduce a decorator to allow both Meshes or raw mesh data (points, cells, cell_type) as in- and output.\\r\\n\\r\\n## Tasks:\\r\\n- [ ] add a function decorator\\r\\n- [ ] apply the decorator on all mesh tools\\r\\n- [ ] update tests\\nUse parallel version of einsum:\\nuse package `einsumt` if `parallel` keyword is provided, involves also #193 \\nRename `parallel` keyword to `jit`:\\n", "FAIL_TO_PASS": ["tests/test_constitution.py::test_kinematics", "tests/test_form.py::test_bilinearform", "tests/test_constitution.py::test_linear", "tests/test_mesh.py::test_meshes", "tests/test_form.py::test_mixed", "tests/test_form.py::test_axi", "tests/test_form.py::test_linearform", "tests/test_form.py::test_linearform_broadcast", "tests/test_mesh.py::test_mirror", "tests/test_form.py::test_bilinearform_broadcast", "tests/test_constitution.py::test_wrappers", "tests/test_constitution.py::test_nh"], "PASS_TO_PASS": ["tests/test_quadrature.py::test_tetra", "tests/test_element.py::test_aol", "tests/test_tools.py::test_solve_mixed_check", "tests/test_element.py::test_tet4", "tests/test_tools.py::test_newton_simple", "tests/test_tools.py::test_newton_mixed", "tests/test_tools.py::test_newton", "tests/test_region.py::test_region", "tests/test_element.py::test_hex8", "tests/test_constitution.py::test_linear_planestress", "tests/test_dof.py::test_mpc", "tests/test_tools.py::test_newton_plane", "tests/test_element.py::test_tet_mini", "tests/test_dof.py::test_boundary", "tests/test_element.py::test_hex27", "tests/test_quadrature.py::test_triangle", "tests/test_element.py::test_tri6", "tests/test_dof.py::test_mpc_mixed", "tests/test_quadrature.py::test_gausslegendre", "tests/test_element.py::test_quad0", "tests/test_element.py::test_hex0", "tests/test_solve.py::test_solve", "tests/test_math.py::test_math", "tests/test_element.py::test_quad4", "tests/test_element.py::test_tri_mini", "tests/test_element.py::test_tet10", "tests/test_element.py::test_hex20", "tests/test_math.py::test_math_field", "tests/test_bilinearform.py::test_bilinearform_mixed", "tests/test_field.py::test_3d_mixed", "tests/test_field.py::test_axi", "tests/test_dof.py::test_loadcase", "tests/test_field.py::test_3d", "tests/test_element.py::test_line2", "tests/test_bilinearform.py::test_bilinearform", "tests/test_constitution.py::test_linear_planestrain", "tests/test_tools.py::test_newton_linearelastic", "tests/test_bilinearform.py::test_linearform", "tests/test_basis.py::test_basis", "tests/test_bilinearform.py::test_linearform_mixed", "tests/test_element.py::test_tri3"], "language": "python", "test_command": "source /saved/ENV || source /saved/*/ENV && tox -- --no-header -rA --tb=no -p no:cacheprovider --continue-on-collection-errors", "test_output_parser": "python/parse_log_pytest_v3", "image_storage_uri": "vmvm-registry.fbinfra.net/repomate_image_activ_pytest/adtzlr_felupe:9a9b2b72054949276f72e001bd17136829321cb3", "patch": "", "test_patch": "[\"diff --git a/tests/test_constitution.py b/tests/test_constitution.py\\nindex 380b8e1c..bad55472 100644\\n--- a/tests/test_constitution.py\\n+++ b/tests/test_constitution.py\\n@@ -53,35 +53,37 @@ def pre_mixed(sym, add_identity):\\n def test_nh():\\n     r, F = pre(sym=False, add_identity=True)\\n \\n-    nh = fe.constitution.NeoHooke(mu=1.0, bulk=2.0)\\n+    for parallel in [False, True]:\\n \\n-    W = nh.function(F)\\n-    P = nh.gradient(F)\\n-    A = nh.hessian(F)\\n+        nh = fe.constitution.NeoHooke(mu=1.0, bulk=2.0, parallel=parallel)\\n \\n-    Wx = nh.energy(F)\\n-    Px = nh.stress(F)\\n-    Ax = nh.elasticity(F)\\n+        W = nh.function(F)\\n+        P = nh.gradient(F)\\n+        A = nh.hessian(F)\\n \\n-    assert np.allclose(W, Wx)\\n-    assert np.allclose(P, Px)\\n-    assert np.allclose(A, Ax)\\n+        Wx = nh.energy(F)\\n+        Px = nh.stress(F)\\n+        Ax = nh.elasticity(F)\\n \\n-    assert W.shape == F.shape[-2:]\\n-    assert P.shape == (3, 3, *F.shape[-2:])\\n-    assert A.shape == (3, 3, 3, 3, *F.shape[-2:])\\n+        assert np.allclose(W, Wx)\\n+        assert np.allclose(P, Px)\\n+        assert np.allclose(A, Ax)\\n \\n-    nh = fe.constitution.NeoHooke(mu=None, bulk=2.0)\\n+        assert W.shape == F.shape[-2:]\\n+        assert P.shape == (3, 3, *F.shape[-2:])\\n+        assert A.shape == (3, 3, 3, 3, *F.shape[-2:])\\n \\n-    W = nh.function(F, mu=2.0)\\n-    P = nh.gradient(F, mu=2.0)\\n-    A = nh.hessian(F, mu=2.0)\\n+        nh = fe.constitution.NeoHooke(mu=None, bulk=2.0, parallel=parallel)\\n \\n-    assert W.shape == F.shape[-2:]\\n-    assert P.shape == (3, 3, *F.shape[-2:])\\n-    assert A.shape == (3, 3, 3, 3, *F.shape[-2:])\\n+        W = nh.function(F, mu=2.0)\\n+        P = nh.gradient(F, mu=2.0)\\n+        A = nh.hessian(F, mu=2.0)\\n \\n-    assert np.allclose(P, 0)\\n+        assert W.shape == F.shape[-2:]\\n+        assert P.shape == (3, 3, *F.shape[-2:])\\n+        assert A.shape == (3, 3, 3, 3, *F.shape[-2:])\\n+\\n+        assert np.allclose(P, 0)\\n \\n \\n def test_linear():\\n@@ -90,12 +92,15 @@ def test_linear():\\n     check_stress = []\\n     check_dsde = []\\n \\n-    for LinearElastic in [\\n-        fe.constitution.LinearElastic,\\n-        fe.constitution.LinearElasticTensorNotation,\\n+    for Material in [\\n+        (fe.constitution.LinearElastic, {}),\\n+        (fe.constitution.LinearElasticTensorNotation, dict(parallel=False)),\\n+        (fe.constitution.LinearElasticTensorNotation, dict(parallel=True)),\\n     ]:\\n \\n-        le = LinearElastic(E=1.0, nu=0.3)\\n+        LinearElastic, kwargs = Material\\n+\\n+        le = LinearElastic(E=1.0, nu=0.3, **kwargs)\\n \\n         stress = le.gradient(F)\\n         dsde = le.hessian(F)\\n@@ -109,7 +114,7 @@ def test_linear():\\n \\n         assert dsde.shape == dsde2.shape\\n \\n-        le = LinearElastic(E=None, nu=0.3)\\n+        le = LinearElastic(E=None, nu=0.3, **kwargs)\\n         stress = le.gradient(F, E=2.0)\\n         stress = le.gradient(F, E=0.5, nu=0.2)\\n         dsde = le.hessian(F, E=2.0)\\n@@ -192,79 +197,85 @@ def test_linear_planestrain():\\n def test_kinematics():\\n     r, F = pre(sym=False, add_identity=True)\\n \\n-    lc = fe.constitution.LineChange()\\n-    ac = fe.constitution.AreaChange()\\n-    vc = fe.constitution.VolumeChange()\\n+    for parallel in [False, True]:\\n \\n-    xf = lc.function(F)\\n-    xg = lc.gradient(F)\\n+        lc = fe.constitution.LineChange(parallel=parallel)\\n+        ac = fe.constitution.AreaChange(parallel=parallel)\\n+        vc = fe.constitution.VolumeChange(parallel=parallel)\\n \\n-    yf = ac.function(F)\\n-    yg = ac.gradient(F)\\n+        xf = lc.function(F)\\n+        xg = lc.gradient(F)\\n \\n-    zf = vc.function(F)\\n-    zg = vc.gradient(F)\\n-    zh = vc.hessian(F)\\n+        yf = ac.function(F)\\n+        yg = ac.gradient(F)\\n \\n-    assert np.allclose(xf, F)\\n+        zf = vc.function(F)\\n+        zg = vc.gradient(F)\\n+        zh = vc.hessian(F)\\n \\n-    assert xf.shape == (3, 3, *F.shape[-2:])\\n-    assert xg.shape == (3, 3, 3, 3, *F.shape[-2:])\\n+        assert np.allclose(xf, F)\\n \\n-    assert yf.shape == (3, 3, *F.shape[-2:])\\n-    assert yg.shape == (3, 3, 3, 3, *F.shape[-2:])\\n+        assert xf.shape == (3, 3, *F.shape[-2:])\\n+        assert xg.shape == (3, 3, 3, 3, *F.shape[-2:])\\n \\n-    assert zf.shape == F.shape[-2:]\\n-    assert zg.shape == (3, 3, *F.shape[-2:])\\n-    assert zh.shape == (3, 3, 3, 3, *F.shape[-2:])\\n+        assert yf.shape == (3, 3, *F.shape[-2:])\\n+        assert yg.shape == (3, 3, 3, 3, *F.shape[-2:])\\n+\\n+        assert zf.shape == F.shape[-2:]\\n+        assert zg.shape == (3, 3, *F.shape[-2:])\\n+        assert zh.shape == (3, 3, 3, 3, *F.shape[-2:])\\n \\n \\n def test_wrappers():\\n     r, F = pre(sym=False, add_identity=True)\\n \\n-    nh = fe.NeoHooke(mu=1.0, bulk=2.0)\\n+    for parallel in [False, True]:\\n+\\n+        nh = fe.NeoHooke(mu=1.0, bulk=2.0, parallel=parallel)\\n \\n-    class AsMatadi:\\n-        def __init__(self, material):\\n-            self.material = material\\n+        class AsMatadi:\\n+            def __init__(self, material):\\n+                self.material = material\\n \\n-        def function(self, x, threads=1):\\n-            if len(x) == 1:\\n-                return [self.material.function(*x)]\\n-            else:\\n-                return self.material.function(*x)\\n+            def function(self, x, threads=1):\\n+                if len(x) == 1:\\n+                    return [self.material.function(*x)]\\n+                else:\\n+                    return self.material.function(*x)\\n \\n-        def gradient(self, x, threads=1):\\n-            if len(x) == 1:\\n-                return [self.material.gradient(*x)]\\n-            else:\\n-                return self.material.gradient(*x)\\n+            def gradient(self, x, threads=1):\\n+                if len(x) == 1:\\n+                    return [self.material.gradient(*x)]\\n+                else:\\n+                    return self.material.gradient(*x)\\n \\n-        def hessian(self, x, threads=1):\\n-            if len(x) == 1:\\n-                return [self.material.hessian(*x)]\\n-            else:\\n-                return self.material.hessian(*x)\\n+            def hessian(self, x, threads=1):\\n+                if len(x) == 1:\\n+                    return [self.material.hessian(*x)]\\n+                else:\\n+                    return self.material.hessian(*x)\\n \\n-    umat = fe.MatadiMaterial(AsMatadi(nh))\\n+        umat = fe.MatadiMaterial(AsMatadi(nh))\\n \\n-    W = umat.function(F)\\n-    P = umat.gradient(F)\\n-    A = umat.hessian(F)\\n+        W = umat.function(F)\\n+        P = umat.gradient(F)\\n+        A = umat.hessian(F)\\n \\n-    assert W.shape == F.shape[-2:]\\n-    assert P.shape == (3, 3, *F.shape[-2:])\\n-    assert A.shape == (3, 3, 3, 3, *F.shape[-2:])\\n+        assert W.shape == F.shape[-2:]\\n+        assert P.shape == (3, 3, *F.shape[-2:])\\n+        assert A.shape == (3, 3, 3, 3, *F.shape[-2:])\\n \\n-    r, FpJ = pre_mixed(sym=False, add_identity=True)\\n+        r, FpJ = pre_mixed(sym=False, add_identity=True)\\n \\n-    umat = fe.MatadiMaterial(AsMatadi(fe.ThreeFieldVariation(nh)))\\n+        umat = fe.MatadiMaterial(\\n+            AsMatadi(fe.ThreeFieldVariation(nh, parallel=parallel))\\n+        )\\n \\n-    P = umat.gradient(*FpJ)\\n-    A = umat.hessian(*FpJ)\\n+        P = umat.gradient(*FpJ)\\n+        A = umat.hessian(*FpJ)\\n \\n-    assert P[0].shape == (3, 3, *FpJ[0].shape[-2:])\\n-    assert A[0].shape == (3, 3, 3, 3, *FpJ[0].shape[-2:])\\n+        assert P[0].shape == (3, 3, *FpJ[0].shape[-2:])\\n+        assert A[0].shape == (3, 3, 3, 3, *FpJ[0].shape[-2:])\\n \\n \\n if __name__ == \\\"__main__\\\":\\n\",\"diff --git a/tests/test_form.py b/tests/test_form.py\\nindex 4239b7e2..38f8ef79 100644\\n--- a/tests/test_form.py\\n+++ b/tests/test_form.py\\n@@ -126,23 +126,25 @@ def test_axi():\\n \\n     for parallel in [False, True]:\\n \\n-        L = fe.IntegralFormAxisymmetric(P, u, r.dV)\\n-        x = L.integrate(parallel=parallel)\\n+        for jit in [False, True]:\\n \\n-        b = L.assemble(x, parallel=parallel).toarray()\\n-        assert b.shape == (r.mesh.ndof, 1)\\n+            L = fe.IntegralFormAxisymmetric(P, u, r.dV)\\n+            x = L.integrate(parallel=parallel, jit=jit)\\n \\n-        b = L.assemble(parallel=parallel).toarray()\\n-        assert b.shape == (r.mesh.ndof, 1)\\n+            b = L.assemble(x, parallel=parallel).toarray()\\n+            assert b.shape == (r.mesh.ndof, 1)\\n \\n-        a = fe.IntegralFormAxisymmetric(A, u, r.dV, u)\\n-        y = a.integrate(parallel=parallel)\\n+            b = L.assemble(parallel=parallel).toarray()\\n+            assert b.shape == (r.mesh.ndof, 1)\\n \\n-        K = a.assemble(y, parallel=parallel).toarray()\\n-        assert K.shape == (r.mesh.ndof, r.mesh.ndof)\\n+            a = fe.IntegralFormAxisymmetric(A, u, r.dV, u)\\n+            y = a.integrate(parallel=parallel, jit=jit)\\n \\n-        K = a.assemble(parallel=parallel).toarray()\\n-        assert K.shape == (r.mesh.ndof, r.mesh.ndof)\\n+            K = a.assemble(y, parallel=parallel, jit=jit).toarray()\\n+            assert K.shape == (r.mesh.ndof, r.mesh.ndof)\\n+\\n+            K = a.assemble(parallel=parallel, jit=jit).toarray()\\n+            assert K.shape == (r.mesh.ndof, r.mesh.ndof)\\n \\n \\n def test_linearform():\\n@@ -151,19 +153,21 @@ def test_linearform():\\n \\n     for parallel in [False, True]:\\n \\n-        L = fe.IntegralForm(P, u, r.dV, grad_v=True)\\n-        x = L.integrate(parallel=parallel)\\n-        b = L.assemble(x, parallel=parallel).toarray()\\n-        assert b.shape == (r.mesh.ndof, 1)\\n-        b = L.assemble(parallel=parallel).toarray()\\n-        assert b.shape == (r.mesh.ndof, 1)\\n+        for jit in [False, True]:\\n+\\n+            L = fe.IntegralForm(P, u, r.dV, grad_v=True)\\n+            x = L.integrate(parallel=parallel, jit=jit)\\n+            b = L.assemble(x, parallel=parallel).toarray()\\n+            assert b.shape == (r.mesh.ndof, 1)\\n+            b = L.assemble(parallel=parallel, jit=jit).toarray()\\n+            assert b.shape == (r.mesh.ndof, 1)\\n \\n-        L = fe.IntegralForm(p.interpolate(), p, r.dV)\\n-        x = L.integrate(parallel=parallel)\\n-        b = L.assemble(x, parallel=parallel).toarray()\\n-        assert b.shape == (r.mesh.npoints, 1)\\n-        b = L.assemble(parallel=parallel).toarray()\\n-        assert b.shape == (r.mesh.npoints, 1)\\n+            L = fe.IntegralForm(p.interpolate(), p, r.dV)\\n+            x = L.integrate(parallel=parallel, jit=jit)\\n+            b = L.assemble(x, parallel=parallel, jit=jit).toarray()\\n+            assert b.shape == (r.mesh.npoints, 1)\\n+            b = L.assemble(parallel=parallel, jit=jit).toarray()\\n+            assert b.shape == (r.mesh.npoints, 1)\\n \\n \\n def test_linearform_broadcast():\\n@@ -172,19 +176,21 @@ def test_linearform_broadcast():\\n \\n     for parallel in [False, True]:\\n \\n-        L = fe.IntegralForm(P, u, r.dV, grad_v=True)\\n-        x = L.integrate(parallel=parallel)\\n-        b = L.assemble(x, parallel=parallel).toarray()\\n-        assert b.shape == (r.mesh.ndof, 1)\\n-        b = L.assemble(parallel=parallel).toarray()\\n-        assert b.shape == (r.mesh.ndof, 1)\\n+        for jit in [False, True]:\\n+\\n+            L = fe.IntegralForm(P, u, r.dV, grad_v=True)\\n+            x = L.integrate(parallel=parallel, jit=jit)\\n+            b = L.assemble(x, parallel=parallel, jit=jit).toarray()\\n+            assert b.shape == (r.mesh.ndof, 1)\\n+            b = L.assemble(parallel=parallel, jit=jit).toarray()\\n+            assert b.shape == (r.mesh.ndof, 1)\\n \\n-        L = fe.IntegralForm(p.interpolate(), p, r.dV)\\n-        x = L.integrate(parallel=parallel)\\n-        b = L.assemble(x, parallel=parallel).toarray()\\n-        assert b.shape == (r.mesh.npoints, 1)\\n-        b = L.assemble(parallel=parallel).toarray()\\n-        assert b.shape == (r.mesh.npoints, 1)\\n+            L = fe.IntegralForm(p.interpolate(), p, r.dV)\\n+            x = L.integrate(parallel=parallel, jit=jit)\\n+            b = L.assemble(x, parallel=parallel, jit=jit).toarray()\\n+            assert b.shape == (r.mesh.npoints, 1)\\n+            b = L.assemble(parallel=parallel, jit=jit).toarray()\\n+            assert b.shape == (r.mesh.npoints, 1)\\n \\n \\n def test_bilinearform():\\n@@ -193,19 +199,21 @@ def test_bilinearform():\\n \\n     for parallel in [False, True]:\\n \\n-        a = fe.IntegralForm(A, u, r.dV, u, True, True)\\n-        y = a.integrate(parallel=parallel)\\n-        K = a.assemble(y, parallel=parallel).toarray()\\n-        assert K.shape == (r.mesh.ndof, r.mesh.ndof)\\n-        K = a.assemble(parallel=parallel).toarray()\\n-        assert K.shape == (r.mesh.ndof, r.mesh.ndof)\\n+        for jit in [False, True]:\\n \\n-        a = fe.IntegralForm(P, u, r.dV, p, True, False)\\n-        y = a.integrate(parallel=parallel)\\n-        K = a.assemble(y, parallel=parallel).toarray()\\n-        assert K.shape == (r.mesh.ndof, r.mesh.npoints)\\n-        K = a.assemble(parallel=parallel).toarray()\\n-        assert K.shape == (r.mesh.ndof, r.mesh.npoints)\\n+            a = fe.IntegralForm(A, u, r.dV, u, True, True)\\n+            y = a.integrate(parallel=parallel, jit=jit)\\n+            K = a.assemble(y, parallel=parallel, jit=jit).toarray()\\n+            assert K.shape == (r.mesh.ndof, r.mesh.ndof)\\n+            K = a.assemble(parallel=parallel, jit=jit).toarray()\\n+            assert K.shape == (r.mesh.ndof, r.mesh.ndof)\\n+\\n+            a = fe.IntegralForm(P, u, r.dV, p, True, False)\\n+            y = a.integrate(parallel=parallel, jit=jit)\\n+            K = a.assemble(y, parallel=parallel, jit=jit).toarray()\\n+            assert K.shape == (r.mesh.ndof, r.mesh.npoints)\\n+            K = a.assemble(parallel=parallel, jit=jit).toarray()\\n+            assert K.shape == (r.mesh.ndof, r.mesh.npoints)\\n \\n \\n def test_bilinearform_broadcast():\\n@@ -214,28 +222,30 @@ def test_bilinearform_broadcast():\\n \\n     for parallel in [False, True]:\\n \\n-        a = fe.IntegralForm(A, u, r.dV, u, True, True)\\n-        y = a.integrate(parallel=parallel)\\n-        K = a.assemble(y, parallel=parallel).toarray()\\n-        assert K.shape == (r.mesh.ndof, r.mesh.ndof)\\n-        K = a.assemble(parallel=parallel).toarray()\\n-        assert K.shape == (r.mesh.ndof, r.mesh.ndof)\\n-\\n-        a = fe.IntegralForm(P, u, r.dV, p, True, False)\\n-        y = a.integrate(parallel=parallel)\\n-        K = a.assemble(y, parallel=parallel).toarray()\\n-        assert K.shape == (r.mesh.ndof, r.mesh.npoints)\\n-        K = a.assemble(parallel=parallel).toarray()\\n-        assert K.shape == (r.mesh.ndof, r.mesh.npoints)\\n-\\n-        q = p.interpolate()\\n-        f = fe.math.dya(q, q, mode=1)\\n-        a = fe.IntegralForm(f, p, r.dV, p, False, False)\\n-        y = a.integrate(parallel=parallel)\\n-        K = a.assemble(y, parallel=parallel).toarray()\\n-        assert K.shape == (r.mesh.npoints, r.mesh.npoints)\\n-        K = a.assemble(parallel=parallel).toarray()\\n-        assert K.shape == (r.mesh.npoints, r.mesh.npoints)\\n+        for jit in [False, True]:\\n+\\n+            a = fe.IntegralForm(A, u, r.dV, u, True, True)\\n+            y = a.integrate(parallel=parallel, jit=jit)\\n+            K = a.assemble(y, parallel=parallel, jit=jit).toarray()\\n+            assert K.shape == (r.mesh.ndof, r.mesh.ndof)\\n+            K = a.assemble(parallel=parallel, jit=jit).toarray()\\n+            assert K.shape == (r.mesh.ndof, r.mesh.ndof)\\n+\\n+            a = fe.IntegralForm(P, u, r.dV, p, True, False)\\n+            y = a.integrate(parallel=parallel, jit=jit)\\n+            K = a.assemble(y, parallel=parallel, jit=jit).toarray()\\n+            assert K.shape == (r.mesh.ndof, r.mesh.npoints)\\n+            K = a.assemble(parallel=parallel, jit=jit).toarray()\\n+            assert K.shape == (r.mesh.ndof, r.mesh.npoints)\\n+\\n+            q = p.interpolate()\\n+            f = fe.math.dya(q, q, mode=1)\\n+            a = fe.IntegralForm(f, p, r.dV, p, False, False)\\n+            y = a.integrate(parallel=parallel, jit=jit)\\n+            K = a.assemble(y, parallel=parallel, jit=jit).toarray()\\n+            assert K.shape == (r.mesh.npoints, r.mesh.npoints)\\n+            K = a.assemble(parallel=parallel, jit=jit).toarray()\\n+            assert K.shape == (r.mesh.npoints, r.mesh.npoints)\\n \\n \\n def test_mixed():\\n@@ -244,39 +254,43 @@ def test_mixed():\\n \\n     for parallel in [False, True]:\\n \\n-        a = fe.IntegralFormMixed(A, v, r.dV, v)\\n-        y = a.integrate(parallel=parallel)\\n-        K = a.assemble(y, parallel=parallel).toarray()\\n-        K = a.assemble(parallel=parallel).toarray()\\n+        for jit in [False, True]:\\n \\n-        z = r.mesh.ndof + 2 * r.mesh.npoints\\n-        assert K.shape == (z, z)\\n+            a = fe.IntegralFormMixed(A, v, r.dV, v)\\n+            y = a.integrate(parallel=parallel, jit=jit)\\n+            K = a.assemble(y, parallel=parallel, jit=jit).toarray()\\n+            K = a.assemble(parallel=parallel, jit=jit).toarray()\\n \\n-        L = fe.IntegralFormMixed(f, v, r.dV)\\n-        x = L.integrate(parallel=parallel)\\n-        b = L.assemble(x, parallel=parallel).toarray()\\n-        b = L.assemble(parallel=parallel).toarray()\\n+            z = r.mesh.ndof + 2 * r.mesh.npoints\\n+            assert K.shape == (z, z)\\n \\n-        assert b.shape == (z, 1)\\n+            L = fe.IntegralFormMixed(f, v, r.dV)\\n+            x = L.integrate(parallel=parallel, jit=jit)\\n+            b = L.assemble(x, parallel=parallel, jit=jit).toarray()\\n+            b = L.assemble(parallel=parallel, jit=jit).toarray()\\n+\\n+            assert b.shape == (z, 1)\\n \\n     r, v, f, A = pre_axi_mixed()\\n \\n     for parallel in [False, True]:\\n \\n-        a = fe.IntegralFormMixed(A, v, r.dV, v)\\n-        y = a.integrate(parallel=parallel)\\n-        K = a.assemble(y, parallel=parallel).toarray()\\n-        K = a.assemble(parallel=parallel).toarray()\\n+        for jit in [False, True]:\\n+\\n+            a = fe.IntegralFormMixed(A, v, r.dV, v)\\n+            y = a.integrate(parallel=parallel, jit=jit)\\n+            K = a.assemble(y, parallel=parallel, jit=jit).toarray()\\n+            K = a.assemble(parallel=parallel, jit=jit).toarray()\\n \\n-        z = r.mesh.ndof + 2 * r.mesh.npoints\\n-        assert K.shape == (z, z)\\n+            z = r.mesh.ndof + 2 * r.mesh.npoints\\n+            assert K.shape == (z, z)\\n \\n-        L = fe.IntegralFormMixed(f, v, r.dV)\\n-        x = L.integrate(parallel=parallel)\\n-        b = L.assemble(x, parallel=parallel).toarray()\\n-        b = L.assemble(parallel=parallel).toarray()\\n+            L = fe.IntegralFormMixed(f, v, r.dV)\\n+            x = L.integrate(parallel=parallel, jit=jit)\\n+            b = L.assemble(x, parallel=parallel, jit=jit).toarray()\\n+            b = L.assemble(parallel=parallel, jit=jit).toarray()\\n \\n-        assert b.shape == (z, 1)\\n+            assert b.shape == (z, 1)\\n \\n \\n if __name__ == \\\"__main__\\\":\\n\",\"diff --git a/tests/test_mesh.py b/tests/test_mesh.py\\nindex b0ac0d59..97c51749 100644\\n--- a/tests/test_mesh.py\\n+++ b/tests/test_mesh.py\\n@@ -30,6 +30,34 @@\\n \\n \\n def test_meshes():\\n+    \\n+    m = fe.Mesh(\\n+        points=np.array(\\n+            [\\n+                [0, 0],\\n+                [1, 0],\\n+                [0, 1],\\n+            ]\\n+        ),\\n+        cells=np.array([[0, 1, 2]]),\\n+        cell_type=\\\"triangle\\\",\\n+    )\\n+    \\n+    fe.mesh.convert(m, order=0)\\n+    fe.mesh.convert(m, order=0, calc_points=True)\\n+    fe.mesh.convert(m, order=2)\\n+    fe.mesh.convert(m, order=2, calc_midfaces=True)\\n+    \\n+    m = fe.Mesh(\\n+        points=np.array([[0, 0, 0], [1, 0, 0], [0, 1, 0], [0, 0, 1]]),\\n+        cells=np.array([[0, 1, 2, 3]]),\\n+        cell_type=\\\"tetra\\\",\\n+    )\\n+    \\n+    fe.mesh.convert(m, order=0)\\n+    fe.mesh.convert(m, order=0, calc_points=True)\\n+    fe.mesh.convert(m, order=2)\\n+    fe.mesh.convert(m, order=2, calc_midfaces=True)\\n \\n     m = fe.mesh.Line(n=5)\\n     assert m.points.shape == (5, 1)\\n@@ -54,13 +82,16 @@ def test_meshes():\\n         fe.mesh.convert(m, order=1)\\n \\n     fe.mesh.revolve(m, n=11, phi=180, axis=0)\\n-    fe.mesh.revolve((m.points, m.cells), n=11, phi=180, axis=0)\\n-    fe.mesh.revolve((m.points, m.cells), n=11, phi=360, axis=0)\\n+    fe.mesh.revolve(m.points, m.cells, m.cell_type, n=11, phi=180, axis=0)\\n+    fe.mesh.revolve(m.points, m.cells, m.cell_type, n=11, phi=360, axis=0)\\n \\n     with pytest.raises(ValueError):\\n-        fe.mesh.revolve((m.points, m.cells), n=11, phi=361, axis=0)\\n+        fe.mesh.revolve(m.points, m.cells, m.cell_type, n=11, phi=361, axis=0)\\n \\n-    fe.mesh.expand((m.points, m.cells))\\n+    fe.mesh.expand(m.points, m.cells, m.cell_type)\\n+    fe.mesh.expand(m.points, m.cells, cell_type=m.cell_type)\\n+    fe.mesh.expand(m.points, cells=m.cells, cell_type=m.cell_type)\\n+    fe.mesh.expand(points=m.points, cells=m.cells, cell_type=m.cell_type)\\n     fe.mesh.expand(m)\\n \\n     m = fe.Cube(a=(-1, -2, -0.5), b=(2, 3.1, 1), n=(4, 9, 5))\\n@@ -69,16 +100,16 @@ def test_meshes():\\n \\n     fe.mesh.convert(m, order=2, calc_midfaces=True, calc_midvolumes=True)\\n \\n-    with pytest.raises(ValueError):\\n-        fe.mesh.expand((m.points, m.cells))\\n+    with pytest.raises(KeyError):\\n+        fe.mesh.expand(m.points, m.cells, m.cell_type)\\n \\n-    with pytest.raises(ValueError):\\n-        fe.mesh.revolve((m.points, m.cells))\\n+    with pytest.raises(KeyError):\\n+        fe.mesh.revolve(m.points, m.cells, m.cell_type)\\n \\n     fe.mesh.convert(m, order=2, calc_midfaces=True, calc_midvolumes=True)\\n \\n     fe.mesh.rotate(m, angle_deg=10, axis=0, center=None)\\n-    fe.mesh.rotate((m.points, m.cells), angle_deg=10, axis=0, center=None)\\n+    fe.mesh.rotate(m.points, m.cells, m.cell_type, angle_deg=10, axis=0, center=None)\\n     fe.mesh.rotate(m, angle_deg=10, axis=1, center=[0, 0, 0])\\n \\n     fe.mesh.CubeArbitraryOrderHexahedron()\\n@@ -94,7 +125,7 @@ def test_meshes():\\n     assert m_dg.npoints == m.cells.size\\n \\n     fe.mesh.sweep(m)\\n-    fe.mesh.sweep((m.points, m.cells), decimals=4)\\n+    fe.mesh.sweep(m.points, m.cells, m.cell_type, decimals=4)\\n \\n     m.save()\\n \\n@@ -103,5 +134,70 @@ def test_meshes():\\n         m.save()\\n \\n \\n+def test_mirror():\\n+\\n+    for kwargs in [\\n+        dict(axis=None, normal=[1, 0, 0]),\\n+        dict(axis=None, normal=[1, 1, 0]),\\n+        dict(axis=None, normal=[1, 1, 1]),\\n+        dict(axis=None, normal=[-1, 1, 0]),\\n+        dict(axis=None, normal=[1, -5, -3]),\\n+        dict(axis=0, normal=[]),\\n+        dict(axis=1, normal=[]),\\n+        dict(axis=2, normal=[]),\\n+    ]:\\n+\\n+        axis = kwargs[\\\"axis\\\"]\\n+\\n+        if axis is None or axis < 1:\\n+\\n+            m = fe.mesh.Line()\\n+            r = fe.Region(m, fe.Line(), fe.GaussLegendre(1, 1))\\n+            n = fe.mesh.mirror(m, **kwargs)\\n+            s = fe.Region(n, fe.Line(), fe.GaussLegendre(1, 1))\\n+            assert np.isclose(r.dV.sum(), s.dV.sum())\\n+\\n+        if axis is None or axis < 2:\\n+\\n+            m = fe.Rectangle()\\n+            r = fe.RegionQuad(m)\\n+            n = fe.mesh.mirror(m, **kwargs)\\n+            s = fe.RegionQuad(n)\\n+            assert np.isclose(r.dV.sum(), s.dV.sum())\\n+\\n+            m = fe.Mesh(\\n+                points=np.array(\\n+                    [\\n+                        [0, 0],\\n+                        [1, 0],\\n+                        [0, 1],\\n+                    ]\\n+                ),\\n+                cells=np.array([[0, 1, 2]]),\\n+                cell_type=\\\"triangle\\\",\\n+            )\\n+            r = fe.RegionTriangle(m)\\n+            n = fe.mesh.mirror(m, **kwargs)\\n+            s = fe.RegionTriangle(n)\\n+            assert np.isclose(r.dV.sum(), s.dV.sum())\\n+\\n+        m = fe.Cube()\\n+        r = fe.RegionHexahedron(m)\\n+        n = fe.mesh.mirror(m, **kwargs)\\n+        s = fe.RegionHexahedron(n)\\n+        assert np.isclose(r.dV.sum(), s.dV.sum())\\n+\\n+        m = fe.Mesh(\\n+            points=np.array([[0, 0, 0], [1, 0, 0], [0, 1, 0], [0, 0, 1]]),\\n+            cells=np.array([[0, 1, 2, 3]]),\\n+            cell_type=\\\"tetra\\\",\\n+        )\\n+        r = fe.RegionTetra(m)\\n+        n = fe.mesh.mirror(m, **kwargs)\\n+        s = fe.RegionTetra(n)\\n+        assert np.isclose(r.dV.sum(), s.dV.sum())\\n+\\n+\\n if __name__ == \\\"__main__\\\":\\n     test_meshes()\\n+    test_mirror()\"]", "hints_text": ""}

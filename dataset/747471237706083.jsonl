{"instance_id": "747471237706083", "repo": "dedupeio/dedupe", "base_commit": "fc09b63417db3d4e0100932b5b9ee6790532f033", "problem_statement": "transition to plugins for dedupe variables.:\\nnewer versions of pip/setuptools are now confused by the [old-style namespace packages](https://github.com/pypa/setuptools/issues/3537#issuecomment-1218204087).\\r\\n\\r\\ni previously tried to migrate to the implicit style namespace packages, but the problem with that i don't think there's a way to do that this not backwards incompatible. \\r\\n\\r\\nspecifically, i don't see how you could use the implicit style namespaces and have something like `from dedupe import Dedupe` work. \\r\\n\\r\\nyou could do `from dedupe.api import Dedupe` but that's not what we have guaranteed.\\r\\n\\r\\nso, then maybe we have to move to the [src-layout](https://setuptools.pypa.io/en/latest/userguide/package_discovery.html#src-layout)", "FAIL_TO_PASS": ["tests/test_dedupe.py::DataModelTest::test_data_model", "tests/test_serializer.py::SerializerTest::test_writeTraining", "tests/test_training.py::TrainingTest::test_uncovered_by", "tests/test_training.py::TrainingTest::test_covered_pairs", "tests/test_core.py::ScoreDuplicates::test_score_duplicates_with_zeros", "tests/test_core.py::FieldDistances::test_comparator_interaction", "tests/test_api.py::ActiveMatch::test_markPair", "tests/test_core.py::ScoreDuplicates::test_score_duplicates", "tests/test_api.py::ActiveMatch::test_check_record", "tests/test_api.py::ActiveMatch::test_initialize_fields", "tests/test_training.py::TrainingTest::test_dedupe_coverage", "tests/test_core.py::FieldDistances::test_exact_comparator", "tests/test_labeler.py::ActiveLearningTest::test_AL", "tests/test_core.py::FieldDistances::test_comparator"], "PASS_TO_PASS": ["tests/test_predicates.py::TestAlpaNumeric::test_alphanumeric", "tests/test_predicate_functions.py::TestPredicateFunctions::test_two_tokens_predicate", "tests/test_canonical.py::CanonicalizationTest::test_get_canonical_rep", "tests/test_tfidf.py::ParsingTest::test_wildcards", "tests/test_predicate_functions.py::TestPredicateFunctions::test_two_gram_fingerprint", "tests/test_blocking.py::TfidfTest::test_unconstrained_inverted_index", "tests/test_tfidf.py::ParsingTest::test_empty_search", "tests/test_core.py::Unique::test_unique", "tests/test_predicate_functions.py::TestPredicateFunctions::test_sorted_acronym", "tests/test_predicate_functions.py::TestPredicateFunctions::test_one_gram_fingerprint", "tests/test_predicates.py::TestSetElement::test_first_last", "tests/test_predicate_functions.py::TestPredicateFunctions::test_whole_set_predicate", "tests/test_blocking.py::TfIndexUnindex::test_unindex", "tests/test_dedupe.py::ConnectedComponentsTest::test_components", "tests/test_predicates.py::TestWholeSet::test_full_set", "tests/test_predicate_functions.py::TestPredicateFunctions::test_suffix_array", "tests/test_blocking.py::TfIndexUnindex::test_index", "tests/test_predicate_functions.py::TestPredicateFunctions::test_common_integer_predicate", "tests/test_predicate_functions.py::TestPredicateFunctions::test_common_two_tokens", "tests/test_predicate_functions.py::TestPredicateFunctions::test_lat_long_grid_predicate", "tests/test_price.py::TestPrice::test_comparator", "tests/test_cpredicates.py::TestCPredicates::test_unique_ngrams", "tests/test_predicate_functions.py::TestPredicateFunctions::test_double_metaphone", "tests/test_predicates.py::TestSetElement::test_empty_set", "tests/test_predicates.py::TestCompoundPredicate::test_escapes_escaped_colon", "tests/test_tfidf.py::ParsingTest::test_keywords_title", "tests/test_predicate_functions.py::TestPredicateFunctions::test_magnitude_of_cardinality", "tests/test_predicate_functions.py::TestPredicateFunctions::test_first_token_predicate", "tests/test_predicates.py::TestCompoundPredicate::test_escapes_colon", "tests/test_predicate_functions.py::TestPredicateFunctions::test_same_three_char_start_predicate", "tests/test_predicate_functions.py::TestPredicateFunctions::test_token_field_predicate", "tests/test_predicates.py::TestNumericPredicates::test_round_to_1", "tests/test_cpredicates.py::TestCPredicates::test_ngrams", "tests/test_predicates.py::TestPuncStrip::test_set", "tests/test_predicates.py::TestLatLongGrid::test_precise_latlong", "tests/test_predicate_functions.py::TestPredicateFunctions::test_common_four_gram", "tests/test_predicate_functions.py::TestPredicateFunctions::test_hundred_integers_predicate", "tests/test_predicate_functions.py::TestPredicateFunctions::test_near_integers_predicate", "tests/test_predicate_functions.py::TestPredicateFunctions::test_same_five_char_start_predicate", "tests/test_predicate_functions.py::TestPredicateFunctions::test_whole_field_predicate", "tests/test_predicate_functions.py::TestPredicateFunctions::test_hundred_integers_odd_predicate", "tests/test_dedupe.py::ClusteringTest::test_gazette_matching", "tests/test_predicates.py::TestSetElement::test_long_set", "tests/test_blocking.py::TfIndexUnindex::test_doubled_index", "tests/test_predicate_functions.py::TestPredicateFunctions::test_metaphone_token", "tests/test_predicates.py::TestNumericPredicates::test_order_of_magnitude", "tests/test_cpredicates.py::TestCPredicates::test_initials", "tests/test_predicate_functions.py::TestPredicateFunctions::test_predicates_correctness", "tests/test_canonical.py::CanonicalizationTest::test_get_centroid", "tests/test_predicate_functions.py::TestPredicateFunctions::test_fingerprint", "tests/test_predicate_functions.py::TestPredicateFunctions::test_first_integer_predicate", "tests/test_dedupe.py::ClusteringTest::test_hierarchical", "tests/test_predicate_functions.py::TestPredicateFunctions::test_same_seven_char_start_predicate", "tests/test_tfidf.py::ParsingTest::test_keywords", "tests/test_predicates.py::TestMetaphone::test_metaphone_token", "tests/test_predicate_functions.py::TestPredicateFunctions::test_alpha_numeric_predicate", "tests/test_predicates.py::TestSetElement::test_magnitude", "tests/test_predicate_functions.py::TestPredicateFunctions::test_common_three_tokens", "tests/test_predicates.py::TestPuncStrip::test_sevenchar", "tests/test_predicate_functions.py::TestPredicateFunctions::test_common_six_gram", "tests/test_dedupe.py::ClusteringTest::test_greedy_matching"], "language": "python", "test_command": "source /saved/ENV || source /saved/*/ENV && pytest --no-header -rA --tb=no -p no:cacheprovider --continue-on-collection-errors", "test_output_parser": "python/parse_log_pytest_v3", "image_storage_uri": "vmvm-registry.fbinfra.net/repomate_image_activ_pytest/dedupeio_dedupe:fc09b63417db3d4e0100932b5b9ee6790532f033", "patch": "[\"diff --git a/.flake8 b/.flake8\\nindex 0e85dce..7350ce3 100644\\n--- a/.flake8\\n+++ b/.flake8\\n@@ -1,3 +1,3 @@\\n [flake8]\\n max-line-length=160\\n-extend-ignore = E203\\n+extend-ignore = E203\\n\\\\ No newline at end of file\\n\",\"diff --git a/.pre-commit-config.yaml b/.pre-commit-config.yaml\\nindex 3202057..4896e74 100644\\n--- a/.pre-commit-config.yaml\\n+++ b/.pre-commit-config.yaml\\n@@ -8,3 +8,8 @@ repos:\\n     hooks:\\n       - id: isort\\n         name: isort (python)\\n+  - repo: https://github.com/pycqa/flake8\\n+    rev: \\\"7.1.0\\\"\\n+    hooks:\\n+      - id: flake8\\n+        args: [--config=.flake8]\\n\",\"diff --git a/CHANGELOG.md b/CHANGELOG.md\\nindex ef3a19b..8a9ee9c 100644\\n--- a/CHANGELOG.md\\n+++ b/CHANGELOG.md\\n@@ -1,3 +1,8 @@\\n+# 3.0.0\\n+- Development in python packaging made supporting the previous namespace approach for\\n+  variable plugins untenable. Since we had to redo the way we defined the data model, \\n+  we took the opportunity to explicity instantiate variable objects. \\n+\\n # 2.0.6\\n - fixed bug that was preventing learning of index predicates in Dedupe mode\\n \\n\",\"diff --git a/benchmarks/benchmarks/canonical.py b/benchmarks/benchmarks/canonical.py\\nindex da075b9..6f23bb0 100644\\n--- a/benchmarks/benchmarks/canonical.py\\n+++ b/benchmarks/benchmarks/canonical.py\\n@@ -32,17 +32,19 @@ class Canonical:\\n         return make_report(self.data, clustering)\\n \\n     def run(self, use_settings=False):\\n+        deduper: dedupe.StaticDedupe | dedupe.Dedupe\\n+\\n         if use_settings and os.path.exists(self.settings_file):\\n             with open(self.settings_file, \\\"rb\\\") as f:\\n                 deduper = dedupe.StaticDedupe(f)\\n \\n         else:\\n             variables = [\\n-                {\\\"field\\\": \\\"name\\\", \\\"type\\\": \\\"String\\\"},\\n-                {\\\"field\\\": \\\"name\\\", \\\"type\\\": \\\"Exact\\\"},\\n-                {\\\"field\\\": \\\"address\\\", \\\"type\\\": \\\"String\\\"},\\n-                {\\\"field\\\": \\\"cuisine\\\", \\\"type\\\": \\\"ShortString\\\", \\\"has missing\\\": True},\\n-                {\\\"field\\\": \\\"city\\\", \\\"type\\\": \\\"ShortString\\\"},\\n+                dedupe.variables.String(\\\"name\\\"),\\n+                dedupe.variables.Exact(\\\"name\\\"),\\n+                dedupe.variables.String(\\\"address\\\"),\\n+                dedupe.variables.ShortString(\\\"cuisine\\\", has_missing=True),\\n+                dedupe.variables.ShortString(\\\"city\\\"),\\n             ]\\n \\n             deduper = dedupe.Dedupe(variables, num_cores=5)\\n\",\"diff --git a/benchmarks/benchmarks/canonical_gazetteer.py b/benchmarks/benchmarks/canonical_gazetteer.py\\nindex bdbc51b..1f73b8e 100644\\n--- a/benchmarks/benchmarks/canonical_gazetteer.py\\n+++ b/benchmarks/benchmarks/canonical_gazetteer.py\\n@@ -25,16 +25,17 @@ class Gazetteer(canonical_matching.Matching):\\n \\n     def run(self, kwargs, use_settings=False):\\n         data_1, data_2 = self.data\\n+        gazetteer: dedupe.StaticGazetteer | dedupe.Gazetteer\\n \\n         if use_settings and os.path.exists(self.settings_file):\\n             with open(self.settings_file, \\\"rb\\\") as f:\\n                 gazetteer = dedupe.StaticGazetteer(f)\\n         else:\\n             variables = [\\n-                {\\\"field\\\": \\\"name\\\", \\\"type\\\": \\\"String\\\"},\\n-                {\\\"field\\\": \\\"address\\\", \\\"type\\\": \\\"String\\\"},\\n-                {\\\"field\\\": \\\"cuisine\\\", \\\"type\\\": \\\"String\\\"},\\n-                {\\\"field\\\": \\\"city\\\", \\\"type\\\": \\\"String\\\"},\\n+                dedupe.variables.String(\\\"name\\\"),\\n+                dedupe.variables.String(\\\"address\\\"),\\n+                dedupe.variables.String(\\\"cuisine\\\"),\\n+                dedupe.variables.String(\\\"city\\\"),\\n             ]\\n \\n             gazetteer = dedupe.Gazetteer(variables)\\n\",\"diff --git a/benchmarks/benchmarks/canonical_matching.py b/benchmarks/benchmarks/canonical_matching.py\\nindex 471cd49..b1c3c82 100644\\n--- a/benchmarks/benchmarks/canonical_matching.py\\n+++ b/benchmarks/benchmarks/canonical_matching.py\\n@@ -42,16 +42,17 @@ class Matching:\\n \\n     def run(self, kwargs, use_settings=False):\\n         data_1, data_2 = self.data\\n+        deduper: dedupe.StaticRecordLink | dedupe.RecordLink\\n \\n         if use_settings and os.path.exists(self.settings_file):\\n             with open(self.settings_file, \\\"rb\\\") as f:\\n                 deduper = dedupe.StaticRecordLink(f)\\n         else:\\n             variables = [\\n-                {\\\"field\\\": \\\"name\\\", \\\"type\\\": \\\"String\\\"},\\n-                {\\\"field\\\": \\\"address\\\", \\\"type\\\": \\\"String\\\"},\\n-                {\\\"field\\\": \\\"cuisine\\\", \\\"type\\\": \\\"String\\\"},\\n-                {\\\"field\\\": \\\"city\\\", \\\"type\\\": \\\"String\\\"},\\n+                dedupe.variables.String(\\\"name\\\"),\\n+                dedupe.variables.String(\\\"address\\\"),\\n+                dedupe.variables.String(\\\"cuisine\\\"),\\n+                dedupe.variables.String(\\\"city\\\"),\\n             ]\\n             deduper = dedupe.RecordLink(variables)\\n             deduper.prepare_training(\\n\",\"diff --git a/benchmarks/benchmarks/common.py b/benchmarks/benchmarks/common.py\\nindex afe9932..17e129f 100644\\n--- a/benchmarks/benchmarks/common.py\\n+++ b/benchmarks/benchmarks/common.py\\n@@ -54,9 +54,9 @@ def get_true_dupes(data: dict) -> set:\\n         sorted(data.items(), key=lambda x: x[1][\\\"unique_id\\\"]),\\n         key=lambda x: x[1][\\\"unique_id\\\"],\\n     ):\\n-        pair = list(pair)\\n-        if len(pair) == 2:\\n-            a, b = pair\\n+        pair_l = list(pair)\\n+        if len(pair_l) == 2:\\n+            a, b = pair_l\\n             duplicates.add(frozenset((a[0], b[0])))\\n     return duplicates\\n \\n\",\"diff --git a/dedupe/__init__.py b/dedupe/__init__.py\\nindex 726836a..7ef7d4c 100644\\n--- a/dedupe/__init__.py\\n+++ b/dedupe/__init__.py\\n@@ -13,3 +13,18 @@ from dedupe.convenience import (  # noqa: F401\\n     training_data_link,\\n )\\n from dedupe.serializer import read_training, write_training  # noqa: F401\\n+\\n+__all__ = [\\n+    \\\"Dedupe\\\",\\n+    \\\"Gazetteer\\\",\\n+    \\\"RecordLink\\\",\\n+    \\\"StaticDedupe\\\",\\n+    \\\"StaticGazetteer\\\",\\n+    \\\"StaticRecordLink\\\",\\n+    \\\"canonicalize\\\",\\n+    \\\"console_label\\\",\\n+    \\\"training_data_dedupe\\\",\\n+    \\\"training_data_link\\\",\\n+    \\\"read_training\\\",\\n+    \\\"write_training\\\",\\n+]\\n\",\"diff --git a/dedupe/_typing.py b/dedupe/_typing.py\\nindex 65922f7..9de9eb5 100644\\n--- a/dedupe/_typing.py\\n+++ b/dedupe/_typing.py\\n@@ -4,17 +4,18 @@ from typing import (\\n     TYPE_CHECKING,\\n     Any,\\n     Callable,\\n-    Collection,\\n     Dict,\\n     FrozenSet,\\n     Iterable,\\n     Iterator,\\n     List,\\n     Mapping,\\n+    MutableSequence,\\n     Sequence,\\n     Tuple,\\n     Type,\\n     Union,\\n+    runtime_checkable,\\n )\\n \\n import numpy\\n@@ -72,6 +73,7 @@ LookupResultsStr = Iterable[Tuple[str, Tuple[Tuple[str, float], ...]]]\\n LookupResults = Union[LookupResultsInt, LookupResultsStr]\\n JoinConstraint = Literal[\\\"one-to-one\\\", \\\"many-to-one\\\", \\\"many-to-many\\\"]\\n Comparator = Callable[[Any, Any], Union[Union[int, float], Sequence[Union[int, float]]]]\\n+CustomComparator = Callable[[Any, Any], Union[int, float]]\\n Scores = Union[numpy.memmap, numpy.ndarray]\\n Labels = List[Literal[0, 1]]\\n LabelsLike = Iterable[Literal[0, 1]]\\n@@ -81,28 +83,10 @@ ComparisonCoverStr = Dict[\\\"Predicate\\\", FrozenSet[Tuple[str, str]]]\\n ComparisonCover = Union[ComparisonCoverInt, ComparisonCoverStr]\\n PredicateFunction = Callable[[Any], FrozenSet[str]]\\n \\n-VariableDefinition = TypedDict(\\n-    \\\"VariableDefinition\\\",\\n-    {\\n-        \\\"type\\\": str,\\n-        \\\"field\\\": str,\\n-        \\\"variable name\\\": str,\\n-        \\\"corpus\\\": Iterable[Union[str, Collection[str]]],\\n-        \\\"comparator\\\": Callable[\\n-            [Any, Any], Union[int, float]\\n-        ],  # a custom comparator can only return a single float or int, not a sequence of numbers\\n-        \\\"categories\\\": List[str],\\n-        \\\"interaction variables\\\": List[str],\\n-        \\\"has missing\\\": bool,\\n-        \\\"name\\\": str,\\n-    },\\n-    total=False,\\n-)\\n-\\n \\n class TrainingData(TypedDict):\\n-    match: List[RecordDictPair]\\n-    distinct: List[RecordDictPair]\\n+    match: MutableSequence[RecordDictPair]\\n+    distinct: MutableSequence[RecordDictPair]\\n \\n \\n # Takes pairs of records and generates a (n_samples X n_features) array\\n@@ -127,6 +111,24 @@ class ClosableJoinable(Protocol):\\n     def join(self) -> None: ...\\n \\n \\n+class Variable(Protocol):\\n+    name: str\\n+    predicates: List[\\\"Predicate\\\"]\\n+    has_missing: bool\\n+\\n+    def __len__(self) -> int: ...\\n+\\n+\\n+@runtime_checkable\\n+class FieldVariable(Variable, Protocol):\\n+    field: str\\n+    comparator: Comparator\\n+\\n+\\n+class InteractionVariable(Variable, Protocol):\\n+    interaction_fields: List[str]\\n+\\n+\\n MapLike = Callable[[Callable[[Any], Any], Iterable], Iterable]\\n \\n PathLike = Union[str, os.PathLike]\\n\",\"diff --git a/dedupe/api.py b/dedupe/api.py\\nindex 1e2e1f4..9d17bc0 100644\\n--- a/dedupe/api.py\\n+++ b/dedupe/api.py\\n@@ -14,7 +14,7 @@ import pickle\\n import sqlite3\\n import tempfile\\n import warnings\\n-from typing import TYPE_CHECKING, cast, overload\\n+from typing import TYPE_CHECKING, Literal, cast, overload\\n \\n import numpy\\n import sklearn.linear_model\\n@@ -27,7 +27,6 @@ import dedupe.datamodel as datamodel\\n import dedupe.labeler as labeler\\n import dedupe.predicates\\n import dedupe.serializer as serializer\\n-from dedupe._typing import Literal\\n \\n if TYPE_CHECKING:\\n     from typing import (\\n@@ -70,7 +69,7 @@ if TYPE_CHECKING:\\n         Scores,\\n         TrainingData,\\n         TupleLinks,\\n-        VariableDefinition,\\n+        Variable,\\n     )\\n \\n logger = logging.getLogger(__name__)\\n@@ -1117,7 +1116,7 @@ class ActiveMatching(Matching):\\n \\n     def __init__(\\n         self,\\n-        variable_definition: Collection[VariableDefinition],\\n+        variable_definition: Collection[Variable],\\n         num_cores: int | None = None,\\n         in_memory: bool = False,\\n         **kwargs,\\n\",\"diff --git a/dedupe/convenience.py b/dedupe/convenience.py\\nindex fb24de2..26b886a 100644\\n--- a/dedupe/convenience.py\\n+++ b/dedupe/convenience.py\\n@@ -7,7 +7,7 @@ import itertools\\n import random\\n import sys\\n import warnings\\n-from typing import Iterator, Tuple, overload\\n+from typing import Iterator, Literal, Tuple, overload\\n \\n import numpy\\n \\n@@ -15,7 +15,6 @@ import dedupe\\n from dedupe._typing import (\\n     DataInt,\\n     DataStr,\\n-    Literal,\\n     RecordDict,\\n     RecordDictPair,\\n     RecordID,\\n@@ -135,7 +134,7 @@ def console_label(deduper: dedupe.api.ActiveMatching) -> None:  # pragma: no cov\\n \\n     finished = False\\n     use_previous = False\\n-    fields = unique(var.field for var in deduper.data_model.primary_variables)\\n+    fields = unique(var.field for var in deduper.data_model.field_variables)\\n \\n     buffer_len = 1  # Max number of previous operations\\n     unlabeled: list[RecordDictPair] = []\\n\",\"diff --git a/dedupe/core.py b/dedupe/core.py\\nindex a9ffd55..975c084 100644\\n--- a/dedupe/core.py\\n+++ b/dedupe/core.py\\n@@ -22,6 +22,7 @@ if TYPE_CHECKING:\\n         Generator,\\n         Iterable,\\n         Iterator,\\n+        Literal,\\n         Optional,\\n         Sequence,\\n         Type,\\n@@ -35,7 +36,6 @@ if TYPE_CHECKING:\\n         ClosableJoinable,\\n         Data,\\n         FeaturizerFunction,\\n-        Literal,\\n         MapLike,\\n         RecordID,\\n         RecordIDDType,\\n\",\"diff --git a/dedupe/datamodel.py b/dedupe/datamodel.py\\nindex 49956bc..1b84b8a 100644\\n--- a/dedupe/datamodel.py\\n+++ b/dedupe/datamodel.py\\n@@ -1,54 +1,80 @@\\n from __future__ import annotations\\n \\n import copyreg\\n-import pkgutil\\n import types\\n+from collections.abc import Mapping\\n from typing import TYPE_CHECKING, cast\\n \\n import numpy\\n \\n-import dedupe.variables\\n-from dedupe.variables.base import FieldType as FieldVariable\\n-from dedupe.variables.base import MissingDataType, Variable\\n+from dedupe._typing import FieldVariable\\n from dedupe.variables.interaction import InteractionType\\n \\n-for _, module, _ in pkgutil.iter_modules(  # type: ignore\\n-    dedupe.variables.__path__, \\\"dedupe.variables.\\\"\\n-):\\n-    __import__(module)\\n-\\n if TYPE_CHECKING:\\n-    from typing import Generator, Iterable, Sequence\\n+    from typing import Collection, Generator, Iterable, Sequence\\n \\n     from dedupe._typing import (\\n         Comparator,\\n+        InteractionVariable,\\n         RecordDict,\\n         RecordDictPair,\\n-        VariableDefinition,\\n+        Variable,\\n     )\\n     from dedupe.predicates import Predicate\\n \\n-VARIABLE_CLASSES = {k: v for k, v in FieldVariable.all_subclasses() if k}\\n \\n+class DataModel:\\n+    version = 2\\n \\n-class DataModel(object):\\n-    version = 1\\n+    def __init__(self, variable_definitions: Collection[Variable]):\\n+        for item in variable_definitions:\\n+            if isinstance(item, Mapping):\\n+                raise ValueError(\\n+                    \\\"It looks like you are trying to use a variable definition \\\"\\n+                    \\\"composed of dictionaries. dedupe 3.0 uses variable objects \\\"\\n+                    'directly. So instead of [{\\\"field\\\": \\\"name\\\", \\\"type\\\": \\\"String\\\"}] '\\n+                    'we now do [dedupe.variables.String(\\\"name\\\")].'\\n+                )\\n \\n-    def __init__(self, variable_definitions: Iterable[VariableDefinition]):\\n         variable_definitions = list(variable_definitions)\\n         if not variable_definitions:\\n             raise ValueError(\\\"The variable definitions cannot be empty\\\")\\n-        all_variables: list[Variable]\\n-        self.primary_variables, all_variables = typify_variables(variable_definitions)\\n-        self._derived_start = len(all_variables)\\n+        if not any(variable.predicates for variable in variable_definitions):\\n+            raise ValueError(\\n+                \\\"At least one of the variable types needs to be a type\\\"\\n+                \\\"other than 'Custom'. 'Custom' types have no associated\\\"\\n+                \\\"blocking rules\\\"\\n+            )\\n+\\n+        # This is a protocol check, not a class inheritance check\\n+        self.field_variables: list[FieldVariable] = [\\n+            variable\\n+            for variable in variable_definitions\\n+            if isinstance(variable, FieldVariable)\\n+        ]\\n+\\n+        # we need to keep track of ordering of variables because in\\n+        # order to calculate derived fields like interaction and missing\\n+        # data fields.\\n+        columns: list[Variable] = []\\n+        for variable in self.field_variables:\\n+            if len(variable) == 1:\\n+                columns.append(variable)\\n+            elif len(variable) > 1:\\n+                assert hasattr(variable, \\\"higher_vars\\\")\\n+                columns.extend(variable.higher_vars)\\n \\n-        all_variables += interactions(variable_definitions, self.primary_variables)\\n-        all_variables += missing(all_variables)\\n+        self._derived_start = len(columns)\\n \\n-        self._missing_field_indices = missing_field_indices(all_variables)\\n-        self._interaction_indices = interaction_indices(all_variables)\\n+        # i'm not really satisfied with how we are dealing with interactions\\n+        # here. seems like there should be a cleaner path, but i don't see it\\n+        # today\\n+        columns += interactions(variable_definitions, self.field_variables)\\n \\n-        self._len = len(all_variables)\\n+        self._missing_field_indices = missing_field_indices(columns)\\n+        self._interaction_indices = interaction_indices(columns)\\n+\\n+        self._len = len(columns) + len(self._missing_field_indices)\\n \\n     def __len__(self) -> int:\\n         return self._len\\n@@ -63,7 +89,7 @@ class DataModel(object):\\n     ) -> Generator[tuple[str, Comparator, int, int], None, None]:\\n         start = 0\\n         stop = 0\\n-        for var in self.primary_variables:\\n+        for var in self.field_variables:\\n             stop = start + len(var)\\n             comparator = cast(\\\"Comparator\\\", var.comparator)\\n             yield (var.field, comparator, start, stop)\\n@@ -72,7 +98,7 @@ class DataModel(object):\\n     @property\\n     def predicates(self) -> set[Predicate]:\\n         predicates = set()\\n-        for var in self.primary_variables:\\n+        for var in self.field_variables:\\n             for predicate in var.predicates:\\n                 predicates.add(predicate)\\n         return predicates\\n@@ -132,100 +158,26 @@ class DataModel(object):\\n         return d\\n \\n     def __setstate__(self, d):\\n-        version = d.pop(\\\"version\\\", None)\\n+        version = d.pop(\\\"object_version\\\", None)\\n         if version is None and \\\"_variables\\\" in d:\\n             d[\\\"_len\\\"] = len(d.pop(\\\"_variables\\\"))\\n             d[\\\"primary_variables\\\"] = d.pop(\\\"primary_fields\\\")\\n+        elif version == 1:\\n+            d[\\\"field_variables\\\"] = d.pop(\\\"primary_variables\\\")\\n \\n         self.__dict__ = d\\n \\n \\n-def typify_variables(\\n-    variable_definitions: Iterable[VariableDefinition],\\n-) -> tuple[list[FieldVariable], list[Variable]]:\\n-    primary_variables: list[FieldVariable] = []\\n-    all_variables: list[Variable] = []\\n-    only_custom = True\\n-\\n-    for definition in variable_definitions:\\n-        try:\\n-            variable_type = definition[\\\"type\\\"]\\n-        except TypeError:\\n-            raise TypeError(\\n-                \\\"Incorrect variable specification: variable \\\"\\n-                \\\"specifications are dictionaries that must \\\"\\n-                \\\"include a type definition, ex. \\\"\\n-                \\\"{'field' : 'Phone', type: 'String'}\\\"\\n-            )\\n-        except KeyError:\\n-            raise KeyError(\\n-                \\\"Missing variable type: variable \\\"\\n-                \\\"specifications are dictionaries that must \\\"\\n-                \\\"include a type definition, ex. \\\"\\n-                \\\"{'field' : 'Phone', type: 'String'}\\\"\\n-            )\\n-\\n-        if variable_type != \\\"Custom\\\":\\n-            only_custom = False\\n-\\n-        if variable_type == \\\"Interaction\\\":\\n-            continue\\n-\\n-        if variable_type == \\\"FuzzyCategorical\\\" and \\\"other fields\\\" not in definition:\\n-            definition[\\\"other fields\\\"] = [  # type: ignore\\n-                d[\\\"field\\\"]\\n-                for d in variable_definitions\\n-                if (\\\"field\\\" in d and d[\\\"field\\\"] != definition[\\\"field\\\"])\\n-            ]\\n-\\n-        try:\\n-            variable_class = VARIABLE_CLASSES[variable_type]\\n-        except KeyError:\\n-            raise KeyError(\\n-                \\\"Field type %s not valid. Valid types include %s\\\"\\n-                % (definition[\\\"type\\\"], \\\", \\\".join(VARIABLE_CLASSES))\\n-            )\\n-\\n-        variable_object = variable_class(definition)\\n-        assert isinstance(variable_object, FieldVariable)\\n-\\n-        primary_variables.append(variable_object)\\n-\\n-        if hasattr(variable_object, \\\"higher_vars\\\"):\\n-            all_variables.extend(variable_object.higher_vars)\\n-        else:\\n-            variable_object = cast(Variable, variable_object)\\n-            all_variables.append(variable_object)\\n-\\n-    if only_custom:\\n-        raise ValueError(\\n-            \\\"At least one of the variable types needs to be a type\\\"\\n-            \\\"other than 'Custom'. 'Custom' types have no associated\\\"\\n-            \\\"blocking rules\\\"\\n-        )\\n-\\n-    return primary_variables, all_variables\\n-\\n-\\n-def missing(variables: list[Variable]) -> list[MissingDataType]:\\n-    missing_variables = []\\n-    for var in variables:\\n-        if var.has_missing:\\n-            missing_variables.append(MissingDataType(var.name))\\n-    return missing_variables\\n-\\n-\\n def interactions(\\n-    definitions: Iterable[VariableDefinition], primary_variables: list[FieldVariable]\\n-) -> list[InteractionType]:\\n+    variables: Iterable[Variable], primary_variables: Iterable[FieldVariable]\\n+) -> list[InteractionVariable]:\\n     field_d = {field.name: field for field in primary_variables}\\n \\n-    interactions = []\\n-    for definition in definitions:\\n-        if definition[\\\"type\\\"] == \\\"Interaction\\\":\\n-            var = InteractionType(definition)\\n-            var.expandInteractions(field_d)\\n-            interactions.extend(var.higher_vars)\\n+    interactions: list[InteractionVariable] = []\\n+    for variable in variables:\\n+        if isinstance(variable, InteractionType):\\n+            variable.expandInteractions(field_d)\\n+            interactions.extend(variable.higher_vars)\\n     return interactions\\n \\n \\n\",\"diff --git a/dedupe/predicates.py b/dedupe/predicates.py\\nindex 2d180ee..1e07c67 100644\\n--- a/dedupe/predicates.py\\n+++ b/dedupe/predicates.py\\n@@ -17,9 +17,9 @@ from dedupe.cpredicates import ngrams\\n from dedupe.predicate_functions import *  # noqa: F401, F403\\n \\n if TYPE_CHECKING:\\n-    from typing import AbstractSet, Any, FrozenSet, Iterable, Mapping, Sequence\\n+    from typing import AbstractSet, Any, FrozenSet, Iterable, Literal, Mapping, Sequence\\n \\n-    from dedupe._typing import Literal, PredicateFunction, RecordDict\\n+    from dedupe._typing import PredicateFunction, RecordDict\\n     from dedupe.index import Index\\n \\n \\n\",\"diff --git a/dedupe/training.py b/dedupe/training.py\\nindex eb6fe0a..98c9f28 100644\\n--- a/dedupe/training.py\\n+++ b/dedupe/training.py\\n@@ -13,7 +13,7 @@ from warnings import warn\\n from . import blocking, branch_and_bound\\n \\n if TYPE_CHECKING:\\n-    from typing import Iterable, Sequence\\n+    from typing import Iterable, Literal, Sequence\\n \\n     from ._typing import (\\n         ComparisonCover,\\n@@ -23,7 +23,6 @@ if TYPE_CHECKING:\\n         Data,\\n         DataInt,\\n         DataStr,\\n-        Literal,\\n     )\\n     from ._typing import RecordDictPairs as TrainingExamples\\n     from ._typing import RecordID, RecordIDPair\\n\",\"diff --git a/dedupe/variables/__init__.py b/dedupe/variables/__init__.py\\nindex b36383a..39c339c 100644\\n--- a/dedupe/variables/__init__.py\\n+++ b/dedupe/variables/__init__.py\\n@@ -1,3 +1,25 @@\\n-from pkgutil import extend_path\\n+from .base import CustomType as Custom\\n+from .categorical_type import CategoricalType as Categorical\\n+from .exact import ExactType as Exact\\n+from .exists import ExistsType as Exists\\n+from .interaction import InteractionType as Interaction\\n+from .latlong import LatLongType as LatLong\\n+from .price import PriceType as Price\\n+from .set import SetType as Set\\n+from .string import ShortStringType as ShortString\\n+from .string import StringType as String\\n+from .string import TextType as Text\\n \\n-__path__ = extend_path(__path__, __name__)\\n+__all__ = [\\n+    \\\"Custom\\\",\\n+    \\\"Categorical\\\",\\n+    \\\"Exact\\\",\\n+    \\\"Exists\\\",\\n+    \\\"Interaction\\\",\\n+    \\\"LatLong\\\",\\n+    \\\"Price\\\",\\n+    \\\"Set\\\",\\n+    \\\"ShortString\\\",\\n+    \\\"String\\\",\\n+    \\\"Text\\\",\\n+]\\n\",\"diff --git a/dedupe/variables/base.py b/dedupe/variables/base.py\\nindex 109d333..71d6e72 100644\\n--- a/dedupe/variables/base.py\\n+++ b/dedupe/variables/base.py\\n@@ -1,20 +1,21 @@\\n from __future__ import annotations\\n \\n-from typing import TYPE_CHECKING\\n+from typing import TYPE_CHECKING, Optional\\n \\n from dedupe import predicates\\n \\n if TYPE_CHECKING:\\n-    from typing import Any, ClassVar, Generator, Iterable, Optional, Sequence, Type\\n+    from typing import Any, ClassVar, Iterable, Sequence, Type\\n \\n-    from dedupe._typing import Comparator, PredicateFunction, VariableDefinition\\n+    from dedupe._typing import Comparator, CustomComparator, PredicateFunction\\n+    from dedupe._typing import Variable as VariableProtocol\\n \\n \\n class Variable(object):\\n     name: str\\n     type: ClassVar[str]\\n     predicates: list[predicates.Predicate]\\n-    higher_vars: Sequence[\\\"Variable\\\"]\\n+    higher_vars: Sequence[\\\"VariableProtocol\\\"]\\n \\n     def __len__(self) -> int:\\n         return 1\\n@@ -29,16 +30,8 @@ class Variable(object):\\n         other_name: str = other.name\\n         return self.name == other_name\\n \\n-    def __init__(self, definition: VariableDefinition):\\n-        if definition.get(\\\"has missing\\\", False):\\n-            self.has_missing = True\\n-            try:\\n-                exists_pred = predicates.ExistsPredicate(definition[\\\"field\\\"])\\n-                self.predicates.append(exists_pred)\\n-            except KeyError:\\n-                pass\\n-        else:\\n-            self.has_missing = False\\n+    def __init__(self, has_missing: bool = False):\\n+        self.has_missing = has_missing\\n \\n     def __getstate__(self) -> dict[str, Any]:\\n         odict = self.__dict__.copy()\\n@@ -46,31 +39,13 @@ class Variable(object):\\n \\n         return odict\\n \\n-    @classmethod\\n-    def all_subclasses(\\n-        cls,\\n-    ) -> Generator[tuple[Optional[str], Type[\\\"Variable\\\"]], None, None]:\\n-        for q in cls.__subclasses__():\\n-            yield getattr(q, \\\"type\\\", None), q\\n-            for p in q.all_subclasses():\\n-                yield p\\n-\\n \\n class DerivedType(Variable):\\n     type = \\\"Derived\\\"\\n \\n-    def __init__(self, definition: VariableDefinition):\\n-        self.name = \\\"(%s: %s)\\\" % (str(definition[\\\"name\\\"]), str(definition[\\\"type\\\"]))\\n-        super(DerivedType, self).__init__(definition)\\n-\\n-\\n-class MissingDataType(Variable):\\n-    type = \\\"MissingData\\\"\\n-\\n-    def __init__(self, name: str):\\n-        self.name = \\\"(%s: Not Missing)\\\" % name\\n-\\n-        self.has_missing = False\\n+    def __init__(self, name: str, var_type: str, **kwargs):\\n+        self.name = \\\"(%s: %s)\\\" % (str(name), str(var_type))\\n+        super().__init__(**kwargs)\\n \\n \\n class FieldType(Variable):\\n@@ -80,13 +55,15 @@ class FieldType(Variable):\\n     _Predicate: Type[predicates.SimplePredicate] = predicates.SimplePredicate\\n     comparator: Comparator\\n \\n-    def __init__(self, definition: VariableDefinition):\\n-        self.field = definition[\\\"field\\\"]\\n+    def __init__(\\n+        self, field: str, name: Optional[str] = None, has_missing: bool = False\\n+    ):\\n+        self.field = field\\n \\n-        if \\\"variable name\\\" in definition:\\n-            self.name = definition[\\\"variable name\\\"]\\n-        else:\\n+        if name is None:\\n             self.name = \\\"(%s: %s)\\\" % (self.field, self.type)\\n+        else:\\n+            self.name = name\\n \\n         self.predicates = [\\n             self._Predicate(pred, self.field) for pred in self._predicate_functions\\n@@ -96,30 +73,39 @@ class FieldType(Variable):\\n             self._index_predicates, self._index_thresholds, self.field\\n         )\\n \\n-        super(FieldType, self).__init__(definition)\\n+        self.has_missing = has_missing\\n+        if self.has_missing:\\n+            exists_pred = predicates.ExistsPredicate(self.field)\\n+            self.predicates.append(exists_pred)\\n \\n \\n class CustomType(FieldType):\\n     type = \\\"Custom\\\"\\n \\n-    def __init__(self, definition: VariableDefinition):\\n-        super(CustomType, self).__init__(definition)\\n-\\n-        try:\\n-            self.comparator = definition[\\\"comparator\\\"]  # type: ignore[assignment]\\n-        except KeyError:\\n-            raise KeyError(\\n-                \\\"For 'Custom' field types you must define \\\"\\n-                \\\"a 'comparator' function in the field \\\"\\n-                \\\"definition. \\\"\\n+    def __init__(\\n+        self,\\n+        field: str,\\n+        comparator: CustomComparator,\\n+        name: Optional[str] = None,\\n+        **kwargs,\\n+    ):\\n+        super().__init__(field, **kwargs)\\n+\\n+        if comparator is None:\\n+            raise ValueError(\\n+                \\\"You must define a comparator function for the Custom class\\\"\\n             )\\n+        else:\\n+            self.comparator = comparator\\n \\n-        if \\\"variable name\\\" not in definition:\\n+        if name is None:\\n             self.name = \\\"(%s: %s, %s)\\\" % (\\n                 self.field,\\n                 self.type,\\n                 self.comparator.__name__,\\n             )\\n+        else:\\n+            self.name = name\\n \\n \\n def indexPredicates(\\n\",\"diff --git a/dedupe/variables/categorical_type.py b/dedupe/variables/categorical_type.py\\nindex b9d3ef6..c2dc567 100644\\n--- a/dedupe/variables/categorical_type.py\\n+++ b/dedupe/variables/categorical_type.py\\n@@ -1,9 +1,11 @@\\n from __future__ import annotations\\n \\n+from typing import Sequence\\n+\\n from categorical import CategoricalComparator\\n \\n from dedupe import predicates\\n-from dedupe._typing import PredicateFunction, VariableDefinition\\n+from dedupe._typing import PredicateFunction\\n from dedupe.variables.base import DerivedType, FieldType\\n \\n \\n@@ -11,26 +13,14 @@ class CategoricalType(FieldType):\\n     type = \\\"Categorical\\\"\\n     _predicate_functions: list[PredicateFunction] = [predicates.wholeFieldPredicate]\\n \\n-    def _categories(self, definition: VariableDefinition) -> list[str]:\\n-        try:\\n-            categories = definition[\\\"categories\\\"]\\n-        except KeyError:\\n-            raise ValueError('No \\\"categories\\\" defined')\\n-\\n-        return categories\\n-\\n-    def __init__(self, definition: VariableDefinition):\\n-        super(CategoricalType, self).__init__(definition)\\n-\\n-        categories = self._categories(definition)\\n+    def __init__(self, field: str, categories: Sequence[str], **kwargs):\\n+        super().__init__(field, **kwargs)\\n \\n         self.comparator = CategoricalComparator(categories)  # type: ignore[assignment]\\n \\n         self.higher_vars = []\\n         for higher_var in self.comparator.dummy_names:  # type: ignore[attr-defined]\\n-            dummy_var = DerivedType(\\n-                {\\\"name\\\": higher_var, \\\"type\\\": \\\"Dummy\\\", \\\"has missing\\\": self.has_missing}\\n-            )\\n+            dummy_var = DerivedType(higher_var, \\\"Dummy\\\", has_missing=False)\\n             self.higher_vars.append(dummy_var)\\n \\n     def __len__(self) -> int:\\n\",\"diff --git a/dedupe/variables/exists.py b/dedupe/variables/exists.py\\nindex 46c36c2..00ca7eb 100644\\n--- a/dedupe/variables/exists.py\\n+++ b/dedupe/variables/exists.py\\n@@ -4,7 +4,7 @@ from typing import Any\\n \\n from categorical import CategoricalComparator\\n \\n-from dedupe._typing import PredicateFunction, VariableDefinition\\n+from dedupe._typing import PredicateFunction\\n from dedupe.variables.base import DerivedType\\n from dedupe.variables.categorical_type import CategoricalType\\n \\n@@ -13,16 +13,14 @@ class ExistsType(CategoricalType):\\n     type = \\\"Exists\\\"\\n     _predicate_functions: list[PredicateFunction] = []\\n \\n-    def __init__(self, definition: VariableDefinition):\\n-        super(CategoricalType, self).__init__(definition)\\n+    def __init__(self, field: str, **kwargs):\\n+        super().__init__(field, **kwargs)\\n \\n         self.cat_comparator = CategoricalComparator([0, 1])\\n \\n         self.higher_vars = []\\n         for higher_var in self.cat_comparator.dummy_names:\\n-            dummy_var = DerivedType(\\n-                {\\\"name\\\": higher_var, \\\"type\\\": \\\"Dummy\\\", \\\"has missing\\\": self.has_missing}\\n-            )\\n+            dummy_var = DerivedType(higher_var, \\\"Dummy\\\", has_missing=self.has_missing)\\n             self.higher_vars.append(dummy_var)\\n \\n     def comparator(self, field_1: Any, field_2: Any) -> list[int]:\\n\",\"diff --git a/dedupe/variables/interaction.py b/dedupe/variables/interaction.py\\nindex b0370e6..e9fbbe5 100644\\n--- a/dedupe/variables/interaction.py\\n+++ b/dedupe/variables/interaction.py\\n@@ -1,24 +1,23 @@\\n from __future__ import annotations\\n \\n import itertools\\n-from typing import Mapping\\n+from typing import List, Mapping\\n \\n-from dedupe._typing import VariableDefinition\\n-from dedupe.variables.base import FieldType as FieldVariable\\n+from dedupe._typing import FieldVariable, InteractionVariable\\n from dedupe.variables.base import Variable\\n \\n \\n class InteractionType(Variable):\\n     type = \\\"Interaction\\\"\\n-    higher_vars: list[\\\"InteractionType\\\"]\\n+    higher_vars: List[InteractionVariable]\\n \\n-    def __init__(self, definition: VariableDefinition):\\n-        self.interactions = definition[\\\"interaction variables\\\"]\\n+    def __init__(self, *args: str, **kwargs):\\n+        self.interactions = list(args)\\n \\n         self.name = \\\"(Interaction: %s)\\\" % str(self.interactions)\\n         self.interaction_fields = self.interactions\\n \\n-        super().__init__(definition)\\n+        super().__init__(**kwargs)\\n \\n     def expandInteractions(self, field_model: Mapping[str, FieldVariable]) -> None:\\n         self.interaction_fields = self.atomicInteractions(\\n@@ -42,14 +41,12 @@ class InteractionType(Variable):\\n             if not hasattr(field_model[field], \\\"higher_vars\\\")\\n         ]\\n \\n-        dummies = [field_model[field].higher_vars for field in categoricals]\\n+        dummies = [field_model[field].higher_vars for field in categoricals]  # type: ignore[attr-defined]\\n \\n         self.higher_vars = []\\n         for combo in itertools.product(*dummies):\\n             var_names = [field.name for field in combo] + noncategoricals\\n-            higher_var = InteractionType(\\n-                {\\\"has missing\\\": self.has_missing, \\\"interaction variables\\\": var_names}\\n-            )\\n+            higher_var = InteractionType(*var_names, has_missing=self.has_missing)\\n             self.higher_vars.append(higher_var)\\n \\n     def atomicInteractions(\\n\",\"diff --git a/dedupe/variables/set.py b/dedupe/variables/set.py\\nindex fddfa5c..8b8253e 100644\\n--- a/dedupe/variables/set.py\\n+++ b/dedupe/variables/set.py\\n@@ -1,7 +1,8 @@\\n+from typing import Collection, Iterable, Optional\\n+\\n from simplecosine.cosine import CosineSetSimilarity\\n \\n from dedupe import predicates\\n-from dedupe._typing import VariableDefinition\\n from dedupe.variables.base import FieldType\\n \\n \\n@@ -24,10 +25,12 @@ class SetType(FieldType):\\n     )\\n     _index_thresholds = (0.2, 0.4, 0.6, 0.8)\\n \\n-    def __init__(self, definition: VariableDefinition):\\n-        super(SetType, self).__init__(definition)\\n+    def __init__(\\n+        self, field: str, corpus: Optional[Iterable[Collection[str]]] = None, **kwargs\\n+    ):\\n+        super().__init__(field, **kwargs)\\n \\n-        if \\\"corpus\\\" not in definition:\\n-            definition[\\\"corpus\\\"] = []\\n+        if corpus is None:\\n+            corpus = []\\n \\n-        self.comparator = CosineSetSimilarity(definition[\\\"corpus\\\"])  # type: ignore[assignment]\\n+        self.comparator = CosineSetSimilarity(corpus)  # type: ignore[assignment]\\n\",\"diff --git a/dedupe/variables/string.py b/dedupe/variables/string.py\\nindex 4272dba..9a2bc8a 100644\\n--- a/dedupe/variables/string.py\\n+++ b/dedupe/variables/string.py\\n@@ -1,11 +1,11 @@\\n-from typing import Sequence, Type\\n+from typing import Iterable, Optional, Sequence, Type\\n \\n from affinegap import normalizedAffineGapDistance as affineGap\\n from highered import CRFEditDistance\\n from simplecosine.cosine import CosineTextSimilarity\\n \\n from dedupe import predicates\\n-from dedupe._typing import PredicateFunction, VariableDefinition\\n+from dedupe._typing import PredicateFunction\\n from dedupe.variables.base import FieldType, indexPredicates\\n \\n crfEd = CRFEditDistance()\\n@@ -36,8 +36,8 @@ class BaseStringType(FieldType):\\n     _Predicate = predicates.StringPredicate\\n     _predicate_functions: Sequence[PredicateFunction] = ()\\n \\n-    def __init__(self, definition: VariableDefinition):\\n-        super(BaseStringType, self).__init__(definition)\\n+    def __init__(self, *args, **kwargs):\\n+        super().__init__(*args, **kwargs)\\n \\n         self.predicates += indexPredicates(\\n             (\\n@@ -67,10 +67,12 @@ class ShortStringType(BaseStringType):\\n     ]\\n     _index_thresholds = (0.2, 0.4, 0.6, 0.8)\\n \\n-    def __init__(self, definition: VariableDefinition):\\n-        super(ShortStringType, self).__init__(definition)\\n+    def __init__(\\n+        self, field: str, name: Optional[str] = None, crf: bool = False, **kwargs\\n+    ):\\n+        super().__init__(field, name=name, **kwargs)\\n \\n-        if definition.get(\\\"crf\\\", False) is True:\\n+        if crf:\\n             self.comparator = crfEd  # type: ignore[assignment]\\n         else:\\n             self.comparator = affineGap  # type: ignore[assignment]\\n@@ -98,10 +100,10 @@ class TextType(BaseStringType):\\n     ]\\n     _index_thresholds = (0.2, 0.4, 0.6, 0.8)\\n \\n-    def __init__(self, definition: VariableDefinition):\\n-        super(TextType, self).__init__(definition)\\n+    def __init__(self, field: str, corpus: Optional[Iterable[str]] = None, **kwargs):\\n+        super().__init__(field, **kwargs)\\n \\n-        if \\\"corpus\\\" not in definition:\\n-            definition[\\\"corpus\\\"] = []\\n+        if corpus is None:\\n+            corpus = []\\n \\n-        self.comparator = CosineTextSimilarity(definition[\\\"corpus\\\"])  # type: ignore[assignment]\\n+        self.comparator = CosineTextSimilarity(corpus)  # type: ignore[assignment]\\n\"]", "test_patch": "[\"diff --git a/docs/Variable-definition.rst b/docs/Variable-definition.rst\\nindex 73abccc..5e6d190 100644\\n--- a/docs/Variable-definition.rst\\n+++ b/docs/Variable-definition.rst\\n@@ -3,31 +3,30 @@\\n Variable Definitions\\n ====================\\n \\n-Variable Types\\n---------------\\n+Variables\\n+---------\\n \\n-A variable definition describes the records that you want to match. It is\\n-a dictionary where the keys are the fields and the values are the\\n-field specification. For example:-\\n+A variable definition describes the records that you want to match. It is sequence\\n+of Variable objects. For example:-\\n \\n .. code:: python\\n \\n+    import dedupe.variables\\n+\\t  \\n     [\\n-        {'field': 'Site name', 'type': 'String'},\\n-        {'field': 'Address', 'type': 'String'},\\n-        {'field': 'Zip', 'type': 'ShortString', 'has missing': True},\\n-        {'field': 'Phone', 'type': 'String', 'has missing': True}\\n+        dedupe.variables.String(\\\"Site Name\\\"),\\n+        dedupe.variables.String(\\\"Address\\\"),\\n+\\tdedupe.variables.ShortString(\\\"Zip\\\", has_missing=True),\\n+\\tdedupe.variables.String(\\\"Phone\\\", has_missing=True)\\n     ]\\n \\n \\n-String Types\\n-^^^^^^^^^^^^\\n+String\\n+^^^^^^\\n \\n-A ``String`` type field must declare the name of the record field to compare\\n-a ``String`` type declaration. The ``String`` type expects fields to be of\\n-class string.\\n+The ``String`` takes the key of the record field to compare.\\n \\n-``String`` types are compared using string edit distance, specifically\\n+``String`` variables are compared using string edit distance, specifically\\n `affine gap string distance <http://en.wikipedia.org/wiki/Gap_penalty#Affine>`__.\\n This is a good metric for measuring fields that might have typos in them,\\n such as \\\"John\\\" vs \\\"Jon\\\".\\n@@ -36,44 +35,45 @@ For example:-\\n \\n .. code:: python\\n \\n-  {'field': 'Address', type: 'String'}\\n+  dedupe.variables.String(\\\"Address\\\")\\n \\n-ShortString Types\\n-^^^^^^^^^^^^^^^^^\\n+ShortString\\n+^^^^^^^^^^^\\n \\n-A ``ShortString`` type field is just like ``String`` types except that dedupe\\n+The ``ShortString`` variable is just like the ``String`` variable except that dedupe\\n will not try to learn any :ref:`index blocking rules <index-blocks-label>` for these fields, which can\\n speed up the training phase considerably.\\n \\n-Zip codes and city names are good candidates for this type. If in doubt,\\n+Zip codes and city names are good candidates for this variable. If in doubt,\\n always use ``String``.\\n \\n For example:-\\n \\n .. code:: python\\n \\n-  {'field': 'Zipcode', type: 'ShortString'}\\n+  dedupe.variables.ShortString(\\\"Zipcode\\\")\\n \\n .. _text-types-label:\\n \\n-Text Types\\n-^^^^^^^^^^\\n+Text\\n+^^^^\\n \\n If you want to compare fields containing blocks of text e.g. product\\n-descriptions or article abstracts, you should use this type. ``Text`` type\\n-fields are compared using the `cosine similarity metric\\n+descriptions or article abstracts, you should use this variable. ``Text``\\n+variables are compared using the `cosine similarity metric\\n <http://en.wikipedia.org/wiki/Vector_space_model>`__.\\n \\n This is a measurement of the amount of words that two documents have in\\n common. This measure can be made more useful as the overlap of rare words\\n counts more than the overlap of common words.\\n \\n-Compare this to ``String`` and ``ShortString`` types: For strings containing\\n-occupations, \\\"yoga teacher\\\" might be fairly similar to \\\"yoga instructor\\\" when\\n-using the ``Text`` measurement, because they both contain the relatively\\n-rare word of \\\"yoga\\\". However, if you compared these two strings using the\\n-``String`` or ``ShortString`` measurements, they might be considered fairly\\n-dis-similar, because the actual string edit distance between them is large.\\n+Compare this to ``String`` and ``ShortString`` variables: For strings\\n+containing occupations, \\\"yoga teacher\\\" might be fairly similar to\\n+\\\"yoga instructor\\\" when using the ``Text`` measurement, because they\\n+both contain the relatively rare word of \\\"yoga\\\". However, if you\\n+compared these two strings using the ``String`` or ``ShortString``\\n+measurements, they might be considered fairly dissimilar, because the\\n+actual string edit distance between them is large.\\n \\n \\n If provided a sequence of example fields (i.e. a corpus) then dedupe will\\n@@ -81,29 +81,27 @@ learn these weights for you. For example:-\\n \\n .. code:: python\\n \\n-   {\\n-    'field': 'Product description',\\n-    'type': 'Text', \\n-    'corpus' : [\\n-            'this product is great',\\n-            'this product is great and blue'\\n-        ]\\n-   } \\n+   dedupe.variables.Text(\\\"Product description\\\",\\n+                         corpus=[\\n+                                 'this product is great',\\n+                                 'this product is great and blue'\\n+                                ]\\n+\\t\\t\\t)\\n \\n If you don't want to adjust the measure to your data, just leave 'corpus' out\\n of the variable definition entirely.\\n \\n .. code:: python\\n \\n-   {'field': 'Product description', 'type': 'Text'} \\n+   dedupe.variables.Text(\\\"Product description\\\") \\n \\n \\n-Custom Types\\n+Custom Variable\\n ^^^^^^^^^^^^\\n \\n-A ``Custom`` type field must have specify the field it wants to compare, a\\n-type declaration of ``Custom``, and a comparator declaration. The comparator\\n-must be a function that can take in two field values and return a number.\\n+A ``Custom`` variables allows you to use a custom function for\\n+comparing fields. The function must take two field values and return a\\n+number.\\n \\n For example, a custom comparator:\\n \\n@@ -120,65 +118,53 @@ The corresponding variable definition:\\n \\n .. code:: python\\n \\n-    {\\n-        'field': 'Zip',\\n-        'type': 'Custom', \\n-        'comparator': same_or_not_comparator\\n-     }\\n+    dedupe.variables.Custom(\\\"Zip\\\", comparator=same_or_not_comparator)\\n \\n-``Custom`` fields do not have any blocking rules associated with them.\\n+``Custom`` variables do not have any blocking rules associated with them.\\n Since dedupe needs blocking rules, a data model that only contains ``Custom``\\n fields will raise an error.\\n \\n LatLong\\n ^^^^^^^\\n \\n-A ``LatLong`` type field must have as the name of a field and a type\\n-declaration of ``LatLong``. ``LatLong`` fields are compared using the `Haversine\\n+``LatLong`` variables are compared using the `Haversine\\n Formula <http://en.wikipedia.org/wiki/Haversine_formula>`__. \\n \\n-A ``LatLong``\\n-type field must consist of tuples of floats corresponding to a latitude and a\\n-longitude.\\n+A ``LatLong`` variable field must consist of tuples of floats\\n+corresponding to a latitude and a longitude.\\n \\n .. code:: python\\n \\n-    {'field': 'Location', 'type': 'LatLong'}\\n+    dedupe.variables.LatLong(\\\"location\\\")\\n \\n Set\\n ^^^\\n \\n-A ``Set`` type field is for comparing lists of elements, like keywords or\\n-client names. ``Set`` types are very similar to :ref:`text-types-label`. They\\n+``Set`` variables are for comparing lists of elements, like keywords or\\n+client names. ``Set`` variables are very similar to :ref:`text-types-label`. They\\n use the same comparison function and you can also let dedupe learn which\\n terms are common or rare by providing a corpus. Within a record, a ``Set``\\n-type field has to be hashable sequences like tuples or frozensets.\\n+variable field has to be hashable sequences like tuples or frozensets.\\n \\n .. code:: python\\n \\n-    {\\n-        'field': 'Co-authors',\\n-        'type': 'Set',\\n-        'corpus' : [\\n-                ('steve edwards'),\\n-                ('steve edwards', 'steve jobs')\\n-            ]\\n-     } \\n+    dedupe.variables.Set(\\\"Co-authors\\\",\\n+                         corpus=[\\n+                                 ('steve edwards'),\\n+                                 ('steve edwards', 'steve jobs')\\n+                                ])\\n \\n or\\n \\n .. code:: python\\n \\n-    {'field': 'Co-authors', 'type': 'Set'}\\n+    dedupe.variables.Set(\\\"Co-authors\\\")\\n \\n Interaction\\n ^^^^^^^^^^^\\n \\n-An ``Interaction`` field multiplies the values of the multiple variables.\\n-An ``Interaction`` variable is created with type declaration of\\n-``Interaction`` and an ``interaction variables`` declaration.\\n-\\n-The ``interaction variables`` field must be a sequence of variable names of\\n+An ``Interaction`` variable multiplies the values of the multiple variables.\\n+The arguments to an ``Interaction`` variable must be a sequence of variable names of\\n other fields you have defined in your variable definition.\\n \\n `Interactions <http://en.wikipedia.org/wiki/Interaction_%28statistics%29>`__\\n@@ -187,10 +173,9 @@ are good when the effect of two predictors is not simply additive.\\n .. code:: python\\n \\n     [\\n-        { 'field': 'Name', 'variable name': 'name', 'type': 'String' },\\n-        { 'field': 'Zip', 'variable name': 'zip', 'type': 'Custom', \\n-      'comparator' : same_or_not_comparator },\\n-        {'type': 'Interaction', 'interaction variables': ['name', 'zip']}\\n+        dedupe.variables.String(\\\"Name\\\", name=\\\"name\\\"),\\n+\\tdedupe.variables.Custom(\\\"Zip\\\", comparator=same_or_not_comparator, name=\\\"zip\\\")\\n+\\tdedupe.variables.Interaction(\\\"name\\\", \\\"zip\\\")\\n     ]\\n \\n Exact\\n@@ -200,7 +185,7 @@ Exact\\n \\n .. code:: python\\n \\n-    {'field': 'city', 'type': 'Exact'}\\n+    dedupe.variables.Exact(\\\"city\\\")\\n \\n \\n Exists\\n@@ -216,7 +201,7 @@ different cases:\\n \\n .. code:: python\\n \\n-    {'field': 'first_name', 'type': 'Exists'} \\n+    dedupe.variables.Exists(\\\"first_name\\\")\\n \\n \\n \\n@@ -254,11 +239,7 @@ You would create a definition such as:\\n \\n .. code:: python\\n \\n-    {\\n-        'field': 'Business Type',\\n-        'type': 'Categorical',\\n-        'categories' : ['taxi', 'lawyer']\\n-    }\\n+    dedupe.variables.Categorical(\\\"Business Type\\\", categories=['taxi', 'lawyer'])\\n \\n Price\\n ^^^^^\\n@@ -269,7 +250,7 @@ prices. The values of ``Price`` field must be a positive float. If the value is\\n \\n .. code:: python\\n \\n-    {'field': 'cost', 'type': 'Price'}\\n+    dedupe.variables.Price(\\\"cost\\\")\\n \\n Optional Variables\\n ------------------\\n@@ -286,8 +267,8 @@ DateTime\\n ``DateTime`` variables are useful for comparing dates and timestamps. This\\n variable can accept strings or Python datetime objects as inputs.\\n \\n-The ``DateTime`` variable definition accepts a few optional arguments that\\n-can help improve behavior if you know your field follows an unusual format:\\n+The ``DateTime`` variable a few optional arguments that can help\\n+improve behavior if you know your field follows an unusual format:\\n \\n * :code:`fuzzy` - Use fuzzy parsing to automatically extract dates from strings like \\\"It happened on June 2nd, 2018\\\" (default :code:`True`)\\n * :code:`dayfirst` - Ambiguous dates should be parsed as dd/mm/yy (default :code:`False`)\\n@@ -297,34 +278,24 @@ Note that the ``DateTime`` variable defaults to mm/dd/yy for ambiguous dates.\\n If both :code:`dayfirst` and :code:`yearfirst` are set to :code:`True`, then\\n :code:`dayfirst` will take precedence.\\n \\n-For example, a sample ``DateTime`` variable definition, using the defaults:\\n \\n .. code:: python\\n \\n-    {\\n-        'field': 'time_of_sale',\\n-        'type': 'DateTime',\\n-        'fuzzy': True,\\n-        'dayfirst': False,\\n-        'yearfirst': False\\n-    }\\n+    import datetimetype\\n \\n-If you're happy with the defaults, you can simply define the :code:`field`\\n-and :code:`type`:\\n+    datetimetype.DateTime(\\\"field\\\")\\n \\n-.. code:: python\\n+To install:\\n \\n-    {'field': 'time_of_sale', 'type': 'DateTime'}\\n+.. code:: console\\n \\n-Install the `dedupe-variable-datetime\\n-<https://pypi.python.org/pypi/dedupe-variable-datetime>`__ package for\\n-``DateTime`` Type. For more info, see the `GitHub Repository\\n-<https://github.com/dedupeio/dedupe-variable-datetime>`__.\\n+    pip install dedupe-variable-datetime\\n \\n-Address Type\\n-^^^^^^^^^^^^\\n \\n-An ``Address`` variable should be used for United States addresses. It uses\\n+Address\\n+^^^^^^^\\n+\\n+An ``USAddress`` variable should be used for United States addresses. It uses\\n the `usaddress <https://usaddress.readthedocs.io/en/latest/>`__ package to\\n split apart an address string into components like address number, street\\n name, and street type and compares component to component.\\n@@ -333,18 +304,22 @@ For example:-\\n \\n .. code:: python\\n \\n-    {'field': 'address', 'type': 'Address'}\\n+    import addressvariable\\n+\\t  \\n+    addressvariable.USAddress(\\\"address\\\")\\n+\\n+\\n+To install:\\n \\n+.. code:: console\\n \\n-Install the `dedupe-variable-address\\n-<https://pypi.python.org/pypi/dedupe-variable-address>`__ package for\\n-``Address`` Type. For more info, see the `GitHub Repository\\n-<https://github.com/dedupeio/dedupe-variable-address>`__.\\n+    pip install dedupe-variable-address\\n \\n-Name Type\\n-^^^^^^^^^\\n \\n-A ``Name`` variable should be used for a field that contains American names,\\n+Name\\n+^^^^\\n+\\n+A ``WesternName`` variable should be used for a field that contains American names,\\n corporations and households. It uses the `probablepeople\\n <https://probablepeople.readthedocs.io/en/latest/>`__ package to split apart\\n an name string into components like give name, surname, generational suffix,\\n@@ -355,42 +330,15 @@ For example:-\\n \\n .. code:: python\\n \\n-    {'field': 'name', 'type': 'Name'}\\n-\\n-\\n-Install the `dedupe-variable-name\\n-<https://pypi.python.org/pypi/dedupe-variable-name>`__ package for ``Name``\\n-Type. For more info, see the `GitHub Repository\\n-<https://github.com/dedupeio/dedupe-variable-name>`__.\\n-\\n-Fuzzy Category\\n-^^^^^^^^^^^^^^\\n-\\n-A ``FuzzyCategorical`` variable should be used for when you for\\n-categorical data that has variations.\\n+    import namevariable\\n \\n-Occupations are an example, where the you may have 'Attorney', 'Counsel', and\\n-'Lawyer'. For this variable type, you need to supply a corpus of records that\\n-contain your focal record and other field types. This corpus should either be\\n-all the data you are trying to link or a representative sample.\\n-\\n-For example:-\\n-\\n-.. code:: python\\n+    namevariable.WesternName(\\\"field\\\")\\n \\n-    {\\n-     'field': 'occupation',\\n-     'type': 'FuzzyCategorical',\\n-     'corpus' : [\\n-            {'name' : 'Jim Doe', 'occupation' : 'Attorney'},\\n-            {'name' : 'Jim Doe', 'occupation' : 'Lawyer'}\\n-        ]\\n-    }\\n+To install: \\n+    \\n+.. code:: console\\n \\n-Install the `dedupe-variable-fuzzycategory\\n-<https://pypi.python.org/pypi/dedupe-variable-fuzzycategory>`__ package for\\n-the ``FuzzyCategorical`` Type. For more info, see the `GitHub Repository\\n-<https://github.com/dedupeio/fuzzycategory>`__.\\n+    pip install dedupe-variable-name\\n \\n \\n Missing Data \\n@@ -407,13 +355,13 @@ a ``None`` object. You should also use ``None`` to represent empty strings\\n         {'Name': None, 'Phone': '773-555-1123'}\\n    ]\\n \\n-If you want to model this missing data for a field, you can set ``'has\\n-missing' : True`` in the variable definition. This creates a new,\\n+If you want to model this missing data for a field, you can set the ``has\\n+missing=True`` in the variable definition. This creates a new,\\n additional field representing whether the data was present or not and\\n zeros out the missing data.\\n \\n-If there is missing data, but you did not declare ``'has\\n-missing' : True`` then the missing data will simply be zeroed out and\\n+If there is missing data, but you did not declare ``has\\n+missing=True`` then the missing data will simply be zeroed out and\\n no field will be created to account for missing data.\\n \\n This approach is called 'response augmented data' and is described in\\n@@ -430,7 +378,7 @@ This approach makes a few assumptions that are usually not completely true:\\n \\n \\n If you define an an interaction with a field that you declared to have\\n-missing data, then ``has missing : True`` will also be set for the\\n+missing data, then ``has missing=True`` will also be set for the\\n Interaction field.\\n \\n Longer example of a variable definition:\\n@@ -438,12 +386,12 @@ Longer example of a variable definition:\\n .. code:: python\\n \\n     [\\n-        {'field': 'name', 'variable name' : 'name', 'type': 'String'},\\n-        {'field': 'address', 'type': 'String'},\\n-        {'field': 'city', 'variable name' : 'city', 'type': 'String'},\\n-        {'field': 'zip', 'type': 'Custom', 'comparator' : same_or_not_comparator},\\n-        {'field': 'cuisine', 'type': 'String', 'has missing': True}\\n-        {'type': 'Interaction', 'interaction variables' : ['name', 'city']}\\n+        dedupe.variables.String(\\\"name\\\", name=\\\"name\\\"),\\n+\\tdedupe.variables.String(\\\"address\\\"),\\n+\\tdedupe.variables.String(\\\"city\\\", name=\\\"city\\\"),\\n+\\tdedupe.variables.Custom(\\\"zip\\\", comparator=same_or_not_comparator),\\n+\\tdedupe.variables.String(\\\"cuisine\\\", has_missing=True),\\n+\\tdedupe.vairables.Interaction(\\\"name\\\", \\\"city\\\")\\n     ]\\n \\n Multiple Variables comparing same field\\n@@ -456,8 +404,8 @@ For example:-\\n .. code:: python\\n \\n     [\\n-        {'field': 'name', 'type': 'String'},\\n-        {'field': 'name', 'type': 'Text'}\\n+        dedupe.variables.String(\\\"name\\\"),\\n+\\tdedupe.variables.Text(\\\"name\\\")\\n     ]\\n \\n \\n@@ -475,4 +423,4 @@ default edit distance.\\n \\n .. code:: python\\n \\n-    {'field': 'name', 'type': 'String', 'crf': True}\\n+    dedupe.variables.String(\\\"name\\\", crf=True)\\n\",\"diff --git a/pyproject.toml b/pyproject.toml\\nindex 9cfe9af..0256eee 100644\\n--- a/pyproject.toml\\n+++ b/pyproject.toml\\n@@ -1,7 +1,7 @@\\n [project]\\n name = \\\"dedupe\\\"\\n description = \\\"A python library for accurate and scaleable data deduplication and entity-resolution\\\"\\n-version = \\\"2.0.24\\\"\\n+version = \\\"3.0.0\\\"\\n readme = \\\"README.md\\\"\\n requires-python = \\\">=3.7\\\"\\n license = {file = \\\"LICENSE\\\"}\\n@@ -63,10 +63,11 @@ dedupe = [\\\"py.typed\\\"]\\n \\n [tool.mypy]\\n plugins = \\\"numpy.typing.mypy_plugin\\\"\\n-files = \\\"dedupe\\\"\\n+files = [\\\"dedupe\\\"]\\n show_error_codes = true\\n ignore_missing_imports = true\\n check_untyped_defs = true\\n+implicit_reexport = false\\n \\n [tool.pytest.ini_options]\\n minversion = \\\"7.1\\\"\\n\",\"diff --git a/tests/test_api.py b/tests/test_api.py\\nindex 84ac916..4e6b929 100644\\n--- a/tests/test_api.py\\n+++ b/tests/test_api.py\\n@@ -46,8 +46,8 @@ data_dict_2 = OrderedDict(\\n class ActiveMatch(unittest.TestCase):\\n     def setUp(self):\\n         self.field_definition = [\\n-            {\\\"field\\\": \\\"name\\\", \\\"type\\\": \\\"String\\\"},\\n-            {\\\"field\\\": \\\"age\\\", \\\"type\\\": \\\"String\\\"},\\n+            dedupe.variables.String(\\\"name\\\"),\\n+            dedupe.variables.String(\\\"age\\\"),\\n         ]\\n \\n     def test_initialize_fields(self):\\n@@ -59,22 +59,25 @@ class ActiveMatch(unittest.TestCase):\\n             )\\n \\n         with self.assertRaises(ValueError):\\n+            dedupe.api.ActiveMatching([{\\\"field\\\": \\\"name\\\", \\\"type\\\": \\\"String\\\"}])\\n+\\n+        with self.assertRaises(ValueError):\\n             dedupe.api.ActiveMatching(\\n-                [{\\\"field\\\": \\\"name\\\", \\\"type\\\": \\\"Custom\\\", \\\"comparator\\\": lambda x, y: 1}],\\n+                [dedupe.variables.Custom(\\\"name\\\", comparator=lambda x, y: 1)],\\n             )\\n \\n         with self.assertRaises(ValueError):\\n             dedupe.api.ActiveMatching(\\n                 [\\n-                    {\\\"field\\\": \\\"name\\\", \\\"type\\\": \\\"Custom\\\", \\\"comparator\\\": lambda x, y: 1},\\n-                    {\\\"field\\\": \\\"age\\\", \\\"type\\\": \\\"Custom\\\", \\\"comparator\\\": lambda x, y: 1},\\n+                    dedupe.variables.Custom(\\\"name\\\", comparator=lambda x, y: 1),\\n+                    dedupe.variables.Custom(\\\"age\\\", comparator=lambda x, y: 1),\\n                 ],\\n             )\\n \\n         dedupe.api.ActiveMatching(\\n             [\\n-                {\\\"field\\\": \\\"name\\\", \\\"type\\\": \\\"Custom\\\", \\\"comparator\\\": lambda x, y: 1},\\n-                {\\\"field\\\": \\\"age\\\", \\\"type\\\": \\\"String\\\"},\\n+                dedupe.variables.Custom(\\\"name\\\", comparator=lambda x, y: 1),\\n+                dedupe.variables.String(\\\"age\\\"),\\n             ],\\n         )\\n \\n\",\"diff --git a/tests/test_core.py b/tests/test_core.py\\nindex 56d1ac0..d0bc8c9 100644\\n--- a/tests/test_core.py\\n+++ b/tests/test_core.py\\n@@ -47,7 +47,7 @@ class ScoreDuplicates(unittest.TestCase):\\n             ]\\n         )\\n \\n-        deduper = dedupe.Dedupe([{\\\"field\\\": \\\"name\\\", \\\"type\\\": \\\"String\\\"}])\\n+        deduper = dedupe.Dedupe([dedupe.variables.String(\\\"name\\\")])\\n         self.data_model = deduper.data_model\\n         self.classifier = MockClassifier()\\n \\n@@ -104,7 +104,7 @@ class ScoreDuplicates(unittest.TestCase):\\n \\n class FieldDistances(unittest.TestCase):\\n     def test_exact_comparator(self):\\n-        deduper = dedupe.Dedupe([{\\\"field\\\": \\\"name\\\", \\\"type\\\": \\\"Exact\\\"}])\\n+        deduper = dedupe.Dedupe([dedupe.variables.Exact(\\\"name\\\")])\\n \\n         record_pairs = (\\n             ({\\\"name\\\": \\\"Shmoo\\\"}, {\\\"name\\\": \\\"Shmee\\\"}),\\n@@ -117,7 +117,7 @@ class FieldDistances(unittest.TestCase):\\n \\n     def test_comparator(self):\\n         deduper = dedupe.Dedupe(\\n-            [{\\\"field\\\": \\\"type\\\", \\\"type\\\": \\\"Categorical\\\", \\\"categories\\\": [\\\"a\\\", \\\"b\\\", \\\"c\\\"]}]\\n+            [dedupe.variables.Categorical(\\\"type\\\", categories=[\\\"a\\\", \\\"b\\\", \\\"c\\\"])]\\n         )\\n \\n         record_pairs = (({\\\"type\\\": \\\"a\\\"}, {\\\"type\\\": \\\"b\\\"}), ({\\\"type\\\": \\\"a\\\"}, {\\\"type\\\": \\\"c\\\"}))\\n@@ -131,14 +131,11 @@ class FieldDistances(unittest.TestCase):\\n     def test_comparator_interaction(self):\\n         deduper = dedupe.Dedupe(\\n             [\\n-                {\\n-                    \\\"field\\\": \\\"type\\\",\\n-                    \\\"variable name\\\": \\\"type\\\",\\n-                    \\\"type\\\": \\\"Categorical\\\",\\n-                    \\\"categories\\\": [\\\"a\\\", \\\"b\\\"],\\n-                },\\n-                {\\\"type\\\": \\\"Interaction\\\", \\\"interaction variables\\\": [\\\"type\\\", \\\"name\\\"]},\\n-                {\\\"field\\\": \\\"name\\\", \\\"variable name\\\": \\\"name\\\", \\\"type\\\": \\\"Exact\\\"},\\n+                dedupe.variables.Categorical(\\n+                    \\\"type\\\", categories=[\\\"a\\\", \\\"b\\\"], name=\\\"type\\\"\\n+                ),\\n+                dedupe.variables.Interaction(\\\"type\\\", \\\"name\\\"),\\n+                dedupe.variables.Exact(\\\"name\\\", name=\\\"name\\\"),\\n             ]\\n         )\\n \\n\",\"diff --git a/tests/test_dedupe.py b/tests/test_dedupe.py\\nindex e50af63..4a925e8 100644\\n--- a/tests/test_dedupe.py\\n+++ b/tests/test_dedupe.py\\n@@ -6,6 +6,7 @@ import unittest\\n import numpy\\n \\n import dedupe\\n+import dedupe.variables\\n \\n DATA = {\\n     100: {\\\"name\\\": \\\"Bob\\\", \\\"age\\\": \\\"50\\\"},\\n@@ -37,9 +38,9 @@ class DataModelTest(unittest.TestCase):\\n \\n         data_model = DataModel(\\n             [\\n-                {\\\"field\\\": \\\"a\\\", \\\"variable name\\\": \\\"a\\\", \\\"type\\\": \\\"String\\\"},\\n-                {\\\"field\\\": \\\"b\\\", \\\"variable name\\\": \\\"b\\\", \\\"type\\\": \\\"String\\\"},\\n-                {\\\"type\\\": \\\"Interaction\\\", \\\"interaction variables\\\": [\\\"a\\\", \\\"b\\\"]},\\n+                dedupe.variables.String(field=\\\"a\\\", name=\\\"a\\\"),\\n+                dedupe.variables.String(field=\\\"b\\\", name=\\\"b\\\"),\\n+                dedupe.variables.Interaction(\\\"a\\\", \\\"b\\\"),\\n             ]\\n         )\\n \\n@@ -47,14 +48,9 @@ class DataModelTest(unittest.TestCase):\\n \\n         data_model = DataModel(\\n             [\\n-                {\\n-                    \\\"field\\\": \\\"a\\\",\\n-                    \\\"variable name\\\": \\\"a\\\",\\n-                    \\\"type\\\": \\\"String\\\",\\n-                    \\\"has missing\\\": True,\\n-                },\\n-                {\\\"field\\\": \\\"b\\\", \\\"variable name\\\": \\\"b\\\", \\\"type\\\": \\\"String\\\"},\\n-                {\\\"type\\\": \\\"Interaction\\\", \\\"interaction variables\\\": [\\\"a\\\", \\\"b\\\"]},\\n+                dedupe.variables.String(field=\\\"a\\\", name=\\\"a\\\", has_missing=True),\\n+                dedupe.variables.String(field=\\\"b\\\", name=\\\"b\\\"),\\n+                dedupe.variables.Interaction(\\\"a\\\", \\\"b\\\"),\\n             ]\\n         )\\n \\n@@ -62,14 +58,9 @@ class DataModelTest(unittest.TestCase):\\n \\n         data_model = DataModel(\\n             [\\n-                {\\n-                    \\\"field\\\": \\\"a\\\",\\n-                    \\\"variable name\\\": \\\"a\\\",\\n-                    \\\"type\\\": \\\"String\\\",\\n-                    \\\"has missing\\\": False,\\n-                },\\n-                {\\\"field\\\": \\\"b\\\", \\\"variable name\\\": \\\"b\\\", \\\"type\\\": \\\"String\\\"},\\n-                {\\\"type\\\": \\\"Interaction\\\", \\\"interaction variables\\\": [\\\"a\\\", \\\"b\\\"]},\\n+                dedupe.variables.String(field=\\\"a\\\", name=\\\"a\\\", has_missing=False),\\n+                dedupe.variables.String(field=\\\"b\\\", name=\\\"b\\\"),\\n+                dedupe.variables.Interaction(\\\"a\\\", \\\"b\\\"),\\n             ]\\n         )\\n \\n\",\"diff --git a/tests/test_labeler.py b/tests/test_labeler.py\\nindex 30609ff..8bbc2ea 100644\\n--- a/tests/test_labeler.py\\n+++ b/tests/test_labeler.py\\n@@ -3,6 +3,7 @@ import unittest\\n \\n import pytest\\n \\n+import dedupe\\n from dedupe import datamodel, labeler\\n from dedupe._typing import RecordDictPair\\n \\n@@ -24,7 +25,7 @@ def freeze_record_pair(record_pair: RecordDictPair):\\n class ActiveLearningTest(unittest.TestCase):\\n     def setUp(self):\\n         self.data_model = datamodel.DataModel(\\n-            [{\\\"field\\\": \\\"name\\\", \\\"type\\\": \\\"String\\\"}, {\\\"field\\\": \\\"age\\\", \\\"type\\\": \\\"String\\\"}]\\n+            [dedupe.variables.String(\\\"name\\\"), dedupe.variables.String(\\\"age\\\")]\\n         )\\n \\n     def test_AL(self):\\n\",\"diff --git a/tests/test_serializer.py b/tests/test_serializer.py\\nindex ab8c0e4..7eb2d93 100644\\n--- a/tests/test_serializer.py\\n+++ b/tests/test_serializer.py\\n@@ -53,7 +53,7 @@ class SerializerTest(unittest.TestCase):\\n         assert isinstance(loaded_training_pairs[\\\"distinct\\\"][0][0][\\\"bar\\\"], frozenset)\\n         assert isinstance(loaded_training_pairs[\\\"distinct\\\"][0][0][\\\"baz\\\"], tuple)\\n \\n-        deduper = dedupe.Dedupe([{\\\"field\\\": \\\"foo\\\", \\\"type\\\": \\\"String\\\"}])\\n+        deduper = dedupe.Dedupe([dedupe.variables.String(\\\"foo\\\")])\\n         deduper.classifier.cv = False\\n \\n         encoded_file.seek(0)\\n\",\"diff --git a/tests/test_training.py b/tests/test_training.py\\nindex b908dde..6b71f3a 100644\\n--- a/tests/test_training.py\\n+++ b/tests/test_training.py\\n@@ -7,7 +7,7 @@ import dedupe.training as training\\n \\n class TrainingTest(unittest.TestCase):\\n     def setUp(self):\\n-        field_definition = [{\\\"field\\\": \\\"name\\\", \\\"type\\\": \\\"String\\\"}]\\n+        field_definition = [dedupe.variables.String(\\\"name\\\")]\\n         self.data_model = dedupe.Dedupe(field_definition).data_model\\n         self.training_pairs = {\\n             \\\"match\\\": [\"]", "hints_text": ""}

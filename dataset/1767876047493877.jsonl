{"instance_id": "1767876047493877", "repo": "adtzlr/felupe", "base_commit": "2754b3a62b07002628b274bce1b2a63bf203d6bc", "problem_statement": "Add Mechanics submodule:\\n# Mechanics submodule\\r\\nA submodule for (solid) mechanics.\\r\\n\\r\\n## Solid Body\\r\\nA umat as a user material class with two methods, one for the evaluation of the gradient and one for the hessian of the total potential energy. A solid body is built on top of it and provides convenient methods for weak-form assemblies based on linear and bilinear forms in combination with fields. In a similar way, hydrostatic pressure boundaries are supported too.\\r\\n\\r\\n```python\\r\\n# Solid Body\\r\\nS = fem.mechanics.SolidBody(umat, field)\\r\\n\\r\\n# Assemble methods for internal force vector and stiffness matrix\\r\\nr = S.vector(field) # force attribute as last assembled vector\\r\\nK = S.matrix(field) # stiffness attribute as last assembled vector\\r\\n\\r\\n# Field gradients/values and stress from latest (force) assembly or given field\\r\\nF = S.extract(field) # kinematics as last evaluated extraction\\r\\nP = S.gradient(field) # stress as last evaluated gradient\\r\\nA = S.hessian(field) # elasticity as last evaluated hessian\\r\\n\\r\\n# Pressure Boundary\\r\\nSP = fem.mechanics.SolidBodyPressure(fieldp)\\r\\nSP.update(fieldp, other_field=field)\\r\\nr -= SP.vector(fieldp, pressure, resize=r)\\r\\nK -= SP.matrix(fieldp, pressure, resize=K)\\r\\n```", "FAIL_TO_PASS": ["tests/test_mechanics.py::test_simple", "tests/test_mechanics.py::test_pressure", "tests/test_constitution.py::test_kinematics", "tests/test_mechanics.py::test_solidbody", "tests/test_mechanics.py::test_solidbody_axi", "tests/test_mechanics.py::test_solidbody_mixed"], "PASS_TO_PASS": ["tests/test_element.py::test_quad4", "tests/test_field.py::test_axi", "tests/test_field.py::test_3d", "tests/test_element.py::test_hex27", "tests/test_element.py::test_tet_mini", "tests/test_tools.py::test_newton_plane", "tests/test_element.py::test_tri6", "tests/test_form.py::test_bilinearform_broadcast", "tests/test_basis.py::test_basis", "tests/test_bilinearform.py::test_linearform_mixed", "tests/test_tools.py::test_newton_simple", "tests/test_form.py::test_linearform_broadcast", "tests/test_math.py::test_math", "tests/test_bilinearform.py::test_linearform", "tests/test_mesh.py::test_triangulate", "tests/test_math.py::test_math_field", "tests/test_tools.py::test_newton", "tests/test_bilinearform.py::test_form_decorator", "tests/test_quadrature.py::test_tetra", "tests/test_constitution.py::test_linear_planestrain", "tests/test_element.py::test_tri_mini", "tests/test_dof.py::test_mpc_mixed", "tests/test_form.py::test_mixed", "tests/test_field.py::test_3d_mixed", "tests/test_element.py::test_aol", "tests/test_bilinearform.py::test_form_decorator_mixed", "tests/test_solve.py::test_solve", "tests/test_element.py::test_hex8", "tests/test_tools.py::test_newton_linearelastic", "tests/test_form.py::test_bilinearform", "tests/test_quadrature.py::test_triangle", "tests/test_tools.py::test_solve_mixed_check", "tests/test_element.py::test_hex0", "tests/test_element.py::test_tet4", "tests/test_region.py::test_region", "tests/test_quadrature.py::test_gausslegendre_boundary", "tests/test_mesh.py::test_meshes", "tests/test_bilinearform.py::test_bilinearform_mixed", "tests/test_constitution.py::test_nh", "tests/test_form.py::test_linearform", "tests/test_constitution.py::test_linear_planestress", "tests/test_bilinearform.py::test_bilinearform", "tests/test_dof.py::test_mpc", "tests/test_tools.py::test_newton_mixed", "tests/test_mesh.py::test_mirror", "tests/test_constitution.py::test_wrappers", "tests/test_dof.py::test_boundary", "tests/test_element.py::test_tri3", "tests/test_element.py::test_line2", "tests/test_element.py::test_hex20", "tests/test_quadrature.py::test_gausslegendre", "tests/test_form.py::test_axi", "tests/test_constitution.py::test_linear", "tests/test_dof.py::test_loadcase", "tests/test_element.py::test_quad0", "tests/test_element.py::test_tet10"], "language": "python", "test_command": "source /saved/ENV || source /saved/*/ENV && tox -- --no-header -rA --tb=no -p no:cacheprovider --continue-on-collection-errors", "test_output_parser": "python/parse_log_pytest_v3", "image_storage_uri": "vmvm-registry.fbinfra.net/repomate_image_activ_pytest/adtzlr_felupe:2754b3a62b07002628b274bce1b2a63bf203d6bc", "patch": "[\"diff --git a/docs/felupe/global.rst b/docs/felupe/global.rst\\nindex e829bf7..21618f4 100644\\n--- a/docs/felupe/global.rst\\n+++ b/docs/felupe/global.rst\\n@@ -14,4 +14,5 @@ felupe\\n    global/dof\\n    global/constitution\\n    global/assembly\\n-   global/tools\\n\\\\ No newline at end of file\\n+   global/tools\\n+   global/mechanics\\n\\\\ No newline at end of file\\n\",\"diff --git a/docs/felupe/global/mechanics.rst b/docs/felupe/global/mechanics.rst\\nnew file mode 100644\\nindex 0000000..8ce1717\\n--- /dev/null\\n+++ b/docs/felupe/global/mechanics.rst\\n@@ -0,0 +1,12 @@\\n+Element\\n+~~~~~~~\\n+   \\n+.. autoclass:: felupe.SolidBody\\n+   :members:\\n+   :undoc-members:\\n+   :show-inheritance:\\n+\\n+.. autoclass:: felupe.SolidBodyPressure\\n+   :members:\\n+   :undoc-members:\\n+   :show-inheritance:\\n\\\\ No newline at end of file\\n\",\"diff --git a/docs/howto.rst b/docs/howto.rst\\nindex b733421..b2d5109 100644\\n--- a/docs/howto.rst\\n+++ b/docs/howto.rst\\n@@ -12,3 +12,4 @@ How-To Guides\\n    howto/solvers\\n    howto/composite\\n    howto/forms\\n+   howto/solid\\n\\\\ No newline at end of file\\n\",\"diff --git a/docs/howto/solid.rst b/docs/howto/solid.rst\\nnew file mode 100644\\nindex 0000000..9a1a2e0\\n--- /dev/null\\n+++ b/docs/howto/solid.rst\\n@@ -0,0 +1,62 @@\\n+Solid Body (Mechanics)\\n+~~~~~~~~~~~~~~~~~~~~~~\\n+\\n+The generation of internal force vectors or stiffness matrices of solid bodies are provided as assembly-methods of a :class:`felupe.SolidBody`. The correct integral form is chosen based on the :class:`felupe.Field`  (default, axisymmetric or mixed).\\n+\\n+..  code-block:: python\\n+\\n+    import felupe as fe\\n+\\n+    neohooke = fe.NeoHooke(mu=1.0, bulk=5000.0)\\n+    mesh = fe.Cube(n=6)\\n+    region = fe.RegionHexahedron(mesh)\\n+    displacement = fe.Field(region, dim=3)\\n+    \\n+    body = fe.SolidBody(umat=neohooke, field=displacement)\\n+    internal_force = body.assemble.vector(displacement, parallel=False, jit=False)\\n+    stiffness_matrix = body.assemble.matrix(displacement, parallel=False, jit=False)\\n+\\n+\\n+During assembly, several results are stored, e.g. the gradient of the strain energy density function per unit undeformed volume (first Piola-Kirchhoff stress tensor). Other results are the deformation gradient or the fourth-order elasticity tensor associated to the first Piola-Kirchhoff stress tensor.\\n+\\n+..  code-block:: python\\n+    \\n+    F = body.results.kinematics[0]\\n+    P = body.results.stress\\n+    A = body.results.elasticity\\n+\\n+\\n+The Cauchy stress tensor, as well as the gradient and the hessian of the strain energy density function per unit undeformed volume are obtained by evaluate-methods of the solid body.\\n+\\n+..  code-block:: python\\n+    \\n+    P = body.evaluate.gradient(displacement)\\n+    A = body.evaluate.hessian(displacement)\\n+    s = body.evaluate.cauchy_stress(displacement)\\n+\\n+\\n+Pressure Boundary on Solid Body (Mechanics)\\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n+\\n+The generation of internal force vectors or stiffness matrices of pressure boundaries of solid bodies are provided as assembly-methods of a :class:`felupe.SolidBodyPressure`. The correct integral form is chosen based on the :class:`felupe.Field` (default or axisymmetric). If the internal field is a mixed field, the assembled vectors and matrices from the pressure contribution have to be resized to the dimensions of the internal force vector and the stiffness matrix.\\n+\\n+..  code-block:: python\\n+    \\n+    region_pressure = fe.RegionHexahedronBoundary(\\n+        mesh=mesh,\\n+        only_surface=True, # select only faces on the outline\\n+        mask=lambda x: x==0, # select a subset of faces on the surface\\n+    )\\n+    \\n+    displacement_boundary = fe.Field(region_pressure)\\n+    displacement_boundary.values = displacement.values # link field values\\n+    \\n+    body_pressure = fe.SolidBodyPressure(field=displacement)\\n+    \\n+    internal_force_pressure = body.assemble.vector(\\n+        field=displacement, parallel=False, jit=False, resize=internal_force\\n+    )\\n+    \\n+    stiffness_matrix_pressure = body.assemble.matrix(\\n+        field=displacement, parallel=False, jit=False, resize=stiffness_matrix\\n+    )\\n\\\\ No newline at end of file\\n\",\"diff --git a/docs/howto/solvers.rst b/docs/howto/solvers.rst\\nindex 0a772b5..055e729 100644\\n--- a/docs/howto/solvers.rst\\n+++ b/docs/howto/solvers.rst\\n@@ -88,36 +88,15 @@ Solvers from external packages:\\n        # ...\\n        \\n        def solver(A, b):\\n-           return PyPardisoSolver(mtype=6).solve(triu(A).tocsr(), b).squeeze()\\n+           # mtype = 1: real and structurally symmetric, supernode pivoting\\n+           # mtype = 2: real and symmetric positive definite\\n+           # mtype =-2: real and symmetric indefinite, \\n+           #             diagonal or Bunch-Kaufman pivoting\\n+           # mtype = 6: complex and symmetric\\n+           return PyPardisoSolver(mtype=2).solve(triu(A).tocsr(), b).squeeze()\\n       \\n        system = fe.solve.partition(field, K, dof1, dof0)\\n        fe.solve.solve(*system, solver=solver)\\n \\n-.. tab:: Krylov (iterative)\\n-\\n-   Ensure to have `Krylov <https://github.com/nschloe/krylov>`_ installed.\\n-\\n-   ..  code-block:: bash\\n-      \\n-       pip install krylov\\n-   \\n-   ``minres`` may be replaced by another iterative method.\\n-\\n-   ..  code-block:: python\\n-        \\n-       import felupe as fe\\n-       import krylov\\n-       \\n-       # ...\\n-       \\n-       def solver(A, b):\\n-           \\\"Wrapper function for Krylov-solvers.\\\"\\n-           \\n-           return krylov.minres(A, b)[0]\\n-       \\n-       system = fe.solve.partition(field, K, dof1, dof0)\\n-       fe.solve.solve(*system, solver=solver)\\n-        \\n-\\n \\n     \\n\\\\ No newline at end of file\\n\",\"diff --git a/docs/index.rst b/docs/index.rst\\nindex bc85ded..b7f08e6 100644\\n--- a/docs/index.rst\\n+++ b/docs/index.rst\\n@@ -57,7 +57,7 @@ Another key feature is the easy and straightforward definition of mixed field fo\\n Installation\\n ------------\\n \\n-Install Python, fire up a terminal and run ``pip install felupe[all]``, where ``[all]`` installs all optional dependencies. By default, FElupe only depends on ``numpy``, ``scipy`` and ``meshio``. However, ``h5py``, ``numba``, ``einsumt`` and ``sparse`` are highly recommended. In order to make use of all features of FElupe, it is suggested to install all optional dependencies. For constitutive material definitions using Automatic Differentation please also install `matADi <https://github.com/adtzlr/matadi>`_.\\n+Install Python, fire up a terminal and run ``pip install felupe[all]``, where ``[all]`` installs all optional dependencies. By default, FElupe only depends on ``numpy`` and ``scipy``. However,  ``meshio``, ``h5py``, ``numba``, ``einsumt`` and ``sparse`` are highly recommended. In order to make use of all features of FElupe, it is suggested to install all optional dependencies. For constitutive material definitions using Automatic Differentation consider also installing `matADi <https://github.com/adtzlr/matadi>`_.\\n \\n .. code-block:: shell\\n \\n\",\"diff --git a/felupe/__about__.py b/felupe/__about__.py\\nindex 528787c..f5f41e5 100644\\n--- a/felupe/__about__.py\\n+++ b/felupe/__about__.py\\n@@ -1 +1 @@\\n-__version__ = \\\"3.0.0\\\"\\n+__version__ = \\\"3.1.0\\\"\\n\",\"diff --git a/felupe/__init__.py b/felupe/__init__.py\\nindex 57791d4..5c5f382 100644\\n--- a/felupe/__init__.py\\n+++ b/felupe/__init__.py\\n@@ -8,6 +8,7 @@ from . import tools\\n from . import constitution\\n from . import solve\\n from . import region\\n+from . import mechanics\\n \\n from .region import (\\n     Region,\\n@@ -107,6 +108,10 @@ from .tools import (\\n     topoints,\\n     project,\\n )\\n+from .mechanics import (\\n+    SolidBody,\\n+    SolidBodyPressure,\\n+)\\n \\n __all__ = [\\n     \\\"__version__\\\",\\n\",\"diff --git a/felupe/_assembly/_axi.py b/felupe/_assembly/_axi.py\\nindex 2187eff..acf6a05 100644\\n--- a/felupe/_assembly/_axi.py\\n+++ b/felupe/_assembly/_axi.py\\n@@ -46,10 +46,10 @@ class IntegralFormAxisymmetric(IntegralForm):\\n \\n                 if grad_v:\\n                     fun_2d = fun[:-1, :-1]\\n-                    fun_zz = fun[(-1,), (-1,)]\\n+                    fun_zz = fun[(-1,), (-1,)] / R\\n                 else:\\n                     fun_2d = fun[:-1]\\n-                    fun_zz = fun[-1].reshape(1, *fun[-1].shape)\\n+                    fun_zz = fun[-1].reshape(1, *fun[-1].shape) / R\\n \\n                 form_a = IntegralForm(fun_2d, v, self.dV, grad_v=grad_v)\\n                 form_b = IntegralForm(fun_zz, v.scalar, self.dV)\\n@@ -142,6 +142,10 @@ class IntegralFormAxisymmetric(IntegralForm):\\n             val = values[0]\\n \\n         if self.mode == 30:\\n+            if len(values[0].shape) > 4:\\n+                values[0] = values[0][:, :, 0, 0]\\n+            if len(values[1].shape) > 4:\\n+                values[1] = values[1][:, :, 0, 0]\\n             a, b, e = values[1].shape\\n             values[1] = values[1].reshape(a, 1, b, e)\\n \\n\",\"diff --git a/felupe/constitution/_kinematics.py b/felupe/constitution/_kinematics.py\\nindex 97f69db..53fda59 100644\\n--- a/felupe/constitution/_kinematics.py\\n+++ b/felupe/constitution/_kinematics.py\\n@@ -77,7 +77,7 @@ class LineChange:\\n         \\\"\\\"\\\"\\n         return F\\n \\n-    def gradient(self, F):\\n+    def gradient(self, F, parallel=None):\\n         \\\"\\\"\\\"Gradient of line change.\\n \\n         Arguments\\n@@ -91,8 +91,11 @@ class LineChange:\\n             Gradient of line change\\n         \\\"\\\"\\\"\\n \\n+        if parallel is None:\\n+            parallel = self.parallel\\n+\\n         Eye = identity(F)\\n-        return cdya_ik(Eye, Eye, parallel=self.parallel)\\n+        return cdya_ik(Eye, Eye, parallel=parallel)\\n \\n \\n class AreaChange:\\n@@ -113,7 +116,7 @@ class AreaChange:\\n     def __init__(self, parallel=False):\\n         self.parallel = parallel\\n \\n-    def function(self, F, N=None):\\n+    def function(self, F, N=None, parallel=None):\\n         \\\"\\\"\\\"Area change.\\n \\n         Arguments\\n@@ -132,12 +135,15 @@ class AreaChange:\\n \\n         Fs = J * transpose(inv(F, J))\\n \\n+        if parallel is None:\\n+            parallel = self.parallel\\n+\\n         if N is None:\\n             return Fs\\n         else:\\n-            return dot(Fs, N, parallel=self.parallel)\\n+            return dot(Fs, N, parallel=parallel)\\n \\n-    def gradient(self, F, N=None):\\n+    def gradient(self, F, N=None, parallel=None):\\n         \\\"\\\"\\\"Gradient of area change.\\n \\n         Arguments\\n@@ -155,13 +161,15 @@ class AreaChange:\\n \\n         J = det(F)\\n \\n+        if parallel is None:\\n+            parallel = self.parallel\\n+\\n         dJdF = self.function(F)\\n         dFsdF = (\\n-            dya(dJdF, dJdF, parallel=self.parallel)\\n-            - cdya_il(dJdF, dJdF, parallel=self.parallel)\\n+            dya(dJdF, dJdF, parallel=parallel) - cdya_il(dJdF, dJdF, parallel=parallel)\\n         ) / J\\n \\n-        if self.parallel:\\n+        if parallel:\\n             einsum = einsumt\\n         else:\\n             einsum = np.einsum\\n@@ -224,7 +232,7 @@ class VolumeChange:\\n         J = self.function(F)\\n         return J * transpose(inv(F, J))\\n \\n-    def hessian(self, F):\\n+    def hessian(self, F, parallel=None):\\n         \\\"\\\"\\\"Hessian of volume change.\\n \\n         Arguments\\n@@ -238,9 +246,11 @@ class VolumeChange:\\n             Hessian of the determinant of the deformation gradient\\n         \\\"\\\"\\\"\\n \\n+        if parallel is None:\\n+            parallel = self.parallel\\n+\\n         J = self.function(F)\\n         dJdF = self.gradient(F)\\n         return (\\n-            dya(dJdF, dJdF, parallel=self.parallel)\\n-            - cdya_il(dJdF, dJdF, parallel=self.parallel)\\n+            dya(dJdF, dJdF, parallel=parallel) - cdya_il(dJdF, dJdF, parallel=parallel)\\n         ) / J\\n\",\"diff --git a/felupe/mechanics/__init__.py b/felupe/mechanics/__init__.py\\nnew file mode 100644\\nindex 0000000..81657ed\\n--- /dev/null\\n+++ b/felupe/mechanics/__init__.py\\n@@ -0,0 +1,2 @@\\n+from ._solidbody import SolidBody\\n+from ._solidbody_pressure import SolidBodyPressure\\n\",\"diff --git a/felupe/mechanics/_helpers.py b/felupe/mechanics/_helpers.py\\nnew file mode 100644\\nindex 0000000..6c7f433\\n--- /dev/null\\n+++ b/felupe/mechanics/_helpers.py\\n@@ -0,0 +1,61 @@\\n+# -*- coding: utf-8 -*-\\n+\\\"\\\"\\\"\\n+ _______  _______  ___      __   __  _______  _______ \\n+|       ||       ||   |    |  | |  ||       ||       |\\n+|    ___||    ___||   |    |  | |  ||    _  ||    ___|\\n+|   |___ |   |___ |   |    |  |_|  ||   |_| ||   |___ \\n+|    ___||    ___||   |___ |       ||    ___||    ___|\\n+|   |    |   |___ |       ||       ||   |    |   |___ \\n+|___|    |_______||_______||_______||___|    |_______|\\n+\\n+This file is part of felupe.\\n+\\n+Felupe is free software: you can redistribute it and/or modify\\n+it under the terms of the GNU General Public License as published by\\n+the Free Software Foundation, either version 3 of the License, or\\n+(at your option) any later version.\\n+\\n+Felupe is distributed in the hope that it will be useful,\\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n+GNU General Public License for more details.\\n+\\n+You should have received a copy of the GNU General Public License\\n+along with Felupe.  If not, see <http://www.gnu.org/licenses/>.\\n+\\n+\\\"\\\"\\\"\\n+\\n+\\n+class Assemble:\\n+    \\\"A class with assembly methods of a SolidBody.\\\"\\n+\\n+    def __init__(self, vector, matrix):\\n+        self.vector = vector\\n+        self.matrix = matrix\\n+\\n+\\n+class Evaluate:\\n+    \\\"A class with evaluate methods of a SolidBody.\\\"\\n+\\n+    def __init__(self, gradient, hessian, cauchy_stress=None):\\n+        self.gradient = gradient\\n+        self.hessian = hessian\\n+\\n+        if cauchy_stress is not None:\\n+            self.cauchy_stress = cauchy_stress\\n+\\n+\\n+class Results:\\n+    \\\"A class with intermediate results of a SolidBody.\\\"\\n+\\n+    def __init__(self, stress=False, elasticity=False):\\n+\\n+        self.force = None\\n+        self.stiffness = None\\n+        self.kinematics = None\\n+\\n+        if stress:\\n+            self.stress = None\\n+\\n+        if elasticity:\\n+            self.elasticity = None\\n\",\"diff --git a/felupe/mechanics/_solidbody.py b/felupe/mechanics/_solidbody.py\\nnew file mode 100644\\nindex 0000000..707eec5\\n--- /dev/null\\n+++ b/felupe/mechanics/_solidbody.py\\n@@ -0,0 +1,155 @@\\n+# -*- coding: utf-8 -*-\\n+\\\"\\\"\\\"\\n+ _______  _______  ___      __   __  _______  _______ \\n+|       ||       ||   |    |  | |  ||       ||       |\\n+|    ___||    ___||   |    |  | |  ||    _  ||    ___|\\n+|   |___ |   |___ |   |    |  |_|  ||   |_| ||   |___ \\n+|    ___||    ___||   |___ |       ||    ___||    ___|\\n+|   |    |   |___ |       ||       ||   |    |   |___ \\n+|___|    |_______||_______||_______||___|    |_______|\\n+\\n+This file is part of felupe.\\n+\\n+Felupe is free software: you can redistribute it and/or modify\\n+it under the terms of the GNU General Public License as published by\\n+the Free Software Foundation, either version 3 of the License, or\\n+(at your option) any later version.\\n+\\n+Felupe is distributed in the hope that it will be useful,\\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n+GNU General Public License for more details.\\n+\\n+You should have received a copy of the GNU General Public License\\n+along with Felupe.  If not, see <http://www.gnu.org/licenses/>.\\n+\\n+\\\"\\\"\\\"\\n+\\n+from .._field import Field, FieldMixed, FieldsMixed, FieldAxisymmetric\\n+from .._assembly import IntegralForm, IntegralFormMixed, IntegralFormAxisymmetric\\n+from ..constitution import AreaChange\\n+from ..math import inv, dot\\n+from ._helpers import Assemble, Evaluate, Results\\n+\\n+\\n+class SolidBody:\\n+    \\\"A SolidBody with methods for the assembly of sparse vectors/matrices.\\\"\\n+\\n+    def __init__(self, umat, field):\\n+\\n+        self.umat = umat\\n+        self.field = field\\n+\\n+        if isinstance(field, FieldMixed):\\n+            self._dV = self.field[0].region.dV\\n+        else:\\n+            self._dV = self.field.region.dV\\n+\\n+        self.results = Results(stress=True, elasticity=True)\\n+        self.results.kinematics = self._extract(self.field)\\n+\\n+        self.assemble = Assemble(vector=self._vector, matrix=self._matrix)\\n+\\n+        self.evaluate = Evaluate(\\n+            gradient=self._gradient,\\n+            hessian=self._hessian,\\n+            cauchy_stress=self._cauchy_stress,\\n+        )\\n+\\n+        self._area_change = AreaChange()\\n+\\n+        self._form = {\\n+            Field: IntegralForm,\\n+            FieldMixed: IntegralFormMixed,\\n+            FieldsMixed: IntegralFormMixed,\\n+            FieldAxisymmetric: IntegralFormAxisymmetric,\\n+        }[type(self.field)]\\n+\\n+        self._kwargs = {\\n+            Field: dict(dV=self._dV, grad_v=True, grad_u=True),\\n+            FieldMixed: dict(dV=self._dV),\\n+            FieldsMixed: dict(dV=self._dV),\\n+            FieldAxisymmetric: dict(dV=self._dV, grad_v=True, grad_u=True),\\n+        }[type(self.field)]\\n+\\n+    def _vector(\\n+        self, field=None, parallel=False, jit=False, items=None, args=(), kwargs={}\\n+    ):\\n+\\n+        if field is not None:\\n+            self.field = field\\n+\\n+        self.results.stress = self._gradient(field, args=args, kwargs=kwargs)\\n+\\n+        self.results.force = self._form(\\n+            fun=self.results.stress[slice(items)],\\n+            v=self.field,\\n+            **self._kwargs,\\n+        ).assemble(parallel=parallel, jit=jit)\\n+\\n+        return self.results.force\\n+\\n+    def _matrix(\\n+        self, field=None, parallel=False, jit=False, items=None, args=(), kwargs={}\\n+    ):\\n+\\n+        if field is not None:\\n+            self.field = field\\n+\\n+        self.results.elasticity = self._hessian(field, args=args, kwargs=kwargs)\\n+\\n+        self.results.stiffness = self._form(\\n+            fun=self.results.elasticity[slice(items)],\\n+            v=self.field,\\n+            u=self.field,\\n+            **self._kwargs,\\n+        ).assemble(parallel=parallel, jit=jit)\\n+\\n+        return self.results.stiffness\\n+\\n+    def _extract(self, field):\\n+\\n+        self.field = field\\n+\\n+        self.results.kinematics = self.field.extract()\\n+        if isinstance(self.field, Field):\\n+            self.results.kinematics = (self.results.kinematics,)\\n+\\n+        return self.results.kinematics\\n+\\n+    def _gradient(self, field=None, args=(), kwargs={}):\\n+\\n+        if field is not None:\\n+            self.field = field\\n+            self.results.kinematics = self._extract(self.field)\\n+\\n+        self.results.stress = self.umat.gradient(\\n+            *self.results.kinematics, *args, **kwargs\\n+        )\\n+\\n+        return self.results.stress\\n+\\n+    def _hessian(self, field=None, args=(), kwargs={}):\\n+\\n+        if field is not None:\\n+            self.field = field\\n+            self.results.kinematics = self._extract(self.field)\\n+\\n+        self.results.elasticity = self.umat.hessian(\\n+            *self.results.kinematics, *args, **kwargs\\n+        )\\n+\\n+        return self.results.elasticity\\n+\\n+    def _cauchy_stress(self, field=None):\\n+\\n+        self._gradient(field)\\n+\\n+        if len(self.results.kinematics) > 1:\\n+            P = self.results.stress[0]\\n+        else:\\n+            P = self.results.stress\\n+\\n+        JiFT = self._area_change.function(self.results.kinematics[0])\\n+\\n+        return dot(P, inv(JiFT))\\n\",\"diff --git a/felupe/mechanics/_solidbody_pressure.py b/felupe/mechanics/_solidbody_pressure.py\\nnew file mode 100644\\nindex 0000000..2af111d\\n--- /dev/null\\n+++ b/felupe/mechanics/_solidbody_pressure.py\\n@@ -0,0 +1,138 @@\\n+# -*- coding: utf-8 -*-\\n+\\\"\\\"\\\"\\n+ _______  _______  ___      __   __  _______  _______ \\n+|       ||       ||   |    |  | |  ||       ||       |\\n+|    ___||    ___||   |    |  | |  ||    _  ||    ___|\\n+|   |___ |   |___ |   |    |  |_|  ||   |_| ||   |___ \\n+|    ___||    ___||   |___ |       ||    ___||    ___|\\n+|   |    |   |___ |       ||       ||   |    |   |___ \\n+|___|    |_______||_______||_______||___|    |_______|\\n+\\n+This file is part of felupe.\\n+\\n+Felupe is free software: you can redistribute it and/or modify\\n+it under the terms of the GNU General Public License as published by\\n+the Free Software Foundation, either version 3 of the License, or\\n+(at your option) any later version.\\n+\\n+Felupe is distributed in the hope that it will be useful,\\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n+GNU General Public License for more details.\\n+\\n+You should have received a copy of the GNU General Public License\\n+along with Felupe.  If not, see <http://www.gnu.org/licenses/>.\\n+\\n+\\\"\\\"\\\"\\n+\\n+from .._field import Field, FieldMixed, FieldsMixed, FieldAxisymmetric\\n+from .._assembly import IntegralForm, IntegralFormMixed, IntegralFormAxisymmetric\\n+from ..constitution import AreaChange\\n+from ._helpers import Assemble, Results\\n+\\n+\\n+class SolidBodyPressure:\\n+    \\\"A hydrostatic pressure boundary on a SolidBody.\\\"\\n+\\n+    def __init__(self, field):\\n+\\n+        self.field = field\\n+\\n+        self._dV = self.field.region.dV\\n+        self._normals = self.field.region.normals\\n+\\n+        self.results = Results()\\n+        self.results.kinematics = self._extract(self.field)\\n+        self.assemble = Assemble(vector=self._vector, matrix=self._matrix)\\n+\\n+        self._form = {\\n+            Field: IntegralForm,\\n+            FieldMixed: IntegralFormMixed,\\n+            FieldsMixed: IntegralFormMixed,\\n+            FieldAxisymmetric: IntegralFormAxisymmetric,\\n+        }[type(self.field)]\\n+\\n+        self._kwargs = {\\n+            Field: dict(dV=self._dV, grad_v=True, grad_u=True),\\n+            FieldMixed: dict(dV=self._dV),\\n+            FieldsMixed: dict(dV=self._dV),\\n+            FieldAxisymmetric: dict(dV=self._dV, grad_v=True, grad_u=True),\\n+        }[type(self.field)]\\n+\\n+        self._IntForm = {\\n+            Field: IntegralForm,\\n+            FieldAxisymmetric: IntegralFormAxisymmetric,\\n+        }[type(self.field)]\\n+\\n+        self._area_change = AreaChange()\\n+\\n+    def _extract(self, field):\\n+\\n+        self.field = field\\n+        self.results.kinematics = (self.field.extract(),)\\n+\\n+        return self.results.kinematics\\n+\\n+    def _vector(self, field=None, pressure=1, parallel=False, jit=False, resize=None):\\n+\\n+        if field is not None:\\n+            self.field = field\\n+            self.results.kinematics = self._extract(field)\\n+\\n+        self.results.pressure = pressure\\n+\\n+        fun = pressure * self._area_change.function(\\n+            *self.results.kinematics,\\n+            self._normals,\\n+            parallel=parallel,\\n+        )\\n+\\n+        self.results.force = self._IntForm(\\n+            fun=fun, v=self.field, dV=self._dV, grad_v=False\\n+        ).assemble(parallel=parallel, jit=jit)\\n+\\n+        if resize is not None:\\n+            self.results.force.resize(*resize.shape)\\n+\\n+        return self.results.force\\n+\\n+    def _matrix(self, field=None, pressure=1, parallel=False, jit=False, resize=None):\\n+\\n+        if field is not None:\\n+            self.field = field\\n+            self.results.kinematics = self._extract(field)\\n+\\n+        self.results.pressure = pressure\\n+\\n+        fun = pressure * self._area_change.gradient(\\n+            *self.results.kinematics,\\n+            self._normals,\\n+            parallel=parallel,\\n+        )\\n+        self.results.stiffness = self._IntForm(\\n+            fun=fun,\\n+            v=self.field,\\n+            u=self.field,\\n+            dV=self._dV,\\n+            grad_v=False,\\n+            grad_u=True,\\n+        ).assemble(parallel=parallel, jit=jit)\\n+\\n+        if resize is not None:\\n+            self.results.stiffness.resize(*resize.shape)\\n+\\n+        return self.results.stiffness\\n+\\n+    def update(self, other_field, field=None):\\n+\\n+        if field is not None:\\n+            self.field = field\\n+\\n+        if isinstance(other_field, FieldMixed) or isinstance(other_field, FieldsMixed):\\n+            self.field.values = other_field[0].values\\n+        else:\\n+            self.field.values = other_field.values\\n+\\n+        self.results.kinematics = self._extract(self.field)\\n+\\n+        return self.field\\n\",\"diff --git a/felupe/mesh/_mesh.py b/felupe/mesh/_mesh.py\\nindex a1d1fba..d932653 100644\\n--- a/felupe/mesh/_mesh.py\\n+++ b/felupe/mesh/_mesh.py\\n@@ -117,10 +117,7 @@ class Mesh:\\n \\n         \\\"\\\"\\\"\\n \\n-        if self.cell_type is None:\\n-            raise TypeError(\\\"Cell type missing.\\\")\\n-        else:\\n-            import meshio\\n+        import meshio\\n \\n         cells = {self.cell_type: self.cells}\\n         return meshio.Mesh(self.points, cells, **kwargs)\\n\",\"diff --git a/felupe/tools/_save.py b/felupe/tools/_save.py\\nindex 91193be..0a92717 100644\\n--- a/felupe/tools/_save.py\\n+++ b/felupe/tools/_save.py\\n@@ -26,7 +26,6 @@ along with Felupe.  If not, see <http://www.gnu.org/licenses/>.\\n \\\"\\\"\\\"\\n \\n import numpy as np\\n-import meshio\\n \\n from ..math import dot, transpose, det, eigvalsh\\n from . import topoints\\n@@ -90,6 +89,8 @@ def save(\\n \\n         point_data[\\\"MaxPrincipalShearCauchyStress\\\"] = cauchyprinc[2] - cauchyprinc[0]\\n \\n+    import meshio\\n+\\n     mesh = meshio.Mesh(\\n         points=mesh.points,\\n         cells=[\\n\",\"diff --git a/pyproject.toml b/pyproject.toml\\nindex c6078a4..e16166e 100644\\n--- a/pyproject.toml\\n+++ b/pyproject.toml\\n@@ -1,6 +1,6 @@\\n [project]\\n name = \\\"felupe\\\"\\n-version = \\\"3.0.0\\\"\\n+version = \\\"3.1.0\\\"\\n description = \\\"Finite Element Analysis\\\"\\n readme = \\\"README.md\\\"\\n requires-python = \\\">=3.6\\\"\\n@@ -40,11 +40,11 @@ classifiers = [\\n dependencies = [\\n   \\\"numpy\\\",\\n   \\\"scipy\\\",\\n-  \\\"meshio\\\",\\n ]\\n \\n [project.optional-dependencies]\\n all = [\\n+    \\\"meshio\\\",\\n     \\\"h5py\\\",\\n     \\\"numba\\\",\\n     \\\"sparse\\\",\\n\",\"diff --git a/setup.cfg b/setup.cfg\\nindex ebdd5a8..5a98365 100644\\n--- a/setup.cfg\\n+++ b/setup.cfg\\n@@ -1,6 +1,6 @@\\n [metadata]\\n name = felupe\\n-version = 3.0.0\\n+version = 3.1.0\\n author = Andreas Dutzler\\n author_email = a.dutzler@gmail.com\\n description = Finite Element Analysis\\n@@ -33,11 +33,11 @@ packages = find:\\n install_requires =\\n     numpy\\n     scipy\\n-    meshio\\n python_requires = >=3.6\\n \\n [options.extras_require]\\n all =\\n+    meshio\\n     h5py\\n     numba\\n     sparse\\n\"]", "test_patch": "[\"diff --git a/tests/test_mechanics.py b/tests/test_mechanics.py\\nnew file mode 100644\\nindex 00000000..0507ee1b\\n--- /dev/null\\n+++ b/tests/test_mechanics.py\\n@@ -0,0 +1,47 @@\\n+# -*- coding: utf-8 -*-\\n+\\\"\\\"\\\"\\n+ _______  _______  ___      __   __  _______  _______ \\n+|       ||       ||   |    |  | |  ||       ||       |\\n+|    ___||    ___||   |    |  | |  ||    _  ||    ___|\\n+|   |___ |   |___ |   |    |  |_|  ||   |_| ||   |___ \\n+|    ___||    ___||   |___ |       ||    ___||    ___|\\n+|   |    |   |___ |       ||       ||   |    |   |___ \\n+|___|    |_______||_______||_______||___|    |_______|\\n+\\n+This file is part of felupe.\\n+\\n+Felupe is free software: you can redistribute it and/or modify\\n+it under the terms of the GNU General Public License as published by\\n+the Free Software Foundation, either version 3 of the License, or\\n+(at your option) any later version.\\n+\\n+Felupe is distributed in the hope that it will be useful,\\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n+GNU General Public License for more details.\\n+\\n+You should have received a copy of the GNU General Public License\\n+along with Felupe.  If not, see <http://www.gnu.org/licenses/>.\\n+\\n+\\\"\\\"\\\"\\n+\\n+import pytest\\n+import felupe as fe\\n+import numpy as np\\n+\\n+\\n+def pre(dim):\\n+\\n+    m = fe.Cube(n=3)\\n+    r = fe.RegionHexahedron(m)\\n+    u = fe.Field(r, dim=dim)\\n+    return r, u\\n+\\n+\\n+def test_solidbody():\\n+\\n+    B = fe.SolidBody()\\n+\\n+\\n+if __name__ == \\\"__main__\\\":\\n+    test_solidbody()\\n\",\"diff --git a/tests/test_mechanics.py b/tests/test_mechanics.py\\nindex 0507ee1b..99854813 100644\\n--- a/tests/test_mechanics.py\\n+++ b/tests/test_mechanics.py\\n@@ -30,18 +30,184 @@\\n import numpy as np\\n \\n \\n+def test_simple():\\n+\\n+    umat = fe.LinearElastic(E=1, nu=0.3)\\n+\\n+    m = fe.Cube(n=3)\\n+    r = fe.RegionHexahedron(m)\\n+    u = fe.Field(r, dim=3)\\n+\\n+    b = fe.SolidBody(umat, u)\\n+    r = b.vector()\\n+\\n+    K = b.matrix()\\n+    r = b.vector(u)\\n+    F = b.kinematics[0]\\n+    s = b.stress\\n+    C = b.elasticity\\n+\\n+    assert K.shape == (81, 81)\\n+    assert r.shape == (81, 1)\\n+    assert F.shape == (3, 3, 8, 8)\\n+    assert s.shape == (3, 3, 8, 8)\\n+    assert C.shape == (3, 3, 3, 3, 8, 8)\\n+\\n+\\n def pre(dim):\\n \\n+    umat = fe.NeoHooke(mu=1, bulk=2)\\n+\\n     m = fe.Cube(n=3)\\n     r = fe.RegionHexahedron(m)\\n     u = fe.Field(r, dim=dim)\\n-    return r, u\\n+\\n+    return umat, u\\n+\\n+\\n+def pre_axi():\\n+\\n+    umat = fe.NeoHooke(mu=1, bulk=2)\\n+\\n+    m = fe.Rectangle(n=3)\\n+    r = fe.RegionQuad(m)\\n+    u = fe.FieldAxisymmetric(r)\\n+\\n+    return umat, u\\n+\\n+\\n+def pre_mixed(dim):\\n+\\n+    umat = fe.ThreeFieldVariation(fe.NeoHooke(mu=1, bulk=2))\\n+\\n+    m = fe.Cube(n=3)\\n+    r = fe.RegionHexahedron(m)\\n+    u = fe.FieldsMixed(r, n=3)\\n+\\n+    return umat, u\\n \\n \\n def test_solidbody():\\n \\n-    B = fe.SolidBody()\\n+    umat, u = pre(dim=3)\\n+    b = fe.SolidBody(umat=umat, field=u)\\n+\\n+    for parallel in [False, True]:\\n+        for jit in [False, True]:\\n+\\n+            kwargs = {\\\"parallel\\\": parallel, \\\"jit\\\": jit}\\n+\\n+            r1 = b.vector(u, **kwargs)\\n+            assert r1.shape == (81, 1)\\n+\\n+            r2 = b.vector(**kwargs)\\n+            assert np.allclose(r1.toarray(), r2.toarray())\\n+\\n+            K1 = b.matrix(u, **kwargs)\\n+            assert K1.shape == (81, 81)\\n+\\n+            K2 = b.matrix(**kwargs)\\n+            assert np.allclose(K1.toarray(), K2.toarray())\\n+\\n+            P1 = b.stress\\n+            P2 = b.gradient()\\n+            P2 = b.gradient(u)\\n+            assert np.allclose(P1, P2)\\n+\\n+            A1 = b.elasticity\\n+            A2 = b.hessian()\\n+            A2 = b.hessian(u)\\n+            assert np.allclose(A1, A2)\\n+\\n+            F1 = b.kinematics\\n+            F2 = b.extract()\\n+            F2 = b.extract(u)\\n+            assert np.allclose(F1, F2)\\n+\\n+\\n+def test_solidbody_axi():\\n+\\n+    umat, u = pre_axi()\\n+    b = fe.SolidBody(umat=umat, field=u)\\n+\\n+    for parallel in [False, True]:\\n+        for jit in [False, True]:\\n+\\n+            kwargs = {\\\"parallel\\\": parallel, \\\"jit\\\": jit}\\n+\\n+            r1 = b.vector(u, **kwargs)\\n+            assert r1.shape == (18, 1)\\n+\\n+            r2 = b.vector(**kwargs)\\n+            assert np.allclose(r1.toarray(), r2.toarray())\\n+\\n+            K1 = b.matrix(u, **kwargs)\\n+            assert K1.shape == (18, 18)\\n+\\n+            K2 = b.matrix(**kwargs)\\n+            assert np.allclose(K1.toarray(), K2.toarray())\\n+\\n+            P1 = b.stress\\n+            P2 = b.gradient()\\n+            P2 = b.gradient(u)\\n+            assert np.allclose(P1, P2)\\n+\\n+            A1 = b.elasticity\\n+            A2 = b.hessian()\\n+            A2 = b.hessian(u)\\n+            assert np.allclose(A1, A2)\\n+\\n+            F1 = b.kinematics\\n+            F2 = b.extract()\\n+            F2 = b.extract(u)\\n+            assert np.allclose(F1, F2)\\n+\\n+\\n+def test_solidbody_mixed():\\n+\\n+    umat, u = pre_mixed(dim=3)\\n+    b = fe.SolidBody(umat=umat, field=u)\\n+\\n+    for parallel in [False, True]:\\n+        for jit in [False, True]:\\n+\\n+            kwargs = {\\\"parallel\\\": parallel, \\\"jit\\\": jit}\\n+\\n+            r1 = b.vector(u, **kwargs)\\n+            r1 = b.vector(u, items=3, **kwargs)\\n+            assert r1.shape == (97, 1)\\n+\\n+            r2 = b.vector(**kwargs)\\n+            assert np.allclose(r1.toarray(), r2.toarray())\\n+\\n+            K1 = b.matrix(u, **kwargs)\\n+            K1 = b.matrix(u, items=6, **kwargs)\\n+            assert K1.shape == (97, 97)\\n+\\n+            K2 = b.matrix(**kwargs)\\n+            assert np.allclose(K1.toarray(), K2.toarray())\\n+\\n+            P1 = b.stress\\n+            P2 = b.gradient()\\n+            P2 = b.gradient(u)\\n+            for p1, p2 in zip(P1, P2):\\n+                assert np.allclose(p1, p2)\\n+\\n+            A1 = b.elasticity\\n+            A2 = b.hessian()\\n+            A2 = b.hessian(u)\\n+            for a1, a2 in zip(A1, A2):\\n+                assert np.allclose(a1, a2)\\n+\\n+            F1 = b.kinematics\\n+            F2 = b.extract()\\n+            F2 = b.extract(u)\\n+            for f1, f2 in zip(F1, F2):\\n+                assert np.allclose(f1, f2)\\n \\n \\n if __name__ == \\\"__main__\\\":\\n+    test_simple()\\n     test_solidbody()\\n+    test_solidbody_axi()\\n+    test_solidbody_mixed()\\n\",\"diff --git a/tests/test_mechanics.py b/tests/test_mechanics.py\\nindex 99854813..2cffaa5f 100644\\n--- a/tests/test_mechanics.py\\n+++ b/tests/test_mechanics.py\\n@@ -62,6 +62,8 @@ def pre(dim):\\n     r = fe.RegionHexahedron(m)\\n     u = fe.Field(r, dim=dim)\\n \\n+    u.values = np.random.rand(*u.values.shape) / 10\\n+\\n     return umat, u\\n \\n \\n@@ -73,6 +75,8 @@ def pre_axi():\\n     r = fe.RegionQuad(m)\\n     u = fe.FieldAxisymmetric(r)\\n \\n+    u.values = np.random.rand(*u.values.shape) / 10\\n+\\n     return umat, u\\n \\n \\n@@ -84,6 +88,10 @@ def pre_mixed(dim):\\n     r = fe.RegionHexahedron(m)\\n     u = fe.FieldsMixed(r, n=3)\\n \\n+    u[0].values = np.random.rand(*u[0].values.shape) / 10\\n+    u[1].values = np.random.rand(*u[1].values.shape) / 10\\n+    u[2].values = np.random.rand(*u[2].values.shape) / 10\\n+\\n     return umat, u\\n \\n \\n@@ -100,12 +108,18 @@ def test_solidbody():\\n             r1 = b.vector(u, **kwargs)\\n             assert r1.shape == (81, 1)\\n \\n+            r1b = b.force\\n+            assert np.allclose(r1.toarray(), r1b.toarray())\\n+\\n             r2 = b.vector(**kwargs)\\n             assert np.allclose(r1.toarray(), r2.toarray())\\n \\n             K1 = b.matrix(u, **kwargs)\\n             assert K1.shape == (81, 81)\\n \\n+            K1b = b.stiffness\\n+            assert np.allclose(K1.toarray(), K1b.toarray())\\n+\\n             K2 = b.matrix(**kwargs)\\n             assert np.allclose(K1.toarray(), K2.toarray())\\n \\n@@ -120,7 +134,6 @@ def test_solidbody():\\n             assert np.allclose(A1, A2)\\n \\n             F1 = b.kinematics\\n-            F2 = b.extract()\\n             F2 = b.extract(u)\\n             assert np.allclose(F1, F2)\\n \\n@@ -158,7 +171,6 @@ def test_solidbody_axi():\\n             assert np.allclose(A1, A2)\\n \\n             F1 = b.kinematics\\n-            F2 = b.extract()\\n             F2 = b.extract(u)\\n             assert np.allclose(F1, F2)\\n \\n@@ -200,7 +212,6 @@ def test_solidbody_mixed():\\n                 assert np.allclose(a1, a2)\\n \\n             F1 = b.kinematics\\n-            F2 = b.extract()\\n             F2 = b.extract(u)\\n             for f1, f2 in zip(F1, F2):\\n                 assert np.allclose(f1, f2)\\n\",\"diff --git a/tests/test_mechanics.py b/tests/test_mechanics.py\\nindex 2cffaa5f..4b734088 100644\\n--- a/tests/test_mechanics.py\\n+++ b/tests/test_mechanics.py\\n@@ -54,6 +54,48 @@ def test_simple():\\n     assert C.shape == (3, 3, 3, 3, 8, 8)\\n \\n \\n+def test_pressure():\\n+\\n+    umat = fe.LinearElastic(E=1, nu=0.3)\\n+\\n+    m = fe.Cube(n=3)\\n+    r = fe.RegionHexahedron(m)\\n+    u = fe.Field(r, dim=3)\\n+\\n+    u.values = np.random.rand(*u.values.shape) / 10\\n+\\n+    s = fe.RegionHexahedronBoundary(m)\\n+    v = fe.Field(s, dim=3)\\n+\\n+    b = fe.SolidBody(umat, u)\\n+    c = fe.SolidBodyPressure(umat, v)\\n+\\n+    r = b.vector()\\n+    K = b.matrix()\\n+    r = b.vector(u)\\n+    F = b.kinematics[0]\\n+    s = b.stress\\n+    C = b.elasticity\\n+\\n+    assert K.shape == (81, 81)\\n+    assert r.shape == (81, 1)\\n+    assert F.shape == (3, 3, 8, 8)\\n+    assert s.shape == (3, 3, 8, 8)\\n+    assert C.shape == (3, 3, 3, 3, 8, 8)\\n+\\n+    r = c.vector()\\n+    K = c.matrix()\\n+    r = c.vector(v)\\n+    F = c.kinematics[0]\\n+\\n+    assert K.shape == (81, 81)\\n+    assert r.shape == (81, 1)\\n+    assert F.shape == (3, 3, 4, 24)\\n+\\n+    c.update(u, v)\\n+    assert np.allclose(u.values, v.values)\\n+\\n+\\n def pre(dim):\\n \\n     umat = fe.NeoHooke(mu=1, bulk=2)\\n@@ -222,3 +264,4 @@ def test_solidbody_mixed():\\n     test_solidbody()\\n     test_solidbody_axi()\\n     test_solidbody_mixed()\\n+    test_pressure()\\n\",\"diff --git a/tests/test_mechanics.py b/tests/test_mechanics.py\\nindex 4b734088..a6632768 100644\\n--- a/tests/test_mechanics.py\\n+++ b/tests/test_mechanics.py\\n@@ -85,7 +85,9 @@ def test_pressure():\\n \\n     r = c.vector()\\n     K = c.matrix()\\n+    K = c.matrix(v, resize=b.matrix())\\n     r = c.vector(v)\\n+    r = c.vector(v, resize=b.vector())\\n     F = c.kinematics[0]\\n \\n     assert K.shape == (81, 81)\\n\",\"diff --git a/tests/test_constitution.py b/tests/test_constitution.py\\nindex 183c53d7..2c3b864c 100644\\n--- a/tests/test_constitution.py\\n+++ b/tests/test_constitution.py\\n@@ -207,9 +207,12 @@ def test_kinematics():\\n \\n         xf = lc.function(F)\\n         xg = lc.gradient(F)\\n+        xg = lc.gradient(F, parallel=parallel)\\n \\n         Yf = ac.function(F, N)\\n+        Yf = ac.function(F, N, parallel=parallel)\\n         Yg = ac.gradient(F, N)\\n+        Yg = ac.gradient(F, N, parallel=parallel)\\n \\n         yf = ac.function(F)\\n         yg = ac.gradient(F)\\n@@ -217,6 +220,7 @@ def test_kinematics():\\n         zf = vc.function(F)\\n         zg = vc.gradient(F)\\n         zh = vc.hessian(F)\\n+        zh = vc.hessian(F, parallel=parallel)\\n \\n         assert np.allclose(xf, F)\\n \\n\",\"diff --git a/tests/test_mechanics.py b/tests/test_mechanics.py\\nindex a6632768..d7b2a414 100644\\n--- a/tests/test_mechanics.py\\n+++ b/tests/test_mechanics.py\\n@@ -44,12 +44,14 @@ def test_simple():\\n     K = b.matrix()\\n     r = b.vector(u)\\n     F = b.kinematics[0]\\n-    s = b.stress\\n+    P = b.stress\\n+    s = b.cauchy_stress()\\n     C = b.elasticity\\n \\n     assert K.shape == (81, 81)\\n     assert r.shape == (81, 1)\\n     assert F.shape == (3, 3, 8, 8)\\n+    assert P.shape == (3, 3, 8, 8)\\n     assert s.shape == (3, 3, 8, 8)\\n     assert C.shape == (3, 3, 3, 3, 8, 8)\\n \\n@@ -68,7 +70,7 @@ def test_pressure():\\n     v = fe.Field(s, dim=3)\\n \\n     b = fe.SolidBody(umat, u)\\n-    c = fe.SolidBodyPressure(umat, v)\\n+    c = fe.SolidBodyPressure(v)\\n \\n     r = b.vector()\\n     K = b.matrix()\\n@@ -180,6 +182,10 @@ def test_solidbody():\\n             F1 = b.kinematics\\n             F2 = b.extract(u)\\n             assert np.allclose(F1, F2)\\n+            \\n+            s1 = b.cauchy_stress()\\n+            s2 = b.cauchy_stress(u)\\n+            assert np.allclose(s1, s2)\\n \\n \\n def test_solidbody_axi():\\n@@ -217,6 +223,10 @@ def test_solidbody_axi():\\n             F1 = b.kinematics\\n             F2 = b.extract(u)\\n             assert np.allclose(F1, F2)\\n+            \\n+            s1 = b.cauchy_stress()\\n+            s2 = b.cauchy_stress(u)\\n+            assert np.allclose(s1, s2)\\n \\n \\n def test_solidbody_mixed():\\n@@ -259,6 +269,10 @@ def test_solidbody_mixed():\\n             F2 = b.extract(u)\\n             for f1, f2 in zip(F1, F2):\\n                 assert np.allclose(f1, f2)\\n+            \\n+            s1 = b.cauchy_stress()\\n+            s2 = b.cauchy_stress(u)\\n+            assert np.allclose(s1, s2)\\n \\n \\n if __name__ == \\\"__main__\\\":\\n\",\"diff --git a/tests/test_mechanics.py b/tests/test_mechanics.py\\nindex d7b2a414..bb54f700 100644\\n--- a/tests/test_mechanics.py\\n+++ b/tests/test_mechanics.py\\n@@ -39,14 +39,14 @@ def test_simple():\\n     u = fe.Field(r, dim=3)\\n \\n     b = fe.SolidBody(umat, u)\\n-    r = b.vector()\\n+    r = b.assemble.vector()\\n \\n-    K = b.matrix()\\n-    r = b.vector(u)\\n-    F = b.kinematics[0]\\n-    P = b.stress\\n-    s = b.cauchy_stress()\\n-    C = b.elasticity\\n+    K = b.assemble.matrix()\\n+    r = b.assemble.vector(u)\\n+    F = b.results.kinematics[0]\\n+    P = b.results.stress\\n+    s = b.evaluate.cauchy_stress()\\n+    C = b.results.elasticity\\n \\n     assert K.shape == (81, 81)\\n     assert r.shape == (81, 1)\\n@@ -72,12 +72,12 @@ def test_pressure():\\n     b = fe.SolidBody(umat, u)\\n     c = fe.SolidBodyPressure(v)\\n \\n-    r = b.vector()\\n-    K = b.matrix()\\n-    r = b.vector(u)\\n-    F = b.kinematics[0]\\n-    s = b.stress\\n-    C = b.elasticity\\n+    r = b.assemble.vector()\\n+    K = b.assemble.matrix()\\n+    r = b.assemble.vector(u)\\n+    F = b.results.kinematics[0]\\n+    s = b.results.stress\\n+    C = b.results.elasticity\\n \\n     assert K.shape == (81, 81)\\n     assert r.shape == (81, 1)\\n@@ -85,12 +85,12 @@ def test_pressure():\\n     assert s.shape == (3, 3, 8, 8)\\n     assert C.shape == (3, 3, 3, 3, 8, 8)\\n \\n-    r = c.vector()\\n-    K = c.matrix()\\n-    K = c.matrix(v, resize=b.matrix())\\n-    r = c.vector(v)\\n-    r = c.vector(v, resize=b.vector())\\n-    F = c.kinematics[0]\\n+    r = c.assemble.vector()\\n+    K = c.assemble.matrix()\\n+    K = c.assemble.matrix(v, resize=b.assemble.matrix())\\n+    r = c.assemble.vector(v)\\n+    r = c.assemble.vector(v, resize=b.assemble.vector())\\n+    F = c.results.kinematics[0]\\n \\n     assert K.shape == (81, 81)\\n     assert r.shape == (81, 1)\\n@@ -151,40 +151,40 @@ def test_solidbody():\\n \\n             kwargs = {\\\"parallel\\\": parallel, \\\"jit\\\": jit}\\n \\n-            r1 = b.vector(u, **kwargs)\\n+            r1 = b.assemble.vector(u, **kwargs)\\n             assert r1.shape == (81, 1)\\n \\n-            r1b = b.force\\n+            r1b = b.results.force\\n             assert np.allclose(r1.toarray(), r1b.toarray())\\n \\n-            r2 = b.vector(**kwargs)\\n+            r2 = b.assemble.vector(**kwargs)\\n             assert np.allclose(r1.toarray(), r2.toarray())\\n \\n-            K1 = b.matrix(u, **kwargs)\\n+            K1 = b.assemble.matrix(u, **kwargs)\\n             assert K1.shape == (81, 81)\\n \\n-            K1b = b.stiffness\\n+            K1b = b.results.stiffness\\n             assert np.allclose(K1.toarray(), K1b.toarray())\\n \\n-            K2 = b.matrix(**kwargs)\\n+            K2 = b.assemble.matrix(**kwargs)\\n             assert np.allclose(K1.toarray(), K2.toarray())\\n \\n-            P1 = b.stress\\n-            P2 = b.gradient()\\n-            P2 = b.gradient(u)\\n+            P1 = b.results.stress\\n+            P2 = b.evaluate.gradient()\\n+            P2 = b.evaluate.gradient(u)\\n             assert np.allclose(P1, P2)\\n \\n-            A1 = b.elasticity\\n-            A2 = b.hessian()\\n-            A2 = b.hessian(u)\\n+            A1 = b.results.elasticity\\n+            A2 = b.evaluate.hessian()\\n+            A2 = b.evaluate.hessian(u)\\n             assert np.allclose(A1, A2)\\n \\n-            F1 = b.kinematics\\n-            F2 = b.extract(u)\\n+            F1 = b.results.kinematics\\n+            F2 = b._extract(u)\\n             assert np.allclose(F1, F2)\\n-            \\n-            s1 = b.cauchy_stress()\\n-            s2 = b.cauchy_stress(u)\\n+\\n+            s1 = b.evaluate.cauchy_stress()\\n+            s2 = b.evaluate.cauchy_stress(u)\\n             assert np.allclose(s1, s2)\\n \\n \\n@@ -198,34 +198,34 @@ def test_solidbody_axi():\\n \\n             kwargs = {\\\"parallel\\\": parallel, \\\"jit\\\": jit}\\n \\n-            r1 = b.vector(u, **kwargs)\\n+            r1 = b.assemble.vector(u, **kwargs)\\n             assert r1.shape == (18, 1)\\n \\n-            r2 = b.vector(**kwargs)\\n+            r2 = b.assemble.vector(**kwargs)\\n             assert np.allclose(r1.toarray(), r2.toarray())\\n \\n-            K1 = b.matrix(u, **kwargs)\\n+            K1 = b.assemble.matrix(u, **kwargs)\\n             assert K1.shape == (18, 18)\\n \\n-            K2 = b.matrix(**kwargs)\\n+            K2 = b.assemble.matrix(**kwargs)\\n             assert np.allclose(K1.toarray(), K2.toarray())\\n \\n-            P1 = b.stress\\n-            P2 = b.gradient()\\n-            P2 = b.gradient(u)\\n+            P1 = b.results.stress\\n+            P2 = b.evaluate.gradient()\\n+            P2 = b.evaluate.gradient(u)\\n             assert np.allclose(P1, P2)\\n \\n-            A1 = b.elasticity\\n-            A2 = b.hessian()\\n-            A2 = b.hessian(u)\\n+            A1 = b.results.elasticity\\n+            A2 = b.evaluate.hessian()\\n+            A2 = b.evaluate.hessian(u)\\n             assert np.allclose(A1, A2)\\n \\n-            F1 = b.kinematics\\n-            F2 = b.extract(u)\\n+            F1 = b.results.kinematics\\n+            F2 = b._extract(u)\\n             assert np.allclose(F1, F2)\\n-            \\n-            s1 = b.cauchy_stress()\\n-            s2 = b.cauchy_stress(u)\\n+\\n+            s1 = b.evaluate.cauchy_stress()\\n+            s2 = b.evaluate.cauchy_stress(u)\\n             assert np.allclose(s1, s2)\\n \\n \\n@@ -239,39 +239,39 @@ def test_solidbody_mixed():\\n \\n             kwargs = {\\\"parallel\\\": parallel, \\\"jit\\\": jit}\\n \\n-            r1 = b.vector(u, **kwargs)\\n-            r1 = b.vector(u, items=3, **kwargs)\\n+            r1 = b.assemble.vector(u, **kwargs)\\n+            r1 = b.assemble.vector(u, items=3, **kwargs)\\n             assert r1.shape == (97, 1)\\n \\n-            r2 = b.vector(**kwargs)\\n+            r2 = b.assemble.vector(**kwargs)\\n             assert np.allclose(r1.toarray(), r2.toarray())\\n \\n-            K1 = b.matrix(u, **kwargs)\\n-            K1 = b.matrix(u, items=6, **kwargs)\\n+            K1 = b.assemble.matrix(u, **kwargs)\\n+            K1 = b.assemble.matrix(u, items=6, **kwargs)\\n             assert K1.shape == (97, 97)\\n \\n-            K2 = b.matrix(**kwargs)\\n+            K2 = b.assemble.matrix(**kwargs)\\n             assert np.allclose(K1.toarray(), K2.toarray())\\n \\n-            P1 = b.stress\\n-            P2 = b.gradient()\\n-            P2 = b.gradient(u)\\n+            P1 = b.results.stress\\n+            P2 = b.evaluate.gradient()\\n+            P2 = b.evaluate.gradient(u)\\n             for p1, p2 in zip(P1, P2):\\n                 assert np.allclose(p1, p2)\\n \\n-            A1 = b.elasticity\\n-            A2 = b.hessian()\\n-            A2 = b.hessian(u)\\n+            A1 = b.results.elasticity\\n+            A2 = b.evaluate.hessian()\\n+            A2 = b.evaluate.hessian(u)\\n             for a1, a2 in zip(A1, A2):\\n                 assert np.allclose(a1, a2)\\n \\n-            F1 = b.kinematics\\n-            F2 = b.extract(u)\\n+            F1 = b.results.kinematics\\n+            F2 = b._extract(u)\\n             for f1, f2 in zip(F1, F2):\\n                 assert np.allclose(f1, f2)\\n-            \\n-            s1 = b.cauchy_stress()\\n-            s2 = b.cauchy_stress(u)\\n+\\n+            s1 = b.evaluate.cauchy_stress()\\n+            s2 = b.evaluate.cauchy_stress(u)\\n             assert np.allclose(s1, s2)\\n \\n \\n\",\"diff --git a/tests/test_constitution.py b/tests/test_constitution.py\\nindex 2c3b864c..925c0b65 100644\\n--- a/tests/test_constitution.py\\n+++ b/tests/test_constitution.py\\n@@ -47,7 +47,7 @@ def pre_mixed(sym, add_identity):\\n     v = fe.Field(r, dim=1)\\n     z = fe.Field(r, dim=1, values=1)\\n     w = fe.FieldMixed((u, v, z))\\n-    return r, w.extract(grad=True, sym=sym, add_identity=add_identity)\\n+    return r, w.extract(grad=True, sym=sym, add_identity=add_identity), m\\n \\n \\n def test_nh():\\n@@ -277,7 +277,7 @@ def hessian(self, x, threads=1):\\n         assert P.shape == (3, 3, *F.shape[-2:])\\n         assert A.shape == (3, 3, 3, 3, *F.shape[-2:])\\n \\n-        r, FpJ = pre_mixed(sym=False, add_identity=True)\\n+        r, FpJ, m = pre_mixed(sym=False, add_identity=True)\\n \\n         umat = fe.MatadiMaterial(\\n             AsMatadi(fe.ThreeFieldVariation(nh, parallel=parallel))\\n@@ -289,6 +289,15 @@ def hessian(self, x, threads=1):\\n         assert P[0].shape == (3, 3, *FpJ[0].shape[-2:])\\n         assert A[0].shape == (3, 3, 3, 3, *FpJ[0].shape[-2:])\\n \\n+        m = fe.Rectangle(n=3)\\n+        r = fe.RegionQuad(m)\\n+        v = fe.FieldsMixed(r, n=3, axisymmetric=True)\\n+        FpJ = v.extract()\\n+        A = umat.hessian(*FpJ)\\n+        K = fe.IntegralFormMixed(A, v, r.dV, v).assemble()\\n+\\n+        assert K.shape == (26, 26)\\n+\\n \\n if __name__ == \\\"__main__\\\":\\n     test_nh()\\n\",\"diff --git a/tests/test_constitution.py b/tests/test_constitution.py\\nindex 925c0b65..9b82777c 100644\\n--- a/tests/test_constitution.py\\n+++ b/tests/test_constitution.py\\n@@ -265,6 +265,13 @@ def hessian(self, x, threads=1):\\n                 if len(x) == 1:\\n                     return [self.material.hessian(*x)]\\n                 else:\\n+                    hess = self.material.hessian(*x)\\n+                    for a in [1, 2]:\\n+                        hess[a].reshape(*hess[a].shape[:-2], 1, 1, *hess[a].shape[-2:])\\n+                    for b in [3, 4, 5]:\\n+                        hess[b].reshape(\\n+                            *hess[b].shape[:-2], 1, 1, 1, *hess[b].shape[-2:]\\n+                        )\\n                     return self.material.hessian(*x)\\n \\n         umat = fe.MatadiMaterial(AsMatadi(nh))\\n\",\"diff --git a/tests/test_mechanics.py b/tests/test_mechanics.py\\nindex bb54f700..1d9b2c62 100644\\n--- a/tests/test_mechanics.py\\n+++ b/tests/test_mechanics.py\\n@@ -61,8 +61,8 @@ def test_pressure():\\n     umat = fe.LinearElastic(E=1, nu=0.3)\\n \\n     m = fe.Cube(n=3)\\n-    r = fe.RegionHexahedron(m)\\n-    u = fe.Field(r, dim=3)\\n+    h = fe.RegionHexahedron(m)\\n+    u = fe.Field(h, dim=3)\\n \\n     u.values = np.random.rand(*u.values.shape) / 10\\n \\n@@ -99,6 +99,12 @@ def test_pressure():\\n     c.update(u, v)\\n     assert np.allclose(u.values, v.values)\\n \\n+    w = fe.FieldsMixed(h)\\n+    w[0].values = np.random.rand(*w[0].values.shape) / 10\\n+\\n+    c.update(w, v)\\n+    assert np.allclose(w[0].values, v.values)\\n+\\n \\n def pre(dim):\\n \\n\",\"diff --git a/README.md b/README.md\\nindex 3feed0b9..1c0c1a51 100644\\n--- a/README.md\\n+++ b/README.md\\n@@ -13,7 +13,7 @@ Install Python, fire up a terminal and run\\n pip install felupe[all]\\n ```\\n \\n-where `[all]` installs all optional dependencies. By default, FElupe does not require `numba` and `sparse`. In order to make use of all features of FElupe, it is suggested to install all optional dependencies.\\n+where `[all]` installs all optional dependencies. By default, FElupe only depends on `numpy` and `scipy`. In order to make use of all features of FElupe, it is suggested to install all optional dependencies.\\n \\n # Hello, FElupe!\\n A quarter model of a solid cube with hyperelastic material behavior is subjected to a uniaxial elongation applied at a clamped end-face. This involves the creation of a mesh, a region and a displacement field. Furthermore, the boundary conditions are created by a template for a uniaxial loadcase. The material behavior is defined through a FElupe-built-in Neo-Hookean material formulation. Inside a Newton-Rhapson procedure, the internal force vector and the tangent stiffness matrix are generated by assembling both linear and bilinear forms of static equilibrium. Finally, the solution of the incremental displacements is calculated und updated until convergence is reached. For more details beside this high-level code snippet, please have a look at the [documentation](https://felupe.readthedocs.io/en/latest/?badge=latest).\\n\",\"diff --git a/tests/test_mesh.py b/tests/test_mesh.py\\nindex 4c9df968..6fcb6f1c 100644\\n--- a/tests/test_mesh.py\\n+++ b/tests/test_mesh.py\\n@@ -142,7 +142,7 @@ def test_meshes():\\n     m.save()\\n \\n     m.cell_type = None\\n-    with pytest.raises(TypeError):\\n+    with pytest.raises(AttributeError):\\n         m.save()\\n \\n \\n\",\"diff --git a/tests/test_mesh.py b/tests/test_mesh.py\\nindex 6fcb6f1c..1b505ae5 100644\\n--- a/tests/test_mesh.py\\n+++ b/tests/test_mesh.py\\n@@ -142,7 +142,7 @@ def test_meshes():\\n     m.save()\\n \\n     m.cell_type = None\\n-    with pytest.raises(AttributeError):\\n+    with pytest.raises(AttributeError) or pytest.raises(KeyError):\\n         m.save()\\n \\n \\n\",\"diff --git a/tests/test_mesh.py b/tests/test_mesh.py\\nindex 1b505ae5..695fd7e5 100644\\n--- a/tests/test_mesh.py\\n+++ b/tests/test_mesh.py\\n@@ -142,7 +142,7 @@ def test_meshes():\\n     m.save()\\n \\n     m.cell_type = None\\n-    with pytest.raises(AttributeError) or pytest.raises(KeyError):\\n+    with pytest.raises(Exception):\\n         m.save()\\n \\n \\n\"]", "hints_text": ""}

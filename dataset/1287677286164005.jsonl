{"instance_id": "1287677286164005", "repo": "td22057/insteon-mqtt", "base_commit": "13d9d39907fde59cc493f17934c879be1202a3e2", "problem_statement": "", "FAIL_TO_PASS": ["tests/handler/test_StandardCmd.py::Test_StandardCmd::test_cmd_from_msg", "tests/handler/test_BroadcastCmdResponse.py::Test_BroadcastCmdResponse::test_cmd_from_msg", "tests/handler/test_DeviceDbGet.py::Test_DeviceDbGet::test_acks", "tests/handler/test_ExtendedCmdResponse.py::Test_ExtendedCmdResponse::test_cmd_from_msg"], "PASS_TO_PASS": ["tests/mqtt/test_Dimmer.py::Test_Dimmer::test_config", "tests/mqtt/test_ThermostatMqtt.py::Test_ThermostatMqtt::test_basic", "tests/device/test_IOLinc.py::Test_IOLinc_Set::test_relay_on[False-Modes.MOMENTARY_A-True-False-0-0]", "tests/db/test_DeviceScanManagerI1.py::Test_Device::test_handle_get_lsb", "tests/mqtt/test_SmokeBridge.py::Test_SmokeBridge::test_mqtt", "tests/mqtt/test_KeypadLinc_sw.py::Test_KeypadLinc_sw::test_config", "tests/test_on_off.py::test_manual_is_valid", "tests/cmd_line/test_util.py::Test_util::test_callback_error", "tests/device/test_IOLinc.py::Test_Handles::test_handle_broadcast[True-17-True-True]", "tests/mqtt/test_MsgTemplate.py::Test_MsgTemplate::test_publish", "tests/mqtt/test_FanLinc.py::Test_FanLinc::test_pubsub", "tests/mqtt/test_Reply.py::Test_Reply::test_end", "tests/db/test_Device.py::Test_Device::test_add_multi_group", "tests/mqtt/test_util.py::Test_util::test_parse_on_off_error", "tests/device/test_IOLinc.py::Test_Handles::test_handle_refresh_sensor[255-True]", "tests/mqtt/test_SmokeBridge.py::Test_SmokeBridge::test_template", "tests/message/test_OutAllLinkCancel.py::Test_OutAllLinkCancel::test_in", "tests/mqtt/test_Dimmer.py::Test_Dimmer::test_pubsub", "tests/test_Signal.py::test_method", "tests/device/test_Thermostat.py::Test_Thermostat::test_basic", "tests/test_Scenes.py::Test_Scenes::test_populate_scenes", "tests/device/test_IOLinc.py::Test_Handles::test_handle_broadcast[False-19-False-None]", "tests/device/test_IOLinc.py::Test_IOLinc_Link_Data::test_link_data[255-255-data_1-True]", "tests/mqtt/test_FanLinc.py::Test_FanLinc::test_input_scene_reason", "tests/test_util.py::Test_util::test_to_hex_limit", "tests/mqtt/test_KeypadLinc_sw.py::Test_KeypadLinc_sw::test_pubsub", "tests/test_config.py::Test_config::test_apply", "tests/device/test_IOLinc.py::Test_IOLinc_Set::test_relay_on[False-Modes.MOMENTARY_A-False-False-0-0]", "tests/test_catalog.py::Test_catalog::test_find_good", "tests/device/test_IOLinc.py::Test_IOLinc_Set::test_set[1-17]", "tests/device/test_IOLinc.py::Test_Handles::test_handle_group_cmd[19-255-Modes.MOMENTARY_C-False-True]", "tests/device/test_IOLinc.py::Test_Handles::test_handle_momentary[1-1-0.1]", "tests/mqtt/test_FanLinc.py::Test_FanLinc::test_config", "tests/db/test_ModemEntry.py::Test_ModemEntry::test_label", "tests/db/test_ModemEntry.py::Test_ModemEntry::test_ctrl", "tests/mqtt/test_Remote.py::Test_Remote::test_template", "tests/db/test_DeviceScanManagerI1.py::Test_Device::test_handle_set_msb", "tests/mqtt/test_KeypadLinc.py::Test_KeypadLinc::test_input_on_off_reason", "tests/device/test_IOLinc.py::Test_IOLinc_Set_Flags::test_set_flags_mode[latching-expected0]", "tests/test_Scenes.py::Test_Scenes::test_merge_by_responders", "tests/device/test_IOLinc.py::Test_IOLinc_Set_Flags::test_set_flags_mode[momentary_a-expected1]", "tests/mqtt/test_Switch.py::Test_Switch::test_mqtt", "tests/test_util.py::Test_util::test_resolve3", "tests/mqtt/test_Outlet.py::Test_Outlet::test_input_on_off_reason", "tests/mqtt/test_KeypadLinc_sw.py::Test_KeypadLinc_sw::test_input_scene", "tests/db/test_DeviceModifyManagerI1.py::Test_Device::test_handle_lsb_response", "tests/cmd_line/test_util.py::Test_util::test_callback_end", "tests/test_Address.py::Test_Address::test_str5", "tests/device/test_IOLinc.py::Test_Handles::test_handle_group_cmd[19-255-Modes.MOMENTARY_C-True-False]", "tests/mqtt/test_util.py::Test_util::test_parse_on_off_basic", "tests/test_on_off.py::test_manual_encode", "tests/mqtt/test_Motion.py::Test_Motion::test_mqtt", "tests/mqtt/test_Remote.py::Test_Remote::test_mqtt", "tests/device/test_IOLinc.py::Test_Handles::test_handle_flags[92-Modes.MOMENTARY_B-True-True]", "tests/message/test_Base.py::Test_Base::test_errors", "tests/test_catalog.py::Test_catalog::test_print", "tests/mqtt/test_KeypadLinc.py::Test_KeypadLinc::test_mqtt", "tests/mqtt/test_Leak.py::Test_Leak::test_config", "tests/test_catalog.py::Test_catalog::test_exists", "tests/mqtt/test_Switch.py::Test_Switch::test_input_scene", "tests/mqtt/test_KeypadLinc.py::Test_KeypadLinc::test_input_scene", "tests/test_Scenes.py::Test_Scenes::test_FanLinc_scenes_same_ramp_rate", "tests/device/test_IOLinc.py::Test_Handles::test_handle_momentary[26-10-26]", "tests/device/test_IOLinc.py::Test_IOLinc_Set_Flags::test_set_flags_other[flag4-expected4]", "tests/mqtt/test_MsgTemplate.py::Test_MsgTemplate::test_render", "tests/test_util.py::Test_util::test_bit_get", "tests/mqtt/test_KeypadLinc.py::Test_KeypadLinc::test_pubsub_same", "tests/device/test_IOLinc.py::Test_IOLinc_Set_Flags::test_set_flags_other[flag0-expected0]", "tests/device/test_IOLinc.py::Test_IOLinc_Set_Flags::test_set_flags_mode[bad-mode-expected4]", "tests/test_Signal.py::test_weakref", "tests/mqtt/test_Dimmer.py::Test_Dimmer::test_mqtt", "tests/mqtt/test_EZIO4O.py::Test_EZIO4O::test_config", "tests/test_Protocol.py::Test_Protocol::test_duplicate", "tests/message/test_Flags.py::Test_DbFlags::test_hops", "tests/test_Scenes.py::Test_Scenes::test_mini_remote_button_config_with_data3", "tests/device/test_IOLinc.py::Test_Handles::test_handle_group_cmd[19-0-Modes.MOMENTARY_C-False-False]", "tests/device/test_IOLinc.py::Test_IOLinc_Simple::test_pair", "tests/device/test_IOLinc.py::Test_Handles::test_handle_momentary[26-100-260]", "tests/message/test_OutAllLinkCancel.py::Test_OutAllLinkCancel::test_out", "tests/message/test_InpExtended.py::Test_InpExtended::test_is_duplicate", "tests/mqtt/test_FanLinc.py::Test_FanLinc::test_fan_template", "tests/mqtt/test_FanLinc.py::Test_FanLinc::test_input_fan_on_off", "tests/device/test_IOLinc.py::Test_Handles::test_handle_flags[12-Modes.MOMENTARY_A-True-False]", "tests/message/test_OutResetPlm.py::Test_OutResetPlm::test_out", "tests/handler/test_StandardCmd.py::Test_StandardCmd::test_engine_version", "tests/mqtt/test_Remote.py::Test_Remote::test_config", "tests/mqtt/test_Switch.py::Test_Switch::test_input_on_off_reason", "tests/test_Address.py::Test_Address::test_addr", "tests/device/test_IOLinc.py::Test_Handles::test_handle_group_cmd[19-0-Modes.MOMENTARY_A-False-True]", "tests/message/test_OutModemLinking.py::Test_OutModemLinking::test_delete", "tests/mqtt/test_Modem.py::Test_Modem::test_input_scene", "tests/mqtt/test_Switch.py::Test_Switch::test_pubsub", "tests/device/test_IOLinc.py::Test_Handles::test_handle_flags[0-Modes.LATCHING-False-False]", "tests/mqtt/test_KeypadLinc.py::Test_KeypadLinc::test_input_scene_reason", "tests/device/test_IOLinc.py::Test_Handles::test_handle_group_cmd[17-None-Modes.LATCHING-False-None]", "tests/device/test_IOLinc.py::Test_IOLinc_Set::test_sensor_on[True-True]", "tests/message/test_Flags.py::Test_DbFlags::test_basic", "tests/device/test_IOLinc.py::Test_IOLinc_Set_Flags::test_set_flags_other[flag2-expected2]", "tests/message/test_OutAllLinkUpdate.py::Test_OutAllLinkUpdate::test_basic", "tests/db/test_ModemEntry.py::Test_ModemEntry::test_resp", "tests/message/test_InpExtended.py::Test_InpExtended::test_basic", "tests/mqtt/test_Leak.py::Test_Leak::test_pubsub", "tests/message/test_InpStandard.py::Test_InpStandard::test_cleanup", "tests/test_Scenes.py::Test_Scenes::test_foreign_hub_group_0", "tests/test_Scenes.py::Test_Scenes::test_Dimmer_scenes_same_ramp_rate", "tests/handler/test_ModemDbGet.py::Test_ModemDbGet::test_acks", "tests/message/test_Timed.py::Test_Timed::test_active", "tests/mqtt/test_Switch.py::Test_Switch::test_config", "tests/mqtt/test_Outlet.py::Test_Outlet::test_pubsub", "tests/test_Address.py::Test_Address::test_id3", "tests/message/test_DblFlags.py::Test_DbFlags::test_copy", "tests/device/test_IOLinc.py::Test_IOLinc_Set::test_relay_on[True-Modes.LATCHING-False-True-0-0]", "tests/db/test_Modem.py::Test_Modem::test_basic", "tests/device/test_IOLinc.py::Test_IOLinc_Set_Flags::test_set_flags_mode[momentary_b-expected2]", "tests/message/test_InpStandard.py::Test_InpStandard::test_basic", "tests/mqtt/test_SmokeBridge.py::Test_SmokeBridge::test_pubsub", "tests/test_Address.py::Test_Address::test_str1", "tests/mqtt/test_IOLincMqtt.py::Test_IOLinc::test_config", "tests/mqtt/test_MsgTemplate.py::Test_MsgTemplate::test_load", "tests/mqtt/test_EZIO4O.py::Test_EZIO4O::test_input_on_off_reason", "tests/device/test_IOLinc.py::Test_IOLinc_Link_Data::test_link_data[0-0-on_off-False]", "tests/mqtt/test_EZIO4O.py::Test_EZIO4O::test_input_on_off", "tests/mqtt/test_KeypadLinc_sw.py::Test_KeypadLinc_sw::test_input_on_off", "tests/test_util.py::Test_util::test_to_hex", "tests/mqtt/test_Outlet.py::Test_Outlet::test_template", "tests/handler/test_StandardCmd.py::Test_StandardCmd::test_input_cmd", "tests/device/test_IOLinc.py::Test_Handles::test_handle_group_cmd[17-255-Modes.MOMENTARY_B-False-True]", "tests/test_Scenes.py::Test_Scenes::test_assign_modem_group", "tests/test_Address.py::Test_Address::test_str3", "tests/mqtt/test_KeypadLinc_sw.py::Test_KeypadLinc_sw::test_mqtt", "tests/handler/test_DeviceDbGet.py::Test_DeviceDbGet::test_recs", "tests/mqtt/test_EZIO4O.py::Test_EZIO4O::test_template", "tests/mqtt/test_Outlet.py::Test_Outlet::test_input_scene_reason", "tests/test_Scenes.py::Test_Scenes::test_KeypadLinc_scenes_different_ramp_rates", "tests/device/test_IOLinc.py::Test_IOLinc_Set_Flags::test_set_flags_other[flag1-expected1]", "tests/db/test_DeviceModifyManagerI1.py::Test_Device::test_handle_set_msb", "tests/message/test_OutExtended.py::Test_OutExtended::test_basic", "tests/mqtt/test_Reply.py::Test_Reply::test_message", "tests/test_Address.py::Test_Address::test_errors", "tests/message/test_OutModemLinking.py::Test_OutModemLinking::test_either", "tests/mqtt/test_KeypadLinc.py::Test_KeypadLinc::test_input_any", "tests/message/test_OutAllLinkGetFirst.py::Test_OutAllLinkGetFirst::test_out", "tests/mqtt/test_Reply.py::Test_Reply::test_error", "tests/mqtt/test_Switch.py::Test_Switch::test_input_scene_reason", "tests/test_Address.py::Test_Address::test_id", "tests/device/test_IOLinc.py::Test_IOLinc_Set_Flags::test_set_flags_other[flag8-expected8]", "tests/test_Scenes.py::Test_Scenes::test_FanLinc_scenes_different_ramp_rates", "tests/test_catalog.py::Test_catalog::test_find_bad", "tests/mqtt/test_Dimmer.py::Test_Dimmer::test_input_on_off_reason", "tests/mqtt/test_BatterySensor.py::Test_BatterySensor::test_template", "tests/db/test_DeviceEntryI1.py::Test_DeviceEntryI1::test_i1", "tests/mqtt/test_IOLincMqtt.py::Test_IOLinc::test_mqtt", "tests/message/test_DblFlags.py::Test_DbFlags::test_basic", "tests/mqtt/test_KeypadLinc.py::Test_KeypadLinc::test_input_level_reason", "tests/test_on_off.py::test_manual_decode", "tests/mqtt/test_Switch.py::Test_Switch::test_template", "tests/test_util.py::Test_util::test_ctrl", "tests/test_Scenes.py::Test_Scenes::test_Dimmer_scenes_different_ramp_rates", "tests/test_Signal.py::test_clear", "tests/device/test_IOLinc.py::Test_IOLinc_Set_Flags::test_set_flags_mode[momentary_c-expected3]", "tests/db/test_DeviceEntry.py::Test_DeviceEntry::test_label", "tests/device/test_IOLinc.py::Test_Handles::test_handle_flags[216-Modes.MOMENTARY_C-False-True]", "tests/device/test_IOLinc.py::Test_Handles::test_handle_broadcast[True-19-False-False]", "tests/test_Scenes.py::Test_Scenes::test_foreign_hub_group_0_and_1", "tests/message/test_OutResetPlm.py::Test_OutResetPlm::test_in", "tests/device/test_IOLinc.py::Test_Handles::test_handle_ack[17-Type.DIRECT_ACK-True]", "tests/test_util.py::Test_util::test_input_choice", "tests/message/test_InpStandard.py::Test_InpStandard::test_broadcast", "tests/mqtt/test_EZIO4O.py::Test_EZIO4O::test_mqtt", "tests/handler/test_ModemDbGet.py::Test_ModemDbGet::test_recs", "tests/mqtt/test_Dimmer.py::Test_Dimmer::test_input_scene", "tests/db/test_DeviceScanManagerI1.py::Test_Device::test_start_scan", "tests/device/test_IOLinc.py::Test_Handles::test_handle_momentary[150-200-3000]", "tests/handler/test_Broadcast.py::Test_Broadcast::test_acks", "tests/message/test_OutModemScene.py::Test_OutModemScene::test_basic", "tests/test_config.py::Test_config::test_multi_error", "tests/device/test_IOLinc.py::Test_Handles::test_handle_group_cmd[255-255-Modes.MOMENTARY_C-True-None]", "tests/device/test_IOLinc.py::Test_Handles::test_handle_broadcast[False-17-True-None]", "tests/test_Scenes.py::Test_Scenes::test_fanlinc_dimmer_ramp_rate_scene", "tests/test_util.py::Test_util::test_input_bool", "tests/mqtt/test_Motion.py::Test_Motion::test_pubsub", "tests/test_Protocol.py::Test_Protocol::test_reads", "tests/message/test_OutStandard.py::Test_OutStandard::test_direct", "tests/test_catalog.py::Test_catalog::test_find_all", "tests/mqtt/test_MsgTemplate.py::Test_MsgTemplate::test_null", "tests/message/test_InpAllLinkStatus.py::Test_InpAllLinkStatus::test_nak", "tests/mqtt/test_FanLinc.py::Test_FanLinc::test_input_fan_on_off_scene", "tests/test_config.py::Test_config::test_multi", "tests/test_on_off.py::test_encode", "tests/mqtt/test_util.py::Test_util::test_parse_on_off_mode", "tests/message/test_InpStandard.py::Test_InpStandard::test_nak_str", "tests/test_Scenes.py::Test_Scenes::test_foreign_hub_set_group_0", "tests/test_Scenes.py::Test_Scenes::test_KeypadLinc_scenes_same_ramp_rate", "tests/device/test_IOLinc.py::Test_IOLinc_Set_Flags::test_set_flags_empty", "tests/device/test_IOLinc.py::Test_Handles::test_handle_group_cmd[17-255-Modes.MOMENTARY_C-True-True]", "tests/test_Scenes.py::Test_Scenes::test_foreign_hub_keypad_button_backlights_scene", "tests/mqtt/test_FanLinc.py::Test_FanLinc::test_input_scene", "tests/mqtt/test_FanLinc.py::Test_FanLinc::test_input_on_off", "tests/device/test_IOLinc.py::Test_Handles::test_handle_refresh_relay[0-False]", "tests/handler/test_StandardCmd.py::Test_StandardCmd::test_any_cmd", "tests/test_on_off.py::test_is_valid", "tests/device/test_IOLinc.py::Test_Handles::test_handle_group_cmd[17-0-Modes.MOMENTARY_A-False-False]", "tests/test_util.py::Test_util::test_bit_set", "tests/mqtt/test_BatterySensor.py::Test_BatterySensor::test_pubsub", "tests/test_on_off.py::test_decode", "tests/db/test_Device.py::Test_Device::test_basic", "tests/device/test_IOLinc.py::Test_Handles::test_handle_group_cmd[17-0-Modes.MOMENTARY_C-False-True]", "tests/mqtt/test_Dimmer.py::Test_Dimmer::test_template", "tests/device/test_IOLinc.py::Test_IOLinc_Set::test_relay_on[True-Modes.MOMENTARY_A-False-True-1-1]", "tests/test_Address.py::Test_Address::test_str2", "tests/test_Signal.py::test_disconnect", "tests/device/test_IOLinc.py::Test_Handles::test_handle_refresh_sensor[0-False]", "tests/device/test_IOLinc.py::Test_IOLinc_Set_Flags::test_set_flags_other[flag3-expected3]", "tests/test_util.py::Test_util::test_callback", "tests/mqtt/test_EZIO4O.py::Test_EZIO4O::test_input_scene", "tests/mqtt/test_IOLincMqtt.py::Test_IOLinc::test_pubsub", "tests/device/test_IOLinc.py::Test_Handles::test_handle_group_cmd[19-255-Modes.MOMENTARY_B-False-True]", "tests/message/test_InpExtended.py::Test_InpExtended::test_broadcast", "tests/message/test_InpAllLinkRec.py::Test_InpAllLinkRec::test_basic", "tests/mqtt/test_util.py::Test_util::test_parse_on_off_fast", "tests/test_Scenes.py::Test_Scenes::test_add_or_update", "tests/message/test_OutModemLinking.py::Test_OutModemLinking::test_controller", "tests/message/test_OutAllLinkGetFirst.py::Test_OutAllLinkGetFirst::test_in", "tests/mqtt/test_EZIO4O.py::Test_EZIO4O::test_input_scene_reason", "tests/mqtt/test_BatterySensor.py::Test_BatterySensor::test_config", "tests/message/test_InpAllLinkStatus.py::Test_InpAllLinkStatus::test_ack", "tests/message/test_OutModemLinking.py::Test_OutModemLinking::test_responder", "tests/device/test_IOLinc.py::Test_IOLinc_Set_Flags::test_set_flags_other[flag6-expected6]", "tests/mqtt/test_KeypadLinc.py::Test_KeypadLinc::test_pubsub", "tests/mqtt/test_KeypadLinc.py::Test_KeypadLinc::test_config", "tests/device/test_IOLinc.py::Test_Handles::test_handle_group_cmd[17-255-Modes.MOMENTARY_C-False-False]", "tests/device/test_IOLinc.py::Test_IOLinc_Set::test_set[0-19]", "tests/message/test_OutStandard.py::Test_OutStandard::test_basic", "tests/mqtt/test_config.py::Test_config::test_find", "tests/mqtt/test_FanLinc.py::Test_FanLinc::test_template", "tests/mqtt/test_Motion.py::Test_Motion::test_config", "tests/test_Scenes.py::Test_Scenes::test_mini_remote_button_config_no_data3", "tests/test_Scenes.py::Test_Scenes::test_bad_config", "tests/device/test_IOLinc.py::Test_Handles::test_handle_momentary[252-250-6300]", "tests/mqtt/test_Leak.py::Test_Leak::test_template", "tests/message/test_Flags.py::Test_DbFlags::test_eq", "tests/message/test_InpStandard.py::Test_InpStandard::test_is_duplicate", "tests/mqtt/test_BatterySensor.py::Test_BatterySensor::test_mqtt", "tests/device/test_IOLinc.py::Test_Handles::test_handle_group_cmd[19-255-Modes.MOMENTARY_A-False-False]", "tests/test_Signal.py::test_func", "tests/message/test_InpAllLinkComplete.py::Test_InpAllLinkComplete::test_delete", "tests/device/test_IOLinc.py::Test_Handles::test_handle_ack[19-Type.DIRECT_ACK-False]", "tests/test_config.py::Test_config::test_errors", "tests/mqtt/test_Switch.py::Test_Switch::test_input_on_off", "tests/message/test_InpAllLinkFailure.py::Test_InpAllLinkFailure::test_basic", "tests/mqtt/test_FanLinc.py::Test_FanLinc::test_input_on_off_reason", "tests/device/test_IOLinc.py::Test_IOLinc_Set::test_sensor_on[False-False]", "tests/mqtt/test_KeypadLinc.py::Test_KeypadLinc::test_input_on_off", "tests/test_util.py::Test_util::test_to_hex_spc", "tests/mqtt/test_Modem.py::Test_Modem::test_template", "tests/mqtt/test_Outlet.py::Test_Outlet::test_input_on_off", "tests/db/test_DeviceModifyManagerI1.py::Test_Device::test_start_modify", "tests/mqtt/test_Dimmer.py::Test_Dimmer::test_input_on_off", "tests/message/test_InpAllLinkComplete.py::Test_InpAllLinkComplete::test_controller", "tests/message/test_Timed.py::Test_Timed::test_send", "tests/test_util.py::Test_util::test_input_byte", "tests/mqtt/test_Dimmer.py::Test_Dimmer::test_input_scene_reason", "tests/test_util.py::Test_util::test_input_integer", "tests/message/test_OutAllLinkGetNext.py::Test_OutAllLinkGetNext::test_out", "tests/mqtt/test_MsgTemplate.py::Test_MsgTemplate::test_clean", "tests/test_Address.py::Test_Address::test_str4", "tests/message/test_InpAllLinkComplete.py::Test_InpAllLinkComplete::test_responder", "tests/device/test_IOLinc.py::Test_Handles::test_handle_broadcast[False-6-None-None]", "tests/device/test_IOLinc.py::Test_Handles::test_handle_group_cmd[17-255-Modes.MOMENTARY_A-False-True]", "tests/test_config.py::Test_config::test_load", "tests/mqtt/test_SmokeBridge.py::Test_SmokeBridge::test_config", "tests/mqtt/test_Remote.py::Test_Remote::test_pubsub", "tests/mqtt/test_Outlet.py::Test_Outlet::test_config", "tests/device/test_IOLinc.py::Test_Handles::test_handle_refresh_relay[255-True]", "tests/mqtt/test_Outlet.py::Test_Outlet::test_mqtt", "tests/device/test_IOLinc.py::Test_IOLinc_Link_Data::test_link_data[255-1-on_off-False]", "tests/device/test_IOLinc.py::Test_IOLinc_Simple::test_refresh", "tests/mqtt/test_MsgTemplate.py::Test_MsgTemplate::test_to_json_error", "tests/device/test_IOLinc.py::Test_IOLinc_Set::test_relay_on[True-Modes.MOMENTARY_A-False-True-1-0]", "tests/message/test_InpUserSetBtn.py::Test_InpUserSetBtn::test_in", "tests/message/test_OutAllLinkGetNext.py::Test_OutAllLinkGetNext::test_in", "tests/device/test_IOLinc.py::Test_Handles::test_handle_group_cmd[19-255-Modes.LATCHING-False-False]", "tests/mqtt/test_KeypadLinc.py::Test_KeypadLinc::test_template", "tests/device/test_IOLinc.py::Test_Handles::test_handle_group_cmd[17-255-Modes.LATCHING-False-True]", "tests/mqtt/test_Modem.py::Test_Modem::test_pubsub", "tests/test_Address.py::Test_Address::test_cmp", "tests/test_Signal.py::test_static", "tests/message/test_InpExtended.py::Test_InpExtended::test_cleanup", "tests/cmd_line/test_util.py::Test_util::test_callback_msg", "tests/mqtt/test_Motion.py::Test_Motion::test_template", "tests/test_config.py::Test_config::test_basic", "tests/mqtt/test_KeypadLinc.py::Test_KeypadLinc::test_input_level", "tests/test_Scenes.py::Test_Scenes::test_set_group", "tests/device/test_IOLinc.py::Test_IOLinc_Set::test_relay_on[False-Modes.MOMENTARY_A-True-False-0-1]", "tests/device/test_IOLinc.py::Test_IOLinc_Set_Flags::test_set_flags_unknown", "tests/mqtt/test_FanLinc.py::Test_FanLinc::test_mqtt", "tests/mqtt/test_IOLincMqtt.py::Test_IOLinc::test_input_on_off", "tests/message/test_OutExtended.py::Test_OutExtended::test_direct", "tests/device/test_IOLinc.py::Test_IOLinc_Set::test_set[255-17]", "tests/mqtt/test_util.py::Test_util::test_parse_on_off_instant", "tests/db/test_DeviceModifyManagerI1.py::Test_Device::test_finish_write", "tests/mqtt/test_IOLincMqtt.py::Test_IOLinc::test_template", "tests/device/test_IOLinc.py::Test_IOLinc_Set_Flags::test_set_flags_other[flag5-expected5]", "tests/mqtt/test_KeypadLinc_sw.py::Test_KeypadLinc_sw::test_template", "tests/mqtt/test_Outlet.py::Test_Outlet::test_input_scene", "tests/mqtt/test_Motion.py::Test_Motion::test_old_config", "tests/mqtt/test_Leak.py::Test_Leak::test_mqtt", "tests/message/test_OutStandard.py::Test_OutStandard::test_size", "tests/device/test_IOLinc.py::Test_IOLinc_Set_Flags::test_set_flags_other[flag7-expected7]", "tests/device/test_IOLinc.py::Test_IOLinc_Simple::test_get_flags", "tests/device/test_IOLinc.py::Test_Handles::test_handle_set_flags", "tests/mqtt/test_EZIO4O.py::Test_EZIO4O::test_pubsub", "tests/mqtt/test_MsgTemplate.py::Test_MsgTemplate::test_to_json", "tests/test_Signal.py::test_multi", "tests/db/test_DeviceEntry.py::Test_DeviceEntry::test_ctrl", "tests/message/test_InpUserReset.py::Test_InpUserReset::test_in"], "language": "python", "test_command": "source /saved/ENV || source /saved/*/ENV && pytest --no-header -rA --tb=no -p no:cacheprovider --continue-on-collection-errors", "test_output_parser": "python/parse_log_pytest_v3", "image_storage_uri": "vmvm-registry.fbinfra.net/repomate_image_activ_pytest/td22057_insteon-mqtt:13d9d39907fde59cc493f17934c879be1202a3e2", "patch": "[\"diff --git a/HISTORY.md b/HISTORY.md\\nindex 52d7c4f..fd402c4 100644\\n--- a/HISTORY.md\\n+++ b/HISTORY.md\\n@@ -1,5 +1,14 @@\\n # Revision Change History\\n \\n+## [0.7.5]\\n+\\n+### Additions\\n+\\n+### Fixes\\n+\\n+- Improved message handling and processing of Pre_NAK messages.\\n+  ([PR 236][P236])\\n+\\n ## [0.7.4]\\n \\n ### Additions\\n@@ -459,3 +468,4 @@ will add new features.\\n [P235]: https://github.com/TD22057/insteon-mqtt/pull/235\\n [P259]: https://github.com/TD22057/insteon-mqtt/pull/259\\n [P234]: https://github.com/TD22057/insteon-mqtt/pull/234\\n+[P236]: https://github.com/TD22057/insteon-mqtt/pull/236\\n\",\"diff --git a/insteon_mqtt/device/Base.py b/insteon_mqtt/device/Base.py\\nindex cae3141..fd29ad6 100644\\n--- a/insteon_mqtt/device/Base.py\\n+++ b/insteon_mqtt/device/Base.py\\n@@ -268,7 +268,7 @@ class Base:\\n         LOG.info(\\\"Join Device %s\\\", self.addr)\\n \\n         # Using a sequence so we can pass the on_done function through.\\n-        seq = CommandSeq(self, \\\"Operation Complete\\\", on_done)\\n+        seq = CommandSeq(self, \\\"Device joined.\\\", on_done)\\n \\n         # First get the engine version.  This process only works and is\\n         # necessary on I2CS devices.\\n@@ -454,7 +454,7 @@ class Base:\\n \\n         # Send the get_engine_version request.\\n         msg = Msg.OutStandard.direct(self.addr, 0x0D, 0x00)\\n-        msg_handler = handler.StandardCmd(msg, self.handle_engine, on_done)\\n+        msg_handler = handler.StandardCmdNAK(msg, self.handle_engine, on_done)\\n         self.send(msg, msg_handler)\\n \\n     #-----------------------------------------------------------------------\\n@@ -1092,11 +1092,7 @@ class Base:\\n                    completed.  Signature is: on_done(success, msg, data)\\n         \\\"\\\"\\\"\\n         on_done = util.make_callback(on_done)\\n-\\n-        if msg.flags.type == Msg.Flags.Type.DIRECT_ACK:\\n-            on_done(True, \\\"Entered linking mode\\\", None)\\n-        else:\\n-            on_done(False, \\\"Linking mode failed\\\", None)\\n+        on_done(True, \\\"Entered linking mode\\\", None)\\n \\n     #-----------------------------------------------------------------------\\n     def _db_update(self, local_group, is_controller, remote_addr, remote_group,\\n\",\"diff --git a/insteon_mqtt/device/Dimmer.py b/insteon_mqtt/device/Dimmer.py\\nindex 0b8008d..db8803b 100644\\n--- a/insteon_mqtt/device/Dimmer.py\\n+++ b/insteon_mqtt/device/Dimmer.py\\n@@ -617,10 +617,7 @@ class Dimmer(Base):\\n           on_done: Finished callback.  This is called when the command has\\n                    completed.  Signature is: on_done(success, msg, data)\\n         \\\"\\\"\\\"\\n-        if msg.flags.type == Msg.Flags.Type.DIRECT_ACK:\\n-            on_done(True, \\\"Backlight level updated\\\", None)\\n-        else:\\n-            on_done(False, \\\"Backlight level failed\\\", None)\\n+        on_done(True, \\\"Backlight level updated\\\", None)\\n \\n     #-----------------------------------------------------------------------\\n     def handle_on_level(self, msg, on_done):\\n@@ -635,10 +632,7 @@ class Dimmer(Base):\\n           on_done: Finished callback.  This is called when the command has\\n                    completed.  Signature is: on_done(success, msg, data)\\n         \\\"\\\"\\\"\\n-        if msg.flags.type == Msg.Flags.Type.DIRECT_ACK:\\n-            on_done(True, \\\"Button on level updated\\\", None)\\n-        else:\\n-            on_done(False, \\\"Button on level failed\\\", None)\\n+        on_done(True, \\\"Button on level updated\\\", None)\\n \\n     #-----------------------------------------------------------------------\\n     def handle_ramp_rate(self, msg, on_done):\\n@@ -764,20 +758,13 @@ class Dimmer(Base):\\n         \\\"\\\"\\\"\\n         # If this it the ACK we're expecting, update the internal state and\\n         # emit our signals.\\n-        if msg.flags.type == Msg.Flags.Type.DIRECT_ACK:\\n-            LOG.debug(\\\"Dimmer %s ACK: %s\\\", self.addr, msg)\\n+        LOG.debug(\\\"Dimmer %s ACK: %s\\\", self.addr, msg)\\n \\n-            _is_on, mode = on_off.Mode.decode(msg.cmd1)\\n-            reason = reason if reason else on_off.REASON_COMMAND\\n-            self._set_level(msg.cmd2, mode, reason)\\n-            on_done(True, \\\"Dimmer state updated to %s\\\" % self._level,\\n-                    msg.cmd2)\\n-\\n-        elif msg.flags.type == Msg.Flags.Type.DIRECT_NAK:\\n-            LOG.error(\\\"Dimmer %s NAK error: %s, Message: %s\\\", self.addr,\\n-                      msg.nak_str(), msg)\\n-            on_done(False, \\\"Dimmer state update failed. \\\" + msg.nak_str(),\\n-                    None)\\n+        _is_on, mode = on_off.Mode.decode(msg.cmd1)\\n+        reason = reason if reason else on_off.REASON_COMMAND\\n+        self._set_level(msg.cmd2, mode, reason)\\n+        on_done(True, \\\"Dimmer state updated to %s\\\" % self._level,\\n+                msg.cmd2)\\n \\n     #-----------------------------------------------------------------------\\n     def handle_scene(self, msg, on_done, reason=\\\"\\\"):\\n@@ -799,21 +786,14 @@ class Dimmer(Base):\\n         # Call the callback.  We don't change state here - the device will\\n         # send a regular broadcast message which will run handle_broadcast\\n         # which will then update the state.\\n-        if msg.flags.type == Msg.Flags.Type.DIRECT_ACK:\\n-            LOG.debug(\\\"Dimmer %s ACK: %s\\\", self.addr, msg)\\n-\\n-            # Reason is device because we're simulating a button press.  We\\n-            # can't really pass this around because we just get a broadcast\\n-            # message later from the device.  So we set a temporary variable\\n-            # here and use it in handle_broadcast() to output the reason.\\n-            self.broadcast_reason = reason if reason else on_off.REASON_DEVICE\\n-            on_done(True, \\\"Scene triggered\\\", None)\\n+        LOG.debug(\\\"Dimmer %s ACK: %s\\\", self.addr, msg)\\n \\n-        elif msg.flags.type == Msg.Flags.Type.DIRECT_NAK:\\n-            LOG.error(\\\"Dimmer %s NAK error: %s, Message: %s\\\", self.addr,\\n-                      msg.nak_str(), msg)\\n-            on_done(False, \\\"Scene trigger failed failed. \\\" + msg.nak_str(),\\n-                    None)\\n+        # Reason is device because we're simulating a button press.  We\\n+        # can't really pass this around because we just get a broadcast\\n+        # message later from the device.  So we set a temporary variable\\n+        # here and use it in handle_broadcast() to output the reason.\\n+        self.broadcast_reason = reason if reason else on_off.REASON_DEVICE\\n+        on_done(True, \\\"Scene triggered\\\", None)\\n \\n     #-----------------------------------------------------------------------\\n     def handle_increment(self, msg, on_done, delta, reason=\\\"\\\"):\\n@@ -835,22 +815,15 @@ class Dimmer(Base):\\n         \\\"\\\"\\\"\\n         # If this it the ACK we're expecting, update the internal state and\\n         # emit our signals.\\n-        if msg.flags.type == Msg.Flags.Type.DIRECT_ACK:\\n-            LOG.debug(\\\"Dimmer %s ACK: %s\\\", self.addr, msg)\\n-\\n-            # Add the delta and bound at [0, 255]\\n-            level = min(self._level + delta, 255)\\n-            level = max(level, 0)\\n-            self._set_level(level, reason=reason)\\n+        LOG.debug(\\\"Dimmer %s ACK: %s\\\", self.addr, msg)\\n \\n-            s = \\\"Dimmer %s state updated to %s\\\" % (self.addr, self._level)\\n-            on_done(True, s, msg.cmd2)\\n+        # Add the delta and bound at [0, 255]\\n+        level = min(self._level + delta, 255)\\n+        level = max(level, 0)\\n+        self._set_level(level, reason=reason)\\n \\n-        elif msg.flags.Dimmer == Msg.Flags.Type.DIRECT_NAK:\\n-            LOG.error(\\\"Dimmer %s NAK error: %s, Message: %s\\\", self.addr,\\n-                      msg.nak_str(), msg)\\n-            on_done(False, \\\"Dimmer %s state update failed. \\\" + msg.nak_str(),\\n-                    None)\\n+        s = \\\"Dimmer %s state updated to %s\\\" % (self.addr, self._level)\\n+        on_done(True, s, msg.cmd2)\\n \\n     #-----------------------------------------------------------------------\\n     def handle_group_cmd(self, addr, msg):\\n\",\"diff --git a/insteon_mqtt/device/FanLinc.py b/insteon_mqtt/device/FanLinc.py\\nindex 0efa94e..be618d8 100644\\n--- a/insteon_mqtt/device/FanLinc.py\\n+++ b/insteon_mqtt/device/FanLinc.py\\n@@ -338,19 +338,12 @@ class FanLinc(Dimmer):\\n \\n         # If this it the ACK we're expecting, update the internal state and\\n         # emit our signals.\\n-        if msg.flags.type == Msg.Flags.Type.DIRECT_ACK:\\n-            LOG.debug(\\\"FanLinc fan %s ACK: %s\\\", self.addr, msg)\\n-\\n-            reason = reason if reason else on_off.REASON_COMMAND\\n-            self._set_fan_speed(msg.cmd2, reason)\\n-            on_done(True, \\\"Fan %s state updated to %s\\\" %\\n-                    (self.addr, self._fan_speed), msg.cmd2)\\n-\\n-        elif msg.flags.type == Msg.Flags.Type.DIRECT_NAK:\\n-            LOG.error(\\\"FanLinc fan %s NAK error: %s, Message: %s\\\", self.addr,\\n-                      msg.nak_str(), msg)\\n-            on_done(False, \\\"Fan %s state update failed. \\\" + msg.nak_str(),\\n-                    None)\\n+        LOG.debug(\\\"FanLinc fan %s ACK: %s\\\", self.addr, msg)\\n+\\n+        reason = reason if reason else on_off.REASON_COMMAND\\n+        self._set_fan_speed(msg.cmd2, reason)\\n+        on_done(True, \\\"Fan %s state updated to %s\\\" %\\n+                (self.addr, self._fan_speed), msg.cmd2)\\n \\n     #-----------------------------------------------------------------------\\n     def handle_group_cmd(self, addr, msg):\\n\",\"diff --git a/insteon_mqtt/device/IOLinc.py b/insteon_mqtt/device/IOLinc.py\\nindex e15b230..e49db79 100644\\n--- a/insteon_mqtt/device/IOLinc.py\\n+++ b/insteon_mqtt/device/IOLinc.py\\n@@ -838,24 +838,18 @@ class IOLinc(Base):\\n                    completed.  Signature is: on_done(success, msg, data)\\n         \\\"\\\"\\\"\\n         # This state is for the relay.\\n-        if msg.flags.type == Msg.Flags.Type.DIRECT_ACK:\\n-            LOG.debug(\\\"IOLinc %s ACK: %s\\\", self.addr, msg)\\n-            on_done(True, \\\"IOLinc command complete\\\", None)\\n+        LOG.debug(\\\"IOLinc %s ACK: %s\\\", self.addr, msg)\\n+        on_done(True, \\\"IOLinc command complete\\\", None)\\n \\n-            # On command.  0x11: on\\n-            if msg.cmd1 == 0x11:\\n-                LOG.info(\\\"IOLinc %s relay ON\\\", self.addr)\\n-                self._set_relay_is_on(True)\\n-\\n-            # Off command. 0x13: off\\n-            elif msg.cmd1 == 0x13:\\n-                LOG.info(\\\"IOLinc %s relay OFF\\\", self.addr)\\n-                self._set_relay_is_on(False)\\n+        # On command.  0x11: on\\n+        if msg.cmd1 == 0x11:\\n+            LOG.info(\\\"IOLinc %s relay ON\\\", self.addr)\\n+            self._set_relay_is_on(True)\\n \\n-        elif msg.flags.type == Msg.Flags.Type.DIRECT_NAK:\\n-            LOG.error(\\\"IOLinc %s NAK error: %s, Message: %s\\\", self.addr,\\n-                      msg.nak_str(), msg)\\n-            on_done(False, \\\"IOLinc command failed. \\\" + msg.nak_str(), None)\\n+        # Off command. 0x13: off\\n+        elif msg.cmd1 == 0x13:\\n+            LOG.info(\\\"IOLinc %s relay OFF\\\", self.addr)\\n+            self._set_relay_is_on(False)\\n \\n     #-----------------------------------------------------------------------\\n     def handle_group_cmd(self, addr, msg):\\n\",\"diff --git a/insteon_mqtt/device/KeypadLinc.py b/insteon_mqtt/device/KeypadLinc.py\\nindex 3bacb1d..bc17ba4 100644\\n--- a/insteon_mqtt/device/KeypadLinc.py\\n+++ b/insteon_mqtt/device/KeypadLinc.py\\n@@ -1197,10 +1197,7 @@ class KeypadLinc(Base):\\n                    completed.  Signature is: on_done(success, msg, data)\\n           task (str):  The message to report.\\n         \\\"\\\"\\\"\\n-        if msg.flags.type == Msg.Flags.Type.DIRECT_ACK:\\n-            on_done(True, \\\"%s updated\\\" % task, None)\\n-        else:\\n-            on_done(False, \\\"%s failed\\\" % task, None)\\n+        on_done(True, \\\"%s updated\\\" % task, None)\\n \\n     #-----------------------------------------------------------------------\\n     def handle_backlight_on(self, msg, on_done, is_on):\\n@@ -1213,11 +1210,8 @@ class KeypadLinc(Base):\\n           is_on (bool): True if the backlight is being turned on, False for\\n                 off.\\n         \\\"\\\"\\\"\\n-        if msg.flags.type == Msg.Flags.Type.DIRECT_ACK:\\n-            on_done(True, \\\"backlight set to %s\\\" % is_on, None)\\n-            self._backlight = is_on\\n-        else:\\n-            on_done(False, \\\"backlight set failed\\\", None)\\n+        on_done(True, \\\"backlight set to %s\\\" % is_on, None)\\n+        self._backlight = is_on\\n \\n     #-----------------------------------------------------------------------\\n     def handle_refresh(self, msg):\\n@@ -1265,27 +1259,20 @@ class KeypadLinc(Base):\\n         \\\"\\\"\\\"\\n         # If this is the ACK we're expecting, update the internal state and\\n         # emit our signals.\\n-        if msg.flags.type == Msg.Flags.Type.DIRECT_ACK:\\n-            LOG.debug(\\\"KeypadLinc LED %s group %s ACK: %s\\\", self.addr, group,\\n-                      msg)\\n-\\n-            # Update the LED bit for the updated group.\\n-            self._led_bits = led_bits\\n-            LOG.ui(\\\"KeypadLinc %s LED's changed to %s\\\", self.addr,\\n-                   \\\"{:08b}\\\".format(self._led_bits))\\n+        LOG.debug(\\\"KeypadLinc LED %s group %s ACK: %s\\\", self.addr, group,\\n+                  msg)\\n \\n-            # Change the level and emit the active signal.\\n-            self._set_level(group, 0xff if is_on else 0x00, reason=reason)\\n+        # Update the LED bit for the updated group.\\n+        self._led_bits = led_bits\\n+        LOG.ui(\\\"KeypadLinc %s LED's changed to %s\\\", self.addr,\\n+               \\\"{:08b}\\\".format(self._led_bits))\\n \\n-            msg = \\\"KeypadLinc %s LED group %s updated to %s\\\" % \\\\\\n-                  (self.addr, group, is_on)\\n-            on_done(True, msg, is_on)\\n+        # Change the level and emit the active signal.\\n+        self._set_level(group, 0xff if is_on else 0x00, reason=reason)\\n \\n-        elif msg.flags.type == Msg.Flags.Type.DIRECT_NAK:\\n-            LOG.error(\\\"KeypadLinc LED %s NAK error: %s, Message: %s\\\",\\n-                      self.addr, msg.nak_str(), msg)\\n-            on_done(False, \\\"KeypadLinc %s LED update failed. \\\" + msg.nak_str(),\\n-                    None)\\n+        msg = \\\"KeypadLinc %s LED group %s updated to %s\\\" % \\\\\\n+              (self.addr, group, is_on)\\n+        on_done(True, msg, is_on)\\n \\n     #-----------------------------------------------------------------------\\n     def handle_load_attach(self, msg, on_done, is_attached):\\n@@ -1299,20 +1286,15 @@ class KeypadLinc(Base):\\n         \\\"\\\"\\\"\\n         # If this it the ACK we're expecting, update the internal state and\\n         # emit our signals.\\n-        if msg.flags.type == Msg.Flags.Type.DIRECT_ACK:\\n-            LOG.debug(\\\"KeypadLinc %s ACK: %s\\\", self.addr, msg)\\n-            if is_attached:\\n-                self._load_group = 1\\n-            else:\\n-                self._load_group = 9\\n-\\n-            LOG.ui(\\\"Keypadlinc %s, setting load to group %s\\\", self.addr,\\n-                   self._load_group)\\n-            on_done(True, \\\"Load set to group: %s\\\" % self._load_group, None)\\n+        LOG.debug(\\\"KeypadLinc %s ACK: %s\\\", self.addr, msg)\\n+        if is_attached:\\n+            self._load_group = 1\\n+        else:\\n+            self._load_group = 9\\n \\n-        elif msg.flags.type == Msg.Flags.Type.DIRECT_NAK:\\n-            LOG.error(\\\"KeypadLinc %s NAK error: %s\\\", self.addr, msg)\\n-            on_done(False, \\\"Changing the load group failed\\\", None)\\n+        LOG.ui(\\\"Keypadlinc %s, setting load to group %s\\\", self.addr,\\n+               self._load_group)\\n+        on_done(True, \\\"Load set to group: %s\\\" % self._load_group, None)\\n \\n     #-----------------------------------------------------------------------\\n     def handle_refresh_led(self, msg):\\n@@ -1505,17 +1487,12 @@ class KeypadLinc(Base):\\n         \\\"\\\"\\\"\\n         # If this is the ACK we're expecting, update the internal state and\\n         # emit our signals.\\n-        if msg.flags.type == Msg.Flags.Type.DIRECT_ACK:\\n-            LOG.debug(\\\"KeypadLinc %s ACK: %s\\\", self.addr, msg)\\n-\\n-            _is_on, mode = on_off.Mode.decode(msg.cmd1)\\n-            self._set_level(self._load_group, msg.cmd2, mode, reason)\\n-            on_done(True, \\\"KeypadLinc state updated to %s\\\" % self._level,\\n-                    msg.cmd2)\\n+        LOG.debug(\\\"KeypadLinc %s ACK: %s\\\", self.addr, msg)\\n \\n-        elif msg.flags.type == Msg.Flags.Type.DIRECT_NAK:\\n-            LOG.error(\\\"KeypadLinc %s NAK error: %s\\\", self.addr, msg)\\n-            on_done(False, \\\"KeypadLinc state update failed\\\", None)\\n+        _is_on, mode = on_off.Mode.decode(msg.cmd1)\\n+        self._set_level(self._load_group, msg.cmd2, mode, reason)\\n+        on_done(True, \\\"KeypadLinc state updated to %s\\\" % self._level,\\n+                msg.cmd2)\\n \\n     #-----------------------------------------------------------------------\\n     def handle_scene(self, msg, on_done, reason=\\\"\\\"):\\n@@ -1537,19 +1514,14 @@ class KeypadLinc(Base):\\n         # Call the callback.  We don't change state here - the device will\\n         # send a regular broadcast message which will run handle_broadcast\\n         # which will then update the state.\\n-        if msg.flags.type == Msg.Flags.Type.DIRECT_ACK:\\n-            LOG.debug(\\\"KeypadLinc %s ACK: %s\\\", self.addr, msg)\\n+        LOG.debug(\\\"KeypadLinc %s ACK: %s\\\", self.addr, msg)\\n \\n-            # Reason is device because we're simulating a button press.  We\\n-            # can't really pass this around because we just get a broadcast\\n-            # message later from the device.  So we set a temporary variable\\n-            # here and use it in handle_broadcast() to output the reason.\\n-            self.broadcast_reason = reason if reason else on_off.REASON_DEVICE\\n-            on_done(True, \\\"Scene triggered\\\", None)\\n-\\n-        elif msg.flags.type == Msg.Flags.Type.DIRECT_NAK:\\n-            LOG.error(\\\"KeypadLinc %s NAK error: %s\\\", self.addr, msg)\\n-            on_done(False, \\\"Scene trigger failed failed\\\", None)\\n+        # Reason is device because we're simulating a button press.  We\\n+        # can't really pass this around because we just get a broadcast\\n+        # message later from the device.  So we set a temporary variable\\n+        # here and use it in handle_broadcast() to output the reason.\\n+        self.broadcast_reason = reason if reason else on_off.REASON_DEVICE\\n+        on_done(True, \\\"Scene triggered\\\", None)\\n \\n     #-----------------------------------------------------------------------\\n     def handle_increment(self, msg, on_done, delta, reason=\\\"\\\"):\\n@@ -1570,20 +1542,15 @@ class KeypadLinc(Base):\\n         \\\"\\\"\\\"\\n         # If this it the ACK we're expecting, update the internal state and\\n         # emit our signals.\\n-        if msg.flags.type == Msg.Flags.Type.DIRECT_ACK:\\n-            LOG.debug(\\\"KeypadLinc %s ACK: %s\\\", self.addr, msg)\\n-\\n-            # Add the delta and bound at [0, 255]\\n-            level = min(self._level + delta, 255)\\n-            level = max(level, 0)\\n-            self._set_level(self._load_group, level, reason=reason)\\n+        LOG.debug(\\\"KeypadLinc %s ACK: %s\\\", self.addr, msg)\\n \\n-            s = \\\"KeypadLinc %s state updated to %s\\\" % (self.addr, self._level)\\n-            on_done(True, s, msg.cmd2)\\n+        # Add the delta and bound at [0, 255]\\n+        level = min(self._level + delta, 255)\\n+        level = max(level, 0)\\n+        self._set_level(self._load_group, level, reason=reason)\\n \\n-        elif msg.flags.type == Msg.Flags.Type.DIRECT_NAK:\\n-            LOG.error(\\\"KeypadLinc %s NAK error: %s\\\", self.addr, msg)\\n-            on_done(False, \\\"KeypadLinc %s state update failed\\\", None)\\n+        s = \\\"KeypadLinc %s state updated to %s\\\" % (self.addr, self._level)\\n+        on_done(True, s, msg.cmd2)\\n \\n     #-----------------------------------------------------------------------\\n     def handle_group_cmd(self, addr, msg):\\n\",\"diff --git a/insteon_mqtt/device/Outlet.py b/insteon_mqtt/device/Outlet.py\\nindex 2e136f2..c1dbc7a 100644\\n--- a/insteon_mqtt/device/Outlet.py\\n+++ b/insteon_mqtt/device/Outlet.py\\n@@ -435,10 +435,7 @@ class Outlet(Base):\\n           on_done: Finished callback.  This is called when the command has\\n                    completed.  Signature is: on_done(success, msg, data)\\n         \\\"\\\"\\\"\\n-        if msg.flags.type == Msg.Flags.Type.DIRECT_ACK:\\n-            on_done(True, \\\"Backlight level updated\\\", None)\\n-        else:\\n-            on_done(False, \\\"Backlight level failed\\\", None)\\n+        on_done(True, \\\"Backlight level updated\\\", None)\\n \\n     #-----------------------------------------------------------------------\\n     def handle_broadcast(self, msg):\\n@@ -563,18 +560,13 @@ class Outlet(Base):\\n \\n         # If this it the ACK we're expecting, update the internal\\n         # state and emit our signals.\\n-        if msg.flags.type == Msg.Flags.Type.DIRECT_ACK:\\n-            LOG.debug(\\\"Outlet %s grp: %s ACK: %s\\\", self.addr, group, msg)\\n-\\n-            is_on, mode = on_off.Mode.decode(msg.cmd1)\\n-            reason = reason if reason else on_off.REASON_COMMAND\\n-            self._set_is_on(group, is_on, mode, reason)\\n-            on_done(True, \\\"Outlet state updated to on=%s\\\" % self._is_on,\\n-                    self._is_on)\\n+        LOG.debug(\\\"Outlet %s grp: %s ACK: %s\\\", self.addr, group, msg)\\n \\n-        elif msg.flags.type == Msg.Flags.Type.DIRECT_NAK:\\n-            LOG.error(\\\"Outlet %s NAK error: %s\\\", self.addr, msg)\\n-            on_done(False, \\\"Outlet state update failed\\\", None)\\n+        is_on, mode = on_off.Mode.decode(msg.cmd1)\\n+        reason = reason if reason else on_off.REASON_COMMAND\\n+        self._set_is_on(group, is_on, mode, reason)\\n+        on_done(True, \\\"Outlet state updated to on=%s\\\" % self._is_on,\\n+                self._is_on)\\n \\n     #-----------------------------------------------------------------------\\n     def handle_scene(self, msg, on_done, reason=\\\"\\\"):\\n@@ -596,20 +588,14 @@ class Outlet(Base):\\n         # Call the callback.  We don't change state here - the device will\\n         # send a regular broadcast message which will run handle_broadcast\\n         # which will then update the state.\\n-        if msg.flags.type == Msg.Flags.Type.DIRECT_ACK:\\n-            LOG.debug(\\\"Outlet %s ACK: %s\\\", self.addr, msg)\\n-\\n-            # Reason is device because we're simulating a button press.  We\\n-            # can't really pass this around because we just get a broadcast\\n-            # message later from the device.  So we set a temporary variable\\n-            # here and use it in handle_broadcast() to output the reason.\\n-            self.broadcast_reason = reason if reason else on_off.REASON_DEVICE\\n-            on_done(True, \\\"Scene triggered\\\", None)\\n-\\n-        elif msg.flags.type == Msg.Flags.Type.DIRECT_NAK:\\n-            LOG.error(\\\"Outlet %s NAK error: %s\\\", self.addr, msg)\\n-            self.broadcast_reason = None\\n-            on_done(False, \\\"Scene trigger failed failed\\\", None)\\n+        LOG.debug(\\\"Outlet %s ACK: %s\\\", self.addr, msg)\\n+\\n+        # Reason is device because we're simulating a button press.  We\\n+        # can't really pass this around because we just get a broadcast\\n+        # message later from the device.  So we set a temporary variable\\n+        # here and use it in handle_broadcast() to output the reason.\\n+        self.broadcast_reason = reason if reason else on_off.REASON_DEVICE\\n+        on_done(True, \\\"Scene triggered\\\", None)\\n \\n     #-----------------------------------------------------------------------\\n     def handle_group_cmd(self, addr, msg):\\n\",\"diff --git a/insteon_mqtt/device/Switch.py b/insteon_mqtt/device/Switch.py\\nindex 20d51fb..23822f0 100644\\n--- a/insteon_mqtt/device/Switch.py\\n+++ b/insteon_mqtt/device/Switch.py\\n@@ -366,10 +366,7 @@ class Switch(Base):\\n           on_done: Finished callback.  This is called when the command has\\n                    completed.  Signature is: on_done(success, msg, data)\\n         \\\"\\\"\\\"\\n-        if msg.flags.type == Msg.Flags.Type.DIRECT_ACK:\\n-            on_done(True, \\\"Backlight level updated\\\", None)\\n-        else:\\n-            on_done(False, \\\"Backlight level failed\\\", None)\\n+        on_done(True, \\\"Backlight level updated\\\", None)\\n \\n     #-----------------------------------------------------------------------\\n     def handle_broadcast(self, msg):\\n@@ -477,20 +474,13 @@ class Switch(Base):\\n         \\\"\\\"\\\"\\n         # If this it the ACK we're expecting, update the internal state and\\n         # emit our signals.\\n-        if msg.flags.type == Msg.Flags.Type.DIRECT_ACK:\\n-            LOG.debug(\\\"Switch %s ACK: %s\\\", self.addr, msg)\\n-\\n-            is_on, mode = on_off.Mode.decode(msg.cmd1)\\n-            reason = reason if reason else on_off.REASON_COMMAND\\n-            self._set_is_on(is_on, mode, reason)\\n-            on_done(True, \\\"Switch state updated to on=%s\\\" % self._is_on,\\n-                    self._is_on)\\n+        LOG.debug(\\\"Switch %s ACK: %s\\\", self.addr, msg)\\n \\n-        elif msg.flags.type == Msg.Flags.Type.DIRECT_NAK:\\n-            LOG.error(\\\"Switch %s NAK error: %s, Message: %s\\\", self.addr,\\n-                      msg.nak_str(), msg)\\n-            on_done(False, \\\"Switch state update failed. \\\" + msg.nak_str(),\\n-                    None)\\n+        is_on, mode = on_off.Mode.decode(msg.cmd1)\\n+        reason = reason if reason else on_off.REASON_COMMAND\\n+        self._set_is_on(is_on, mode, reason)\\n+        on_done(True, \\\"Switch state updated to on=%s\\\" % self._is_on,\\n+                self._is_on)\\n \\n     #-----------------------------------------------------------------------\\n     def handle_scene(self, msg, on_done, reason=\\\"\\\"):\\n@@ -512,22 +502,14 @@ class Switch(Base):\\n         # Call the callback.  We don't change state here - the device will\\n         # send a regular broadcast message which will run handle_broadcast\\n         # which will then update the state.\\n-        if msg.flags.type == Msg.Flags.Type.DIRECT_ACK:\\n-            LOG.debug(\\\"Switch %s ACK: %s\\\", self.addr, msg)\\n-\\n-            # Reason is device because we're simulating a button press.  We\\n-            # can't really pass this around because we just get a broadcast\\n-            # message later from the device.  So we set a temporary variable\\n-            # here and use it in handle_broadcast() to output the reason.\\n-            self.broadcast_reason = reason if reason else on_off.REASON_DEVICE\\n-            on_done(True, \\\"Scene triggered\\\", None)\\n-\\n-        elif msg.flags.type == Msg.Flags.Type.DIRECT_NAK:\\n-            LOG.error(\\\"Switch %s NAK error: %s, Message: %s\\\", self.addr,\\n-                      msg.nak_str(), msg)\\n-            self.broadcast_reason = None\\n-            on_done(False, \\\"Scene trigger failed failed. \\\" + msg.nak_str(),\\n-                    None)\\n+        LOG.debug(\\\"Switch %s ACK: %s\\\", self.addr, msg)\\n+\\n+        # Reason is device because we're simulating a button press.  We\\n+        # can't really pass this around because we just get a broadcast\\n+        # message later from the device.  So we set a temporary variable\\n+        # here and use it in handle_broadcast() to output the reason.\\n+        self.broadcast_reason = reason if reason else on_off.REASON_DEVICE\\n+        on_done(True, \\\"Scene triggered\\\", None)\\n \\n     #-----------------------------------------------------------------------\\n     def handle_group_cmd(self, addr, msg):\\n\",\"diff --git a/insteon_mqtt/device/Thermostat.py b/insteon_mqtt/device/Thermostat.py\\nindex a31736f..dbe7940 100644\\n--- a/insteon_mqtt/device/Thermostat.py\\n+++ b/insteon_mqtt/device/Thermostat.py\\n@@ -454,14 +454,8 @@ class Thermostat(Base):\\n         \\\"\\\"\\\"\\n         on_done = util.make_callback(on_done)\\n \\n-        if msg.flags.type == Msg.Flags.Type.DIRECT_NAK:\\n-            LOG.error(\\\"%s NAK: %s, Message: %s\\\", self.db.addr, msg.nak_str(),\\n-                      msg)\\n-            on_done(False, \\\"Thermostat command NAK. \\\" + msg.nak_str(), None)\\n-\\n-        else:\\n-            LOG.debug(\\\"Thermostat %s generic ack recevied\\\", self.addr)\\n-            on_done(True, \\\"Thermostat generic ack recevied\\\", None)\\n+        LOG.debug(\\\"Thermostat %s generic ack recevied\\\", self.addr)\\n+        on_done(True, \\\"Thermostat generic ack recevied\\\", None)\\n \\n     #-----------------------------------------------------------------------\\n     def handle_broadcast(self, msg):\\n@@ -538,13 +532,7 @@ class Thermostat(Base):\\n         \\\"\\\"\\\"\\n         on_done = util.make_callback(on_done)\\n \\n-        if msg.flags.type == Msg.Flags.Type.DIRECT_NAK:\\n-            LOG.error(\\\"%s mode command NAK: %s, Message: %s\\\", self.db.addr,\\n-                      msg.nak_str(), msg)\\n-            on_done(False, \\\"Thermostat mode command NAK. \\\" + msg.nak_str(),\\n-                    None)\\n-\\n-        elif msg.cmd1 == 0x6b:\\n+        if msg.cmd1 == 0x6b:\\n             self.signal_mode_change.emit(self,\\n                                          Thermostat.ModeCommands(msg.cmd2))\\n             on_done(True, \\\"Thermostat recevied mode command\\\", None)\\n@@ -586,13 +574,7 @@ class Thermostat(Base):\\n         \\\"\\\"\\\"\\n         on_done = util.make_callback(on_done)\\n \\n-        if msg.flags.type == Msg.Flags.Type.DIRECT_NAK:\\n-            LOG.error(\\\"%s fan command NAK: %s, Message: %s\\\", self.db.addr,\\n-                      msg.nak_str(), msg)\\n-            on_done(False, \\\"Thermostat fan command NAK. \\\" + msg.nak_str(),\\n-                    None)\\n-\\n-        elif msg.cmd1 == 0x6b:\\n+        if msg.cmd1 == 0x6b:\\n             self.signal_fan_mode_change.emit(self,\\n                                              Thermostat.FanCommands(msg.cmd2))\\n             on_done(True, \\\"Thermostat recevied fan mode command\\\", None)\\n\",\"diff --git a/insteon_mqtt/handler/BroadcastCmdResponse.py b/insteon_mqtt/handler/BroadcastCmdResponse.py\\nindex ef0e412..865f2b5 100644\\n--- a/insteon_mqtt/handler/BroadcastCmdResponse.py\\n+++ b/insteon_mqtt/handler/BroadcastCmdResponse.py\\n@@ -60,9 +60,9 @@ class BroadcastCmdResponse(Base):\\n             # waiting for a reply.\\n             if msg.to_addr == self.addr and msg.cmd1 == self.cmd:\\n                 if not msg.is_ack:\\n-                    LOG.error(\\\"%s NAK response\\\", self.addr)\\n-\\n-                LOG.debug(\\\"%s got msg ACK\\\", self.addr)\\n+                    LOG.warning(\\\"%s PLM NAK response\\\", self.addr)\\n+                else:\\n+                    LOG.debug(\\\"%s got PLM ACK\\\", self.addr)\\n                 return Msg.CONTINUE\\n \\n             # Message didn't match the expected addr/cmd.\\n@@ -82,9 +82,17 @@ class BroadcastCmdResponse(Base):\\n                 return Msg.CONTINUE\\n \\n             elif msg.flags.type == Msg.Flags.Type.DIRECT_NAK:\\n-                LOG.error(\\\"%s device NAK error: %s\\\", msg.from_addr, msg)\\n-                self.on_done(False, \\\"Device command NAK\\\", None)\\n-                return Msg.FINISHED\\n+                if msg.cmd2 == msg.NakType.PRE_NAK:\\n+                    # This is a \\\"Pre NAK in case database search takes\\n+                    # too long\\\".  This happens when the device database is\\n+                    # large.  Just ignore it, add more wait time and wait.\\n+                    LOG.warning(\\\"%s Pre-NAK: %s, Message: %s\\\", msg.from_addr,\\n+                                msg.nak_str(), msg)\\n+                    return Msg.CONTINUE\\n+                else:\\n+                    LOG.error(\\\"%s device NAK error: %s\\\", msg.from_addr, msg)\\n+                    self.on_done(False, \\\"Device command NAK\\\", None)\\n+                    return Msg.FINISHED\\n \\n             else:\\n                 LOG.warning(\\\"%s device unexpected msg: %s\\\", msg.from_addr, msg)\\n\",\"diff --git a/insteon_mqtt/handler/DeviceDbGet.py b/insteon_mqtt/handler/DeviceDbGet.py\\nindex 507d46b..f9a84cc 100644\\n--- a/insteon_mqtt/handler/DeviceDbGet.py\\n+++ b/insteon_mqtt/handler/DeviceDbGet.py\\n@@ -83,7 +83,7 @@ class DeviceDbGet(Base):\\n         if isinstance(msg, (Msg.OutExtended, Msg.OutStandard)):\\n             if msg.to_addr == self.db.addr and msg.cmd1 == 0x2f:\\n                 if not msg.is_ack:\\n-                    LOG.error(\\\"%s NAK response\\\", self.db.addr)\\n+                    LOG.warning(\\\"%s PLM NAK response\\\", self.db.addr)\\n                 return Msg.CONTINUE\\n \\n             return Msg.UNKNOWN\\n@@ -103,11 +103,19 @@ class DeviceDbGet(Base):\\n                 return Msg.CONTINUE\\n \\n             elif msg.flags.type == Msg.Flags.Type.DIRECT_NAK:\\n-                LOG.error(\\\"%s device NAK error: %s, Message: %s\\\",\\n-                          msg.from_addr, msg.nak_str(), msg)\\n-                self.on_done(False, \\\"Database command NAK. \\\" + msg.nak_str(),\\n-                             None)\\n-                return Msg.FINISHED\\n+                if msg.cmd2 == msg.NakType.PRE_NAK:\\n+                    # This is a \\\"Pre NAK in case database search takes\\n+                    # too long\\\".  This happens when the device database is\\n+                    # large.  Just ignore it, add more wait time and wait.\\n+                    LOG.warning(\\\"%s Pre-NAK: %s, Message: %s\\\", msg.from_addr,\\n+                                msg.nak_str(), msg)\\n+                    return Msg.CONTINUE\\n+                else:\\n+                    LOG.error(\\\"%s device NAK error: %s, Message: %s\\\",\\n+                              msg.from_addr, msg.nak_str(), msg)\\n+                    self.on_done(False, \\\"Database command NAK. \\\" +\\n+                                 msg.nak_str(), None)\\n+                    return Msg.FINISHED\\n \\n             else:\\n                 LOG.warning(\\\"%s device unexpected msg: %s\\\", msg.from_addr, msg)\\n\",\"diff --git a/insteon_mqtt/handler/DeviceDbModify.py b/insteon_mqtt/handler/DeviceDbModify.py\\nindex 60ef897..8d0ad5f 100644\\n--- a/insteon_mqtt/handler/DeviceDbModify.py\\n+++ b/insteon_mqtt/handler/DeviceDbModify.py\\n@@ -78,10 +78,18 @@ class DeviceDbModify(Base):\\n                                  self.entry)\\n \\n                 elif msg.flags.type == Msg.Flags.Type.DIRECT_NAK:\\n-                    LOG.error(\\\"%s db mod NAK: %s, Message: %s\\\", self.db.addr,\\n-                              msg.nak_str(), msg)\\n-                    self.on_done(False, \\\"Device database update failed. \\\" +\\n-                                 msg.nak_str(), None)\\n+                    if msg.cmd2 == msg.NakType.PRE_NAK:\\n+                        # This is a \\\"Pre NAK in case database search takes\\n+                        # too long\\\".  This happens when the device database is\\n+                        # large.  Just ignore it, add more wait time and wait.\\n+                        LOG.warning(\\\"%s Pre-NAK: %s, Message: %s\\\",\\n+                                    self.db.addr, msg.nak_str(), msg)\\n+                        return Msg.CONTINUE\\n+                    else:\\n+                        LOG.error(\\\"%s db mod NAK: %s, Message: %s\\\",\\n+                                  self.db.addr, msg.nak_str(), msg)\\n+                        self.on_done(False, \\\"Device database update failed. \\\" +\\n+                                     msg.nak_str(), None)\\n \\n                 else:\\n                     LOG.error(\\\"%s db mod unexpected msg type: %s\\\",\\n\",\"diff --git a/insteon_mqtt/handler/DeviceRefresh.py b/insteon_mqtt/handler/DeviceRefresh.py\\nindex 86464ec..6cc3ec9 100644\\n--- a/insteon_mqtt/handler/DeviceRefresh.py\\n+++ b/insteon_mqtt/handler/DeviceRefresh.py\\n@@ -69,12 +69,11 @@ class DeviceRefresh(Base):\\n         # Probably an echo back of our sent message.\\n         if isinstance(msg, Msg.OutStandard) and msg.to_addr == self.addr:\\n             if msg.is_ack:\\n-                LOG.debug(\\\"%s ACK response\\\", self.addr)\\n+                LOG.debug(\\\"%s PLM ACK response\\\", self.addr)\\n                 return Msg.CONTINUE\\n             else:\\n-                LOG.error(\\\"%s NAK response\\\", self.addr)\\n-                self.on_done(False, \\\"NAK response\\\", None)\\n-                return Msg.FINISHED\\n+                LOG.warning(\\\"%s PLM NAK response\\\", self.addr)\\n+                return Msg.CONTINUE\\n \\n         # See if this is the standard message ack/nak we're expecting.\\n         elif isinstance(msg, Msg.InpStandard) and msg.from_addr == self.addr:\\n\",\"diff --git a/insteon_mqtt/handler/ExtendedCmdResponse.py b/insteon_mqtt/handler/ExtendedCmdResponse.py\\nindex 1f064e4..9b7c50f 100644\\n--- a/insteon_mqtt/handler/ExtendedCmdResponse.py\\n+++ b/insteon_mqtt/handler/ExtendedCmdResponse.py\\n@@ -71,7 +71,7 @@ class ExtendedCmdResponse(Base):\\n         if isinstance(msg, (Msg.OutExtended, Msg.OutStandard)):\\r\\n             if msg.to_addr == self.addr and msg.cmd1 == self.cmd:\\r\\n                 if not msg.is_ack:\\r\\n-                    LOG.error(\\\"%s NAK response\\\", self.addr)\\r\\n+                    LOG.warning(\\\"%s PLM NAK response\\\", self.addr)\\r\\n                 return Msg.CONTINUE\\r\\n \\r\\n             return Msg.UNKNOWN\\r\\n@@ -88,11 +88,19 @@ class ExtendedCmdResponse(Base):\\n                 return Msg.CONTINUE\\r\\n \\r\\n             elif msg.flags.type == Msg.Flags.Type.DIRECT_NAK:\\r\\n-                LOG.error(\\\"%s device NAK error: %s, Message: %s\\\",\\r\\n-                          msg.from_addr, msg.nak_str(), msg)\\r\\n-                self.on_done(False, \\\"Device command NAK. \\\" + msg.nak_str(),\\r\\n-                             None)\\r\\n-                return Msg.FINISHED\\r\\n+                if msg.cmd2 == msg.NakType.PRE_NAK:\\r\\n+                    # This is a \\\"Pre NAK in case database search takes\\r\\n+                    # too long\\\".  This happens when the device database is\\r\\n+                    # large.  Just ignore it, add more wait time and wait.\\r\\n+                    LOG.warning(\\\"%s Pre-NAK: %s, Message: %s\\\", msg.from_addr,\\r\\n+                                msg.nak_str(), msg)\\r\\n+                    return Msg.CONTINUE\\r\\n+                else:\\r\\n+                    LOG.error(\\\"%s device NAK error: %s, Message: %s\\\",\\r\\n+                              msg.from_addr, msg.nak_str(), msg)\\r\\n+                    self.on_done(False, \\\"Device command NAK. \\\" + msg.nak_str(),\\r\\n+                                 None)\\r\\n+                    return Msg.FINISHED\\r\\n \\r\\n             else:\\r\\n                 LOG.warning(\\\"%s device unexpected msg: %s\\\", msg.from_addr, msg)\\r\\n\",\"diff --git a/insteon_mqtt/handler/StandardCmd.py b/insteon_mqtt/handler/StandardCmd.py\\nindex 76b8fe3..776a8fd 100644\\n--- a/insteon_mqtt/handler/StandardCmd.py\\n+++ b/insteon_mqtt/handler/StandardCmd.py\\n@@ -24,7 +24,7 @@ class StandardCmd(Base):\\n \\n     When we get the InptStandard message we expect to see, it will be passed\\n     to the callback set in the constructor which is usually a method on the\\n-    device to handle the result (or the ACK that the command went through).\\n+    device to handle the ACK.\\n     \\\"\\\"\\\"\\n     def __init__(self, msg, callback, on_done=None, num_retry=3):\\n         \\\"\\\"\\\"Constructor\\n@@ -34,7 +34,7 @@ class StandardCmd(Base):\\n               reply must match the address and msg.cmd1 field to be\\n               processed by this handler.\\n           callback:  The message handler callback. This is called when a\\n-                     matching message is read.  Calling signature:\\n+                     matching ACK is read.  Calling signature:\\n                      callback( msg, on_done )\\n           on_done: The finished callback.  Calling signature:\\n                    on_done( bool success, str message, data )\\n@@ -72,9 +72,9 @@ class StandardCmd(Base):\\n             # waiting for a reply.\\n             if msg.to_addr == self.addr and msg.cmd1 == self.cmd:\\n                 if not msg.is_ack:\\n-                    LOG.error(\\\"%s NAK response\\\", self.addr)\\n-\\n-                LOG.debug(\\\"%s got msg ACK\\\", self.addr)\\n+                    LOG.warning(\\\"%s PLM NAK response\\\", self.addr)\\n+                else:\\n+                    LOG.debug(\\\"%s got PLM ACK\\\", self.addr)\\n                 return Msg.CONTINUE\\n \\n             # Message didn't match the expected addr/cmd.\\n@@ -86,13 +86,28 @@ class StandardCmd(Base):\\n             # If this message matches our address and command, it's probably\\n             # the ACK we're expecting.\\n             if msg.from_addr == self.addr and msg.cmd1 == self.cmd:\\n-                # Run the callback - it's up to the callback to check if this\\n-                # is really the ACK or not.\\n-                self.callback(msg, on_done=self.on_done)\\n-\\n-                # Indicate no more messages are expected.\\n-                return Msg.FINISHED\\n-            else:\\n+                if msg.flags.type == Msg.Flags.Type.DIRECT_NAK:\\n+                    if msg.cmd2 == msg.NakType.PRE_NAK:\\n+                        # This is a \\\"Pre NAK in case database search takes\\n+                        # too long\\\".  This happens when the device database is\\n+                        # large.  Just ignore it, add more wait time and wait.\\n+                        LOG.warning(\\\"%s Pre-NAK: %s, Message: %s\\\",\\n+                                    msg.from_addr, msg.nak_str(), msg)\\n+                        return Msg.CONTINUE\\n+                    else:\\n+                        LOG.error(\\\"%s device NAK error: %s, Message: %s\\\",\\n+                                  msg.from_addr, msg.nak_str(), msg)\\n+                        self.on_done(False, \\\"Command failed. \\\" +\\n+                                     msg.nak_str(), None)\\n+                        return Msg.FINISHED\\n+\\n+                elif msg.flags.type == Msg.Flags.Type.DIRECT_ACK:\\n+                    # Run the callback\\n+                    self.callback(msg, on_done=self.on_done)\\n+                    # Indicate no more messages are expected.\\n+                    return Msg.FINISHED\\n+\\n+                # Only make it here if this is a bad msg.\\n                 LOG.info(\\\"Possible unexpected message from %s cmd %#04x but \\\"\\n                          \\\"expected %s cmd %#04x\\\", msg.from_addr, msg.cmd1,\\n                          self.addr, self.cmd)\\n\",\"diff --git a/insteon_mqtt/handler/StandardCmdNAK.py b/insteon_mqtt/handler/StandardCmdNAK.py\\nnew file mode 100644\\nindex 0000000..0fecf17\\n--- /dev/null\\n+++ b/insteon_mqtt/handler/StandardCmdNAK.py\\n@@ -0,0 +1,72 @@\\n+#===========================================================================\\n+#\\n+# Insteon broadcast message handler\\n+#\\n+#===========================================================================\\n+from .. import log\\n+from .. import message as Msg\\n+from .StandardCmd import StandardCmd\\n+\\n+LOG = log.get_logger()\\n+\\n+\\n+class StandardCmdNAK(StandardCmd):\\n+    \\\"\\\"\\\"Insteon standard input mesage handler that passes on NAKs\\n+\\n+    The Standard command handler will process and not pass on Naks to the\\n+    callback function.\\n+\\n+    This is handler is identical in everyway, but will pass on a NAK so that\\n+    the callback can process it.  This is rarely needed\\n+    \\\"\\\"\\\"\\n+\\n+    #-----------------------------------------------------------------------\\n+    def msg_received(self, protocol, msg):\\n+        \\\"\\\"\\\"See if we can handle the message.\\n+\\n+        See if the message is the expected ACK of our output or the expected\\n+        InpStandard reply message.  If we get a reply, pass it to the\\n+        callback.\\n+\\n+        Args:\\n+          protocol (Protocol):  The Insteon Protocol object\\n+          msg: Insteon message object that was read.\\n+\\n+        Returns:\\n+          Msg.UNKNOWN if we can't handle this message.\\n+          Msg.CONTINUE if we handled the message and expect more.\\n+          Msg.FINISHED if we handled the message and are done.\\n+        \\\"\\\"\\\"\\n+        # Probably an echo back of our sent message.\\n+        if isinstance(msg, Msg.OutStandard):\\n+            # If the message is the echo back of our message, then continue\\n+            # waiting for a reply.\\n+            if msg.to_addr == self.addr and msg.cmd1 == self.cmd:\\n+                if not msg.is_ack:\\n+                    LOG.warning(\\\"%s PLM NAK response\\\", self.addr)\\n+                else:\\n+                    LOG.debug(\\\"%s got PLM ACK\\\", self.addr)\\n+                return Msg.CONTINUE\\n+\\n+            # Message didn't match the expected addr/cmd.\\n+            LOG.debug(\\\"%s handler unknown msg\\\", self.addr)\\n+            return Msg.UNKNOWN\\n+\\n+        # See if this is the standard message ack/nak we're expecting.\\n+        elif isinstance(msg, Msg.InpStandard):\\n+            # If this message matches our address and command, it's probably\\n+            # the ACK we're expecting.\\n+            if msg.from_addr == self.addr and msg.cmd1 == self.cmd:\\n+                # Run the callback it decides what to do with an ACK or NAK\\n+                self.callback(msg, on_done=self.on_done)\\n+\\n+                # Indicate no more messages are expected.\\n+                return Msg.FINISHED\\n+            else:\\n+                LOG.info(\\\"Possible unexpected message from %s cmd %#04x but \\\"\\n+                         \\\"expected %s cmd %#04x\\\", msg.from_addr, msg.cmd1,\\n+                         self.addr, self.cmd)\\n+\\n+        return Msg.UNKNOWN\\n+\\n+    #-----------------------------------------------------------------------\\n\",\"diff --git a/insteon_mqtt/handler/__init__.py b/insteon_mqtt/handler/__init__.py\\nindex 39d8c27..e869cdb 100644\\n--- a/insteon_mqtt/handler/__init__.py\\n+++ b/insteon_mqtt/handler/__init__.py\\n@@ -44,5 +44,6 @@ from .ModemLinkStart import ModemLinkStart\\n from .ModemReset import ModemReset\\n from .ModemScene import ModemScene\\n from .StandardCmd import StandardCmd\\n+from .StandardCmdNAK import StandardCmdNAK\\n from .ThermostatCmd import ThermostatCmd\\n from .BroadcastCmdResponse import BroadcastCmdResponse\\n\",\"diff --git a/insteon_mqtt/message/InpStandard.py b/insteon_mqtt/message/InpStandard.py\\nindex 5d89461..8810d65 100644\\n--- a/insteon_mqtt/message/InpStandard.py\\n+++ b/insteon_mqtt/message/InpStandard.py\\n@@ -3,6 +3,7 @@\\n # Input insteon standard and extended message.\\n #\\n #===========================================================================\\n+import enum\\n import io\\n import time\\n from ..Address import Address\\n@@ -23,6 +24,14 @@ class InpStandard(Base):\\n     msg_code = 0x50\\n     fixed_msg_size = 11\\n \\n+    # NAK types\\n+    class NakType(enum.IntEnum):\\n+        SENDER_NOT_IN_DB = 0xFF\\n+        NO_LOAD = 0xFE\\n+        BAD_CHECKSUM = 0xFD\\n+        PRE_NAK = 0xFC\\n+        ILLEGAL_VALUE = 0xFB\\n+\\n     #-----------------------------------------------------------------------\\n     @classmethod\\n     def from_bytes(cls, raw):\\n@@ -104,11 +113,13 @@ class InpStandard(Base):\\n         \\\"\\\"\\\"\\n         ret = \\\"\\\"\\n         naks = {\\n-            0xFF: \\\"Senders ID not in responders db. Try linking again.\\\",\\n-            0xFE: \\\"Load sense detects no load\\\",\\n-            0xFD: \\\"Checksum is incorrect\\\",\\n-            0xFC: \\\"Pre NAK in case database search takes too long\\\",\\n-            0xFB: \\\"Illegal value in command\\\"\\n+            self.NakType.SENDER_NOT_IN_DB:\\n+                \\\"Senders ID not in responders db. Try running 'join' again.\\\",\\n+            self.NakType.NO_LOAD: \\\"Load sense detects no load\\\",\\n+            self.NakType.BAD_CHECKSUM: \\\"Checksum is incorrect\\\",\\n+            self.NakType.PRE_NAK:\\n+                \\\"Pre NAK in case database search takes too long\\\",\\n+            self.NakType.ILLEGAL_VALUE: \\\"Illegal value in command\\\"\\n         }\\n         if (self.flags.type == Flags.Type.DIRECT_NAK and\\n                 self.cmd2 in naks.keys()):\\n\"]", "test_patch": "[\"diff --git a/tests/device/test_IOLinc.py b/tests/device/test_IOLinc.py\\nindex d0d15fc..a146b55 100644\\n--- a/tests/device/test_IOLinc.py\\n+++ b/tests/device/test_IOLinc.py\\n@@ -278,7 +278,6 @@ class Test_Handles():\\n     @pytest.mark.parametrize(\\\"cmd1, type, expected\\\", [\\r\\n         (0x11, IM.message.Flags.Type.DIRECT_ACK, True),\\r\\n         (0X13, IM.message.Flags.Type.DIRECT_ACK, False),\\r\\n-        (0X11, IM.message.Flags.Type.DIRECT_NAK, None),\\r\\n     ])\\r\\n     def test_handle_ack(self, test_iolinc, cmd1, type, expected):\\r\\n         with mock.patch.object(IM.Signal, 'emit'):\\r\\n@@ -288,11 +287,8 @@ class Test_Handles():\\n             msg = IM.message.InpStandard(from_addr, to_addr, flags, cmd1, 0x01)\\r\\n             test_iolinc.handle_ack(msg, lambda success, msg, cmd: True)\\r\\n             calls = IM.Signal.emit.call_args_list\\r\\n-            if expected is not None:\\r\\n-                assert calls[0][0][2] == expected\\r\\n-                assert IM.Signal.emit.call_count == 1\\r\\n-            else:\\r\\n-                assert IM.Signal.emit.call_count == 0\\r\\n+            assert calls[0][0][2] == expected\\r\\n+            assert IM.Signal.emit.call_count == 1\\r\\n \\r\\n     @pytest.mark.parametrize(\\\"cmd1, entry_d1, mode, sensor, expected\\\", [\\r\\n         (0x11, None, IM.device.IOLinc.Modes.LATCHING, False, None),\\r\\n\",\"diff --git a/tests/handler/test_BroadcastCmdResponse.py b/tests/handler/test_BroadcastCmdResponse.py\\nindex 3a58f53..7d7f708 100644\\n--- a/tests/handler/test_BroadcastCmdResponse.py\\n+++ b/tests/handler/test_BroadcastCmdResponse.py\\n@@ -67,6 +67,12 @@ class Test_BroadcastCmdResponse:\\n         r = handler.msg_received(proto, msg)\\n         assert r == Msg.FINISHED\\n \\n+        # direct Pre NAK\\n+        flags = Msg.Flags(Msg.Flags.Type.DIRECT_NAK, False)\\n+        msg = Msg.InpStandard(addr, addr, flags, 0x10, 0xFC)\\n+        r = handler.msg_received(proto, msg)\\n+        assert r == Msg.CONTINUE\\n+\\n         # unexpected\\n         flags = Msg.Flags(Msg.Flags.Type.ALL_LINK_BROADCAST, False)\\n         msg = Msg.InpStandard(addr, addr, flags, 0x10, 0x00)\\n\",\"diff --git a/tests/handler/test_DeviceDbGet.py b/tests/handler/test_DeviceDbGet.py\\nindex 0441b5e..f6b4810 100644\\n--- a/tests/handler/test_DeviceDbGet.py\\n+++ b/tests/handler/test_DeviceDbGet.py\\n@@ -36,6 +36,12 @@ class Test_DeviceDbGet:\\n         r = handler.msg_received(proto, std_ack)\\n         assert r == Msg.UNKNOWN\\n \\n+        # direct Pre NAK\\n+        flags = Msg.Flags(Msg.Flags.Type.DIRECT_NAK, False)\\n+        msg = Msg.InpStandard(addr, addr, flags, 0x2f, 0xFC)\\n+        r = handler.msg_received(proto, msg)\\n+        assert r == Msg.CONTINUE\\n+\\n         # Try w/ an extended msg.\\n         ext_data = bytes(14)\\n         ext_ack = Msg.OutExtended.direct(addr, 0x2f, 0x00, ext_data)\\n\",\"diff --git a/tests/handler/test_ExtendedCmdResponse.py b/tests/handler/test_ExtendedCmdResponse.py\\nindex 56ddc28..1e76a42 100644\\n--- a/tests/handler/test_ExtendedCmdResponse.py\\n+++ b/tests/handler/test_ExtendedCmdResponse.py\\n@@ -69,6 +69,12 @@ class Test_ExtendedCmdResponse:\\n         r = handler.msg_received(proto, msg)\\n         assert r == Msg.FINISHED\\n \\n+        # direct Pre NAK\\n+        flags = Msg.Flags(Msg.Flags.Type.DIRECT_NAK, False)\\n+        msg = Msg.InpStandard(addr, addr, flags, 0x2e, 0xFC)\\n+        r = handler.msg_received(proto, msg)\\n+        assert r == Msg.CONTINUE\\n+\\n         # unexpected\\n         flags = Msg.Flags(Msg.Flags.Type.BROADCAST, False)\\n         msg = Msg.InpStandard(addr, addr, flags, 0x2e, 0x00)\\n\",\"diff --git a/tests/handler/test_StandardCmd.py b/tests/handler/test_StandardCmd.py\\nindex d1c8910..f68aa77 100644\\n--- a/tests/handler/test_StandardCmd.py\\n+++ b/tests/handler/test_StandardCmd.py\\n@@ -41,6 +41,12 @@ class Test_StandardCmd:\\n         r = handler.msg_received(proto, out)\\n         assert r == Msg.UNKNOWN\\n \\n+        # direct Pre NAK\\n+        flags = Msg.Flags(Msg.Flags.Type.DIRECT_NAK, False)\\n+        msg = Msg.InpStandard(addr, addr, flags, 0x11, 0xFC)\\n+        r = handler.msg_received(proto, msg)\\n+        assert r == Msg.CONTINUE\\n+\\n         # Now pass in the input message.\\n \\n         # expected input meesage\"]", "hints_text": ""}

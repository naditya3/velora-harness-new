{"instance_id": "1068335432129332", "repo": "tobymao/sqlglot", "base_commit": "e604fe6d8258c73b511159a953bb130c65b608cc", "problem_statement": "Optimizer error with UNNEST in CTE:\\nI get errors with the following queries:\\r\\n\\r\\nError: `Unknown column: time_window`\\r\\n```\\r\\nWITH\\r\\n  cte1 AS(\\r\\n    SELECT\\r\\n      *\\r\\n    FROM\\r\\n    UNNEST\\r\\n      (['7', '14', '30', '45', '45+']) AS time_window\\r\\n  )\\r\\nSELECT\\r\\n  cte1.time_window\\r\\nFROM\\r\\n  cte1\\r\\n```\\r\\n\\r\\nError: `Ambiguous column: time_window`\\r\\n```\\r\\nWITH\\r\\n  cte1 AS(\\r\\n    SELECT\\r\\n      time_window\\r\\n    FROM\\r\\n    UNNEST\\r\\n      (['7', '14', '30', '45', '45+']) AS time_window\\r\\n  )\\r\\nSELECT\\r\\n  cte1.time_window\\r\\nFROM\\r\\n  cte1\\r\\n```", "FAIL_TO_PASS": ["test_dialects.TestDialects.test_bigquery", "test_dialects.TestDialects.test_presto"], "PASS_TO_PASS": ["test_expressions.TestExpressions.test_eq", "test_optimizer.TestOptimizer.test_simplify", "test_transpile.TestTranspile.test_types", "test_expressions.TestExpressions.test_text", "test_expressions.TestExpressions.test_functions", "test_transpile.TestTranspile.test_identity", "test_dialects.TestDialects.test_starrocks", "test_parser.TestParser.test_expression", "test_transpile.TestTranspile.test_pretty", "test_dialects.TestDialects.test_hive", "test_expressions.TestExpressions.test_transform_no_infinite_recursion", "test_dialects.TestDialects.test_tableau", "test_optimizer.TestOptimizer.test_qualify_columns__invalid", "test_expressions.TestExpressions.test_arg_key", "test_expressions.TestExpressions.test_selects", "test_optimizer.TestOptimizer.test_quote_identities", "test_transpile.TestTranspile.test_time", "test_optimizer.TestOptimizer.test_qualify_tables", "test_expressions.TestExpressions.test_transform_with_arguments", "test_transpile.TestTranspile.test_index_offset", "test_expressions.TestExpressions.test_transform_simple", "test_expressions.TestExpressions.test_walk", "test_parser.TestParser.test_parse_into", "test_expressions.TestExpressions.test_sql", "test_expressions.TestExpressions.test_find_all", "test_helper.TestHelper.test_tsort", "test_dialects.TestDialects.test_mysql", "test_transpile.TestTranspile.test_comments", "test_optimizer.TestOptimizer.test_eliminate_subqueries", "test_build.TestBuild.test_build", "test_parser.TestParser.test_missing_by", "test_optimizer.TestOptimizer.test_scope", "test_optimizer.TestOptimizer.test_optimize_joins", "test_parser.TestParser.test_space", "test_transpile.TestTranspile.test_alias", "test_transpile.TestTranspile.test_space", "test_expressions.TestExpressions.test_find_ancestor", "test_optimizer.TestOptimizer.test_file_schema", "test_parser.TestParser.test_parse_errors", "test_parser.TestParser.test_table", "test_expressions.TestExpressions.test_hash", "test_expressions.TestExpressions.test_ctes", "test_parser.TestParser.test_parse_empty", "test_expressions.TestExpressions.test_find", "test_dialects.TestDialects.test_sqlite", "test_expressions.TestExpressions.test_depth", "test_expressions.TestExpressions.test_alias", "test_expressions.TestExpressions.test_alias_or_name", "test_dialects.TestDialects.test_oracle", "test_parser.TestParser.test_column", "test_parser.TestParser.test_pretty_config_override", "test_parser.TestParser.test_annotations", "test_transpile.TestTranspile.test_not_range", "test_optimizer.TestOptimizer.test_isolate_table_selects", "test_dialects.TestDialects.test_duckdb", "test_optimizer.TestOptimizer.test_schema", "test_expressions.TestExpressions.test_transform_multiple_children", "test_transpile.TestTranspile.test_some", "test_parser.TestParser.test_multi", "test_dialects.TestDialects.test_snowflake", "test_transpile.TestTranspile.test_error_level", "test_transpile.TestTranspile.test_partial", "test_parser.TestParser.test_identify", "test_dialects.TestDialects.test_spark", "test_optimizer.TestOptimizer.test_expand_multi_table_selects", "test_expressions.TestExpressions.test_named_selects", "test_dialects.TestDialects.test_trino", "test_expressions.TestExpressions.test_unit", "test_generator.TestGenerator.test_fallback_function_var_args_sql", "test_generator.TestGenerator.test_fallback_function_sql", "test_optimizer.TestOptimizer.test_qualify_columns", "test_expressions.TestExpressions.test_column", "test_optimizer.TestOptimizer.test_pushdown_predicates", "test_time.TestTime.test_format_time", "test_optimizer.TestOptimizer.test_normalize", "test_optimizer.TestOptimizer.test_optimize", "test_optimizer.TestOptimizer.test_pushdown_projection", "test_transpile.TestTranspile.test_ignore_nulls", "test_expressions.TestExpressions.test_replace", "test_transpile.TestTranspile.test_extract", "test_transpile.TestTranspile.test_paren", "test_transpile.TestTranspile.test_if", "test_dialects.TestDialects.test_postgres", "test_transpile.TestTranspile.test_asc", "test_parser.TestParser.test_command", "test_expressions.TestExpressions.test_alias_column_names"], "language": "python", "test_command": "source /saved/ENV || source /saved/*/ENV && /opt/hostedtoolcache/Python/3.7.17/x64/bin/python3 /app/repo/unittest_loader_no_traceback.py ./tests ;", "test_output_parser": "python/parse_log_unittest", "image_storage_uri": "vmvm-registry.fbinfra.net/repomate_image_activ_python_unittest/tobymao_sqlglot:e604fe6d8258c73b511159a953bb130c65b608cc", "patch": "[\"diff --git a/README.md b/README.md\\nindex c522ac1..83bfb67 100644\\n--- a/README.md\\n+++ b/README.md\\n@@ -89,7 +89,7 @@ for column in parse_one(\\\"SELECT a, b + 1 AS c FROM d\\\").find_all(exp.Column):\\n \\n # find all projections in select statements (a and c)\\n for select in parse_one(\\\"SELECT a, b + 1 AS c FROM d\\\").find_all(exp.Select):\\n-  for projection in select.args[\\\"expressions\\\"]:\\n+  for projection in select.expressions:\\n     print(projection.alias_or_name)\\n \\n # find all tables (x, y, z)\\n\",\"diff --git a/sqlglot/dialects/bigquery.py b/sqlglot/dialects/bigquery.py\\nindex 7d2b6aa..9ec73e5 100644\\n--- a/sqlglot/dialects/bigquery.py\\n+++ b/sqlglot/dialects/bigquery.py\\n@@ -31,6 +31,7 @@ def _date_add_sql(kind):\\n class BigQuery(Dialect):\\n     identifier = \\\"`\\\"\\n     escape = \\\"\\\\\\\\\\\"\\n+    unnest_column_only = True\\n \\n     class Tokenizer(Tokenizer):\\n         QUOTES = [\\\"'\\\", '\\\"', '\\\"\\\"\\\"']\\n\",\"diff --git a/sqlglot/dialects/dialect.py b/sqlglot/dialects/dialect.py\\nindex d60c2dc..8b43c42 100644\\n--- a/sqlglot/dialects/dialect.py\\n+++ b/sqlglot/dialects/dialect.py\\n@@ -41,6 +41,7 @@ class Dialect(metaclass=_Dialect):\\n     identifier = None\\n     escape = \\\"'\\\"\\n     index_offset = 0\\n+    unnest_column_only = False\\n \\n     date_format = \\\"'%Y-%m-%d'\\\"\\n     dateint_format = \\\"'%Y%m%d'\\\"\\n@@ -104,6 +105,7 @@ class Dialect(metaclass=_Dialect):\\n         return self.parser_class(\\n             **{\\n                 \\\"index_offset\\\": self.index_offset,\\n+                \\\"unnest_column_only\\\": self.unnest_column_only,\\n                 **opts,\\n             },\\n         )\\n@@ -118,6 +120,7 @@ class Dialect(metaclass=_Dialect):\\n                 \\\"index_offset\\\": self.index_offset,\\n                 \\\"time_mapping\\\": self.inverse_time_mapping,\\n                 \\\"time_trie\\\": self.inverse_time_trie,\\n+                \\\"unnest_column_only\\\": self.unnest_column_only,\\n                 **opts,\\n             }\\n         )\\n\",\"diff --git a/sqlglot/dialects/hive.py b/sqlglot/dialects/hive.py\\nindex f90b5c4..1e980d0 100644\\n--- a/sqlglot/dialects/hive.py\\n+++ b/sqlglot/dialects/hive.py\\n@@ -38,7 +38,7 @@ def _map_sql(self, expression):\\n         return f\\\"MAP({self.sql(keys)}, {self.sql(values)})\\\"\\n \\n     args = []\\n-    for key, value in zip(keys.args[\\\"expressions\\\"], values.args[\\\"expressions\\\"]):\\n+    for key, value in zip(keys.expressions, values.expressions):\\n         args.append(self.sql(key))\\n         args.append(self.sql(value))\\n     return f\\\"MAP({csv(*args)})\\\"\\n@@ -52,7 +52,7 @@ def _array_sort(self, expression):\\n \\n def _properties_sql(self, expression):\\n     expression = expression.copy()\\n-    properties = expression.args[\\\"expressions\\\"]\\n+    properties = expression.expressions\\n \\n     stored_as = \\\"\\\"\\n     partitioned_by = \\\"\\\"\\n@@ -108,19 +108,19 @@ def _time_to_str(self, expression):\\n \\n \\n def _unnest_to_explode_sql(self, expression):\\n-    if isinstance(expression.this, exp.Unnest):\\n-        unnest = expression.this\\n+    unnest = expression.this\\n+    if isinstance(unnest, exp.Unnest):\\n+        alias = unnest.args.get(\\\"alias\\\")\\n         udtf = exp.Posexplode if unnest.args.get(\\\"ordinality\\\") else exp.Explode\\n         return \\\"\\\".join(\\n             self.sql(\\n                 exp.Lateral(\\n                     this=udtf(this=expression),\\n-                    table=unnest.args.get(\\\"table\\\"),\\n-                    columns=[column],\\n+                    alias=exp.TableAlias(this=alias.this, columns=[column]),\\n                 )\\n             )\\n             for expression, column in zip(\\n-                unnest.args[\\\"expressions\\\"], unnest.args.get(\\\"columns\\\", [])\\n+                unnest.expressions, alias.columns if alias else []\\n             )\\n         )\\n     return self.join_sql(expression)\\n\",\"diff --git a/sqlglot/dialects/presto.py b/sqlglot/dialects/presto.py\\nindex c5f88c4..922882a 100644\\n--- a/sqlglot/dialects/presto.py\\n+++ b/sqlglot/dialects/presto.py\\n@@ -22,7 +22,7 @@ def _approx_distinct_sql(self, expression):\\n \\n \\n def _concat_ws_sql(self, expression):\\n-    sep, *args = expression.args[\\\"expressions\\\"]\\n+    sep, *args = expression.expressions\\n     sep = self.sql(sep)\\n     if len(args) > 1:\\n         return f\\\"ARRAY_JOIN(ARRAY[{csv(*(self.sql(e) for e in args))}], {sep})\\\"\\n@@ -46,8 +46,7 @@ def _explode_to_unnest_sql(self, expression):\\n             exp.Join(\\n                 this=exp.Unnest(\\n                     expressions=[expression.this.this],\\n-                    table=expression.args.get(\\\"table\\\"),\\n-                    columns=expression.args.get(\\\"columns\\\"),\\n+                    alias=expression.args.get(\\\"alias\\\"),\\n                     ordinality=isinstance(expression.this, exp.Posexplode),\\n                 ),\\n                 kind=\\\"cross\\\",\\n@@ -72,15 +71,13 @@ def _no_sort_array(self, expression):\\n \\n def _schema_sql(self, expression):\\n     if isinstance(expression.parent, exp.Property):\\n-        columns = \\\", \\\".join(\\n-            f\\\"'{c.text('this')}'\\\" for c in expression.args[\\\"expressions\\\"]\\n-        )\\n+        columns = \\\", \\\".join(f\\\"'{c.text('this')}'\\\" for c in expression.expressions)\\n         return f\\\"ARRAY[{columns}]\\\"\\n \\n     for schema in expression.parent.find_all(exp.Schema):\\n         if isinstance(schema.parent, exp.Property):\\n             expression = expression.copy()\\n-            expression.args[\\\"expressions\\\"].extend(schema.args[\\\"expressions\\\"])\\n+            expression.expressions.extend(schema.expressions)\\n \\n     return self.schema_sql(expression)\\n \\n\",\"diff --git a/sqlglot/expressions.py b/sqlglot/expressions.py\\nindex 1453ec0..36e6803 100644\\n--- a/sqlglot/expressions.py\\n+++ b/sqlglot/expressions.py\\n@@ -56,6 +56,10 @@ class Expression(metaclass=_Expression):\\n     def this(self):\\n         return self.args.get(\\\"this\\\")\\n \\n+    @property\\n+    def expressions(self):\\n+        return self.args.get(\\\"expressions\\\") or []\\n+\\n     def text(self, key):\\n         field = self.args.get(key)\\n         if isinstance(field, str):\\n@@ -430,7 +434,7 @@ class Predicate(Condition):\\n     \\\"\\\"\\\"Relationships like x = y, x > 1, x >= y.\\\"\\\"\\\"\\n \\n \\n-class DerivedTable:\\n+class DerivedTable(Expression):\\n     @property\\n     def alias_column_names(self):\\n         table_alias = self.args.get(\\\"alias\\\")  # pylint: disable=no-member\\n@@ -439,6 +443,18 @@ class DerivedTable:\\n         column_list = table_alias.assert_is(TableAlias).args.get(\\\"columns\\\") or []\\n         return [c.name for c in column_list]\\n \\n+    @property\\n+    def selects(self):\\n+        alias = self.args.get(\\\"alias\\\")\\n+\\n+        if alias:\\n+            return alias.columns\\n+        return []\\n+\\n+    @property\\n+    def named_selects(self):\\n+        return [select.alias_or_name for select in self.selects]\\n+\\n \\n class Annotation(Expression):\\n     arg_types = {\\n@@ -491,12 +507,16 @@ class WithinGroup(Expression):\\n     arg_types = {\\\"this\\\": True, \\\"expression\\\": False}\\n \\n \\n-class CTE(Expression, DerivedTable):\\n+class CTE(DerivedTable):\\n     arg_types = {\\\"this\\\": True, \\\"alias\\\": True}\\n \\n \\n class TableAlias(Expression):\\n-    arg_types = {\\\"this\\\": True, \\\"columns\\\": False}\\n+    arg_types = {\\\"this\\\": False, \\\"columns\\\": False}\\n+\\n+    @property\\n+    def columns(self):\\n+        return self.args.get(\\\"columns\\\") or []\\n \\n \\n class Column(Condition):\\n@@ -668,8 +688,8 @@ class Join(Expression):\\n         return join\\n \\n \\n-class Lateral(Expression):\\n-    arg_types = {\\\"this\\\": True, \\\"outer\\\": False, \\\"table\\\": False, \\\"columns\\\": False}\\n+class Lateral(DerivedTable):\\n+    arg_types = {\\\"this\\\": True, \\\"outer\\\": False, \\\"alias\\\": False}\\n \\n \\n class Offset(Expression):\\n@@ -732,7 +752,7 @@ class Subqueryable:\\n         with_ = self.args.get(\\\"with\\\")  # pylint: disable=no-member\\n         if not with_:\\n             return []\\n-        return with_.args.get(\\\"expressions\\\", [])\\n+        return with_.expressions\\n \\n     def with_(\\n         self,\\n@@ -820,12 +840,11 @@ class Intersect(Union):\\n     pass\\n \\n \\n-class Unnest(Expression):\\n+class Unnest(DerivedTable):\\n     arg_types = {\\n         \\\"expressions\\\": True,\\n         \\\"ordinality\\\": False,\\n-        \\\"table\\\": False,\\n-        \\\"columns\\\": False,\\n+        \\\"alias\\\": False,\\n     }\\n \\n \\n@@ -1305,14 +1324,14 @@ class Select(Subqueryable, Expression):\\n \\n     @property\\n     def named_selects(self):\\n-        return [e.alias_or_name for e in self.args[\\\"expressions\\\"] if e.alias_or_name]\\n+        return [e.alias_or_name for e in self.expressions if e.alias_or_name]\\n \\n     @property\\n     def selects(self):\\n-        return self.args.get(\\\"expressions\\\", [])\\n+        return self.expressions\\n \\n \\n-class Subquery(Expression, DerivedTable):\\n+class Subquery(DerivedTable):\\n     arg_types = {\\\"this\\\": True, \\\"alias\\\": False}\\n \\n     def unnest(self):\\n@@ -1588,7 +1607,7 @@ class Aliases(Expression):\\n \\n     @property\\n     def aliases(self):\\n-        return self.args[\\\"expressions\\\"]\\n+        return self.expressions\\n \\n \\n class AtTimeZone(Expression):\\n@@ -2199,11 +2218,11 @@ def _apply_child_list_builder(\\n             prefix=prefix,\\n             parser_opts=parser_opts,\\n         )\\n-        parsed.extend(expression.args[\\\"expressions\\\"])\\n+        parsed.extend(expression.expressions)\\n \\n     existing = instance.args.get(arg)\\n     if append and existing:\\n-        parsed = ensure_list(existing.args.get(\\\"expressions\\\")) + parsed\\n+        parsed = existing.expressions + parsed\\n \\n     child = into(expressions=parsed)\\n     for k, v in kwargs.items():\\n\",\"diff --git a/sqlglot/generator.py b/sqlglot/generator.py\\nindex 7300b4e..73a6fc3 100644\\n--- a/sqlglot/generator.py\\n+++ b/sqlglot/generator.py\\n@@ -28,6 +28,7 @@ class Generator:\\n         escape (str): specifies an escape character. Default: '.\\n         pad (int): determines padding in a formatted string. Default: 2.\\n         indent (int): determines the size of indentation in a formatted string. Default: 4.\\n+        unnest_column_only (bool): if true unnest table aliases are considered only as column aliases\\n         unsupported_level (ErrorLevel): determines the generator's behavior when it encounters\\n             unsupported expressions. Default ErrorLevel.WARN.\\n     \\\"\\\"\\\"\\n@@ -52,6 +53,7 @@ class Generator:\\n         \\\"escape\\\",\\n         \\\"pad\\\",\\n         \\\"index_offset\\\",\\n+        \\\"unnest_column_only\\\",\\n         \\\"unsupported_level\\\",\\n         \\\"unsupported_messages\\\",\\n         \\\"_indent\\\",\\n@@ -70,6 +72,7 @@ class Generator:\\n         pad=2,\\n         indent=2,\\n         index_offset=0,\\n+        unnest_column_only=False,\\n         unsupported_level=ErrorLevel.WARN,\\n     ):\\n         # pylint: disable=too-many-arguments\\n@@ -86,6 +89,7 @@ class Generator:\\n         self.escape = escape or \\\"'\\\"\\n         self.pad = pad\\n         self.index_offset = index_offset\\n+        self.unnest_column_only = unnest_column_only\\n         self.unsupported_level = unsupported_level\\n         self.unsupported_messages = []\\n         self._indent = indent\\n@@ -123,7 +127,7 @@ class Generator:\\n         return f\\\"{self.sep(sep)}{sql}\\\"\\n \\n     def properties(self, name, expression):\\n-        if expression.args[\\\"expressions\\\"]:\\n+        if expression.expressions:\\n             return f\\\"{self.seg(name)} ({self.sep('')}{self.expressions(expression)}{self.sep('')})\\\"\\n         return \\\"\\\"\\n \\n@@ -472,10 +476,12 @@ class Generator:\\n         op_sql = self.seg(\\n             f\\\"LATERAL VIEW{' OUTER' if expression.args.get('outer') else ''}\\\"\\n         )\\n-        alias = self.sql(expression, \\\"table\\\")\\n-        columns = self.expressions(expression, key=\\\"columns\\\", flat=True)\\n+        alias = expression.args[\\\"alias\\\"]\\n+        table = alias.name\\n+        table = f\\\" {table}\\\" if table else table\\n+        columns = self.expressions(alias, key=\\\"columns\\\", flat=True)\\n         columns = f\\\" AS {columns}\\\" if columns else \\\"\\\"\\n-        return f\\\"{op_sql}{self.sep()}{this} {alias}{columns}\\\"\\n+        return f\\\"{op_sql}{self.sep()}{this}{table}{columns}\\\"\\n \\n     def limit_sql(self, expression):\\n         this = self.sql(expression, \\\"this\\\")\\n@@ -568,11 +574,14 @@ class Generator:\\n \\n     def unnest_sql(self, expression):\\n         args = self.expressions(expression, flat=True)\\n-        table = self.sql(expression, \\\"table\\\")\\n+        alias = expression.args.get(\\\"alias\\\")\\n+        if alias and self.unnest_column_only:\\n+            columns = alias.columns\\n+            alias = self.sql(columns[0]) if columns else \\\"\\\"\\n+        else:\\n+            alias = self.sql(expression, \\\"alias\\\")\\n+        alias = f\\\" AS {alias}\\\" if alias else alias\\n         ordinality = \\\" WITH ORDINALITY\\\" if expression.args.get(\\\"ordinality\\\") else \\\"\\\"\\n-        columns = self.expressions(expression, key=\\\"columns\\\", flat=True)\\n-        alias = f\\\" AS {table}\\\" if table else \\\"\\\"\\n-        alias = f\\\"{alias} ({columns})\\\" if columns else alias\\n         return f\\\"UNNEST({args}){ordinality}{alias}\\\"\\n \\n     def where_sql(self, expression):\\n@@ -612,9 +621,7 @@ class Generator:\\n         return f\\\"{this} BETWEEN {low} AND {high}\\\"\\n \\n     def bracket_sql(self, expression):\\n-        expressions = apply_index_offset(\\n-            expression.args[\\\"expressions\\\"], self.index_offset\\n-        )\\n+        expressions = apply_index_offset(expression.expressions, self.index_offset)\\n         expressions = \\\", \\\".join(self.sql(e) for e in expressions)\\n \\n         return f\\\"{self.sql(expression, 'this')}[{expressions}]\\\"\\n\",\"diff --git a/sqlglot/helper.py b/sqlglot/helper.py\\nindex 9c7ebee..0640862 100644\\n--- a/sqlglot/helper.py\\n+++ b/sqlglot/helper.py\\n@@ -109,7 +109,7 @@ def csv_reader(table):\\n     Returns:\\n         A python csv reader.\\n     \\\"\\\"\\\"\\n-    file, *args = table.this.args[\\\"expressions\\\"]\\n+    file, *args = table.this.expressions\\n     file = file.name\\n     file = open_file(file)\\n \\n\",\"diff --git a/sqlglot/optimizer/expand_multi_table_selects.py b/sqlglot/optimizer/expand_multi_table_selects.py\\nindex 88eb752..ba562df 100644\\n--- a/sqlglot/optimizer/expand_multi_table_selects.py\\n+++ b/sqlglot/optimizer/expand_multi_table_selects.py\\n@@ -5,12 +5,12 @@ def expand_multi_table_selects(expression):\\n     for from_ in expression.find_all(exp.From):\\n         parent = from_.parent\\n \\n-        for query in from_.args[\\\"expressions\\\"][1:]:\\n+        for query in from_.expressions[1:]:\\n             parent.join(\\n                 query,\\n                 join_type=\\\"CROSS\\\",\\n                 copy=False,\\n             )\\n-            from_.args[\\\"expressions\\\"].remove(query)\\n+            from_.expressions.remove(query)\\n \\n     return expression\\n\",\"diff --git a/sqlglot/optimizer/optimize_joins.py b/sqlglot/optimizer/optimize_joins.py\\nindex 51982f4..40e4ab1 100644\\n--- a/sqlglot/optimizer/optimize_joins.py\\n+++ b/sqlglot/optimizer/optimize_joins.py\\n@@ -42,7 +42,7 @@ def reorder_joins(expression):\\n     Reorder joins by topological sort order based on predicate references.\\n     \\\"\\\"\\\"\\n     for from_ in expression.find_all(exp.From):\\n-        head = from_.args[\\\"expressions\\\"][0]\\n+        head = from_.expressions[0]\\n         parent = from_.parent\\n         joins = {join.this.alias_or_name: join for join in parent.args.get(\\\"joins\\\", [])}\\n         dag = {head.alias_or_name: []}\\n\",\"diff --git a/sqlglot/optimizer/qualify_columns.py b/sqlglot/optimizer/qualify_columns.py\\nindex c39253f..ab11856 100644\\n--- a/sqlglot/optimizer/qualify_columns.py\\n+++ b/sqlglot/optimizer/qualify_columns.py\\n@@ -6,6 +6,9 @@ from sqlglot.optimizer.schema import ensure_schema\\n from sqlglot.optimizer.scope import traverse_scope\\n \\n \\n+SKIP_QUALIFY = (exp.Unnest, exp.Lateral)\\n+\\n+\\n def qualify_columns(expression, schema):\\n     \\\"\\\"\\\"\\n     Rewrite sqlglot AST to have fully qualified columns.\\n@@ -30,8 +33,9 @@ def qualify_columns(expression, schema):\\n         _pop_table_column_aliases(scope.ctes)\\n         _pop_table_column_aliases(scope.derived_tables)\\n         _qualify_columns(scope, schema)\\n-        _expand_stars(scope, schema)\\n-        _qualify_outputs(scope)\\n+        if not isinstance(scope.expression, SKIP_QUALIFY):\\n+            _expand_stars(scope, schema)\\n+            _qualify_outputs(scope)\\n         _check_unknown_tables(scope)\\n \\n     return expression\\n@@ -55,6 +59,8 @@ def _pop_table_column_aliases(derived_tables):\\n     (e.g. SELECT ... FROM (SELECT ...) AS foo(col1, col2)\\n     \\\"\\\"\\\"\\n     for derived_table in derived_tables:\\n+        if isinstance(derived_table, SKIP_QUALIFY):\\n+            continue\\n         table_alias = derived_table.args.get(\\\"alias\\\")\\n         if table_alias:\\n             table_alias.args.pop(\\\"columns\\\", None)\\n@@ -155,7 +161,6 @@ def _add_replace_columns(expression, tables, replace_columns):\\n \\n def _qualify_outputs(scope):\\n     \\\"\\\"\\\"Ensure all output columns are aliased\\\"\\\"\\\"\\n-\\n     new_selections = []\\n \\n     for i, (selection, aliased_column) in enumerate(\\n\",\"diff --git a/sqlglot/optimizer/scope.py b/sqlglot/optimizer/scope.py\\nindex b1286f2..ddd805a 100644\\n--- a/sqlglot/optimizer/scope.py\\n+++ b/sqlglot/optimizer/scope.py\\n@@ -93,7 +93,7 @@ class Scope:\\n                 self._tables.append(node)\\n             elif isinstance(node, exp.CTE):\\n                 self._ctes.append(node)\\n-            elif isinstance(node, exp.Subquery):\\n+            elif isinstance(node, (exp.Subquery, exp.Unnest, exp.Lateral)):\\n                 self._derived_tables.append(node)\\n             elif isinstance(node, exp.Subqueryable) and not isinstance(\\n                 node.parent, (exp.CTE, exp.Subquery)\\n@@ -178,9 +178,7 @@ class Scope:\\n             # Expression.named_selects also includes unaliased columns.\\n             # In this case, we want to be sure to only include selects that are aliased.\\n             aliased_outputs = {\\n-                e.alias\\n-                for e in self.expression.args.get(\\\"expressions\\\", [])\\n-                if isinstance(e, exp.Alias)\\n+                e.alias for e in self.expression.expressions if isinstance(e, exp.Alias)\\n             }\\n \\n             self._columns = [\\n@@ -320,6 +318,8 @@ def _traverse_scope(scope):\\n         yield from _traverse_select(scope)\\n     elif isinstance(scope.expression, exp.Union):\\n         yield from _traverse_union(scope)\\n+    elif isinstance(scope.expression, (exp.Lateral, exp.Unnest)):\\n+        pass\\n     else:\\n         raise OptimizeError(f\\\"Unexpected expression type: {scope.expression}\\\")\\n     yield scope\\n@@ -359,7 +359,9 @@ def _traverse_derived_tables(derived_tables, scope, scope_type):\\n     for derived_table in derived_tables:\\n         for child_scope in _traverse_scope(\\n             scope.branch(\\n-                derived_table.this,\\n+                derived_table\\n+                if isinstance(derived_table, (exp.Unnest, exp.Lateral))\\n+                else derived_table.this,\\n                 add_sources=sources if chain else None,\\n                 outer_column_list=derived_table.alias_column_names,\\n                 scope_type=scope_type,\\n\",\"diff --git a/sqlglot/parser.py b/sqlglot/parser.py\\nindex c9a1bba..297c478 100644\\n--- a/sqlglot/parser.py\\n+++ b/sqlglot/parser.py\\n@@ -223,6 +223,7 @@ class Parser:\\n         \\\"sql\\\",\\n         \\\"errors\\\",\\n         \\\"index_offset\\\",\\n+        \\\"unnest_column_only\\\",\\n         \\\"_tokens\\\",\\n         \\\"_chunks\\\",\\n         \\\"_index\\\",\\n@@ -236,10 +237,12 @@ class Parser:\\n         error_level=None,\\n         error_message_context=100,\\n         index_offset=0,\\n+        unnest_column_only=False,\\n     ):\\n         self.error_level = error_level or ErrorLevel.RAISE\\n         self.error_message_context = error_message_context\\n         self.index_offset = index_offset\\n+        self.unnest_column_only = unnest_column_only\\n         self.reset()\\n \\n     def reset(self):\\n@@ -526,15 +529,15 @@ class Parser:\\n             value = self._parse_schema() or self._parse_bracket(self._parse_field())\\n \\n             if schema and not isinstance(value, exp.Schema):\\n-                columns = {v.text(\\\"this\\\").upper() for v in value.args[\\\"expressions\\\"]}\\n+                columns = {v.text(\\\"this\\\").upper() for v in value.expressions}\\n                 partitions = [\\n                     expression\\n-                    for expression in schema.args[\\\"expressions\\\"]\\n+                    for expression in schema.expressions\\n                     if expression.this.text(\\\"this\\\").upper() in columns\\n                 ]\\n                 schema.set(\\n                     \\\"expressions\\\",\\n-                    [e for e in schema.args[\\\"expressions\\\"] if e not in partitions],\\n+                    [e for e in schema.expressions if e not in partitions],\\n                 )\\n                 value = self.expression(exp.Schema, expressions=partitions)\\n         else:\\n@@ -843,20 +846,20 @@ class Parser:\\n             self.raise_error(\\\"Expected VIEW after LATERAL\\\")\\n \\n         outer = self._match(TokenType.OUTER)\\n-        this = self._parse_function()\\n-        table = self._parse_id_var()\\n-        columns = (\\n-            self._parse_csv(self._parse_id_var)\\n-            if self._match(TokenType.ALIAS)\\n-            else None\\n-        )\\n \\n         return self.expression(\\n             exp.Lateral,\\n-            this=this,\\n+            this=self._parse_function(),\\n             outer=outer,\\n-            table=self.expression(exp.Table, this=table),\\n-            columns=columns,\\n+            alias=self.expression(\\n+                exp.TableAlias,\\n+                this=self._parse_id_var(any_token=False),\\n+                columns=(\\n+                    self._parse_csv(self._parse_id_var)\\n+                    if self._match(TokenType.ALIAS)\\n+                    else None\\n+                ),\\n+            ),\\n         )\\n \\n     def _parse_joins(self):\\n@@ -932,25 +935,24 @@ class Parser:\\n         expressions = self._parse_csv(self._parse_column)\\n         self._match_r_paren()\\n \\n-        ordinality = self._match(TokenType.WITH) and self._match(TokenType.ORDINALITY)\\n-        table = self._parse_id_var(self._match(TokenType.ALIAS))\\n+        ordinality = bool(\\n+            self._match(TokenType.WITH) and self._match(TokenType.ORDINALITY)\\n+        )\\n \\n-        if not self._match(TokenType.L_PAREN):\\n-            return self.expression(\\n-                exp.Unnest, expressions=expressions, ordinality=ordinality, table=table\\n-            )\\n+        alias = self._parse_table_alias()\\n \\n-        columns = self._parse_csv(self._parse_id_var)\\n-        unnest = self.expression(\\n+        if alias and self.unnest_column_only:\\n+            if alias.args.get(\\\"columns\\\"):\\n+                self.raise_error(\\\"Unexpected extra column alias in unnest.\\\")\\n+            alias.set(\\\"columns\\\", [alias.this])\\n+            alias.set(\\\"this\\\", None)\\n+\\n+        return self.expression(\\n             exp.Unnest,\\n             expressions=expressions,\\n-            ordinality=bool(ordinality),\\n-            table=table,\\n-            columns=columns,\\n+            ordinality=ordinality,\\n+            alias=alias,\\n         )\\n-        self._match_r_paren()\\n-\\n-        return unnest\\n \\n     def _parse_table_sample(self, this):\\n         if not self._match(TokenType.TABLE_SAMPLE):\\n\",\"diff --git a/sqlglot/planner.py b/sqlglot/planner.py\\nindex 8a2b227..2006a75 100644\\n--- a/sqlglot/planner.py\\n+++ b/sqlglot/planner.py\\n@@ -62,7 +62,7 @@ class Step:\\n         # CTEs break the mold of scope and introduce themselves to all in the context.\\n         if with_:\\n             ctes = ctes.copy()\\n-            for cte in with_.args[\\\"expressions\\\"]:\\n+            for cte in with_.expressions:\\n                 step = Step.from_expression(cte.this, ctes)\\n                 step.name = cte.alias\\n                 ctes[step.name] = step\\n@@ -70,7 +70,7 @@ class Step:\\n         from_ = expression.args.get(\\\"from\\\")\\n \\n         if from_:\\n-            from_ = from_.args[\\\"expressions\\\"]\\n+            from_ = from_.expressions\\n             if len(from_) > 1:\\n                 raise UnsupportedError(\\n                     \\\"Multi-from statements are unsupported. Run it through the optimizer\\\"\\n@@ -93,7 +93,7 @@ class Step:\\n         aggregations = []\\n         sequence = itertools.count()\\n \\n-        for e in expression.args[\\\"expressions\\\"]:\\n+        for e in expression.expressions:\\n             aggregation = e.find(exp.AggFunc)\\n \\n             if aggregation:\\n@@ -127,7 +127,7 @@ class Step:\\n             aggregate.aggregations = aggregations\\n             aggregate.group = [\\n                 exp.column(e.alias_or_name, step.name, quoted=True)\\n-                for e in group.args[\\\"expressions\\\"]\\n+                for e in group.expressions\\n             ]\\n             aggregate.add_dependency(step)\\n             step = aggregate\\n@@ -142,7 +142,7 @@ class Step:\\n         if order:\\n             sort = Sort()\\n             sort.name = step.name\\n-            sort.key = order.args[\\\"expressions\\\"]\\n+            sort.key = order.expressions\\n             sort.add_dependency(step)\\n             step = sort\\n             for k in sort.key + projections:\\n\"]", "test_patch": "[\"diff --git a/tests/fixtures/identity.sql b/tests/fixtures/identity.sql\\nindex 63c1ad8..c546a76 100644\\n--- a/tests/fixtures/identity.sql\\n+++ b/tests/fixtures/identity.sql\\n@@ -343,16 +343,18 @@ SELECT MAP(ARRAY(1), ARRAY(2)) FROM x\\n SELECT MAX(ARRAY(1, 2, 3)) FROM x\\n SELECT ARRAY(ARRAY(0))[0][0] FROM x\\n SELECT MAP[ARRAY('x'), ARRAY(0)]['x'] FROM x\\n+SELECT student, score FROM tests LATERAL VIEW EXPLODE(scores)\\n+SELECT student, score FROM tests LATERAL VIEW EXPLODE(scores) AS score\\n SELECT student, score FROM tests LATERAL VIEW EXPLODE(scores) t AS score\\n SELECT student, score FROM tests LATERAL VIEW EXPLODE(scores) t AS score, name\\n SELECT student, score FROM tests LATERAL VIEW OUTER EXPLODE(scores) t AS score, name\\n SELECT tf.* FROM (SELECT 0) AS t LATERAL VIEW STACK(1, 2) tf\\n SELECT tf.* FROM (SELECT 0) AS t LATERAL VIEW STACK(1, 2) tf AS col0, col1, col2\\n-SELECT student, score FROM tests CROSS JOIN UNNEST(scores) AS t (score)\\n-SELECT student, score FROM tests CROSS JOIN UNNEST(scores) AS t (a, b)\\n-SELECT student, score FROM tests CROSS JOIN UNNEST(scores) WITH ORDINALITY AS t (a, b)\\n-SELECT student, score FROM tests CROSS JOIN UNNEST(x.scores) AS t (score)\\n-SELECT student, score FROM tests CROSS JOIN UNNEST(ARRAY(x.scores)) AS t (score)\\n+SELECT student, score FROM tests CROSS JOIN UNNEST(scores) AS t(score)\\n+SELECT student, score FROM tests CROSS JOIN UNNEST(scores) AS t(a, b)\\n+SELECT student, score FROM tests CROSS JOIN UNNEST(scores) WITH ORDINALITY AS t(a, b)\\n+SELECT student, score FROM tests CROSS JOIN UNNEST(x.scores) AS t(score)\\n+SELECT student, score FROM tests CROSS JOIN UNNEST(ARRAY(x.scores)) AS t(score)\\n CREATE TABLE a.b AS SELECT 1\\n CREATE TABLE a.b AS SELECT a FROM a.c\\n CREATE TABLE IF NOT EXISTS x AS SELECT a FROM d\\n\",\"diff --git a/tests/fixtures/optimizer/optimizer.sql b/tests/fixtures/optimizer/optimizer.sql\\nindex 8fff637..005ec1c 100644\\n--- a/tests/fixtures/optimizer/optimizer.sql\\n+++ b/tests/fixtures/optimizer/optimizer.sql\\n@@ -1,3 +1,20 @@\\n+SELECT a, m FROM z LATERAL VIEW EXPLODE([1, 2]) q AS m;\\n+SELECT\\n+  \\\"z\\\".\\\"a\\\" AS \\\"a\\\",\\n+  \\\"q\\\".\\\"m\\\" AS \\\"m\\\"\\n+FROM (\\n+  SELECT\\n+    \\\"z\\\".\\\"a\\\" AS \\\"a\\\"\\n+  FROM \\\"z\\\" AS \\\"z\\\"\\n+) AS \\\"z\\\"\\n+LATERAL VIEW\\n+EXPLODE(ARRAY(1, 2)) q AS \\\"m\\\";\\n+\\n+SELECT x FROM UNNEST([1, 2]) AS q(x, y);\\n+SELECT\\n+  \\\"q\\\".\\\"x\\\" AS \\\"x\\\"\\n+FROM UNNEST(ARRAY(1, 2)) AS \\\"q\\\"(\\\"x\\\", \\\"y\\\");\\n+\\n WITH cte AS (\\n     (\\n         SELECT\\n\",\"diff --git a/tests/test_dialects.py b/tests/test_dialects.py\\nindex 9f05342..1097368 100644\\n--- a/tests/test_dialects.py\\n+++ b/tests/test_dialects.py\\n@@ -1,6 +1,6 @@\\n import unittest\\n \\n-from sqlglot import ErrorLevel, UnsupportedError, transpile\\n+from sqlglot import ErrorLevel, ParseError, UnsupportedError, transpile\\n \\n \\n class TestDialects(unittest.TestCase):\\n@@ -381,16 +381,26 @@ class TestDialects(unittest.TestCase):\\n         )\\n         self.validate(\\n             \\\"SELECT * FROM UNNEST(['7', '14']) AS x\\\",\\n-            \\\"SELECT * FROM UNNEST(ARRAY['7', '14']) AS x\\\",\\n+            \\\"SELECT * FROM UNNEST(ARRAY['7', '14']) AS (x)\\\",\\n             read=\\\"bigquery\\\",\\n             write=\\\"presto\\\",\\n         )\\n         self.validate(\\n             \\\"SELECT * FROM UNNEST(ARRAY['7', '14']) AS x\\\",\\n-            \\\"SELECT * FROM UNNEST(['7', '14']) AS x\\\",\\n+            \\\"SELECT * FROM UNNEST(['7', '14'])\\\",\\n+            read=\\\"presto\\\",\\n+            write=\\\"bigquery\\\",\\n+        )\\n+        self.validate(\\n+            \\\"SELECT * FROM UNNEST(ARRAY['7', '14']) AS x(y)\\\",\\n+            \\\"SELECT * FROM UNNEST(['7', '14']) AS y\\\",\\n             read=\\\"presto\\\",\\n             write=\\\"bigquery\\\",\\n         )\\n+\\n+        with self.assertRaises(ParseError):\\n+            transpile(\\\"SELECT * FROM UNNEST(x) AS x(y)\\\", read=\\\"bigquery\\\")\\n+\\n         self.validate(\\n             \\\"x IS unknown\\\",\\n             \\\"x IS NULL\\\",\\n@@ -897,17 +907,17 @@ class TestDialects(unittest.TestCase):\\n         )\\n         self.validate(\\n             \\\"SELECT a, b FROM x LATERAL VIEW EXPLODE(y) t AS a LATERAL VIEW EXPLODE(z) u AS b\\\",\\n-            \\\"SELECT a, b FROM x CROSS JOIN UNNEST(y) AS t (a) CROSS JOIN UNNEST(z) AS u (b)\\\",\\n+            \\\"SELECT a, b FROM x CROSS JOIN UNNEST(y) AS t(a) CROSS JOIN UNNEST(z) AS u(b)\\\",\\n             write=\\\"presto\\\",\\n         )\\n         self.validate(\\n             \\\"SELECT a FROM x LATERAL VIEW EXPLODE(y) t AS a\\\",\\n-            \\\"SELECT a FROM x CROSS JOIN UNNEST(y) AS t (a)\\\",\\n+            \\\"SELECT a FROM x CROSS JOIN UNNEST(y) AS t(a)\\\",\\n             write=\\\"presto\\\",\\n         )\\n         self.validate(\\n             \\\"SELECT a FROM x LATERAL VIEW POSEXPLODE(y) t AS a\\\",\\n-            \\\"SELECT a FROM x CROSS JOIN UNNEST(y) WITH ORDINALITY AS t (a)\\\",\\n+            \\\"SELECT a FROM x CROSS JOIN UNNEST(y) WITH ORDINALITY AS t(a)\\\",\\n             write=\\\"presto\\\",\\n         )\\n \\n@@ -919,7 +929,7 @@ class TestDialects(unittest.TestCase):\\n         )\\n         self.validate(\\n             \\\"SELECT a FROM x LATERAL VIEW EXPLODE(ARRAY(y)) t AS a\\\",\\n-            \\\"SELECT a FROM x CROSS JOIN UNNEST(ARRAY[y]) AS t (a)\\\",\\n+            \\\"SELECT a FROM x CROSS JOIN UNNEST(ARRAY[y]) AS t(a)\\\",\\n             read=\\\"hive\\\",\\n             write=\\\"presto\\\",\\n         )\\n\",\"diff --git a/tests/test_expressions.py b/tests/test_expressions.py\\nindex ddd5ac8..817534c 100644\\n--- a/tests/test_expressions.py\\n+++ b/tests/test_expressions.py\\n@@ -91,11 +91,11 @@ class TestExpressions(unittest.TestCase):\\n             \\\"SELECT a, b AS B, c + d AS e, *, 'zz', 'zz' AS z FROM foo as bar, baz\\\"\\n         )\\n         self.assertEqual(\\n-            [e.alias_or_name for e in expression.args[\\\"expressions\\\"]],\\n+            [e.alias_or_name for e in expression.expressions],\\n             [\\\"a\\\", \\\"B\\\", \\\"e\\\", \\\"*\\\", \\\"zz\\\", \\\"z\\\"],\\n         )\\n         self.assertEqual(\\n-            [e.alias_or_name for e in expression.args[\\\"from\\\"].args[\\\"expressions\\\"]],\\n+            [e.alias_or_name for e in expression.args[\\\"from\\\"].expressions],\\n             [\\\"bar\\\", \\\"baz\\\"],\\n         )\\n \\n@@ -108,12 +108,12 @@ class TestExpressions(unittest.TestCase):\\n         )\\n \\n         self.assertEqual(\\n-            [e.alias_or_name for e in expression.args[\\\"with\\\"].args[\\\"expressions\\\"]],\\n+            [e.alias_or_name for e in expression.args[\\\"with\\\"].expressions],\\n             [\\\"first\\\", \\\"second\\\"],\\n         )\\n \\n         self.assertEqual(\\n-            [e.alias_or_name for e in expression.args[\\\"from\\\"].args[\\\"expressions\\\"]],\\n+            [e.alias_or_name for e in expression.args[\\\"from\\\"].expressions],\\n             [\\\"first\\\", \\\"second\\\", \\\"third\\\"],\\n         )\\n \\n\",\"diff --git a/tests/test_parser.py b/tests/test_parser.py\\nindex 43aac38..bec56ff 100644\\n--- a/tests/test_parser.py\\n+++ b/tests/test_parser.py\\n@@ -43,12 +43,12 @@ class TestParser(unittest.TestCase):\\n         \\\"\\\"\\\"\\n         )\\n \\n-        assert expression.args[\\\"expressions\\\"][0].text(\\\"this\\\") == \\\"a\\\"\\n-        assert expression.args[\\\"expressions\\\"][1].text(\\\"this\\\") == \\\"b\\\"\\n-        assert expression.args[\\\"expressions\\\"][2].text(\\\"alias\\\") == \\\"c\\\"\\n-        assert expression.args[\\\"expressions\\\"][3].text(\\\"alias\\\") == \\\"D\\\"\\n-        assert expression.args[\\\"expressions\\\"][4].text(\\\"alias\\\") == \\\"y|z'\\\"\\n-        table = expression.args[\\\"from\\\"].args[\\\"expressions\\\"][0]\\n+        assert expression.expressions[0].text(\\\"this\\\") == \\\"a\\\"\\n+        assert expression.expressions[1].text(\\\"this\\\") == \\\"b\\\"\\n+        assert expression.expressions[2].text(\\\"alias\\\") == \\\"c\\\"\\n+        assert expression.expressions[3].text(\\\"alias\\\") == \\\"D\\\"\\n+        assert expression.expressions[4].text(\\\"alias\\\") == \\\"y|z'\\\"\\n+        table = expression.args[\\\"from\\\"].expressions[0]\\n         assert table.args[\\\"this\\\"].args[\\\"this\\\"] == \\\"z\\\"\\n         assert table.args[\\\"db\\\"].args[\\\"this\\\"] == \\\"y\\\"\\n \\n@@ -61,12 +61,10 @@ class TestParser(unittest.TestCase):\\n \\n         assert len(expressions) == 2\\n         assert (\\n-            expressions[0].args[\\\"from\\\"].args[\\\"expressions\\\"][0].args[\\\"this\\\"].args[\\\"this\\\"]\\n-            == \\\"a\\\"\\n+            expressions[0].args[\\\"from\\\"].expressions[0].args[\\\"this\\\"].args[\\\"this\\\"] == \\\"a\\\"\\n         )\\n         assert (\\n-            expressions[1].args[\\\"from\\\"].args[\\\"expressions\\\"][0].args[\\\"this\\\"].args[\\\"this\\\"]\\n-            == \\\"b\\\"\\n+            expressions[1].args[\\\"from\\\"].expressions[0].args[\\\"this\\\"].args[\\\"this\\\"] == \\\"b\\\"\\n         )\\n \\n     def test_expression(self):\\n@@ -119,12 +117,12 @@ class TestParser(unittest.TestCase):\\n         \\\"\\\"\\\"\\n         )\\n \\n-        assert expression.args[\\\"expressions\\\"][0].text(\\\"this\\\") == \\\"annotation1\\\"\\n-        assert expression.args[\\\"expressions\\\"][1].text(\\\"this\\\") == \\\"annotation2:testing\\\"\\n-        assert expression.args[\\\"expressions\\\"][2].text(\\\"this\\\") == \\\"test#annotation\\\"\\n-        assert expression.args[\\\"expressions\\\"][3].text(\\\"this\\\") == \\\"c#annotation3\\\"\\n-        assert expression.args[\\\"expressions\\\"][4].text(\\\"this\\\") == \\\"annotation4\\\"\\n-        assert expression.args[\\\"expressions\\\"][5].text(\\\"this\\\") == \\\"\\\"\\n+        assert expression.expressions[0].text(\\\"this\\\") == \\\"annotation1\\\"\\n+        assert expression.expressions[1].text(\\\"this\\\") == \\\"annotation2:testing\\\"\\n+        assert expression.expressions[2].text(\\\"this\\\") == \\\"test#annotation\\\"\\n+        assert expression.expressions[3].text(\\\"this\\\") == \\\"c#annotation3\\\"\\n+        assert expression.expressions[4].text(\\\"this\\\") == \\\"annotation4\\\"\\n+        assert expression.expressions[5].text(\\\"this\\\") == \\\"\\\"\\n \\n     def test_pretty_config_override(self):\\n         self.assertEqual(parse_one(\\\"SELECT col FROM x\\\").sql(), \\\"SELECT col FROM x\\\")\"]", "hints_text": ""}

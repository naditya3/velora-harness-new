{"instance_id": "824518349910624", "repo": "srserves85/avro-to-python", "base_commit": "122268137aa542f1203052dd81a88e70cb149b68", "problem_statement": "Encoding selection not supported:\\nWhen trying to process avsc encoded as UTF-8 in windows following error is thrown (if non-ascii characters are present):\\r\\n\\r\\n```\\r\\n\\tTraceback (most recent call last):\\r\\n\\t  File \"O:\\ws\\mdp\\avro-to-python\\venv\\Scripts\\avro-to-python-script.py\", line 33, in <module>\\r\\n\\t\\tsys.exit(load_entry_point('avro-to-python', 'console_scripts', 'avro-to-python')())\\r\\n\\t  File \"O:\\ws\\mdp\\avro-to-python\\venv\\lib\\site-packages\\click\\core.py\", line 1128, in __call__\\r\\n\\t\\treturn self.main(*args, **kwargs)\\r\\n\\t  File \"O:\\ws\\mdp\\avro-to-python\\venv\\lib\\site-packages\\click\\core.py\", line 1053, in main\\r\\n\\t\\trv = self.invoke(ctx)\\r\\n\\t  File \"O:\\ws\\mdp\\avro-to-python\\venv\\lib\\site-packages\\click\\core.py\", line 1395, in invoke\\r\\n\\t\\treturn ctx.invoke(self.callback, **ctx.params)\\r\\n\\t  File \"O:\\ws\\mdp\\avro-to-python\\venv\\lib\\site-packages\\click\\core.py\", line 754, in invoke\\r\\n\\t\\treturn __callback(*args, **kwargs)\\r\\n\\t  File \"O:\\ws\\mdp\\avro-to-python\\venv\\lib\\site-packages\\avro_to_python\\cli.py\", line 34, in main\\r\\n\\t\\treader.read()\\r\\n\\t  File \"O:\\ws\\mdp\\avro-to-python\\venv\\lib\\site-packages\\avro_to_python\\reader\\read.py\", line 80, in read\\r\\n\\t\\tself._read_files()\\r\\n\\t  File \"O:\\ws\\mdp\\avro-to-python\\venv\\lib\\site-packages\\avro_to_python\\reader\\read.py\", line 125, in _read_files\\r\\n\\t\\tserialized = json.load(f)\\r\\n\\t  File \"C:\\Users\\miguelez\\AppData\\Local\\Programs\\Python\\Python310\\lib\\json\\__init__.py\", line 293, in load\\r\\n\\t\\treturn loads(fp.read(),\\r\\n\\t  File \"C:\\Users\\miguelez\\AppData\\Local\\Programs\\Python\\Python310\\lib\\encodings\\cp1252.py\", line 23, in decode\\r\\n\\t\\treturn codecs.charmap_decode(input,self.errors,decoding_table)[0]\\r\\n\\tUnicodeDecodeError: 'charmap' codec can't decode byte 0x9d in position 41600: character maps to <undefined>\\r\\n```\\r\\n\\r\\n\\r\\n\\nSerialization to JSON of `bytes` fails:\\nWhen trying to serialize to JSON an object generated from an schema with a `bytes` type it fails with following error:\\r\\n\\r\\n```\\r\\nTraceback (most recent call last):\\r\\n  File \"O:\\ws\\mdp\\avro-to-python\\mytest.py\", line 13, in <module>\\r\\n    print(f\"Hello CDM. This is my first entity: {myEvent.serialize()}\")\\r\\n  File \"O:\\ws\\mdp\\avro-to-python\\venv\\lib\\site-packages\\mdh_model_common\\com\\kapschtraffic\\mdp\\mdh\\model\\common\\events\\BaseEvent.py\", line 259, in serialize\\r\\n    return json.dumps(self, default=default_json_serialize)\\r\\n  File \"C:\\Users\\miguelez\\AppData\\Local\\Programs\\Python\\Python310\\lib\\json\\__init__.py\", line 238, in dumps\\r\\n    **kw).encode(obj)\\r\\n  File \"C:\\Users\\miguelez\\AppData\\Local\\Programs\\Python\\Python310\\lib\\json\\encoder.py\", line 199, in encode\\r\\n    chunks = self.iterencode(o, _one_shot=True)\\r\\n  File \"C:\\Users\\miguelez\\AppData\\Local\\Programs\\Python\\Python310\\lib\\json\\encoder.py\", line 257, in iterencode\\r\\n    return _iterencode(o, 0)\\r\\n  File \"O:\\ws\\mdp\\avro-to-python\\venv\\lib\\site-packages\\mdh_model_common\\helpers.py\", line 11, in default_json_serialize\\r\\n    return obj.__dict__\\r\\nAttributeError: 'bytes' object has no attribute '__dict__'. Did you mean: '__dir__'?\\r\\n\\r\\nProcess finished with exit code 1\\r\\n```\\r\\n\\nAllow generated objects to be instantiated without a JSON, dict or object copy:\\nGenerated constructor requires either a `JSON` string, a dictionary or another instance of the same object. \\r\\n\\r\\nThis way it is not possible to initialize an object and fill it up just using the setters. \\r\\n\\r\\nUsing a dict has also disadvantages as error checking is delayed to runtime. ", "FAIL_TO_PASS": ["tests/test_cli.py::CliTests::test_top_level_package_cli", "tests/writer/test_compiled_files.py::PathTests::test_enum", "tests/writer/test_compiled_files.py::PathTests::test_thing", "tests/test_cli.py::CliTests::test_pip_cli", "tests/writer/test_compiled_files.py::PathTests::test_record_with_enum", "tests/writer/test_compiled_files.py::PathTests::test_map_record", "tests/writer/test_compiled_files.py::PathTests::test_record_with_union", "tests/writer/test_compiled_files.py::PathTests::test_record_with_logical_types", "tests/writer/test_compiled_files.py::PathTests::test_record_with_bytes", "tests/reader/avro/test_reader.py::AvroReaderTests::testRecordWithArray", "tests/writer/test_compiled_files.py::PathTests::test_nested_map_record", "tests/reader/avro/test_reader.py::AvroReaderTests::testComplexPrimitiveRecord", "tests/writer/test_compiled_files.py::PathTests::test_record_with_record", "tests/writer/test_compiled_files.py::PathTests::test_nested_things"], "PASS_TO_PASS": ["tests/reader/avro/test_reader.py::AvroReaderTests::testReadRecordWithRecord", "tests/reader/avro/test_reader.py::AvroReaderTests::testRecordWithMap", "tests/reader/avro/test_reader.py::AvroReaderTests::testReadThing", "tests/reader/avro/test_reader.py::AvroReaderTests::testRecordWithNestedMap", "tests/reader/avro/test_reader.py::AvroReaderTests::testUnionRecord", "tests/reader/avro/test_type_factory.py::TestTypeFactory::test_array_field", "tests/test_paths.py::PathTests::test_verify_or_create_namespace_path", "tests/reader/avro/test_type_factory.py::TestTypeFactory::test_enum_type", "tests/reader/avro/test_helpers.py::AvroHelperTests::test_dedupe_imports", "tests/reader/avro/test_helpers.py::AvroHelperTests::test_namespace_retrieval", "tests/test_cli.py::CliTests::test_cli_interface", "tests/reader/avro/test_type_factory.py::TestTypeFactory::test_record_type", "tests/reader/avro/test_type_factory.py::TestTypeFactory::test_union_type", "tests/reader/avro/test_reader.py::AvroReaderTests::testLogicalRecord", "tests/writer/test_duplicate_namespace.py::PathTests::test_namespace_duplicate", "tests/test_paths.py::PathTests::test_get_system_file_path", "tests/reader/avro/test_helpers.py::AvroHelperTests::test_reference_creation", "tests/test_paths.py::PathTests::test_get_avsc_files", "tests/test_paths.py::PathTests::test_get_or_create_path", "tests/reader/avro/test_type_factory.py::TestTypeFactory::test_primitive_type", "tests/test_paths.py::PathTests::test_verify_path_exists", "tests/reader/avro/test_reader.py::AvroReaderTests::testRecordWithNestedUnion", "tests/test_paths.py::PathTests::test_is_avsc_file", "tests/reader/avro/test_reader.py::AvroReaderTests::testRecordWithArrayOrMap", "tests/reader/avro/test_reader.py::AvroReaderTests::testReadRecordWithEnum"], "language": "python", "test_command": "source /saved/ENV || source /saved/*/ENV && pytest --no-header -rA --tb=no -p no:cacheprovider --continue-on-collection-errors", "test_output_parser": "python/parse_log_pytest_v3", "image_storage_uri": "vmvm-registry.fbinfra.net/repomate_image_activ_pytest/srserves85_avro-to-python:122268137aa542f1203052dd81a88e70cb149b68", "patch": "[\"diff --git a/AUTHORS.rst b/AUTHORS.rst\\nindex 2cd15e6..1f8aec7 100644\\n--- a/AUTHORS.rst\\n+++ b/AUTHORS.rst\\n@@ -14,4 +14,5 @@ Contributors\\n * Ivan isenilov <https://github.com/isenilov>\\n * Ethan Schwab <https://github.com/ethan-schwab>\\n * Alejandro Jaramillo <https://github.com/irux>\\n-* Jon Leung <https://github.com/jkleung11>\\n\\\\ No newline at end of file\\n+* Jon Leung <https://github.com/jkleung11>\\n+* Fernando Migu√©lez Palomo <https://github.com/fmiguelez>\\n\",\"diff --git a/HISTORY.rst b/HISTORY.rst\\nindex 689733e..4326bd7 100644\\n--- a/HISTORY.rst\\n+++ b/HISTORY.rst\\n@@ -2,6 +2,16 @@\\n History\\n =======\\n \\n+0.3.4 (Future)\\n+^^^^^^^^^^^^^^^^^^\\n+\\n+* Fix primitive type with metadata handling.\\n+* Fix multi-dimensional array handling.\\n+* Allow empty constructor in generated objects.\\n+* Support encoding bytes in JSON as base64 string.\\n+* Added encoding option for source and target files.\\n+* Support arrays with union item types.\\n+\\n 0.3.3 (2022-01-26)\\n ^^^^^^^^^^^^^^^^^^\\n \\n\",\"diff --git a/avro_to_python/cli.py b/avro_to_python/cli.py\\nindex aecf8a4..4ec539f 100644\\n--- a/avro_to_python/cli.py\\n+++ b/avro_to_python/cli.py\\n@@ -11,9 +11,10 @@ from avro_to_python.reader.read import AvscReader\\n from avro_to_python.writer.writer import AvroWriter\\n \\n \\n-PIP_HELP = 'make package pip installable using this name'\\n-AUTHOR_HELP = 'author name of the pip installable package'\\n-VERSION_HELP = 'version of the pip intallable package'\\n+PIP_HELP = 'Make package pip installable using this name.'\\n+AUTHOR_HELP = 'Author name of the pip installable package.'\\n+VERSION_HELP = 'Version of the pip installable package.'\\n+ENCODING_HELP = 'Encoding to use for source and target (overrides system encoding).'\\n \\n \\n @click.command()\\n@@ -23,21 +24,23 @@ VERSION_HELP = 'version of the pip intallable package'\\n @click.option('--top_level_package', type=str, default=None, required=False, show_default=True, help=PIP_HELP)  # NOQA\\n @click.option('--author', type=str, default=None, required=False, show_default=True, help=AUTHOR_HELP)  # NOQA\\n @click.option('--package_version', type=str, default='0.1.0', required=False, show_default=True, help=VERSION_HELP)  # NOQA\\n-def main(source, target, pip=None, top_level_package=None, author=None, package_version=None):\\n+@click.option('--encoding', type=str, default=None, required=False, show_default=True, help=ENCODING_HELP)  # NOQA\\n+def main(source, target, pip=None, top_level_package=None, author=None, package_version=None, encoding=None):\\n     \\\"\\\"\\\"avro-to-python: compile avro avsc schemata to python classes\\n     \\\"\\\"\\\"\\n \\n     if os.path.isfile(source):\\n-        reader = AvscReader(file=source)\\n+        reader = AvscReader(file=source, encoding=encoding)\\n     else:\\n-        reader = AvscReader(directory=source)\\n+        reader = AvscReader(directory=source, encoding=encoding)\\n     reader.read()\\n     writer = AvroWriter(\\n         reader.file_tree,\\n         pip=pip,\\n         top_level_package=top_level_package,\\n         author=author,\\n-        package_version=package_version\\n+        package_version=package_version,\\n+        encoding=encoding\\n     )\\n     writer.write(root_dir=target)\\n     del reader\\n\",\"diff --git a/avro_to_python/reader/read.py b/avro_to_python/reader/read.py\\nindex 9390089..2bee0ce 100644\\n--- a/avro_to_python/reader/read.py\\n+++ b/avro_to_python/reader/read.py\\n@@ -28,7 +28,7 @@ class AvscReader(object):\\n     \\\"\\\"\\\"\\n     file_tree = None\\n \\n-    def __init__(self, directory: str=None, file: str=None) -> None:\\n+    def __init__(self, directory: str=None, file: str=None, encoding: str=None) -> None:\\n         \\\"\\\"\\\" Initializer should just create a list of files to process\\n \\n         Parameters\\n@@ -41,6 +41,10 @@ class AvscReader(object):\\n                 path of avsc file to compile\\n                 Cannot be used with \\\"directory\\\" param\\n \\n+            encoding: str\\n+                encoding of the source file(s) (defaults to\\n+                system encoding)\\n+\\n         Returns\\n         -------\\n             None\\n@@ -49,6 +53,7 @@ class AvscReader(object):\\n         # initialize cental object\\n         self.obj = {}\\n         self.file_tree = None\\n+        self.encoding = encoding\\n \\n         if directory:\\n             if os.path.isfile(directory):\\n@@ -121,7 +126,7 @@ class AvscReader(object):\\n         \\\"\\\"\\\" reads and serializes avsc files to central object\\n         \\\"\\\"\\\"\\n         for file in self.files:\\n-            with open(file, 'r') as f:\\n+            with open(file, 'r', encoding=self.encoding) as f:\\n                 serialized = json.load(f)\\n                 self.obj['avsc'].append(serialized)\\n \\n\",\"diff --git a/avro_to_python/templates/fields/arrayField.j2 b/avro_to_python/templates/fields/arrayField.j2\\nindex 4d082c3..cb57cc7 100644\\n--- a/avro_to_python/templates/fields/arrayField.j2\\n+++ b/avro_to_python/templates/fields/arrayField.j2\\n@@ -1,6 +1,5 @@\\n {%- block array %}\\n     def set_{{name}}(self, values: list) -> None:\\n-\\n         self.{{name}} = []\\n         if isinstance(values, list):\\n             for element in values:\\n@@ -14,7 +13,7 @@\\n                     raise TypeError(\\n                         \\\"Type for '{{name}}' should be '{{primitive_type_map[field.array_item_type.fieldtype]}}'\\\"\\n                     )\\n-                {%- elif field.array_item_type.fieldtype == 'map'%}\\n+                {%- elif field.array_item_type.fieldtype == 'map' or field.array_item_type.fieldtype == 'array' or field.array_item_type.fieldtype == 'union'%}\\n                 self.{{name}}.append(element)\\n                 {%- endif %}\\n         else:\\n\",\"diff --git a/avro_to_python/templates/fields/primitiveField.j2 b/avro_to_python/templates/fields/primitiveField.j2\\nindex a7c7e3b..163926d 100644\\n--- a/avro_to_python/templates/fields/primitiveField.j2\\n+++ b/avro_to_python/templates/fields/primitiveField.j2\\n@@ -1,12 +1,10 @@\\n {%- block primitive %}\\n     def set_{{name}}(self, value: {{primitive_type_map[field.avrotype]}}) -> None:\\n-\\n         if isinstance(value, {{primitive_type_map[field.avrotype]}}):\\n             self.{{name}} = value\\n         else:\\n             raise TypeError(\\\"field '{{name}}' should be type {{primitive_type_map[field.avrotype]}}\\\")\\n \\n     def get_{{name}}(self) -> {{primitive_type_map[field.avrotype]}}:\\n-\\n         return self.{{name}}\\n-{%- endblock -%}\\n\\\\ No newline at end of file\\n+{%- endblock -%}\\n\",\"diff --git a/avro_to_python/templates/files/helpers.j2 b/avro_to_python/templates/files/helpers.j2\\nindex 410d407..cb8c016 100644\\n--- a/avro_to_python/templates/files/helpers.j2\\n+++ b/avro_to_python/templates/files/helpers.j2\\n@@ -1,15 +1,24 @@\\n \\\"\\\"\\\" helper files for avro serialization \\\"\\\"\\\"\\n \\n from enum import Enum, EnumMeta\\n+from base64 import b64encode, b64decode\\n \\n \\n def default_json_serialize(obj):\\n-    \\\"\\\"\\\" Wrapper for serializing enum types \\\"\\\"\\\"\\n+    \\\"\\\"\\\" Wrapper for serializing enum and bytes types\\\"\\\"\\\"\\n     if isinstance(obj, Enum):\\n         return obj.name\\n+    elif isinstance(obj, bytes):\\n+        return b64encode(obj).decode('utf-8')\\n     else:\\n         return obj.__dict__\\n \\n+def default_json_deserialize(obj, targetType):\\n+    \\\"\\\"\\\" Wrapper for deserializing bytes type\\\"\\\"\\\"\\n+    if isinstance(obj, str) and targetType == bytes:\\n+        return b64decode(obj)\\n+    else:\\n+        return obj\\n \\n def todict(obj, classkey=None):\\n     \\\"\\\"\\\" helper function to convert nested objects to dicts \\\"\\\"\\\"\\n@@ -43,4 +52,4 @@ class DefaultEnumMeta(EnumMeta):\\n             # Assume the first enum is default\\n             return next(iter(cls))\\n         return super().__call__(value, *args, **kwargs)\\n-{##}\\n\\\\ No newline at end of file\\n+{##}\\n\",\"diff --git a/avro_to_python/templates/files/record.j2 b/avro_to_python/templates/files/record.j2\\nindex 7ab9a61..97d8e6f 100644\\n--- a/avro_to_python/templates/files/record.j2\\n+++ b/avro_to_python/templates/files/record.j2\\n@@ -2,7 +2,10 @@\\n class {{file.name}}(object):\\n \\n     {% include 'partials/avroSchema.j2'|indent(-4) %}\\n-    def __init__(self, obj: Union[str, dict, '{{file.name}}']) -> None:\\n+    def __init__(self, obj: Union[str, dict, '{{file.name}}'] = None) -> None:\\n+        if obj is None:\\n+            return\\n+\\n         if isinstance(obj, str):\\n             obj = json.loads(obj)\\n \\n@@ -22,4 +25,4 @@ class {{file.name}}(object):\\n {% for name, field in file.fields.items() -%}\\n {% include 'fields/fieldFactory.j2' %}\\n {% endfor -%}\\n-{%- endblock -%}\\n\\\\ No newline at end of file\\n+{%- endblock -%}\\n\",\"diff --git a/avro_to_python/templates/imports/basicImports.j2 b/avro_to_python/templates/imports/basicImports.j2\\nindex 32f3ccc..6eacc23 100644\\n--- a/avro_to_python/templates/imports/basicImports.j2\\n+++ b/avro_to_python/templates/imports/basicImports.j2\\n@@ -1,11 +1,11 @@\\n {%- block basicimports %}\\n import json\\n {%- if file.avrotype == 'record' %}\\n-from {{pip_import}}helpers import default_json_serialize, todict\\n+from {{pip_import}}helpers import default_json_serialize, default_json_deserialize, todict\\n from typing import Union\\n {%- endif -%}\\n {%- if file.avrotype == 'enum' %}\\n from enum import Enum\\n from {{pip_import}}helpers import default_json_serialize, DefaultEnumMeta, todict\\n {%- endif -%}\\n-{% endblock %}\\n\\\\ No newline at end of file\\n+{% endblock %}\\n\",\"diff --git a/avro_to_python/templates/partials/objectSetter.j2 b/avro_to_python/templates/partials/objectSetter.j2\\nindex da4c2af..b8c8c9c 100644\\n--- a/avro_to_python/templates/partials/objectSetter.j2\\n+++ b/avro_to_python/templates/partials/objectSetter.j2\\n@@ -1,7 +1,11 @@\\n {%- block object_setter %}\\n {%- if field.default is string -%}\\n         self.set_{{name}}(obj.get('{{name}}', '{{field.default}}'))\\n+{%- elif field.fieldtype == 'primitive' -%}\\n+        self.set_{{name}}(default_json_deserialize(obj.get('{{name}}', {{field.default}}), {{primitive_type_map[field.avrotype]}}))\\n+{%- elif field.fieldtype == 'union' and get_not_null_primitive_type_in_union(field) != '' -%}\\n+        self.set_{{name}}(default_json_deserialize(obj.get('{{name}}', {{field.default}}), {{get_not_null_primitive_type_in_union(field)}}))\\n {%- else -%}\\n         self.set_{{name}}(obj.get('{{name}}', {{field.default}}))\\n {%- endif -%}\\n-{% endblock -%}\\n\\\\ No newline at end of file\\n+{% endblock -%}\\n\",\"diff --git a/avro_to_python/utils/avro/helpers.py b/avro_to_python/utils/avro/helpers.py\\nindex e467614..8297348 100644\\n--- a/avro_to_python/utils/avro/helpers.py\\n+++ b/avro_to_python/utils/avro/helpers.py\\n@@ -107,7 +107,7 @@ def get_union_types(\\n     Returns\\n     -------\\n         out_types: str\\n-            comma seperated string of python types\\n+            comma separated string of python types\\n     \\\"\\\"\\\"\\n \\n     out_types = []\\n@@ -133,6 +133,33 @@ def get_union_types(\\n \\n     return ','.join(out_types)\\n \\n+def get_not_null_primitive_type_in_union(\\n+    field: Field,\\n+    PRIMITIVE_TYPE_MAP: dict=PRIMITIVE_TYPE_MAP\\n+) -> str:\\n+    \\\"\\\"\\\" Takes a field object and returns the not null primitive type if any\\n+\\n+    Parameters\\n+    ----------\\n+        field: dict\\n+            dictionary resembling a field for a union type\\n+        PRIMITIVE_TYPE_MAP: dict\\n+            lookup table mapping avro types to python types\\n+\\n+    Returns\\n+    -------\\n+        out_type: str\\n+            primitive type in union if any or empty string otherwise\\n+    \\\"\\\"\\\"\\n+\\n+    for obj in field.union_types:\\n+\\n+        # primitive type\\n+        if obj.fieldtype == 'primitive' and obj.avrotype != 'null':\\n+            return PRIMITIVE_TYPE_MAP.get(obj.avrotype)\\n+\\n+    return ''\\n+\\n \\n def dedupe_imports(imports: List[Reference]) -> None:\\n     \\\"\\\"\\\" Dedupes list of imports\\n\",\"diff --git a/avro_to_python/utils/avro/types/array.py b/avro_to_python/utils/avro/types/array.py\\nindex 884c07f..bfeca2a 100644\\n--- a/avro_to_python/utils/avro/types/array.py\\n+++ b/avro_to_python/utils/avro/types/array.py\\n@@ -46,6 +46,8 @@ def _array_field(field: dict,\\n \\n     if isinstance(field['type']['items'], str):\\n         field['type']['items'] = {'type': field['type']['items']}\\n+    elif isinstance(field['type']['items'], list):\\n+        field['type']['items'] = {'type': field['type']['items']}\\n \\n     field_item_type = _get_field_type(\\n         field['type']['items'],\\n@@ -61,7 +63,7 @@ def _array_field(field: dict,\\n         })\\n \\n     # handle complex types\\n-    elif field_item_type in ['record', 'enum', 'map']:\\n+    elif field_item_type in ['record', 'enum', 'map', 'array', 'union']:\\n         if field_item_type == 'record':\\n             _func = _record_field\\n         elif field_item_type == 'enum':\\n@@ -71,6 +73,14 @@ def _array_field(field: dict,\\n             # the same in map.py\\n             from avro_to_python.utils.avro.types.map import _map_field\\n             _func = _map_field\\n+        elif field_item_type == 'array':\\n+            _func = _array_field\\n+        elif field_item_type == 'union':\\n+            # delayed importing to avoid circular dependency, may want to do\\n+            # the same in map.py\\n+            from avro_to_python.utils.avro.types.union import _union_field\\n+            field['type']['items'] = field['type']['items']['type']\\n+            _func = _union_field\\n         else:\\n             raise ValueError(\\\"you shouldn't have been able to get here\\\")\\n         kwargs.update({'array_item_type': _func(\\n\",\"diff --git a/avro_to_python/utils/avro/types/primitive.py b/avro_to_python/utils/avro/types/primitive.py\\nindex c0cb177..93f1f64 100644\\n--- a/avro_to_python/utils/avro/types/primitive.py\\n+++ b/avro_to_python/utils/avro/types/primitive.py\\n@@ -39,6 +39,8 @@ def _primitive_type(field: Union[dict, str]) -> dict:\\n         elif isinstance(field.get('type'), dict):\\n             if field.get('type', {}).get('logicalType'):\\n                 kwargs.update({'avrotype': field['type']['type']})\\n+            elif field.get('type', {}).get('type') in PRIMITIVE_TYPES:\\n+                kwargs.update({'avrotype': field['type']['type']})\\n \\n         elif isinstance(field.get('type'), str):\\n             if field['type'] in PRIMITIVE_TYPES:\\n\",\"diff --git a/avro_to_python/utils/avro/types/type_factory.py b/avro_to_python/utils/avro/types/type_factory.py\\nindex 6b1bfd2..5b21a5f 100644\\n--- a/avro_to_python/utils/avro/types/type_factory.py\\n+++ b/avro_to_python/utils/avro/types/type_factory.py\\n@@ -44,6 +44,9 @@ def _get_field_type(field: dict, references: list=None) -> str:\\n                 raise ValueError(\\n                     f'{field[\\\"type\\\"][\\\"type\\\"]} is not supported.'\\n                 )\\n+        # primitive type with metadata (e.g. \\\"java-class\\\":\\\"[B]\\\")\\n+        elif field['type']['type'] in PRIMITIVE_TYPES:\\n+            return 'primitive'\\n \\n         else:\\n             raise ValueError(\\n\",\"diff --git a/avro_to_python/writer/writer.py b/avro_to_python/writer/writer.py\\nindex c43eaf8..dff7232 100644\\n--- a/avro_to_python/writer/writer.py\\n+++ b/avro_to_python/writer/writer.py\\n@@ -6,7 +6,7 @@ import os\\n from jinja2 import Environment, FileSystemLoader\\n \\n from avro_to_python.classes.node import Node\\n-from avro_to_python.utils.avro.helpers import get_union_types\\n+from avro_to_python.utils.avro.helpers import get_union_types, get_not_null_primitive_type_in_union\\n from avro_to_python.utils.avro.primitive_types import PRIMITIVE_TYPE_MAP\\n from avro_to_python.utils.paths import (\\n     get_system_path, verify_or_create_namespace_path, get_or_create_path,\\n@@ -54,7 +54,7 @@ class AvroWriter(object):\\n     files = []\\n \\n     def __init__(self, tree: dict, pip: str=None, top_level_package: str=None, author: str=None,\\n-                 package_version: str=None) -> None:\\n+                 package_version: str=None, encoding=None) -> None:\\n         \\\"\\\"\\\" Parses tree structured dictionaries into python files\\n \\n         Parameters\\n@@ -64,8 +64,14 @@ class AvroWriter(object):\\n                 acyclic tree representing a read avro schema namespace\\n             pip: str\\n                 pip package name\\n+            top_level_package: str\\n+                top level package to use (if specified)\\n             author: str\\n                 author of pip package\\n+            package_version: str\\n+                version of pip package\\n+            encoding: str\\n+                output encoding to use (default to system encoding)\\n \\n         Returns\\n         -------\\n@@ -85,6 +91,7 @@ class AvroWriter(object):\\n         self.author = author\\n         self.package_version = package_version\\n         self.tree = tree\\n+        self.encoding = encoding\\n \\n         # jinja2 templates\\n         self.template_env = Environment(loader=FileSystemLoader(TEMPLATE_PATH))\\n@@ -133,7 +140,7 @@ class AvroWriter(object):\\n         filetext = template.render(\\n             pip = self.pip\\n         )\\n-        with open(filepath, 'w') as f:\\n+        with open(filepath, 'w', encoding=self.encoding) as f:\\n             f.write(filetext)\\n \\n     def _write_setup_file(self) -> None:\\n@@ -145,7 +152,7 @@ class AvroWriter(object):\\n             author=self.author,\\n             package_version=self.package_version\\n         )\\n-        with open(filepath, 'w') as f:\\n+        with open(filepath, 'w', encoding=self.encoding) as f:\\n             f.write(filetext)\\n \\n     def _write_pip_init_file(self) -> None:\\n@@ -157,7 +164,7 @@ class AvroWriter(object):\\n             author=self.author,\\n             package_version=self.package_version\\n         )\\n-        with open(filepath, 'w') as f:\\n+        with open(filepath, 'w', encoding=self.encoding) as f:\\n             f.write(filetext)\\n \\n     def _write_helper_file(self) -> None:\\n@@ -165,7 +172,7 @@ class AvroWriter(object):\\n         filepath = self.top_level_package_dir + '/helpers.py'\\n         template = self.template_env.get_template('files/helpers.j2')\\n         filetext = template.render()\\n-        with open(filepath, 'w') as f:\\n+        with open(filepath, 'w', encoding=self.encoding) as f:\\n             f.write(filetext)\\n \\n     def _write_init_file(self, imports: set, namespace: str) -> None:\\n@@ -180,7 +187,7 @@ class AvroWriter(object):\\n             namespace=namespace\\n         )\\n         filepath = self.top_level_package_dir + namespace.replace('.', '/') + '/' + '__init__.py'  # NOQA\\n-        with open(filepath, 'w') as f:\\n+        with open(filepath, 'w', encoding=self.encoding) as f:\\n             f.write(filetext)\\n \\n     def _write_file(\\n@@ -193,7 +200,7 @@ class AvroWriter(object):\\n             namespace=namespace\\n         )\\n         filepath = self.top_level_package_dir + namespace.replace('.', '/') + '/' + filename + '.py'  # NOQA\\n-        with open(filepath, 'w') as f:\\n+        with open(filepath, 'w', encoding=self.encoding) as f:\\n             f.write(filetext)\\n \\n     def _render_file(self, file: dict) -> str:\\n@@ -213,6 +220,7 @@ class AvroWriter(object):\\n             file=file,\\n             primitive_type_map=PRIMITIVE_TYPE_MAP,\\n             get_union_types=get_union_types,\\n+            get_not_null_primitive_type_in_union=get_not_null_primitive_type_in_union,\\n             json=json,\\n             pip_import=self.pip_import,\\n             enumerate=enumerate\\n\",\"diff --git a/helpers.py b/helpers.py\\nindex c91e0e5..d6f779c 100644\\n--- a/helpers.py\\n+++ b/helpers.py\\n@@ -1,15 +1,24 @@\\n \\\"\\\"\\\" helper files for avro serialization \\\"\\\"\\\"\\n \\n from enum import Enum, EnumMeta\\n+from base64 import b64encode, b64decode\\n \\n \\n def default_json_serialize(obj):\\n-    \\\"\\\"\\\" Wrapper for serializing enum types \\\"\\\"\\\"\\n+    \\\"\\\"\\\" Wrapper for serializing enum and bytes types\\\"\\\"\\\"\\n     if isinstance(obj, Enum):\\n         return obj.name\\n+    elif isinstance(obj, bytes):\\n+        return b64encode(obj).decode('utf-8')\\n     else:\\n         return obj.__dict__\\n \\n+def default_json_deserialize(obj, targetType):\\n+    \\\"\\\"\\\" Wrapper for deserializing bytes type\\\"\\\"\\\"\\n+    if isinstance(obj, str) and targetType == bytes:\\n+        return b64decode(obj)\\n+    else:\\n+        return obj\\n \\n def todict(obj, classkey=None):\\n     \\\"\\\"\\\" helper function to convert nested objects to dicts \\\"\\\"\\\"\\n\",\"diff --git a/requirements.txt b/requirements.txt\\nindex b0c473a..9349e8e 100644\\n--- a/requirements.txt\\n+++ b/requirements.txt\\n@@ -1,3 +1,3 @@\\n-Jinja2==3.0.3\\n+Jinja2==3.1.2\\n MarkupSafe==2.0.1\\n-Click==7.0\\n\\\\ No newline at end of file\\n+Click==8.0.4\\n\",\"diff --git a/setup.cfg b/setup.cfg\\nindex 39e81ed..1f05201 100644\\n--- a/setup.cfg\\n+++ b/setup.cfg\\n@@ -1,5 +1,5 @@\\n [bumpversion]\\n-current_version = 0.3.3\\n+current_version = 0.3.4\\n commit = True\\n tag = True\\n \\n\"]", "test_patch": "[\"diff --git a/README.rst b/README.rst\\nindex dd8586d..dad432e 100644\\n--- a/README.rst\\n+++ b/README.rst\\n@@ -58,12 +58,14 @@ To use the cli, here is the available cli commands:\\n \\n     avro-to-python [source] [target]\\n         Options:\\n-            --pip TEXT              make package pip installable using this name\\n-            --top_level_package     override top level package name (optional)\\n-            --author TEXT           author name of the pip installable package\\n-            --package_version TEXT  version of the pip intallable package  [default: 0.1.0]\\n-            --help                  Show this message and exit\\n-\\n+            --pip TEXT                Make package pip installable using this name.\\n+            --top_level_package TEXT  Make package pip installable using this name.\\n+            --author TEXT             Author name of the pip installable package.\\n+            --package_version TEXT    Version of the pip installable package.  [default:\\n+                            0.1.0]\\n+            --encoding TEXT           Encoding to use for source and target (overrides\\n+                                      system encoding).\\n+            --help                    Show this message and exit.\\n \\n The above will compile the avsc files and convert the to python classes found in [path_to_target_directory]\\n \\n@@ -130,7 +132,7 @@ You can customize the top level package name *test_avro*, modifying the \\\"--top_l\\n \\n avro-to-python in a Script\\n --------------------------\\n-You can also use the reader and writer packages in avro-to-python as you would any other python package. Avro to python is split between a *reader* and *writer* classes. avro-to-python treates namespaces as acyclic trees and uses depth first search to ensure no duplication or namespace collisions on read and write. An example useage is below:\\n+You can also use the reader and writer packages in avro-to-python as you would any other python package. Avro to python is split between a *reader* and *writer* classes. avro-to-python treats namespaces as acyclic trees and uses depth first search to ensure no duplication or namespace collisions on read and write. An example usage is below:\\n \\n .. code-block:: python\\n \\n@@ -179,7 +181,7 @@ Writer\\n \\n CLI\\n \\n-- [X] Wrap Writer and Reader into one cli commmit\\n+- [X] Wrap Writer and Reader into one cli commit\\n - [X] Add pip install option (would include all files to pip install compiled package)\\n - [ ] Add better --help documentation\\n \\n\",\"diff --git a/requirements_dev.txt b/requirements_dev.txt\\nindex cb6fe84..4040386 100644\\n--- a/requirements_dev.txt\\n+++ b/requirements_dev.txt\\n@@ -1,12 +1,12 @@\\n-pip==22.0.4,\\n-bump2version==1.0.1,\\n-wheel==0.37.1,\\n-watchdog==2.1.6,\\n-flake8==4.0.1,\\n-tox==3.24.5,\\n-coverage==6.3.2,\\n-Sphinx==4.4.0,\\n-twine==3.8.0,\\n-Click==8.0.4,\\n-pytest==7.1.1,\\n-pytest-runner==6.0.0\\n\\\\ No newline at end of file\\n+pip==22.0.4\\n+bump2version==1.0.1\\n+wheel==0.37.1\\n+watchdog==2.1.6\\n+flake8==4.0.1\\n+tox==3.24.5\\n+coverage==6.3.2\\n+Sphinx==4.4.0\\n+twine==3.8.0\\n+Click==8.0.4\\n+pytest==7.1.1\\n+pytest-runner==6.0.0\\n\",\"diff --git a/setup.py b/setup.py\\nindex 749df71..bf1a512 100644\\n--- a/setup.py\\n+++ b/setup.py\\n@@ -12,7 +12,7 @@ with open('HISTORY.rst') as history_file:\\n     history = history_file.read()\\n \\n \\n-requirements = ['Jinja2==2.10.3', 'Click==7.0', 'MarkupSafe==2.0.1']\\n+requirements = ['Jinja2==3.1.2', 'Click==8.0.4', 'MarkupSafe==2.0.1']\\n \\n test_requirements = [\\n     'pip==22.0.4',\\n@@ -27,7 +27,7 @@ test_requirements = [\\n     'Click==8.0.4',\\n     'pytest==7.1.1',\\n     'pytest-runner==6.0.0',\\n-    'Jinja2==3.0.3',\\n+    'Jinja2==3.1.2',\\n     'MarkupSafe==2.0.1'\\n ]\\n \\n@@ -62,6 +62,6 @@ setup(\\n     test_suite='tests',\\n     tests_require=test_requirements,\\n     url='https://github.com/srserves85/avro-to-python',\\n-    version='1.0.1',\\n+    version='0.3.4.dev1',\\n     zip_safe=False,\\n )\\n\",\"diff --git a/tests/avsc/namespace_duplicate_test/records/RecordWithComplexPrimitive.py b/tests/avsc/namespace_duplicate_test/records/RecordWithComplexPrimitive.py\\nnew file mode 100644\\nindex 0000000..b6740c2\\n--- /dev/null\\n+++ b/tests/avsc/namespace_duplicate_test/records/RecordWithComplexPrimitive.py\\n@@ -0,0 +1,59 @@\\n+# -*- coding: utf-8 -*-\\n+\\n+\\\"\\\"\\\" avro python class for file: RecordWithComplexPrimitive \\\"\\\"\\\"\\n+\\n+import json\\n+from helpers import default_json_serialize, default_json_deserialize, todict\\n+from typing import Union\\n+\\n+\\n+class RecordWithComplexPrimitive(object):\\n+\\n+    schema = \\\"\\\"\\\"\\n+    {\\n+        \\\"type\\\": \\\"record\\\",\\n+        \\\"name\\\": \\\"RecordWithComplexPrimitive\\\",\\n+        \\\"namespace\\\": \\\"records\\\",\\n+        \\\"fields\\\": [\\n+            {\\n+                \\\"name\\\": \\\"binaryData\\\",\\n+                \\\"type\\\": {\\n+                    \\\"type\\\": \\\"bytes\\\",\\n+                    \\\"java-class\\\": \\\"[B\\\"\\n+                }\\n+            }\\n+        ]\\n+    }\\n+    \\\"\\\"\\\"\\n+\\n+    def __init__(self, obj: Union[str, dict, 'RecordWithComplexPrimitive'] = None) -> None:\\n+        if obj is None:\\n+            return\\n+\\n+        if isinstance(obj, str):\\n+            obj = json.loads(obj)\\n+\\n+        elif isinstance(obj, type(self)):\\n+            obj = obj.__dict__\\n+\\n+        elif not isinstance(obj, dict):\\n+            raise TypeError(\\n+                f\\\"{type(obj)} is not in ('str', 'dict', 'RecordWithComplexPrimitive')\\\"\\n+            )\\n+\\n+        self.set_binaryData(default_json_deserialize(obj.get('binaryData', None), bytes))\\n+\\n+    def dict(self):\\n+        return todict(self)\\n+\\n+    def set_binaryData(self, value: bytes) -> None:\\n+        if isinstance(value, bytes):\\n+            self.binaryData = value\\n+        else:\\n+            raise TypeError(\\\"field 'binaryData' should be type bytes\\\")\\n+\\n+    def get_binaryData(self) -> bytes:\\n+        return self.binaryData\\n+\\n+    def serialize(self) -> None:\\n+        return json.dumps(self, default=default_json_serialize)\\n\",\"diff --git a/tests/avsc/records/RecordWithArray.avsc b/tests/avsc/records/RecordWithArray.avsc\\nindex c3725fe..10d4f82 100644\\n--- a/tests/avsc/records/RecordWithArray.avsc\\n+++ b/tests/avsc/records/RecordWithArray.avsc\\n@@ -29,5 +29,34 @@\\n         \\\"type\\\": \\\"Thing\\\"\\n       }\\n     }\\n+  }, {\\n+    \\\"name\\\": \\\"twoDimDoubleArray\\\",\\n+    \\\"type\\\": {\\n+      \\\"type\\\": \\\"array\\\",\\n+      \\\"items\\\" : {\\n+        \\\"type\\\" : \\\"array\\\",\\n+        \\\"items\\\" : \\\"double\\\",\\n+        \\\"java-class\\\" : \\\"[D\\\"\\n+      },\\n+      \\\"java-class\\\" : \\\"[[D\\\"\\n+    }\\n+  }, {\\n+    \\\"name\\\": \\\"threeDimRecordArray\\\",\\n+    \\\"type\\\": {\\n+      \\\"type\\\": \\\"array\\\",\\n+      \\\"items\\\" : {\\n+        \\\"type\\\" : \\\"array\\\",\\n+        \\\"items\\\" : {\\n+          \\\"type\\\" : \\\"array\\\",\\n+          \\\"items\\\" : \\\"Thing\\\"\\n+        }\\n+      }\\n+    }\\n+  }, {\\n+    \\\"name\\\": \\\"arrayOfUnion\\\",\\n+    \\\"type\\\": {\\n+      \\\"type\\\": \\\"array\\\",\\n+      \\\"items\\\" : [ \\\"Thing\\\", \\\"int\\\" ]\\n+    }\\n   } ]\\n-}\\n\\\\ No newline at end of file\\n+}\\n\",\"diff --git a/tests/avsc/records/RecordWithBytes.avsc b/tests/avsc/records/RecordWithBytes.avsc\\nnew file mode 100644\\nindex 0000000..1c01a75\\n--- /dev/null\\n+++ b/tests/avsc/records/RecordWithBytes.avsc\\n@@ -0,0 +1,9 @@\\n+{\\n+  \\\"type\\\" : \\\"record\\\",\\n+  \\\"name\\\" : \\\"RecordWithBytes\\\",\\n+  \\\"namespace\\\" : \\\"records\\\",\\n+  \\\"fields\\\" : [ {\\n+    \\\"name\\\" : \\\"binaryData\\\",\\n+    \\\"type\\\" : \\\"bytes\\\"\\n+  } ]\\n+}\\n\",\"diff --git a/tests/avsc/records/RecordWithComplexPrimitive.avsc b/tests/avsc/records/RecordWithComplexPrimitive.avsc\\nnew file mode 100644\\nindex 0000000..bc25cf3\\n--- /dev/null\\n+++ b/tests/avsc/records/RecordWithComplexPrimitive.avsc\\n@@ -0,0 +1,12 @@\\n+{\\n+  \\\"type\\\" : \\\"record\\\",\\n+  \\\"name\\\" : \\\"RecordWithComplexPrimitive\\\",\\n+  \\\"namespace\\\" : \\\"records\\\",\\n+  \\\"fields\\\" : [ {\\n+    \\\"name\\\" : \\\"binaryData\\\",\\n+    \\\"type\\\" : {\\n+      \\\"type\\\" : \\\"bytes\\\",\\n+      \\\"java-class\\\" : \\\"[B\\\"\\n+    }\\n+  } ]\\n+}\\n\",\"diff --git a/tests/avsc/records/helpers.py b/tests/avsc/records/helpers.py\\nindex c91e0e5..d6f779c 100644\\n--- a/tests/avsc/records/helpers.py\\n+++ b/tests/avsc/records/helpers.py\\n@@ -1,15 +1,24 @@\\n \\\"\\\"\\\" helper files for avro serialization \\\"\\\"\\\"\\n \\n from enum import Enum, EnumMeta\\n+from base64 import b64encode, b64decode\\n \\n \\n def default_json_serialize(obj):\\n-    \\\"\\\"\\\" Wrapper for serializing enum types \\\"\\\"\\\"\\n+    \\\"\\\"\\\" Wrapper for serializing enum and bytes types\\\"\\\"\\\"\\n     if isinstance(obj, Enum):\\n         return obj.name\\n+    elif isinstance(obj, bytes):\\n+        return b64encode(obj).decode('utf-8')\\n     else:\\n         return obj.__dict__\\n \\n+def default_json_deserialize(obj, targetType):\\n+    \\\"\\\"\\\" Wrapper for deserializing bytes type\\\"\\\"\\\"\\n+    if isinstance(obj, str) and targetType == bytes:\\n+        return b64decode(obj)\\n+    else:\\n+        return obj\\n \\n def todict(obj, classkey=None):\\n     \\\"\\\"\\\" helper function to convert nested objects to dicts \\\"\\\"\\\"\\n\",\"diff --git a/tests/reader/avro/test_reader.py b/tests/reader/avro/test_reader.py\\nindex 900534d..f3e79cf 100644\\n--- a/tests/reader/avro/test_reader.py\\n+++ b/tests/reader/avro/test_reader.py\\n@@ -1,16 +1,12 @@\\n \\\"\\\"\\\" class to test reading of various avro formats \\\"\\\"\\\"\\n \\n-import copy\\n import os\\n import unittest\\n from unittest.mock import patch\\n \\n import avro_to_python\\n-from avro_to_python.classes.file import File\\n from avro_to_python.reader.read import AvscReader\\n from avro_to_python.utils.paths import get_joined_path\\n-from avro_to_python.utils.avro.types.array import _array_field\\n-from avro_to_python.utils.avro.types.reference import _reference_type\\n \\n \\n class AvroReaderTests(unittest.TestCase):\\n@@ -196,6 +192,20 @@ class AvroReaderTests(unittest.TestCase):\\n             'primitive'\\n         )\\n \\n+    def testComplexPrimitiveRecord(self):\\n+        filepath = self.directory + '/RecordWithComplexPrimitive.avsc'\\n+\\n+        reader = AvscReader(file=filepath)\\n+        reader.read()\\n+\\n+        obj = reader.file_tree\\n+\\n+        # test complex primitive type was mapped to primitive\\n+        self.assertEqual(\\n+            obj.children['records'].files['RecordWithComplexPrimitive'].fields['binaryData'].fieldtype,  # NOQA\\n+            'primitive'\\n+        )\\n+\\n     def testUnionRecord(self):\\n         filepath = self.directory + '/RecordWithUnion.avsc'\\n \\n@@ -250,7 +260,7 @@ class AvroReaderTests(unittest.TestCase):\\n         # should have 3 fields\\n         self.assertEqual(\\n             len(obj.children['records'].files['RecordWithArray'].fields),\\n-            3\\n+            6\\n         )\\n \\n         # field 0 should be of type reference\\n@@ -271,6 +281,45 @@ class AvroReaderTests(unittest.TestCase):\\n             'reference'\\n         )\\n \\n+        # field 3 should be of type array\\n+        self.assertEqual(\\n+            obj.children['records'].files['RecordWithArray'].fields['twoDimDoubleArray'].array_item_type.fieldtype,  # NOQA\\n+            'array'\\n+        )\\n+        self.assertEqual(\\n+            obj.children['records'].files['RecordWithArray'].fields['twoDimDoubleArray'].array_item_type.array_item_type.fieldtype,  # NOQA\\n+            'primitive'\\n+        )\\n+\\n+        # field 4 should be of type array\\n+        self.assertEqual(\\n+            obj.children['records'].files['RecordWithArray'].fields['threeDimRecordArray'].array_item_type.fieldtype,  # NOQA\\n+            'array'\\n+        )\\n+        self.assertEqual(\\n+            obj.children['records'].files['RecordWithArray'].fields['threeDimRecordArray'].array_item_type.array_item_type.fieldtype,  # NOQA\\n+            'array'\\n+        )\\n+        self.assertEqual(\\n+            obj.children['records'].files['RecordWithArray'].fields['threeDimRecordArray'].array_item_type.array_item_type.array_item_type.fieldtype,  # NOQA\\n+            'reference'\\n+        )\\n+\\n+        # field 5 should be of type union\\n+        self.assertEqual(\\n+            obj.children['records'].files['RecordWithArray'].fields['arrayOfUnion'].array_item_type.fieldtype,  # NOQA\\n+            'union'\\n+        )\\n+        self.assertEqual(\\n+            obj.children['records'].files['RecordWithArray'].fields['arrayOfUnion'].array_item_type.union_types[0].fieldtype,  # NOQA\\n+            'reference'\\n+        )\\n+        self.assertEqual(\\n+            obj.children['records'].files['RecordWithArray'].fields['arrayOfUnion'].array_item_type.union_types[1].fieldtype,  # NOQA\\n+            'primitive'\\n+        )\\n+\\n+\\n     def testRecordWithArrayOrMap(self):\\n         filepath = self.directory + '/RecordWithArrayOfMap.avsc'\\n \\n\",\"diff --git a/tests/writer/test_compiled_files.py b/tests/writer/test_compiled_files.py\\nindex b2a9e2b..38dabe5 100644\\n--- a/tests/writer/test_compiled_files.py\\n+++ b/tests/writer/test_compiled_files.py\\n@@ -43,6 +43,8 @@ class PathTests(unittest.TestCase):\\n         thing = Thing(data)\\n         thing_from_thing = Thing(thing)\\n         thing_from_json = Thing(data_json)\\n+        thing_from_setters = Thing()\\n+        thing_from_setters.id = 10\\n \\n         self.assertEqual(\\n             eval(thing.serialize()),\\n@@ -62,6 +64,12 @@ class PathTests(unittest.TestCase):\\n             'thing should be able to initialize from json'\\n         )\\n \\n+        self.assertEqual(\\n+            thing.serialize(),\\n+            thing_from_setters.serialize(),\\n+            'thing should be able to initialize from setters'\\n+        )\\n+\\n     def test_record_with_record(self):\\n         \\\"\\\"\\\" tests nested records work \\\"\\\"\\\"\\n \\n@@ -137,6 +145,44 @@ class PathTests(unittest.TestCase):\\n             record3.serialize()\\n         )\\n \\n+    def test_record_with_bytes(self):\\n+        \\\"\\\"\\\" tests records with bytes work \\\"\\\"\\\"\\n+\\n+        from records import RecordWithBytes\\n+\\n+        data1 = '{\\\"binaryData\\\": \\\"SGVsbG8gd29ybGQh\\\"}'\\n+        data2 = {'binaryData': b\\\"Hello world!\\\"}\\n+\\n+        record1 = RecordWithBytes(data1)\\n+        record2 = RecordWithBytes(data2)\\n+        record3 = RecordWithBytes()\\n+        record3.binaryData = b\\\"Hello world!\\\"\\n+\\n+        self.assertEqual(\\n+            record1.serialize(),\\n+            data1\\n+        )\\n+\\n+        self.assertEqual(\\n+            record1.serialize(),\\n+            record2.serialize()\\n+        )\\n+\\n+        self.assertEqual(\\n+            record1.binaryData,\\n+            record2.binaryData\\n+        )\\n+\\n+        self.assertEqual(\\n+            record1.serialize(),\\n+            record3.serialize()\\n+        )\\n+\\n+        self.assertEqual(\\n+            record1.binaryData,\\n+            record3.binaryData\\n+        )\\n+\\n     def test_record_with_logical_types(self):\\n         \\\"\\\"\\\" tests records with logical types work \\\"\\\"\\\"\\n \\n@@ -163,9 +209,9 @@ class PathTests(unittest.TestCase):\\n         from records import RecordWithArray\\n         from records import Thing\\n \\n-        data1 = {'things': [{'id': 10}, {'id': 50}], 'numbers': [10, 40], 'things2': []}  # NOQA\\n-        data2 = {'things': [Thing({'id': 10}), {'id': 50}], 'numbers': [10, 40], 'things2': []}  # NOQA\\n-        data3 = {'things': [], 'numbers': [], 'things2': []}\\n+        data1 = {'things': [{'id': 10}, {'id': 50}], 'numbers': [10, 40], 'things2': [], 'twoDimDoubleArray': [[1.1, 2.2], [3.3, 4.5]], 'threeDimRecordArray': [[[{'id': 10}, {'id': 50}]]]}  # NOQA\\n+        data2 = {'things': [Thing({'id': 10}), {'id': 50}], 'numbers': [10, 40], 'things2': [], 'twoDimDoubleArray': [[1.1, 2.2], [3.3, 4.5]], 'threeDimRecordArray': [[[Thing({'id': 10}), {'id': 50}]]]}  # NOQA\\n+        data3 = {'things': [], 'numbers': [], 'things2': [], 'twoDimDoubleArray': [], 'threeDimRecordArray': []}\\n         data4 = {'things': [{'id': 10}, {'id': 50}], 'numbers': ['not a long'], 'things2': []}  # NOQA\\n         data5 = {'things': [{'id': 'not a long'}, {'id': 50}], 'numbers': [10, 40], 'things2': []}  # NOQA\\n \\n@@ -181,7 +227,7 @@ class PathTests(unittest.TestCase):\\n \\n         self.assertEqual(\\n             record3.serialize(),\\n-            '{\\\"things\\\": [], \\\"numbers\\\": [], \\\"things2\\\": []}'\\n+            '{\\\"things\\\": [], \\\"numbers\\\": [], \\\"things2\\\": [], \\\"twoDimDoubleArray\\\": [], \\\"threeDimRecordArray\\\": []}'\\n         )\\n \\n         self.assertEqual(\"]", "hints_text": ""}

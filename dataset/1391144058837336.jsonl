{"instance_id": "1391144058837336", "repo": "iterative/scmrepo", "base_commit": "f388e710e3f1eb4c0f553d41475aa7ada4c72f74", "problem_statement": "import: from external git  does not import lfs-tracked file content:\\n# Bug Report\\r\\n\\r\\n## Description\\r\\n\\r\\nI encountered an issue when trying to import an external git repository that contains files tracked by git-lfs (using either `import` or `get`). Files not tracked by git-lfs are imported correctly, however the lfs-tracked files only contain pointers to the lfs instead of the actual content.\\r\\n\\r\\n\\r\\n### Reproduce\\r\\n\\r\\n1. Run `dvc import https://huggingface.co/datasets/morteza/cogtext.git gpt3/abstracts_gpt3ada.nc`\\r\\n2. Run `dvc pull`\\r\\n3. Open the `abstracts_gpt3ada.nc` file, which should contain the actual binary content but instead contains text pointers to the lfs object.\\r\\n\\r\\n\\r\\n### Expected\\r\\n\\r\\nWhen importing LFS-tracked files from an external git repository, the files should contain the actual content and not text pointers.\\r\\n\\r\\n\\r\\n### Environment information\\r\\n\\r\\n```console\\r\\nDVC version: 2.47.2 (pip)\\r\\n-------------------------\\r\\nPlatform: Python 3.11.0 on Linux-5.15.0-67-generic-x86_64-with-glibc2.35\\r\\nSubprojects:\\r\\n        dvc_data = 0.42.3\\r\\n        dvc_objects = 0.21.1\\r\\n        dvc_render = 0.2.0\\r\\n        dvc_task = 0.2.0\\r\\n        scmrepo = 0.1.15\\r\\nSupports:\\r\\n        http (aiohttp = 3.8.4, aiohttp-retry = 2.8.3),\\r\\n        https (aiohttp = 3.8.4, aiohttp-retry = 2.8.3),\\r\\n        ssh (sshfs = 2023.1.0)\\r\\nCache types: hardlink, symlink\\r\\nCache directory: ext4 on /dev/sdb5\\r\\nCaches: local\\r\\nRemotes: None\\r\\nWorkspace directory: ext4 on /dev/sdb5\\r\\nRepo: dvc, git\\r\\n```\\r\\n", "FAIL_TO_PASS": ["tests/test_git.py::test_check_attr[pygit2]", "tests/test_git.py::test_check_attr[gitpython]"], "PASS_TO_PASS": ["tests/test_git.py::test_fetch[gitpython]", "tests/test_git.py::test_commit_in_root_repo_with_submodule[gitpython]", "tests/test_stash.py::test_git_stash_apply_index[gitpython]", "tests/test_fs.py::test_isfile[dulwich]", "tests/test_git.py::test_belongs_to_scm[dulwich-git_internal_file]", "tests/test_git.py::test_is_dirty_deleted[gitpython]", "tests/test_git.py::test_no_commits[dulwich]", "tests/test_git.py::test_gitignore_should_append_newline_to_gitignore[dulwich]", "tests/test_git.py::test_clone[gitpython-True-None-file://]", "tests/test_credentials.py::test_subprocess_get_no_output", "tests/test_fs.py::test_isfile[pygit2]", "tests/test_git.py::test_clone[gitpython-False-master-]", "tests/test_git.py::test_commit_no_verify[dulwich-commit-msg]", "tests/test_git.py::test_clone[pygit2-True-None-]", "tests/test_git.py::test_merge[gitpython-True]", "tests/test_git.py::test_ignored[pygit2]", "tests/test_git.py::test_is_tracked_func[gitpython]", "tests/test_git.py::test_commit_no_verify[dulwich-pre-commit]", "tests/test_git.py::test_is_dirty_empty[dulwich]", "tests/test_git.py::test_remove_ref[gitpython]", "tests/test_fs.py::test_walk_with_submodules[pygit2]", "tests/test_pygit2.py::test_pygit_use_env_vars_for_signature[committer]", "tests/test_git.py::test_clone[pygit2-False-master-file://]", "tests/test_credentials.py::test_memory_helper_prompt_askpass", "tests/test_git.py::test_merge[gitpython-False]", "tests/test_pygit2.py::test_pygit_resolve_refish[True]", "tests/test_git.py::test_get_ref[gitpython]", "tests/test_fs.py::test_isfile[gitpython]", "tests/test_git.py::test_git_submodule[pygit2]", "tests/test_git.py::test_status[pygit2-False-all]", "tests/test_git.py::test_gitignore_should_append_newline_to_gitignore[gitpython]", "tests/test_git.py::test_describe[dulwich]", "tests/test_fs.py::test_walk[gitpython]", "tests/test_git.py::test_clone[pygit2-True-master-]", "tests/test_git.py::test_is_dirty_untracked[gitpython]", "tests/test_stash.py::test_git_stash_drop[refs/foo/stash]", "tests/test_git.py::test_checkout_index_conflicts[pygit2-ours-baz]", "tests/test_scmrepo.py::test_clone_shallow", "tests/test_git.py::test_checkout_index[pygit2]", "tests/test_git.py::test_is_dirty_added[dulwich]", "tests/test_git.py::test_reset[gitpython]", "tests/test_fs.py::test_exists[gitpython]", "tests/test_git.py::test_clone[pygit2-False-master-]", "tests/test_git.py::test_git_submodule[gitpython]", "tests/test_git.py::test_set_ref[dulwich]", "tests/test_git.py::test_get_gitignore_symlink[dulwich]", "tests/test_stash.py::test_git_stash_workspace_reinstate_index", "tests/test_git.py::test_is_dirty_modified[gitpython]", "tests/test_noscm.py::test_noscm", "tests/test_git.py::test_commit_no_verify[gitpython-pre-commit]", "tests/test_git.py::test_ignore[pygit2]", "tests/test_git.py::test_checkout[pygit2]", "tests/test_git.py::test_fetch_refspecs[pygit2-False]", "tests/test_git.py::test_resolve_rev[gitpython]", "tests/test_fs.py::test_ls[gitpython]", "tests/test_git.py::test_git_init[gitpython]", "tests/test_scmrepo.py::test_clone", "tests/test_credentials.py::test_subprocess_get", "tests/test_git.py::test_ignored_dir_unignored_subdirs[dulwich]", "tests/test_git.py::test_clone[pygit2-True-master-file://]", "tests/test_git.py::test_status[pygit2-False-normal]", "tests/test_git.py::test_add[gitpython]", "tests/test_stash.py::test_git_stash_clear[refs/foo/stash]", "tests/test_git.py::test_clone[dulwich-False-None-]", "tests/test_git.py::test_git_init_bare[dulwich]", "tests/test_git.py::test_is_dirty_modified[dulwich]", "tests/test_stash.py::test_git_stash_push_clean_workspace[dulwich]", "tests/test_git.py::test_backend_func[backends0]", "tests/test_git.py::test_clone[dulwich-True-None-file://]", "tests/test_git.py::test_clone[gitpython-True-None-]", "tests/test_git.py::test_iter_remote_refs[dulwich-True]", "tests/test_git.py::test_fetch[dulwich]", "tests/test_fs.py::test_ls[dulwich]", "tests/test_git.py::test_add_force[dulwich]", "tests/test_git.py::test_clone[dulwich-True-None-]", "tests/test_stash.py::test_git_stash_push[refs/foo/stash-True]", "tests/test_git.py::test_is_dirty_empty[gitpython]", "tests/test_git.py::test_refs_containing[gitpython]", "tests/test_stash.py::test_git_stash_push_clean_workspace[pygit2]", "tests/test_git.py::test_git_init_bare[pygit2]", "tests/test_credentials.py::test_subprocess_get_failed", "tests/test_git.py::test_checkout[gitpython]", "tests/test_git.py::test_get_gitignore_symlink[pygit2]", "tests/test_git.py::test_set_ref[pygit2]", "tests/test_git.py::test_set_ref[gitpython]", "tests/test_git.py::test_status[dulwich-True-no]", "tests/test_git.py::test_is_tracked[gitpython]", "tests/test_git.py::test_is_dirty_added[gitpython]", "tests/test_git.py::test_remove_ref[pygit2]", "tests/test_git.py::test_get_tag[gitpython]", "tests/test_git.py::test_clone[dulwich-False-None-file://]", "tests/test_git.py::test_status[pygit2-False-no]", "tests/test_git.py::test_push_refspecs[dulwich-False]", "tests/test_git.py::test_no_commits[gitpython]", "tests/test_git.py::test_clone[pygit2-False-None-file://]", "tests/test_pygit2.py::test_pygit_stash_apply_conflicts[False]", "tests/test_git.py::test_is_dirty_deleted[dulwich]", "tests/test_git.py::test_clone[gitpython-True-master-file://]", "tests/test_git.py::test_ignore[gitpython]", "tests/test_git.py::test_gitignore_should_append_newline_to_gitignore[pygit2]", "tests/test_git.py::test_commit_no_verify[gitpython-commit-msg]", "tests/test_pygit2.py::test_pygit_use_env_vars_for_signature[author]", "tests/test_git.py::test_git_detach_head[gitpython]", "tests/test_fs.py::test_exists[pygit2]", "tests/test_git.py::test_git_detach_head[pygit2]", "tests/test_git.py::test_status[dulwich-True-all]", "tests/test_git.py::test_get_gitignore[dulwich]", "tests/test_git.py::test_ignored[dulwich]", "tests/test_git.py::test_resolve_rev[pygit2]", "tests/test_stash.py::test_git_stash_push[refs/foo/stash-False]", "tests/test_fs.py::test_ls[pygit2]", "tests/test_git.py::test_clone[gitpython-True-master-]", "tests/test_git.py::test_checkout_index_conflicts[gitpython-theirs-bar]", "tests/test_git.py::test_belongs_to_scm[pygit2-non_git_file]", "tests/test_stash.py::test_git_stash_push[None-False]", "tests/test_git.py::test_backend_func[backends1]", "tests/test_credentials.py::test_memory_helper_prompt_disabled", "tests/test_fs.py::test_exists[dulwich]", "tests/test_git.py::test_status[dulwich-False-no]", "tests/test_git.py::test_config[dulwich]", "tests/test_git.py::test_list_all_commits[gitpython]", "tests/test_git.py::test_belongs_to_scm[dulwich-gitignore_file]", "tests/test_git.py::test_clone[gitpython-False-None-file://]", "tests/test_git.py::test_get_tag[dulwich]", "tests/test_noscm.py::test_noscm_raises_exc_on_unimplemented_apis", "tests/test_git.py::test_clone[dulwich-True-master-file://]", "tests/test_git.py::test_tag[dulwich]", "tests/test_stash.py::test_git_stash_apply_index[pygit2]", "tests/test_git.py::test_git_submodule[dulwich]", "tests/test_git.py::test_branch_revs[pygit2]", "tests/test_git.py::test_ignored[gitpython]", "tests/test_git.py::test_clone[pygit2-False-None-]", "tests/test_git.py::test_tag[gitpython]", "tests/test_git.py::test_clone[dulwich-True-master-]", "tests/test_git.py::test_fetch_refspecs[dulwich-False]", "tests/test_git.py::test_git_init[pygit2]", "tests/test_git.py::test_get_gitignore[pygit2]", "tests/test_git.py::test_get_gitignore[gitpython]", "tests/test_git.py::test_merge[pygit2-True]", "tests/test_stash.py::test_git_stash_clear[None]", "tests/test_stash.py::test_git_stash_push_clean_workspace[gitpython]", "tests/test_git.py::test_add[dulwich]", "tests/test_git.py::test_reset[pygit2]", "tests/test_git.py::test_belongs_to_scm[dulwich-non_git_file]", "tests/test_git.py::test_get_tag[pygit2]", "tests/test_git.py::test_belongs_to_scm[gitpython-non_git_file]", "tests/test_git.py::test_commit[dulwich]", "tests/test_git.py::test_status[pygit2-True-normal]", "tests/test_fs.py::test_isdir[gitpython]", "tests/test_credentials.py::test_subprocess_get_use_http_path", "tests/test_git.py::test_branch_revs[gitpython]", "tests/test_git.py::test_is_dirty_untracked[dulwich]", "tests/test_git.py::test_clone[gitpython-False-None-]", "tests/test_git.py::test_push_refspecs[dulwich-True]", "tests/test_git.py::test_ignore[dulwich]", "tests/test_git.py::test_commit_in_root_repo_with_submodule[dulwich]", "tests/test_fs.py::test_walk_with_submodules[dulwich]", "tests/test_git.py::test_checkout_index_conflicts[pygit2-theirs-bar]", "tests/test_pygit2.py::test_pygit_resolve_refish[False]", "tests/test_git.py::test_clone[pygit2-True-None-file://]", "tests/test_git.py::test_config[pygit2]", "tests/test_pygit2.py::test_pygit_stash_apply_conflicts[True]", "tests/test_git.py::test_add_force[gitpython]", "tests/test_pygit2.py::test_pygit_ssh_error[git@github.com:iterative/scmrepo.git]", "tests/test_git.py::test_get_gitignore_subdir[gitpython]", "tests/test_git.py::test_is_tracked[dulwich]", "tests/test_git.py::test_get_ref[dulwich]", "tests/test_git.py::test_belongs_to_scm[pygit2-git_internal_file]", "tests/test_git.py::test_clone[dulwich-False-master-]", "tests/test_fs.py::test_walk[dulwich]", "tests/test_fs.py::test_walk_with_submodules[gitpython]", "tests/test_git.py::test_is_tracked_unicode[dulwich]", "tests/test_git.py::test_fetch_refspecs[pygit2-True]", "tests/test_git.py::test_tag[pygit2]", "tests/test_fs.py::test_isdir[pygit2]", "tests/test_credentials.py::test_get_matching_commands", "tests/test_git.py::test_iter_remote_refs[dulwich-False]", "tests/test_git.py::test_git_init[dulwich]", "tests/test_git.py::test_belongs_to_scm[pygit2-gitignore_file]", "tests/test_git.py::test_belongs_to_scm[gitpython-git_internal_file]", "tests/test_git.py::test_get_gitignore_symlink[gitpython]", "tests/test_git.py::test_git_init_bare[gitpython]", "tests/test_credentials.py::test_memory_helper_get_cached", "tests/test_git.py::test_get_ref[pygit2]", "tests/test_pygit2.py::test_pygit_ssh_error[ssh://login@server.com:12345/repository.git]", "tests/test_git.py::test_status[pygit2-True-all]", "tests/test_credentials.py::test_subprocess_erase", "tests/test_credentials.py::test_memory_helper_get", "tests/test_fs.py::test_isdir[dulwich]", "tests/test_git.py::test_clone[gitpython-False-master-file://]", "tests/test_git.py::test_clone[dulwich-False-master-file://]", "tests/test_git.py::test_remove_ref[dulwich]", "tests/test_git.py::test_status[dulwich-False-all]", "tests/test_git.py::test_ignore_remove_empty[dulwich]", "tests/test_git.py::test_get_gitignore_subdir[pygit2]", "tests/test_stash.py::test_git_stash_workspace", "tests/test_git.py::test_ignore_remove_empty[gitpython]", "tests/test_stash.py::test_git_stash_drop[None]", "tests/test_git.py::test_is_tracked_func[dulwich]", "tests/test_stash.py::test_git_stash_push[None-True]", "tests/test_git.py::test_commit[gitpython]", "tests/test_git.py::test_checkout_index_conflicts[gitpython-ours-baz]", "tests/test_git.py::test_get_gitignore_subdir[dulwich]", "tests/test_git.py::test_status[pygit2-True-no]", "tests/test_credentials.py::test_subprocess_store", "tests/test_git.py::test_is_tracked_unicode[gitpython]", "tests/test_git.py::test_fetch_refspecs[dulwich-True]", "tests/test_fs.py::test_walk[pygit2]", "tests/test_git.py::test_merge[pygit2-False]", "tests/test_git.py::test_refs_containing[pygit2]", "tests/test_git.py::test_checkout_subdir[pygit2]", "tests/test_git.py::test_checkout_index[gitpython]", "tests/test_git.py::test_belongs_to_scm[gitpython-gitignore_file]"], "language": "python", "test_command": "source /saved/ENV || source /saved/*/ENV && nox -- --no-header -rA --tb=no -p no:cacheprovider --continue-on-collection-errors", "test_output_parser": "python/parse_log_pytest_v3", "image_storage_uri": "vmvm-registry.fbinfra.net/repomate_image_activ_pytest/iterative_scmrepo:f388e710e3f1eb4c0f553d41475aa7ada4c72f74", "patch": "[\"diff --git a/src/scmrepo/base.py b/src/scmrepo/base.py\\nindex 67f6e8c4..8c6418d6 100644\\n--- a/src/scmrepo/base.py\\n+++ b/src/scmrepo/base.py\\n@@ -1,7 +1,8 @@\\n \\\"\\\"\\\"Manages source control systems (e.g. Git) in DVC.\\\"\\\"\\\"\\n+from contextlib import AbstractContextManager\\n \\n \\n-class Base:\\n+class Base(AbstractContextManager):\\n     \\\"\\\"\\\"Base class for source control management driver implementations.\\\"\\\"\\\"\\n \\n     def __init__(self, root_dir=None):\\n@@ -18,6 +19,9 @@ def __repr__(self):\\n             class_name=type(self).__name__, directory=self.dir\\n         )\\n \\n+    def __exit__(self, exc_type, exc_value, traceback):\\n+        self.close()\\n+\\n     @property\\n     def dir(self):\\n         \\\"\\\"\\\"Path to a directory with SCM specific information.\\\"\\\"\\\"\\n\",\"diff --git a/src/scmrepo/fs.py b/src/scmrepo/fs.py\\nindex 85b75ab4..7de65cdd 100644\\n--- a/src/scmrepo/fs.py\\n+++ b/src/scmrepo/fs.py\\n@@ -187,9 +187,10 @@ def _open(\\n         self,\\n         path: str,\\n         mode: str = \\\"rb\\\",\\n-        block_size: int = None,\\n+        block_size: Optional[int] = None,\\n         autocommit: bool = True,\\n-        cache_options: Dict = None,\\n+        cache_options: Optional[Dict] = None,\\n+        raw: bool = False,\\n         **kwargs: Any,\\n     ) -> BinaryIO:\\n         if mode != \\\"rb\\\":\\n@@ -197,7 +198,7 @@ def _open(\\n \\n         key = self._get_key(path)\\n         try:\\n-            obj = self.trie.open(key, mode=mode)\\n+            obj = self.trie.open(key, mode=mode, raw=raw)\\n             obj.size = bytesio_len(obj)\\n             return obj\\n         except KeyError as exc:\\n\",\"diff --git a/src/scmrepo/git/__init__.py b/src/scmrepo/git/__init__.py\\nindex 8c852370..b828144a 100644\\n--- a/src/scmrepo/git/__init__.py\\n+++ b/src/scmrepo/git/__init__.py\\n@@ -171,6 +171,13 @@ def _get_git_dir(root_dir):\\n     def ignore_file(self):\\n         return self.GITIGNORE\\n \\n+    @cached_property\\n+    def lfs_storage(self):\\n+        from .lfs import LFSStorage\\n+        from .lfs.storage import get_storage_path\\n+\\n+        return LFSStorage(get_storage_path(self))\\n+\\n     def _get_gitignore(self, path):\\n         ignore_file_dir = os.path.dirname(path)\\n \\n@@ -267,6 +274,8 @@ def has_rev(self, rev):\\n \\n     def close(self):\\n         self.backends.close_initialized()\\n+        if \\\"lfs_storage\\\" in self.__dict__:\\n+            self.lfs_storage.close()\\n \\n     @property\\n     def no_commits(self):\\n@@ -358,6 +367,7 @@ def fetch_refspecs(\\n     is_tracked = partialmethod(_backend_func, \\\"is_tracked\\\")\\n     is_dirty = partialmethod(_backend_func, \\\"is_dirty\\\")\\n     active_branch = partialmethod(_backend_func, \\\"active_branch\\\")\\n+    active_branch_remote = partialmethod(_backend_func, \\\"active_branch_remote\\\")\\n     list_branches = partialmethod(_backend_func, \\\"list_branches\\\")\\n     list_tags = partialmethod(_backend_func, \\\"list_tags\\\")\\n     list_all_commits = partialmethod(_backend_func, \\\"list_all_commits\\\")\\n@@ -387,6 +397,7 @@ def fetch_refspecs(\\n     check_ref_format = partialmethod(_backend_func, \\\"check_ref_format\\\")\\n     get_tag = partialmethod(_backend_func, \\\"get_tag\\\")\\n     get_config = partialmethod(_backend_func, \\\"get_config\\\")\\n+    check_attr = partialmethod(_backend_func, \\\"check_attr\\\")\\n \\n     get_tree_obj = partialmethod(_backend_func, \\\"get_tree_obj\\\")\\n \\n\",\"diff --git a/src/scmrepo/git/backend/base.py b/src/scmrepo/git/backend/base.py\\nindex f482406a..124b6399 100644\\n--- a/src/scmrepo/git/backend/base.py\\n+++ b/src/scmrepo/git/backend/base.py\\n@@ -432,3 +432,24 @@ def get_config(self, path: Optional[str] = None) -> \\\"Config\\\":\\n                 returned. By default, the standard Git system/global/repo config\\n                 stack object will be returned.\\n         \\\"\\\"\\\"\\n+\\n+    @abstractmethod\\n+    def check_attr(\\n+        self,\\n+        path: str,\\n+        attr: str,\\n+        source: Optional[str] = None,\\n+    ) -> Optional[Union[bool, str]]:\\n+        \\\"\\\"\\\"Return the value of the specified attribute for a pathname.\\n+\\n+        Args:\\n+            path: Pathname to check.\\n+            attr: Attribute to check.\\n+            source: Optional tree-ish source to check.\\n+\\n+        Returns:\\n+            None when the attribute is not defined for the path (unspecified).\\n+            True when the attribute is defined as true (set).\\n+            False when the attribute is defined as false (unset).\\n+            The value of the attribute when a value has been assigned.\\n+        \\\"\\\"\\\"\\n\",\"diff --git a/src/scmrepo/git/backend/dulwich/__init__.py b/src/scmrepo/git/backend/dulwich/__init__.py\\nindex 215e20c8..68f1e375 100644\\n--- a/src/scmrepo/git/backend/dulwich/__init__.py\\n+++ b/src/scmrepo/git/backend/dulwich/__init__.py\\n@@ -51,7 +51,16 @@ def __init__(self, repo, name, mode, sha):\\n         self._mode = mode\\n         self._sha = sha\\n \\n-    def open(self, mode: str = \\\"r\\\", encoding: str = None):\\n+    def open(  # pylint: disable=unused-argument\\n+        self,\\n+        mode: str = \\\"r\\\",\\n+        encoding: Optional[str] = None,\\n+        raw: bool = True,\\n+        rev: Optional[str] = None,\\n+        **kwargs,\\n+    ):\\n+        if not raw:\\n+            raise NotImplementedError\\n         if not encoding:\\n             encoding = locale.getpreferredencoding(False)\\n         # NOTE: we didn't load the object before as Dulwich will also try to\\n@@ -144,18 +153,18 @@ def encoding(self) -> str:\\n             return self._config.encoding\\n         return self._config.backends[0].encoding\\n \\n-    def get(self, section: Tuple[str], name: str) -> str:\\n+    def get(self, section: Tuple[str, ...], name: str) -> str:\\n         \\\"\\\"\\\"Return the specified setting as a string.\\\"\\\"\\\"\\n         return self._config.get(section, name).decode(self.encoding)\\n \\n-    def get_bool(self, section: Tuple[str], name: str) -> bool:\\n+    def get_bool(self, section: Tuple[str, ...], name: str) -> bool:\\n         \\\"\\\"\\\"Return the specified setting as a boolean.\\\"\\\"\\\"\\n         value = self._config.get_boolean(section, name)\\n         if value is None:\\n             raise ValueError(\\\"setting is not a valid boolean\\\")\\n         return value\\n \\n-    def get_multivar(self, section: Tuple[str], name: str) -> Iterator[str]:\\n+    def get_multivar(self, section: Tuple[str, ...], name: str) -> Iterator[str]:\\n         \\\"\\\"\\\"Iterate over string values in the specified multivar setting.\\\"\\\"\\\"\\n         for value in self._config.get_multivar(section, name):\\n             yield value.decode(self.encoding)\\n@@ -962,6 +971,14 @@ def get_config(self, path: Optional[str] = None) -> \\\"Config\\\":\\n             return DulwichConfig(ConfigFile.from_path(path))\\n         return DulwichConfig(self.repo.get_config_stack())\\n \\n+    def check_attr(\\n+        self,\\n+        path: str,\\n+        attr: str,\\n+        source: Optional[str] = None,\\n+    ) -> Optional[Union[bool, str]]:\\n+        raise NotImplementedError\\n+\\n \\n _IDENTITY_RE = re.compile(r\\\"(?P<name>.+)\\\\s+<(?P<email>.+)>\\\")\\n \\n\",\"diff --git a/src/scmrepo/git/backend/gitpython.py b/src/scmrepo/git/backend/gitpython.py\\nindex 279bcfe3..25855860 100644\\n--- a/src/scmrepo/git/backend/gitpython.py\\n+++ b/src/scmrepo/git/backend/gitpython.py\\n@@ -2,6 +2,7 @@\\n import locale\\n import logging\\n import os\\n+import re\\n import sys\\n from functools import partial, wraps\\n from typing import (\\n@@ -83,7 +84,15 @@ class GitPythonObject(GitObject):\\n     def __init__(self, obj):\\n         self.obj = obj\\n \\n-    def open(self, mode: str = \\\"r\\\", encoding: str = None):\\n+    def open(\\n+        self,\\n+        mode: str = \\\"r\\\",\\n+        encoding: str = None,\\n+        raw: bool = True,\\n+        **kwargs,\\n+    ):\\n+        if not raw:\\n+            raise NotImplementedError\\n         if not encoding:\\n             encoding = locale.getpreferredencoding(False)\\n         # GitPython's obj.data_stream is a fragile thing, it is better to\\n@@ -756,3 +765,29 @@ def get_tag(self, name: str) -> Optional[Union[str, \\\"GitTag\\\"]]:\\n \\n     def get_config(self, path: Optional[str] = None) -> \\\"Config\\\":\\n         raise NotImplementedError\\n+\\n+    def check_attr(\\n+        self,\\n+        path: str,\\n+        attr: str,\\n+        source: Optional[str] = None,\\n+    ) -> Optional[Union[bool, str]]:\\n+        from git.exc import GitCommandError\\n+\\n+        try:\\n+            result = self.git.check_attr(attr, \\\"--\\\", path, source=source)\\n+        except GitCommandError as exc:\\n+            raise SCMError(\\\"Failed to check attribute\\\") from exc\\n+        escaped_path = re.escape(path)\\n+        escaped_attr = re.escape(attr)\\n+        m = re.match(f\\\"{escaped_path}: {escaped_attr}: (?P<info>.*)\\\", result)\\n+        if not m or not m.group(\\\"info\\\"):\\n+            raise SCMError(\\\"Failed to check attribute\\\")\\n+        info = m.group(\\\"info\\\")\\n+        if info == \\\"unspecified\\\":\\n+            return None\\n+        if info == \\\"set\\\":\\n+            return True\\n+        if info == \\\"unset\\\":\\n+            return False\\n+        return info\\n\",\"diff --git a/src/scmrepo/git/backend/pygit2/__init__.py b/src/scmrepo/git/backend/pygit2/__init__.py\\nindex 278b9e3b..8a3b0e2c 100644\\n--- a/src/scmrepo/git/backend/pygit2/__init__.py\\n+++ b/src/scmrepo/git/backend/pygit2/__init__.py\\n@@ -3,7 +3,7 @@\\n import os\\n import stat\\n from contextlib import contextmanager\\n-from io import BytesIO, StringIO\\n+from io import BytesIO, StringIO, TextIOWrapper\\n from typing import (\\n     TYPE_CHECKING,\\n     Callable,\\n@@ -37,7 +37,7 @@\\n \\n \\n if TYPE_CHECKING:\\n-    from pygit2 import Oid, Signature\\n+    from pygit2 import Commit, Oid, Signature\\n     from pygit2.config import Config as _Pygit2Config\\n     from pygit2.remote import Remote  # type: ignore\\n     from pygit2.repository import Repository\\n@@ -46,13 +46,47 @@\\n \\n \\n class Pygit2Object(GitObject):\\n-    def __init__(self, obj):\\n+    def __init__(self, obj, backend: Optional[\\\"Pygit2Backend\\\"] = None):\\n         self.obj = obj\\n+        self.backend = backend\\n+\\n+    def open(\\n+        self,\\n+        mode: str = \\\"r\\\",\\n+        encoding: str = None,\\n+        key: Optional[Tuple[str, ...]] = None,\\n+        raw: bool = True,\\n+        rev: Optional[str] = None,\\n+        **kwargs,\\n+    ):\\n+        from pygit2 import BlobIO, GitError\\n \\n-    def open(self, mode: str = \\\"r\\\", encoding: str = None):\\n         if not encoding:\\n             encoding = locale.getpreferredencoding(False)\\n-        data = self.obj.read_raw()\\n+        if self.backend is not None:\\n+            try:\\n+                if rev:\\n+                    # pylint: disable-next=protected-access\\n+                    commit, _ref = self.backend._resolve_refish(rev)\\n+                else:\\n+                    pass\\n+                if raw:\\n+                    blob_kwargs = {}\\n+                else:\\n+                    assert key is not None\\n+                    path = \\\"/\\\".join(key)\\n+                    blob_kwargs = {\\n+                        \\\"as_path\\\": path,\\n+                        \\\"commit_id\\\": commit.oid,\\n+                    }\\n+                blobio = BlobIO(self.obj, **blob_kwargs)\\n+                if mode == \\\"rb\\\":\\n+                    return blobio\\n+                return TextIOWrapper(blobio, encoding=encoding)\\n+            except GitError as exc:\\n+                raise SCMError(\\\"failed to read git blob\\\") from exc\\n+        else:\\n+            data = self.obj.read_raw()\\n         if mode == \\\"rb\\\":\\n             return BytesIO(data)\\n         return StringIO(data.decode(encoding))\\n@@ -83,20 +117,20 @@ def sha(self) -> str:\\n \\n     def scandir(self) -> Iterable[\\\"Pygit2Object\\\"]:\\n         for entry in self.obj:  # noqa: B301\\n-            yield Pygit2Object(entry)\\n+            yield Pygit2Object(entry, backend=self.backend)\\n \\n \\n class Pygit2Config(Config):\\n     def __init__(self, config: \\\"_Pygit2Config\\\"):\\n         self._config = config\\n \\n-    def _key(self, section: Tuple[str], name: str) -> str:\\n+    def _key(self, section: Tuple[str, ...], name: str) -> str:\\n         return \\\".\\\".join(section + (name,))\\n \\n-    def get(self, section: Tuple[str], name: str) -> str:\\n+    def get(self, section: Tuple[str, ...], name: str) -> str:\\n         return self._config[self._key(section, name)]\\n \\n-    def get_bool(self, section: Tuple[str], name: str) -> bool:\\n+    def get_bool(self, section: Tuple[str, ...], name: str) -> bool:\\n         from pygit2 import GitError\\n \\n         try:\\n@@ -104,7 +138,7 @@ def get_bool(self, section: Tuple[str], name: str) -> bool:\\n         except GitError as exc:\\n             raise ValueError(\\\"invalid boolean config entry\\\") from exc\\n \\n-    def get_multivar(self, section: Tuple[str], name: str) -> Iterator[str]:\\n+    def get_multivar(self, section: Tuple[str, ...], name: str) -> Iterator[str]:\\n         from pygit2 import GitError\\n \\n         try:\\n@@ -119,6 +153,8 @@ def __init__(  # pylint:disable=W0231\\n     ):\\n         import pygit2\\n \\n+        from .filter import LFSFilter\\n+\\n         if search_parent_directories:\\n             ceiling_dirs = \\\"\\\"\\n         else:\\n@@ -135,6 +171,14 @@ def __init__(  # pylint:disable=W0231\\n \\n         self._stashes: dict = {}\\n \\n+        try:\\n+            # NOTE: we want this init to be lazy so we do it on backend init.\\n+            # for subsequent backend instances, this call will error out since\\n+            # the filter is already registered\\n+            pygit2.filter_register(\\\"lfs\\\", LFSFilter)\\n+        except ValueError:\\n+            pass\\n+\\n     def close(self):\\n         if hasattr(self, \\\"_refdb\\\"):\\n             del self._refdb\\n@@ -411,7 +455,7 @@ def list_all_commits(self) -> Iterable[str]:\\n \\n     def get_tree_obj(self, rev: str, **kwargs) -> Pygit2Object:\\n         tree = self.repo[rev].tree\\n-        return Pygit2Object(tree)\\n+        return Pygit2Object(tree, backend=self)\\n \\n     def get_rev(self) -> str:\\n         raise NotImplementedError\\n@@ -1054,3 +1098,31 @@ def get_config(self, path: Optional[str] = None) -> \\\"Config\\\":\\n         if path:\\n             return Pygit2Config(_Pygit2Config(path))\\n         return Pygit2Config(self.repo.config)\\n+\\n+    def check_attr(\\n+        self,\\n+        path: str,\\n+        attr: str,\\n+        source: Optional[str] = None,\\n+    ) -> Optional[Union[bool, str]]:\\n+        from pygit2 import (\\n+            GIT_ATTR_CHECK_FILE_THEN_INDEX,\\n+            GIT_ATTR_CHECK_INCLUDE_COMMIT,\\n+            GIT_ATTR_CHECK_INDEX_ONLY,\\n+            GitError,\\n+        )\\n+\\n+        commit: Optional[\\\"Commit\\\"] = None\\n+        flags = GIT_ATTR_CHECK_FILE_THEN_INDEX\\n+        if source:\\n+            try:\\n+                commit, _ref = self._resolve_refish(source)\\n+                flags = GIT_ATTR_CHECK_INDEX_ONLY | GIT_ATTR_CHECK_INCLUDE_COMMIT\\n+            except (KeyError, GitError) as exc:\\n+                raise SCMError(f\\\"Invalid commit '{source}'\\\") from exc\\n+        try:\\n+            return self.repo.get_attr(\\n+                path, attr, flags=flags, commit=commit.id if commit else None\\n+            )\\n+        except GitError as exc:\\n+            raise SCMError(\\\"Failed to check attribute\\\") from exc\\n\",\"diff --git a/src/scmrepo/git/backend/pygit2/filter.py b/src/scmrepo/git/backend/pygit2/filter.py\\nnew file mode 100644\\nindex 00000000..306a4355\\n--- /dev/null\\n+++ b/src/scmrepo/git/backend/pygit2/filter.py\\n@@ -0,0 +1,65 @@\\n+import io\\n+import logging\\n+from typing import TYPE_CHECKING, Callable, List, Optional\\n+\\n+from pygit2 import GIT_FILTER_CLEAN, Filter, Passthrough\\n+\\n+if TYPE_CHECKING:\\n+    from pygit2 import FilterSource\\n+\\n+logger = logging.getLogger(__name__)\\n+\\n+\\n+class LFSFilter(Filter):\\n+    attributes = \\\"filter=*\\\"\\n+\\n+    def __init__(self, *args, **kwargs):\\n+        self._smudge_buf: Optional[io.BytesIO] = None\\n+        self._smudge_root: Optional[str] = None\\n+\\n+    def check(self, src: \\\"FilterSource\\\", attr_values: List[str]):\\n+        if attr_values[0] == \\\"lfs\\\":\\n+            if src.mode != GIT_FILTER_CLEAN:\\n+                self._smudge_buf = io.BytesIO()\\n+                self._smudge_root = src.repo.workdir or src.repo.path\\n+                return\\n+        raise Passthrough\\n+\\n+    def write(\\n+        self, data: bytes, src: \\\"FilterSource\\\", write_next: Callable[[bytes], None]\\n+    ):\\n+        if src.mode == GIT_FILTER_CLEAN:\\n+            write_next(data)\\n+            return\\n+        if self._smudge_buf is None:\\n+            self._smudge_buf = io.BytesIO()\\n+        if self._smudge_root is None:\\n+            self._smudge_root = src.repo.workdir or src.repo.path\\n+        self._smudge_buf.write(data)\\n+\\n+    def close(self, write_next: Callable[[bytes], None]):\\n+        if self._smudge_buf is not None:\\n+            assert self._smudge_root\\n+            self._smudge(write_next)\\n+\\n+    def _smudge(self, write_next: Callable[[bytes], None]):\\n+        from scmrepo.exceptions import InvalidRemote\\n+        from scmrepo.git import Git\\n+        from scmrepo.git.lfs import smudge\\n+        from scmrepo.git.lfs.fetch import get_fetch_url\\n+\\n+        assert self._smudge_buf is not None\\n+        self._smudge_buf.seek(0)\\n+        with Git(self._smudge_root) as scm:\\n+            try:\\n+                url = get_fetch_url(scm)\\n+            except InvalidRemote:\\n+                url = None\\n+            fobj = smudge(scm.lfs_storage, self._smudge_buf, url=url)\\n+            data = fobj.read(io.DEFAULT_BUFFER_SIZE)\\n+            try:\\n+                while data:\\n+                    write_next(data)\\n+                    data = fobj.read(io.DEFAULT_BUFFER_SIZE)\\n+            except KeyboardInterrupt:\\n+                return\\n\",\"diff --git a/src/scmrepo/git/config.py b/src/scmrepo/git/config.py\\nindex 8b8e5a34..fc12baf9 100644\\n--- a/src/scmrepo/git/config.py\\n+++ b/src/scmrepo/git/config.py\\n@@ -10,7 +10,7 @@ class Config(ABC):\\n     \\\"\\\"\\\"Read-only Git config.\\\"\\\"\\\"\\n \\n     @abstractmethod\\n-    def get(self, section: Tuple[str], name: str) -> str:\\n+    def get(self, section: Tuple[str, ...], name: str) -> str:\\n         \\\"\\\"\\\"Return the specified setting as a string.\\n \\n         Raises:\\n@@ -18,7 +18,7 @@ def get(self, section: Tuple[str], name: str) -> str:\\n         \\\"\\\"\\\"\\n \\n     @abstractmethod\\n-    def get_bool(self, section: Tuple[str], name: str) -> bool:\\n+    def get_bool(self, section: Tuple[str, ...], name: str) -> bool:\\n         \\\"\\\"\\\"Return the specified setting as a boolean.\\n \\n         Raises:\\n@@ -27,7 +27,7 @@ def get_bool(self, section: Tuple[str], name: str) -> bool:\\n         \\\"\\\"\\\"\\n \\n     @abstractmethod\\n-    def get_multivar(self, section: Tuple[str], name: str) -> Iterator[str]:\\n+    def get_multivar(self, section: Tuple[str, ...], name: str) -> Iterator[str]:\\n         \\\"\\\"\\\"Iterate over string values in the specified multivar setting.\\n \\n         Raises:\\n\",\"diff --git a/src/scmrepo/git/lfs/__init__.py b/src/scmrepo/git/lfs/__init__.py\\nnew file mode 100644\\nindex 00000000..67b82826\\n--- /dev/null\\n+++ b/src/scmrepo/git/lfs/__init__.py\\n@@ -0,0 +1,8 @@\\n+from .client import LFSClient\\n+from .exceptions import LFSError\\n+from .fetch import fetch\\n+from .pointer import Pointer\\n+from .smudge import smudge\\n+from .storage import LFSStorage\\n+\\n+__all__ = [\\\"LFSClient\\\", \\\"LFSError\\\", \\\"LFSStorage\\\", \\\"Pointer\\\", \\\"fetch\\\", \\\"smudge\\\"]\\n\",\"diff --git a/src/scmrepo/git/lfs/client.py b/src/scmrepo/git/lfs/client.py\\nnew file mode 100644\\nindex 00000000..a9fc91cb\\n--- /dev/null\\n+++ b/src/scmrepo/git/lfs/client.py\\n@@ -0,0 +1,223 @@\\n+import logging\\n+from contextlib import AbstractContextManager\\n+from functools import wraps\\n+from typing import TYPE_CHECKING, Any, Awaitable, Callable, Dict, Iterable, Optional\\n+\\n+import aiohttp\\n+from dvc_http import HTTPFileSystem\\n+from dvc_http.retry import ReadOnlyRetryClient\\n+from dvc_objects.executors import batch_coros\\n+from dvc_objects.fs import localfs\\n+from dvc_objects.fs.callbacks import DEFAULT_CALLBACK\\n+from dvc_objects.fs.utils import as_atomic\\n+from fsspec.asyn import sync_wrapper\\n+from funcy import cached_property\\n+\\n+from ..credentials import Credential, CredentialNotFoundError\\n+from .exceptions import LFSError\\n+from .pointer import Pointer\\n+\\n+if TYPE_CHECKING:\\n+    from dvc_objects.fs.callbacks import Callback\\n+\\n+    from .storage import LFSStorage\\n+\\n+logger = logging.getLogger(__name__)\\n+\\n+\\n+class _LFSClient(ReadOnlyRetryClient):\\n+    async def _request(self, *args, **kwargs):\\n+        return await super()._request(*args, **kwargs)  # pylint: disable=no-member\\n+\\n+\\n+# pylint: disable=abstract-method\\n+class _LFSFileSystem(HTTPFileSystem):\\n+    def __init__(self, *args, **kwargs):\\n+        super().__init__(*args, **kwargs)\\n+\\n+    def _prepare_credentials(self, **config):\\n+        return {}\\n+\\n+    async def get_client(self, **kwargs):\\n+        from aiohttp_retry import ExponentialRetry\\n+        from dvc_http import make_context\\n+\\n+        kwargs[\\\"retry_options\\\"] = ExponentialRetry(\\n+            attempts=self.SESSION_RETRIES,\\n+            factor=self.SESSION_BACKOFF_FACTOR,\\n+            max_timeout=self.REQUEST_TIMEOUT,\\n+            exceptions={aiohttp.ClientError},\\n+        )\\n+\\n+        # The default total timeout for an aiohttp request is 300 seconds\\n+        # which is too low for DVC's interactions when dealing with large\\n+        # data blobs. We remove the total timeout, and only limit the time\\n+        # that is spent when connecting to the remote server and waiting\\n+        # for new data portions.\\n+        connect_timeout = kwargs.pop(\\\"connect_timeout\\\")\\n+        kwargs[\\\"timeout\\\"] = aiohttp.ClientTimeout(\\n+            total=None,\\n+            connect=connect_timeout,\\n+            sock_connect=connect_timeout,\\n+            sock_read=kwargs.pop(\\\"read_timeout\\\"),\\n+        )\\n+\\n+        kwargs[\\\"connector\\\"] = aiohttp.TCPConnector(\\n+            # Force cleanup of closed SSL transports.\\n+            # See https://github.com/iterative/dvc/issues/7414\\n+            enable_cleanup_closed=True,\\n+            ssl=make_context(kwargs.pop(\\\"ssl_verify\\\", None)),\\n+        )\\n+\\n+        return ReadOnlyRetryClient(**kwargs)\\n+\\n+\\n+def _authed(f: Callable[..., Awaitable]):\\n+    \\\"\\\"\\\"Set credentials and retry the given coroutine if needed.\\\"\\\"\\\"\\n+\\n+    # pylint: disable=protected-access\\n+    @wraps(f)  # type: ignore[arg-type]\\n+    async def wrapper(self, *args, **kwargs):\\n+        try:\\n+            return await f(self, *args, **kwargs)\\n+        except aiohttp.ClientResponseError as exc:\\n+            if exc.status != 401:\\n+                raise\\n+            session = await self._set_session()\\n+            if session.auth:\\n+                raise\\n+            auth = self._get_auth()\\n+            if auth is None:\\n+                raise\\n+            self._session._auth = auth\\n+        return await f(self, *args, **kwargs)\\n+\\n+    return wrapper\\n+\\n+\\n+class LFSClient(AbstractContextManager):\\n+    \\\"\\\"\\\"Naive read-only LFS HTTP client.\\\"\\\"\\\"\\n+\\n+    JSON_CONTENT_TYPE = \\\"application/vnd.git-lfs+json\\\"\\n+\\n+    def __init__(\\n+        self,\\n+        url: str,\\n+        git_url: Optional[str] = None,\\n+        headers: Optional[Dict[str, str]] = None,\\n+    ):\\n+        \\\"\\\"\\\"\\n+        Args:\\n+            url: LFS server URL.\\n+        \\\"\\\"\\\"\\n+        self.url = url\\n+        self.git_url = git_url\\n+        self.headers: Dict[str, str] = headers or {}\\n+\\n+    def __exit__(self, *args, **kwargs):\\n+        self.close()\\n+\\n+    @cached_property\\n+    def fs(self) -> \\\"_LFSFileSystem\\\":\\n+        return _LFSFileSystem()\\n+\\n+    @property\\n+    def httpfs(self) -> \\\"HTTPFileSystem\\\":\\n+        return self.fs.fs\\n+\\n+    @property\\n+    def loop(self):\\n+        return self.httpfs.loop\\n+\\n+    @classmethod\\n+    def from_git_url(cls, git_url: str) -> \\\"LFSClient\\\":\\n+        if git_url.endswith(\\\".git\\\"):\\n+            url = f\\\"{git_url}/info/lfs\\\"\\n+        else:\\n+            url = f\\\"{git_url}.git/info/lfs\\\"\\n+        return cls(url, git_url=git_url)\\n+\\n+    def close(self):\\n+        pass\\n+\\n+    def _get_auth(self) -> Optional[aiohttp.BasicAuth]:\\n+        try:\\n+            creds = Credential(url=self.git_url).fill()\\n+            if creds.username and creds.password:\\n+                return aiohttp.BasicAuth(creds.username, creds.password)\\n+        except CredentialNotFoundError:\\n+            pass\\n+        return None\\n+\\n+    async def _set_session(self) -> aiohttp.ClientSession:\\n+        return await self.fs.fs.set_session()\\n+\\n+    @_authed\\n+    async def _batch_request(\\n+        self,\\n+        objects: Iterable[Pointer],\\n+        upload: bool = False,\\n+        ref: Optional[str] = None,\\n+        hash_algo: str = \\\"sha256\\\",\\n+    ) -> Dict[str, Any]:\\n+        \\\"\\\"\\\"Send LFS API /objects/batch request.\\\"\\\"\\\"\\n+        url = f\\\"{self.url}/objects/batch\\\"\\n+        body: Dict[str, Any] = {\\n+            \\\"operation\\\": \\\"upload\\\" if upload else \\\"download\\\",\\n+            \\\"transfers\\\": [\\\"basic\\\"],\\n+            \\\"objects\\\": [{\\\"oid\\\": obj.oid, \\\"size\\\": obj.size} for obj in objects],\\n+            \\\"hash_algo\\\": hash_algo,\\n+        }\\n+        if ref:\\n+            body[\\\"ref\\\"] = [{\\\"name\\\": ref}]\\n+        session = await self._set_session()\\n+        headers = dict(self.headers)\\n+        headers[\\\"Content-Type\\\"] = self.JSON_CONTENT_TYPE\\n+        async with session.post(\\n+            url,\\n+            headers=headers,\\n+            json=body,\\n+        ) as resp:\\n+            data = await resp.json()\\n+        return data\\n+\\n+    @_authed\\n+    async def _download(\\n+        self,\\n+        storage: \\\"LFSStorage\\\",\\n+        objects: Iterable[Pointer],\\n+        callback: \\\"Callback\\\" = DEFAULT_CALLBACK,\\n+        **kwargs,\\n+    ):\\n+        async def _get_one(from_path: str, to_path: str, **kwargs):\\n+            get_coro = callback.wrap_and_branch_coro(\\n+                self.httpfs._get_file  # pylint: disable=protected-access\\n+            )\\n+            with as_atomic(localfs, to_path, create_parents=True) as tmp_file:\\n+                return await get_coro(\\n+                    from_path,\\n+                    tmp_file,\\n+                    **kwargs,\\n+                )\\n+\\n+        resp_data = await self._batch_request(objects, **kwargs)\\n+        if resp_data.get(\\\"transfer\\\") != \\\"basic\\\":\\n+            raise LFSError(\\\"Unsupported LFS transfer type\\\")\\n+        coros = []\\n+        for data in resp_data.get(\\\"objects\\\", []):\\n+            obj = Pointer(data[\\\"oid\\\"], data[\\\"size\\\"])\\n+            download = data.get(\\\"actions\\\", {}).get(\\\"download\\\", {})\\n+            url = download.get(\\\"href\\\")\\n+            if not url:\\n+                logger.debug(\\\"No download URL for LFS object '%s'\\\", obj)\\n+                continue\\n+            headers = download.get(\\\"header\\\", {})\\n+            to_path = storage.oid_to_path(obj.oid)\\n+            coros.append(_get_one(url, to_path, headers=headers))\\n+        for result in await batch_coros(\\n+            coros, batch_size=self.fs.jobs, return_exceptions=True\\n+        ):\\n+            if isinstance(result, BaseException):\\n+                raise result\\n+\\n+    download = sync_wrapper(_download)\\n\",\"diff --git a/src/scmrepo/git/lfs/exceptions.py b/src/scmrepo/git/lfs/exceptions.py\\nnew file mode 100644\\nindex 00000000..d7ad9eb9\\n--- /dev/null\\n+++ b/src/scmrepo/git/lfs/exceptions.py\\n@@ -0,0 +1,5 @@\\n+from scmrepo.exceptions import SCMError\\n+\\n+\\n+class LFSError(SCMError):\\n+    pass\\n\",\"diff --git a/src/scmrepo/git/lfs/fetch.py b/src/scmrepo/git/lfs/fetch.py\\nnew file mode 100644\\nindex 00000000..5c6f9347\\n--- /dev/null\\n+++ b/src/scmrepo/git/lfs/fetch.py\\n@@ -0,0 +1,162 @@\\n+import fnmatch\\n+import io\\n+import os\\n+from typing import TYPE_CHECKING, Callable, Iterable, Iterator, List, Optional, Set\\n+\\n+from scmrepo.exceptions import InvalidRemote, SCMError\\n+\\n+from .pointer import HEADERS, Pointer\\n+\\n+if TYPE_CHECKING:\\n+    from scmrepo.git import Git\\n+    from scmrepo.git.config import Config\\n+    from scmrepo.progress import GitProgressEvent\\n+\\n+\\n+def fetch(\\n+    scm: \\\"Git\\\",\\n+    revs: Optional[List[str]] = None,\\n+    remote: Optional[str] = None,\\n+    include: Optional[List[str]] = None,\\n+    exclude: Optional[List[str]] = None,\\n+    progress: Optional[Callable[[\\\"GitProgressEvent\\\"], None]] = None,\\n+):\\n+    # NOTE: This currently does not support fetching objects from the worktree\\n+    if not revs:\\n+        revs = [\\\"HEAD\\\"]\\n+    objects: Set[Pointer] = set()\\n+    for rev in revs:\\n+        objects.update(\\n+            pointer\\n+            for pointer in _collect_objects(scm, rev, include, exclude)\\n+            if not scm.lfs_storage.exists(pointer)\\n+        )\\n+    if not objects:\\n+        return\\n+    try:\\n+        url = get_fetch_url(scm, remote=remote)\\n+    except InvalidRemote:\\n+        if remote:\\n+            # treat remote as a raw Git remote\\n+            url = remote\\n+        else:\\n+            raise\\n+    scm.lfs_storage.fetch(url, objects, progress=progress)\\n+\\n+\\n+def get_fetch_url(scm: \\\"Git\\\", remote: Optional[str] = None):  # noqa: C901\\n+    \\\"\\\"\\\"Return LFS fetch URL for the specified repository.\\\"\\\"\\\"\\n+    git_config = scm.get_config()\\n+\\n+    # check lfs.url (can be set in git config and .lfsconfig)\\n+    try:\\n+        return git_config.get((\\\"lfs\\\",), \\\"url\\\")\\n+    except KeyError:\\n+        pass\\n+    try:\\n+        lfs_config: Optional[\\\"Config\\\"] = scm.get_config(\\n+            os.path.join(scm.root_dir, \\\".lfsconfig\\\")\\n+        )\\n+    except FileNotFoundError:\\n+        lfs_config = None\\n+    if lfs_config:\\n+        try:\\n+            return lfs_config.get((\\\"lfs\\\",), \\\"url\\\")\\n+        except KeyError:\\n+            pass\\n+\\n+    # use:\\n+    #   current tracking-branch remote\\n+    #   or remote.lfsdefault  (can only be set in git config)\\n+    #   or \\\"origin\\\"\\n+    # in that order\\n+    if not remote:\\n+        try:\\n+            remote = scm.active_branch_remote()\\n+        except SCMError:\\n+            pass\\n+    if not remote:\\n+        try:\\n+            remote = git_config.get((\\\"remote\\\",), \\\"lfsdefault\\\")\\n+        except KeyError:\\n+            remote = \\\"origin\\\"\\n+\\n+    # check remote.*.lfsurl (can be set in git config and .lfsconfig)\\n+    assert remote is not None\\n+    try:\\n+        return git_config.get((\\\"remote\\\", remote), \\\"lfsurl\\\")\\n+    except KeyError:\\n+        pass\\n+    if lfs_config:\\n+        try:\\n+            return lfs_config.get((\\\"remote\\\", remote), \\\"lfsurl\\\")\\n+        except KeyError:\\n+            pass\\n+\\n+    # return default Git fetch URL for this remote\\n+    return scm.get_remote_url(remote)\\n+\\n+\\n+def _collect_objects(\\n+    scm: \\\"Git\\\",\\n+    rev: str,\\n+    include: Optional[List[str]],\\n+    exclude: Optional[List[str]],\\n+) -> Iterator[Pointer]:\\n+    fs = scm.get_fs(rev)\\n+    for path in _filter_paths(fs.find(\\\"/\\\"), include, exclude):\\n+        check_path = path.lstrip(\\\"/\\\")\\n+        if scm.check_attr(check_path, \\\"filter\\\", source=rev) == \\\"lfs\\\":\\n+            try:\\n+                with fs.open(path, \\\"rb\\\", raw=True) as fobj:\\n+                    with io.BufferedReader(fobj) as reader:\\n+                        data = reader.peek(100)\\n+                        if any(data.startswith(header) for header in HEADERS):\\n+                            yield Pointer.load(reader)\\n+            except (ValueError, OSError):\\n+                pass\\n+\\n+\\n+def _filter_paths(\\n+    paths: Iterable[str], include: Optional[List[str]], exclude: Optional[List[str]]\\n+) -> Iterator[str]:\\n+    filtered = set()\\n+    if include:\\n+        for pattern in include:\\n+            filtered.update(fnmatch.filter(paths, pattern))\\n+    else:\\n+        filtered.update(paths)\\n+    if exclude:\\n+        for pattern in exclude:\\n+            filtered.difference_update(fnmatch.filter(paths, pattern))\\n+    yield from filtered\\n+\\n+\\n+if __name__ == \\\"__main__\\\":\\n+    # Minimal `git lfs fetch` CLI implementation\\n+    import argparse\\n+    import sys\\n+\\n+    from scmrepo.git import Git  # noqa: F811\\n+\\n+    parser = argparse.ArgumentParser(\\n+        description=(\\n+            \\\"Download Git LFS objects at the given refs from the specified remote.\\\"\\n+        ),\\n+    )\\n+    parser.add_argument(\\n+        \\\"remote\\\",\\n+        nargs=\\\"?\\\",\\n+        default=\\\"origin\\\",\\n+        help=\\\"Remote to fetch from. Defaults to 'origin'.\\\",\\n+    )\\n+    parser.add_argument(\\n+        \\\"refs\\\",\\n+        nargs=\\\"*\\\",\\n+        default=[\\\"HEAD\\\"],\\n+        help=\\\"Refs or commits to fetch. Defaults to 'HEAD'.\\\",\\n+    )\\n+    args = parser.parse_args()\\n+    with Git(\\\".\\\") as scm_:  # pylint: disable=E0601\\n+        print(\\\"fetch: fetching reference\\\", \\\", \\\".join(args.refs), file=sys.stderr)\\n+        fetch(scm_, revs=args.refs, remote=args.remote)\\n\",\"diff --git a/src/scmrepo/git/lfs/object.py b/src/scmrepo/git/lfs/object.py\\nnew file mode 100644\\nindex 00000000..7a96b300\\n--- /dev/null\\n+++ b/src/scmrepo/git/lfs/object.py\\n@@ -0,0 +1,15 @@\\n+from dataclasses import dataclass, fields\\n+from typing import Any, Dict\\n+\\n+\\n+@dataclass(frozen=True)\\n+class LFSObject:\\n+    oid: str\\n+    size: int\\n+\\n+    def __str__(self) -> str:\\n+        return self.oid\\n+\\n+    @classmethod\\n+    def from_dict(cls, d: Dict[str, Any]) -> \\\"LFSObject\\\":\\n+        return cls(**{k: v for k, v in d.items() if k in fields(cls)})\\n\",\"diff --git a/src/scmrepo/git/lfs/pointer.py b/src/scmrepo/git/lfs/pointer.py\\nnew file mode 100644\\nindex 00000000..ec0445b4\\n--- /dev/null\\n+++ b/src/scmrepo/git/lfs/pointer.py\\n@@ -0,0 +1,109 @@\\n+import hashlib\\n+import io\\n+import logging\\n+from dataclasses import dataclass\\n+from typing import IO, BinaryIO, TextIO, Tuple\\n+\\n+logger = logging.getLogger(__name__)\\n+\\n+\\n+LFS_VERSION = \\\"https://git-lfs.github.com/spec/v1\\\"\\n+LEGACY_LFS_VERSION = \\\"https://hawser.github.com/spec/v1\\\"\\n+ALLOWED_VERSIONS = (LFS_VERSION, LEGACY_LFS_VERSION)\\n+HEADERS = [(b\\\"version \\\" + version.encode(\\\"utf-8\\\")) for version in ALLOWED_VERSIONS]\\n+\\n+\\n+def _get_kv(line: str) -> Tuple[str, str]:\\n+    key, value = line.strip().split(maxsplit=1)\\n+    return key, value\\n+\\n+\\n+@dataclass\\n+class Pointer:\\n+    oid: str\\n+    size: int\\n+\\n+    def __init__(self, oid: str, size: int, **kwargs):\\n+        self.oid = oid\\n+        self.size = size\\n+        self._dict = kwargs\\n+\\n+    def __hash__(self):\\n+        return hash(self.dump())\\n+\\n+    @classmethod\\n+    def build(cls, fobj: BinaryIO) -> \\\"Pointer\\\":\\n+        m = hashlib.sha256()\\n+        data = fobj.read()\\n+        m.update(data)\\n+        return cls(m.hexdigest(), len(data))\\n+\\n+    @classmethod\\n+    def load(cls, fobj: IO) -> \\\"Pointer\\\":\\n+        \\\"\\\"\\\"Load the specified pointer file.\\\"\\\"\\\"\\n+\\n+        if isinstance(fobj, io.TextIOBase):  # type: ignore[unreachable]\\n+            text_obj: TextIO = fobj  # type: ignore[unreachable]\\n+\\n+        else:\\n+            text_obj = io.TextIOWrapper(fobj, encoding=\\\"utf-8\\\")\\n+\\n+        cls.check_version(text_obj.readline())\\n+        d = dict(_get_kv(line) for line in text_obj.readlines())\\n+        try:\\n+            value = d.pop(\\\"oid\\\")\\n+            hash_method, oid = value.split(\\\":\\\", maxsplit=1)\\n+            if hash_method != \\\"sha256\\\":\\n+                raise ValueError(\\\"Invalid LFS hash method '{hash_method}'\\\")\\n+        except ValueError as e:\\n+            raise ValueError(\\\"Invalid LFS pointer oid\\\") from e\\n+        try:\\n+            value = d.pop(\\\"size\\\")\\n+            size = int(value)\\n+        except ValueError as e:\\n+            raise ValueError(\\\"Invalid LFS pointer size\\\") from e\\n+\\n+        return cls(oid, size, **d)\\n+\\n+    @staticmethod\\n+    def check_version(line: str):\\n+        try:\\n+            key, value = _get_kv(line)\\n+            if key != \\\"version\\\":\\n+                raise ValueError(\\\"LFS pointer file must start with 'version'\\\")\\n+            if value not in ALLOWED_VERSIONS:\\n+                raise ValueError(f\\\"Unsupported LFS pointer version '{value}'\\\")\\n+        except (ValueError, OSError) as e:\\n+            raise ValueError(\\\"Invalid LFS pointer file\\\") from e\\n+\\n+    def dump(self) -> str:\\n+        d = {\\n+            \\\"oid\\\": f\\\"sha256:{self.oid}\\\",\\n+            \\\"size\\\": self.size,\\n+        }\\n+        d.update(self._dict)\\n+        return \\\"\\\\n\\\".join(\\n+            [f\\\"version {LFS_VERSION}\\\"] + [f\\\"{key} {d[key]}\\\" for key in sorted(d)] + [\\\"\\\"]\\n+        )\\n+\\n+    def to_bytes(self) -> bytes:\\n+        return self.dump().encode(\\\"utf-8\\\")\\n+\\n+\\n+if __name__ == \\\"__main__\\\":\\n+    # Minimal `git lfs pointer` CLI implementation\\n+    import argparse\\n+    import sys\\n+\\n+    parser = argparse.ArgumentParser(\\n+        description=\\\"Build generated pointer files.\\\",\\n+    )\\n+    parser.add_argument(\\\"--file\\\", help=\\\"A local file to build the pointer from.\\\")\\n+    args = parser.parse_args()\\n+    if not args.file:\\n+        sys.exit(\\\"Nothing to do\\\")\\n+\\n+    print(f\\\"Git LFS pointer for {args.file}\\\\n\\\", file=sys.stderr)\\n+    with open(args.file, mode=\\\"rb\\\") as fobj_:\\n+        p = Pointer.build(fobj_)\\n+    print(p.dump(), end=\\\"\\\")\\n\",\"diff --git a/src/scmrepo/git/lfs/progress.py b/src/scmrepo/git/lfs/progress.py\\nnew file mode 100644\\nindex 00000000..898384ab\\n--- /dev/null\\n+++ b/src/scmrepo/git/lfs/progress.py\\n@@ -0,0 +1,61 @@\\n+from typing import Any, BinaryIO, Callable, Dict, Optional, Union\\n+\\n+from dvc_objects.fs.callbacks import DEFAULT_CALLBACK, Callback, TqdmCallback\\n+\\n+from scmrepo.progress import GitProgressEvent\\n+\\n+\\n+class LFSCallback(Callback):\\n+    \\\"\\\"\\\"Callback subclass to generate Git/LFS style progress.\\\"\\\"\\\"\\n+\\n+    def __init__(\\n+        self,\\n+        *args,\\n+        git_progress: Optional[Callable[[GitProgressEvent], None]] = None,\\n+        direction: str = \\\"Downloading\\\",\\n+        **kwargs,\\n+    ):\\n+        super().__init__(*args, **kwargs)\\n+        self.direction = direction\\n+        self.git_progress = git_progress\\n+\\n+    def call(self, *args, **kwargs):\\n+        super().call(*args, **kwargs)\\n+        self._update_git()\\n+\\n+    def _update_git(self):\\n+        if not self.git_progress:\\n+            return\\n+        event = GitProgressEvent(\\n+            phase=f\\\"{self.direction} LFS objects\\\",\\n+            completed=self.value,\\n+            total=self.size,\\n+        )\\n+        self.git_progress(event)\\n+\\n+    def branch(\\n+        self,\\n+        path_1: Union[str, BinaryIO],\\n+        path_2: str,\\n+        kwargs: Dict[str, Any],\\n+        child: Optional[Callback] = None,\\n+    ):\\n+        if child:\\n+            pass\\n+        elif self.git_progress:\\n+            child = TqdmCallback(\\n+                bytes=True, desc=path_1 if isinstance(path_1, str) else path_2\\n+            )\\n+        else:\\n+            child = DEFAULT_CALLBACK\\n+        return super().branch(path_1, path_2, kwargs, child=child)\\n+\\n+    @classmethod\\n+    def as_lfs_callback(\\n+        cls,\\n+        git_progress: Optional[Callable[[GitProgressEvent], None]] = None,\\n+        **kwargs,\\n+    ):\\n+        if git_progress is None:\\n+            return DEFAULT_CALLBACK\\n+        return cls(git_progress=git_progress, **kwargs)\\n\",\"diff --git a/src/scmrepo/git/lfs/smudge.py b/src/scmrepo/git/lfs/smudge.py\\nnew file mode 100644\\nindex 00000000..dcf7e0ed\\n--- /dev/null\\n+++ b/src/scmrepo/git/lfs/smudge.py\\n@@ -0,0 +1,51 @@\\n+import io\\n+import logging\\n+from typing import TYPE_CHECKING, BinaryIO, Optional\\n+\\n+from .pointer import HEADERS, Pointer\\n+\\n+if TYPE_CHECKING:\\n+    from .storage import LFSStorage\\n+\\n+logger = logging.getLogger(__name__)\\n+\\n+\\n+def smudge(\\n+    storage: \\\"LFSStorage\\\", fobj: BinaryIO, url: Optional[str] = None\\n+) -> BinaryIO:\\n+    \\\"\\\"\\\"Wrap the specified binary IO stream and run LFS smudge if necessary.\\\"\\\"\\\"\\n+    reader = io.BufferedReader(fobj)  # type: ignore[arg-type]\\n+    data = reader.peek(100)\\n+    if any(data.startswith(header) for header in HEADERS):\\n+        # read the pointer data into memory since the raw stream is unseekable\\n+        # and we may need to return it in fallback case\\n+        data = reader.read()\\n+        lfs_obj: Optional[BinaryIO] = None\\n+        try:\\n+            pointer = Pointer.load(io.BytesIO(data))\\n+            lfs_obj = storage.open(pointer, mode=\\\"rb\\\", fetch_url=url)\\n+        except (ValueError, OSError):\\n+            logger.warning(\\\"Could not open LFS object, falling back to raw pointer\\\")\\n+        if lfs_obj:\\n+            return lfs_obj\\n+        return io.BytesIO(data)\\n+    return reader\\n+\\n+\\n+if __name__ == \\\"__main__\\\":\\n+    # Minimal `git lfs smudge` CLI implementation\\n+    import sys\\n+\\n+    from scmrepo.git import Git\\n+\\n+    if sys.stdin.isatty():\\n+        sys.exit(\\n+            \\\"Cannot read from STDIN: \\\"\\n+            \\\"This command should be run by the Git 'smudge' filter\\\"\\n+        )\\n+    scm = Git()\\n+    try:\\n+        with smudge(scm.lfs_storage, sys.stdin.buffer) as fobj_:\\n+            sys.stdout.buffer.write(fobj_.read())\\n+    finally:\\n+        scm.close()\\n\",\"diff --git a/src/scmrepo/git/lfs/storage.py b/src/scmrepo/git/lfs/storage.py\\nnew file mode 100644\\nindex 00000000..0570a3bc\\n--- /dev/null\\n+++ b/src/scmrepo/git/lfs/storage.py\\n@@ -0,0 +1,74 @@\\n+import errno\\n+import os\\n+from typing import TYPE_CHECKING, BinaryIO, Callable, Collection, Optional, Union\\n+\\n+from .pointer import Pointer\\n+from .progress import LFSCallback\\n+\\n+if TYPE_CHECKING:\\n+    from scmrepo.git import Git\\n+    from scmrepo.progress import GitProgressEvent\\n+\\n+\\n+class LFSStorage:\\n+    def __init__(self, path: str):\\n+        self.path = path\\n+\\n+    def fetch(\\n+        self,\\n+        url: str,\\n+        objects: Collection[Pointer],\\n+        progress: Optional[Callable[[\\\"GitProgressEvent\\\"], None]] = None,\\n+    ):\\n+        from .client import LFSClient\\n+\\n+        with LFSCallback.as_lfs_callback(progress) as cb:\\n+            cb.set_size(len(objects))\\n+            with LFSClient.from_git_url(url) as client:\\n+                client.download(self, objects, callback=cb)\\n+\\n+    def oid_to_path(self, oid: str):\\n+        return os.path.join(self.path, \\\"objects\\\", oid[0:2], oid[2:4], oid)\\n+\\n+    def exists(self, obj: Union[Pointer, str]):\\n+        oid = obj if isinstance(obj, str) else obj.oid\\n+        path = self.oid_to_path(oid)\\n+        return os.path.exists(path)\\n+\\n+    def open(\\n+        self,\\n+        obj: Union[Pointer, str],\\n+        fetch_url: Optional[str] = None,\\n+        **kwargs,\\n+    ) -> BinaryIO:\\n+        oid = obj if isinstance(obj, str) else obj.oid\\n+        path = self.oid_to_path(oid)\\n+        try:\\n+            return open(path, **kwargs)  # pylint: disable=unspecified-encoding\\n+        except FileNotFoundError:\\n+            if not fetch_url or not isinstance(obj, Pointer):\\n+                raise\\n+        try:\\n+            self.fetch(fetch_url, [obj])\\n+        except BaseException as exc:\\n+            raise FileNotFoundError(\\n+                errno.ENOENT, os.strerror(errno.ENOENT), path\\n+            ) from exc\\n+        return open(path, **kwargs)  # pylint: disable=unspecified-encoding\\n+\\n+    def close(self):\\n+        pass\\n+\\n+\\n+def get_storage_path(scm: \\\"Git\\\") -> str:\\n+    \\\"\\\"\\\"Return the LFS storage directory for the specified repository.\\\"\\\"\\\"\\n+\\n+    config = scm.get_config()\\n+    git_dir = scm._get_git_dir(scm.root_dir)  # pylint: disable=protected-access\\n+    try:\\n+        path = config.get((\\\"lfs\\\",), \\\"storage\\\")\\n+        if os.path.isabs(path):\\n+            return path\\n+    except KeyError:\\n+        path = \\\"lfs\\\"\\n+    return os.path.join(git_dir, path)\\n\",\"diff --git a/src/scmrepo/git/objects.py b/src/scmrepo/git/objects.py\\nindex 192fd802..edb5047b 100644\\n--- a/src/scmrepo/git/objects.py\\n+++ b/src/scmrepo/git/objects.py\\n@@ -20,7 +20,7 @@ def _to_datetime(time: int, offset: int) -> datetime.datetime:\\n \\n class GitObject(ABC):\\n     @abstractmethod\\n-    def open(self, mode: str = \\\"r\\\", encoding: str = None):\\n+    def open(self, mode: str = \\\"r\\\", encoding: str = None, **kwargs):\\n         pass\\n \\n     @property\\n@@ -82,12 +82,13 @@ def open(\\n         key: tuple,\\n         mode: Optional[str] = \\\"r\\\",\\n         encoding: Optional[str] = None,\\n+        raw: bool = True,\\n     ):\\n         obj = self.trie[key]\\n         if obj.isdir:\\n             raise IsADirectoryError\\n \\n-        return obj.open(mode=mode, encoding=encoding)\\n+        return obj.open(mode=mode, encoding=encoding, key=key, raw=raw, rev=self.rev)\\n \\n     def exists(self, key: tuple) -> bool:\\n         return bool(self.trie.has_node(key))\\n\"]", "test_patch": "[\"diff --git a/pyproject.toml b/pyproject.toml\\nindex aa5b78cf..9b40460b 100644\\n--- a/pyproject.toml\\n+++ b/pyproject.toml\\n@@ -70,6 +70,7 @@ files = [\\\"src\\\", \\\"tests\\\"]\\n [[tool.mypy.overrides]]\\n module = [\\n     \\\"pygtrie\\\",\\n+    \\\"dvc_http.*\\\",\\n     \\\"funcy\\\",\\n     \\\"git\\\",\\n     \\\"gitdb.*\\\",\\n\",\"diff --git a/setup.cfg b/setup.cfg\\nindex 7887e599..44505d01 100644\\n--- a/setup.cfg\\n+++ b/setup.cfg\\n@@ -26,13 +26,15 @@ packages = find:\\n install_requires=\\n     gitpython>3\\n     dulwich>=0.21.6\\n-    pygit2>=1.13.0\\n+    pygit2>=1.13.3\\n     pygtrie>=2.3.2\\n     fsspec>=2021.7.0\\n     pathspec>=0.9.0\\n     asyncssh>=2.13.1,<3\\n     funcy>=1.14\\n     shortuuid>=0.5.0\\n+    dvc-objects>=1.0.1,<2\\n+    dvc-http>=2.29.0\\n \\n [options.extras_require]\\n tests =\\n\",\"diff --git a/tests/test_fs.py b/tests/test_fs.py\\nindex 36808225..451022bf 100644\\n--- a/tests/test_fs.py\\n+++ b/tests/test_fs.py\\n@@ -22,19 +22,23 @@ def _make_fs(rev=None):\\n     return _make_fs\\n \\n \\n-def test_open(tmp_dir: TmpDir, scm: Git, make_fs):\\n+@pytest.mark.parametrize(\\\"raw\\\", [True, False])\\n+def test_open(tmp_dir: TmpDir, scm: Git, make_fs, raw: bool, git_backend: str):\\n+    if not raw and git_backend != \\\"pygit2\\\":\\n+        pytest.skip()\\n+\\n     files = tmp_dir.gen({\\\"foo\\\": \\\"foo\\\", \\\"\\\": \\\"\\\", \\\"data\\\": {\\\"lorem\\\": \\\"ipsum\\\"}})\\n     scm.add_commit(files, message=\\\"add\\\")\\n \\n     fs = make_fs()\\n-    with fs.open(\\\"foo\\\", mode=\\\"r\\\", encoding=\\\"utf-8\\\") as fobj:\\n+    with fs.open(\\\"foo\\\", mode=\\\"r\\\", encoding=\\\"utf-8\\\", raw=raw) as fobj:\\n         assert fobj.read() == \\\"foo\\\"\\n-    with fs.open(\\\"\\\", mode=\\\"r\\\", encoding=\\\"utf-8\\\") as fobj:\\n+    with fs.open(\\\"\\\", mode=\\\"r\\\", encoding=\\\"utf-8\\\", raw=raw) as fobj:\\n         assert fobj.read() == \\\"\\\"\\n     with pytest.raises(IOError):\\n-        fs.open(\\\"not-existing-file\\\")\\n+        fs.open(\\\"not-existing-file\\\", raw=raw)\\n     with pytest.raises(IOError):\\n-        fs.open(\\\"data\\\")\\n+        fs.open(\\\"data\\\", raw=raw)\\n \\n \\n def test_exists(tmp_dir: TmpDir, scm: Git, make_fs):\\n\",\"diff --git a/tests/test_git.py b/tests/test_git.py\\nindex d9ce7863..050feb63 100644\\n--- a/tests/test_git.py\\n+++ b/tests/test_git.py\\n@@ -1142,3 +1142,19 @@ def test_config(tmp_dir, scm: Git, git: Git):\\n     config = git.get_config(\\\".otherconfig\\\")\\n     assert config.get((\\\"test\\\",), \\\"foo\\\") == \\\"false\\\"\\n     assert config.get_bool((\\\"test\\\",), \\\"foo\\\") is False\\n+\\n+\\n+@pytest.mark.skip_git_backend(\\\"dulwich\\\")\\n+def test_check_attr(tmp_dir, scm: Git, git: Git):\\n+    tmp_dir.gen(\\\"foo.txt\\\", \\\"foo\\\")\\n+    tmp_dir.gen(\\\".gitattributes\\\", \\\"*.txt text\\\")\\n+    scm.add_commit([\\\".gitattributes\\\", \\\"foo\\\"], message=\\\"init\\\")\\n+    rev = scm.get_rev()\\n+    assert git.check_attr(\\\"foo.txt\\\", \\\"text\\\") is True\\n+    assert git.check_attr(\\\"foo.txt\\\", \\\"filter\\\") is None\\n+\\n+    tmp_dir.gen(\\\".gitattributes\\\", \\\"*.txt -text filter=lfs\\\")\\n+    assert git.check_attr(\\\"foo.txt\\\", \\\"text\\\") is False\\n+    assert git.check_attr(\\\"foo.txt\\\", \\\"filter\\\") == \\\"lfs\\\"\\n+    assert git.check_attr(\\\"foo.txt\\\", \\\"text\\\", source=rev) is True\\n+    assert git.check_attr(\\\"foo.txt\\\", \\\"filter\\\", source=rev) is None\\n\",\"diff --git a/tests/test_lfs.py b/tests/test_lfs.py\\nnew file mode 100644\\nindex 00000000..6918f05f\\n--- /dev/null\\n+++ b/tests/test_lfs.py\\n@@ -0,0 +1,76 @@\\n+# pylint: disable=redefined-outer-name\\n+import io\\n+\\n+import pytest\\n+from pytest_mock import MockerFixture\\n+from pytest_test_utils import TempDirFactory, TmpDir\\n+\\n+from scmrepo.git import Git\\n+from scmrepo.git.lfs import LFSStorage, Pointer, smudge\\n+\\n+FOO_OID = \\\"2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae\\\"\\n+FOO_POINTER = (\\n+    f\\\"version https://git-lfs.github.com/spec/v1\\\\noid sha256:{FOO_OID}\\\\nsize 3\\\\n\\\"\\n+).encode()\\n+\\n+\\n+@pytest.fixture\\n+def storage(tmp_dir_factory: TempDirFactory) -> LFSStorage:\\n+    storage_path = tmp_dir_factory.mktemp(\\\"lfs\\\")\\n+    return LFSStorage(storage_path)\\n+\\n+\\n+@pytest.fixture\\n+def lfs(tmp_dir: TmpDir, scm: Git) -> None:\\n+    tmp_dir.gen(\\\".gitattributes\\\", \\\"*.lfs filter=lfs diff=lfs merge=lfs -text\\\")\\n+    scm.add([\\\".gitattributes\\\"])\\n+    scm.commit(\\\"init lfs attributes\\\")\\n+\\n+\\n+@pytest.fixture\\n+def lfs_objects(tmp_dir: TmpDir) -> TmpDir:\\n+    objects = tmp_dir / \\\".git\\\" / \\\"lfs\\\" / \\\"objects\\\"\\n+    objects.mkdir(parents=True)\\n+    return objects\\n+\\n+\\n+def test_pointer_build(tmp_dir: TmpDir):\\n+    tmp_dir.gen(\\\"foo\\\", \\\"foo\\\")\\n+    with open(tmp_dir / \\\"foo\\\", \\\"rb\\\") as fobj:\\n+        pointer = Pointer.build(fobj)\\n+\\n+    assert pointer.dump() == FOO_POINTER.decode(\\\"utf-8\\\")\\n+\\n+\\n+def test_pointer_load(tmp_dir: TmpDir):\\n+    tmp_dir.gen(\\\"foo.lfs\\\", FOO_POINTER)\\n+    with open(tmp_dir / \\\"foo.lfs\\\", \\\"rb\\\") as fobj:\\n+        pointer = Pointer.load(fobj)\\n+    assert pointer.oid == FOO_OID\\n+    assert pointer.size == 3\\n+\\n+\\n+def test_smudge(tmp_dir: TmpDir, storage: LFSStorage, mocker: MockerFixture):\\n+    tmp_dir.gen(\\\"foo.lfs\\\", FOO_POINTER)\\n+    with open(tmp_dir / \\\"foo.lfs\\\", \\\"rb\\\") as fobj:\\n+        assert smudge(storage, fobj).read() == FOO_POINTER\\n+\\n+    mocker.patch.object(storage, \\\"open\\\", return_value=io.BytesIO(b\\\"foo\\\"))\\n+    with open(tmp_dir / \\\"foo.lfs\\\", \\\"rb\\\") as fobj:\\n+        assert smudge(storage, fobj).read() == b\\\"foo\\\"\\n+\\n+\\n+@pytest.mark.usefixtures(\\\"lfs\\\")\\n+def test_lfs(tmp_dir: TmpDir, scm: Git, lfs_objects: TmpDir):\\n+    # NOTE: scmrepo does not currently support LFS clean (writes), this writes\\n+    # the pointer to the git odb (simulating an actual LFS clean)\\n+    tmp_dir.gen(\\\"foo.lfs\\\", FOO_POINTER)\\n+    scm.add([\\\"foo.lfs\\\"])\\n+    scm.commit(\\\"add foo\\\")\\n+    lfs_objects.gen({FOO_OID[0:2]: {FOO_OID[2:4]: {FOO_OID: \\\"foo\\\"}}})\\n+\\n+    fs = scm.get_fs(\\\"HEAD\\\")\\n+    with fs.open(\\\"foo.lfs\\\", \\\"rb\\\", raw=True) as fobj:\\n+        assert fobj.read() == FOO_POINTER\\n+    with fs.open(\\\"foo.lfs\\\", \\\"rb\\\", raw=False) as fobj:\\n+        assert fobj.read() == b\\\"foo\\\"\"]", "hints_text": ""}

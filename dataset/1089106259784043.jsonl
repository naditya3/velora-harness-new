{"instance_id": "1089106259784043", "repo": "sqlfluff/sqlfluff", "base_commit": "ed4e0561feb754ed984b3ca2ca6cf77331b0edaf", "problem_statement": "CROSS JOIN confuses parser?:\\n## Expected Behaviour\\r\\nSQLFluff should recognize the alias `foo`\\r\\n\\r\\n## Observed Behaviour\\r\\n\\r\\nThe alias `foo` isn't recognized. When I remove the `CROSS JOIN`, SQLFluff no longer emits L026 for `foo`. \\r\\n\\r\\n```\\r\\n$ sqlfluff lint test.sql\\r\\n== [test.sql] FAIL\\r\\nL:   7 | P:   5 | L026 | Reference 'foo.name' refers to table/view 'foo' not\\r\\n                       | found in the FROM clause or found in parent subquery.\\r\\nL:   8 | P:   5 | L026 | Reference 'foo.value' refers to table/view 'foo' not\\r\\n                       | found in the FROM clause or found in parent subquery.\\r\\nL:  12 | P:   1 | L003 | Indent expected and not found compared to line #10\\r\\nL:  12 | P:  16 | L031 | Avoid using aliases in join condition\\r\\nL:  12 | P:  20 | L032 | Found USING statement. Expected only ON statements.\\r\\n```\\r\\n\\r\\n## Steps to Reproduce\\r\\n`sqlfluff lint test.sql` with default config\\r\\n\\r\\nContents of `test.sql` --\\r\\n```sql\\r\\nWITH constants AS (\\r\\n    SELECT 8760 AS hours_per_year\\r\\n)\\r\\n\\r\\nSELECT\\r\\n    table1.name,\\r\\n    foo.name,\\r\\n    foo.value * constants.hours_per_year AS some_value\\r\\nFROM table1\\r\\nCROSS JOIN\\r\\n    constants\\r\\nJOIN table2 AS foo USING (id)\\r\\n;\\r\\n```\\r\\n\\r\\n\\r\\n## Version\\r\\n```\\r\\n$ sqlfluff --version\\r\\nsqlfluff, version 0.4.1\\r\\n$ python --version\\r\\nPython 3.9.2\\r\\n```\\r\\n\\r\\n## Configuration\\r\\nI don't have a config file; I'm using the default config for 0.4.1.\\r\\n", "FAIL_TO_PASS": ["test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_true_and_not_false.sql-True-select_true_and_not_false.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_b.sql-True-select_b.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[bigquery-select_replace.sql-True-select_replace.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_simple_g.sql-True-select_simple_g.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_right.sql-True-select_right.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_simple_d.sql-True-select_simple_d.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[snowflake-snowflake_secure_view.sql-True-snowflake_secure_view.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-delete_from.sql-True-delete_from.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_with_offset_limit.sql-True-select_with_offset_limit.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[bigquery-select_quoting.sql-True-select_quoting.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[snowflake-snowflake_qualify.sql-True-snowflake_qualify.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[bigquery-string_literals.sql-True-string_literals.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_v.sql-True-select_v.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_named_window_no_parentheses.sql-True-select_named_window_no_parentheses.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_l.sql-True-select_l.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[snowflake-snowflake_semi_structured_3.sql-True-snowflake_semi_structured_3.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_union_distinct.sql-True-select_union_distinct.yml]", "test/core/dialects/ansi_test.py::test__dialect__ansi_specific_segment_parses[SelectClauseElementSegment-a.b.*]", "test/core/templaters/jinja_test.py::test__templater_full[jinja_i_raw/raw_tag-True]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_o.sql-True-select_o.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_d.sql-True-select_d.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_union_all.sql-True-select_union_all.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-expression_recursion_2.sql-True-expression_recursion_2.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-create_model_options.sql-True-create_model_options.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_case_b.sql-True-select_case_b.yml]", "test/core/templaters/jinja_test.py::test__templater_full[jinja_i_raw/raw_tag_2-True]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[bigquery-select_for_system_time.sql-True-select_for_system_time.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[postgres-postgres_join_no_space.sql-True-postgres_join_no_space.yml]", "test/core/templaters/jinja_test.py::test__templater_full[jinja_b/jinja-False]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-create_table_as.sql-True-create_table_as.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[bigquery-select_datetime.sql-True-select_datetime.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[snowflake-snowflake_string_literal.sql-True-snowflake_string_literal.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-expression_recursion.sql-True-expression_recursion.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_p.sql-True-select_p.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_simple_f.sql-True-select_simple_f.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-update_with_from_clause.sql-True-update_with_from_clause.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[snowflake-snowflake_semi_structured_2.sql-True-snowflake_semi_structured_2.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-bracket_in_comment.sql-True-bracket_in_comment.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_c.sql-True-select_c.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[snowflake-snowflake_pivot.sql-True-snowflake_pivot.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[bigquery-select_1_gt_0.sql-True-select_1_gt_0.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[bigquery-select_multi_except.sql-True-select_multi_except.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[teradata-select_stmt_cast.sql-True-select_stmt_cast.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[postgres-postgres_within_group.sql-True-postgres_within_group.yml]", "test/core/dialects/ansi_test.py::test__dialect__ansi_specific_segment_parses[SelectClauseElementSegment-(count_18_24", "test/core/dialects/ansi_test.py::test__dialect__ansi_specific_segment_parses[SelectClauseElementSegment--", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[snowflake-snowflake_within_group.sql-True-snowflake_within_group.yml]", "test/core/dialects/ansi_test.py::test__dialect__ansi_specific_segment_parses[SelectClauseElementSegment-CAST(num", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[bigquery-select_ml_weights.sql-True-select_ml_weights.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[snowflake-snowflake_view_comment.sql-True-snowflake_view_comment.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-arithmetic_a.sql-True-arithmetic_a.yml]", "test/core/dialects/ansi_test.py::test__dialect__ansi_specific_segment_parses[SelectClauseElementSegment-MIN", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-escape.sql-True-escape.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[bigquery-select_except_replace.sql-True-select_except_replace.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[bigquery-array_agg_distinct_ignore_nulls.sql-True-array_agg_distinct_ignore_nulls.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_e.sql-True-select_e.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-create_view_a.sql-True-create_view_a.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[bigquery-interval_function.sql-True-interval_function.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[snowflake-snowflake_json_underscore_key.sql-True-snowflake_json_underscore_key.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[bigquery-select_ml_predict_with_select.sql-True-select_ml_predict_with_select.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-modulo.sql-True-modulo.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[snowflake-snowflake_semi_structured.sql-True-snowflake_semi_structured.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_multiple_named_windows.sql-True-select_multiple_named_windows.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_simple_j.sql-True-select_simple_j.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-multi_statement_a.sql-False-multi_statement_a_nc.yml]", "test/core/dialects/ansi_test.py::test__dialect__ansi_specific_segment_parses[SelectClauseElementSegment-a.b.c.*]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_h.sql-True-select_h.yml]", "test/core/templaters/jinja_test.py::test__templater_full[jinja_f/jinja-True]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_fn_square_bracket_array_parameter.sql-True-select_fn_square_bracket_array_parameter.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_simple_i.sql-True-select_simple_i.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[bigquery-select_replace_2.sql-True-select_replace_2.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[bigquery-select_where_greater_than.sql-True-select_where_greater_than.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_q.sql-True-select_q.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_simple_b.sql-True-select_simple_b.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_union.sql-True-select_union.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[bigquery-select_with_date_literal_coercion_and_two_part_string_interval.sql-True-select_with_date_literal_coercion_and_two_part_string_interval.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-functions_a.sql-True-functions_a.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_named_window.sql-True-select_named_window.yml]", "test/core/templaters/jinja_test.py::test__templater_full[jinja_j_libraries/jinja-True]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[bigquery-select_where_less_than.sql-True-select_where_less_than.yml]", "test/core/dialects/ansi_test.py::test__dialect__ansi_specific_segment_parses[SelectClauseElementSegment-NULL::INT", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-create_table_as_select_cte_no_parentheses.sql-True-create_table_as_select_cte_no_parentheses.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_function_in_group_by.sql-True-select_function_in_group_by.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[snowflake-snowflake_window_function_ignore_nulls.sql-True-snowflake_window_function_ignore_nulls.yml]", "test/core/dialects/ansi_test.py::test__dialect__ansi_specific_segment_parses[SelectClauseElementSegment-t.val/t.id]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_with_b.sql-True-select_with_b.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_n.sql-True-select_n.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[bigquery-select_lt_gt.sql-True-select_lt_gt.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_simple_e.sql-False-select_simple_e_nc.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-functions_b.sql-True-functions_b.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_simple_e.sql-True-select_simple_e.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-create_table_as_select_cte_parentheses.sql-True-create_table_as_select_cte_parentheses.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[bigquery-create_temp_function_with_select.sql-True-create_temp_function_with_select.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[bigquery-select_gt_lt.sql-True-select_gt_lt.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_t.sql-True-select_t.yml]", "test/core/templaters/jinja_test.py::test__templater_full[jinja_g_macros/jinja-True]", "test/core/templaters/jinja_test.py::test__templater_full[jinja_c_dbt/dbt_builtins-True]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_many_join.sql-True-select_many_join.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_with_simple_limit.sql-True-select_with_simple_limit.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[bigquery-select_with_offset.sql-True-select_with_offset.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_m.sql-True-select_m.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-table_expression.sql-True-table_expression.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[bigquery-select_except.sql-True-select_except.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-multi_statement_a.sql-True-multi_statement_a.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_r.sql-True-select_r.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_named_window_with_parentheses.sql-True-select_named_window_with_parentheses.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[bigquery-select_example.sql-True-select_example.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_case_a.sql-True-select_case_a.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[snowflake-snowflake_first_value_ignore_nulls.sql-True-snowflake_first_value_ignore_nulls.yml]", "test/core/templaters/jinja_test.py::test__templater_full[jinja_k_config_override_path_macros/jinja-True]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[bigquery-array_agg_ignore_nulls.sql-True-array_agg_ignore_nulls.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_where_in_unnest.sql-True-select_where_in_unnest.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[snowflake-snowflake_lateral_flatten_after_join.sql-True-snowflake_lateral_flatten_after_join.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[bigquery-select_where_array_element_less_than.sql-True-select_where_array_element_less_than.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_s.sql-True-select_s.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_with_limit_and_offset.sql-True-select_with_limit_and_offset.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_a_and_not_b.sql-True-select_a_and_not_b.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_with_a.sql-True-select_with_a.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_named_windows_each_window_specification.sql-True-select_named_windows_each_window_specification.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-with_no_schema_binding.sql-True-with_no_schema_binding.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-multi_statement_c.sql-True-multi_statement_c.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_simple_a.sql-True-select_simple_a.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[bigquery-array_agg_respect_nulls.sql-True-array_agg_respect_nulls.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_trailing_comma_column_list.sql-True-select_trailing_comma_column_list.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_u.sql-True-select_u.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_simple_c.sql-True-select_simple_c.yml]", "test/core/dialects/ansi_test.py::test__dialect__ansi_specific_segment_parses[SelectClauseElementSegment--some_variable]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[bigquery-select_case.sql-True-select_case.yml]", "test/core/templaters/jinja_test.py::test__templater_full[jinja_a/jinja-True]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-multi_statement_b.sql-True-multi_statement_b.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_a.sql-True-select_a.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_simple_h.sql-True-select_simple_h.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_in_multiline_comment.sql-True-select_in_multiline_comment.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[snowflake-snowflake_secure_view_comment.sql-True-snowflake_secure_view_comment.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-escaped_quotes.sql-True-escaped_quotes.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-shorthand_cast.sql-True-shorthand_cast.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[snowflake-snowflake_select_transient_table.sql-True-snowflake_select_transient_table.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_f.sql-True-select_f.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[snowflake-snowflake_col_position.sql-True-snowflake_col_position.yml]", "test/core/dialects/ansi_test.py::test__dialect__ansi_specific_segment_parses[SelectClauseElementSegment-a.*]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[teradata-select_stmt.sql-True-select_stmt.yml]", "test/core/templaters/jinja_test.py::test__templater_full[jinja_e/jinja-True]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_g.sql-True-select_g.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_cross_join.sql-True-select_cross_join.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[bigquery-select_1_lt_0.sql-True-select_1_lt_0.yml]", "test/core/templaters/jinja_test.py::test__templater_full[jinja_h_macros/jinja-True]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[ansi-select_j.sql-True-select_j.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[teradata-update_from.sql-True-update_from.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[bigquery-select_struct.sql-True-select_struct.yml]", "test/core/dialects/dialects_test.py::test__dialect__base_parse_struct[bigquery-select_for_system_time_2.sql-True-select_for_system_time_2.yml]"], "PASS_TO_PASS": [], "language": "python", "test_command": "source /saved/ENV || source /saved/*/ENV && pytest --no-header -rA --tb=no -p no:cacheprovider --continue-on-collection-errors", "test_output_parser": "python/parse_log_pytest_v3", "image_storage_uri": "vmvm-registry.fbinfra.net/repomate_image_activ_pytest/sqlfluff_sqlfluff:ed4e0561feb754ed984b3ca2ca6cf77331b0edaf", "patch": "[\"diff --git a/src/sqlfluff/core/dialects/dialect_ansi.py b/src/sqlfluff/core/dialects/dialect_ansi.py\\nindex 96c1f2fa4d0..87b932d3a00 100644\\n--- a/src/sqlfluff/core/dialects/dialect_ansi.py\\n+++ b/src/sqlfluff/core/dialects/dialect_ansi.py\\n@@ -789,11 +789,8 @@ class PartitionClauseSegment(BaseSegment):\\n         \\\"PARTITION\\\",\\n         \\\"BY\\\",\\n         Indent,\\n-        OneOf(\\n-            # Brackets are optional in a partition by statement\\n-            Bracketed(Delimited(Ref(\\\"ExpressionSegment\\\"))),\\n-            Delimited(Ref(\\\"ExpressionSegment\\\")),\\n-        ),\\n+        # Brackets are optional in a partition by statement\\n+        OptionallyBracketed(Delimited(Ref(\\\"ExpressionSegment\\\"))),\\n         Dedent,\\n     )\\n \\n@@ -824,30 +821,21 @@ class AliasInfo(NamedTuple):\\n     ref_str: str  # Name given to the alias\\n     segment: BaseSegment  # Identifier segment containing the name\\n     aliased: bool\\n-    table_expression: BaseSegment\\n+    from_expression_element: BaseSegment\\n     alias_expression: Optional[BaseSegment]\\n     object_reference: Optional[BaseSegment]\\n \\n \\n @ansi_dialect.segment()\\n-class TableExpressionSegment(BaseSegment):\\n+class FromExpressionElementSegment(BaseSegment):\\n     \\\"\\\"\\\"A table expression.\\\"\\\"\\\"\\n \\n-    type = \\\"table_expression\\\"\\n+    type = \\\"from_expression_element\\\"\\n     match_grammar = Sequence(\\n-        Indent,\\n         Ref(\\\"PreTableFunctionKeywordsGrammar\\\", optional=True),\\n-        OneOf(\\n-            Ref(\\\"MainTableExpressionSegment\\\"),\\n-            Bracketed(Ref(\\\"MainTableExpressionSegment\\\")),\\n-        ),\\n+        OptionallyBracketed(Ref(\\\"TableExpressionSegment\\\")),\\n         Ref(\\\"AliasExpressionSegment\\\", optional=True),\\n         Ref(\\\"PostTableExpressionGrammar\\\", optional=True),\\n-        Dedent.when(indented_joins=False),\\n-        AnyNumberOf(\\n-            Ref(\\\"JoinClauseSegment\\\"), Ref(\\\"JoinLikeClauseGrammar\\\"), optional=True\\n-        ),\\n-        Dedent.when(indented_joins=True),\\n     )\\n \\n     def get_eventual_alias(self) -> Optional[AliasInfo]:\\n@@ -860,7 +848,7 @@ def get_eventual_alias(self) -> Optional[AliasInfo]:\\n \\n         \\\"\\\"\\\"\\n         alias_expression = self.get_child(\\\"alias_expression\\\")\\n-        ref = self.get_child(\\\"main_table_expression\\\").get_child(\\\"object_reference\\\")\\n+        ref = self.get_child(\\\"table_expression\\\").get_child(\\\"object_reference\\\")\\n         if alias_expression:\\n             # If it has an alias, return that\\n             segment = alias_expression.get_child(\\\"identifier\\\")\\n@@ -880,10 +868,30 @@ def get_eventual_alias(self) -> Optional[AliasInfo]:\\n \\n \\n @ansi_dialect.segment()\\n-class MainTableExpressionSegment(BaseSegment):\\n+class FromExpressionSegment(BaseSegment):\\n+    \\\"\\\"\\\"A from expression segment.\\\"\\\"\\\"\\n+\\n+    type = \\\"from_expression\\\"\\n+    match_grammar = Sequence(\\n+        Indent,\\n+        OneOf(\\n+            # check first for MLTableExpression, because of possible FunctionSegment in MainTableExpression\\n+            Ref(\\\"MLTableExpressionSegment\\\"),\\n+            Ref(\\\"FromExpressionElementSegment\\\"),\\n+        ),\\n+        Dedent.when(indented_joins=False),\\n+        AnyNumberOf(\\n+            Ref(\\\"JoinClauseSegment\\\"), Ref(\\\"JoinLikeClauseGrammar\\\"), optional=True\\n+        ),\\n+        Dedent.when(indented_joins=True),\\n+    )\\n+\\n+\\n+@ansi_dialect.segment()\\n+class TableExpressionSegment(BaseSegment):\\n     \\\"\\\"\\\"The main table expression e.g. within a FROM clause.\\\"\\\"\\\"\\n \\n-    type = \\\"main_table_expression\\\"\\n+    type = \\\"table_expression\\\"\\n     match_grammar = OneOf(\\n         Ref(\\\"BareFunctionSegment\\\"),\\n         Ref(\\\"FunctionSegment\\\"),\\n@@ -941,10 +949,10 @@ class WildcardExpressionSegment(BaseSegment):\\n \\n \\n @ansi_dialect.segment()\\n-class SelectTargetElementSegment(BaseSegment):\\n+class SelectClauseElementSegment(BaseSegment):\\n     \\\"\\\"\\\"An element in the targets of a select statement.\\\"\\\"\\\"\\n \\n-    type = \\\"select_target_element\\\"\\n+    type = \\\"select_clause_element\\\"\\n     # Important to split elements before parsing, otherwise debugging is really hard.\\n     match_grammar = GreedyUntil(\\n         \\\"FROM\\\",\\n@@ -1002,7 +1010,7 @@ class SelectClauseSegment(BaseSegment):\\n         Ref(\\\"SelectClauseModifierSegment\\\", optional=True),\\n         Indent,\\n         Delimited(\\n-            Ref(\\\"SelectTargetElementSegment\\\"),\\n+            Ref(\\\"SelectClauseElementSegment\\\"),\\n             allow_trailing=True,\\n         ),\\n         # NB: The Dedent for the indent above lives in the\\n@@ -1036,7 +1044,7 @@ class JoinClauseSegment(BaseSegment):\\n         \\\"JOIN\\\",\\n         Indent,\\n         Sequence(\\n-            Ref(\\\"TableExpressionSegment\\\"),\\n+            Ref(\\\"FromExpressionElementSegment\\\"),\\n             # NB: this is optional\\n             OneOf(\\n                 # ON clause\\n@@ -1069,8 +1077,8 @@ class JoinClauseSegment(BaseSegment):\\n \\n     def get_eventual_alias(self) -> AliasInfo:\\n         \\\"\\\"\\\"Return the eventual table name referred to by this join clause.\\\"\\\"\\\"\\n-        table_expression = self.get_child(\\\"table_expression\\\")\\n-        return table_expression.get_eventual_alias()\\n+        from_expression_element = self.get_child(\\\"from_expression_element\\\")\\n+        return from_expression_element.get_eventual_alias()\\n \\n \\n @ansi_dialect.segment()\\n@@ -1094,7 +1102,18 @@ class JoinOnConditionSegment(BaseSegment):\\n \\n @ansi_dialect.segment()\\n class FromClauseSegment(BaseSegment):\\n-    \\\"\\\"\\\"A `FROM` clause like in `SELECT`.\\\"\\\"\\\"\\n+    \\\"\\\"\\\"A `FROM` clause like in `SELECT`.\\n+\\n+    NOTE: thiis is a delimited set of table expressions, with a variable\\n+    number of optional join clauses with those table expressions. The\\n+    delmited aspect is the higher of the two such that the following is\\n+    valid (albeit unusual):\\n+\\n+    ```\\n+    SELECT *\\n+    FROM a JOIN b, c JOIN d\\n+    ```\\n+    \\\"\\\"\\\"\\n \\n     type = \\\"from_clause\\\"\\n     match_grammar = StartsWith(\\n@@ -1105,11 +1124,7 @@ class FromClauseSegment(BaseSegment):\\n     parse_grammar = Sequence(\\n         \\\"FROM\\\",\\n         Delimited(\\n-            OneOf(\\n-                # check first for MLTableExpression, because of possible FunctionSegment in MainTableExpression\\n-                Ref(\\\"MLTableExpressionSegment\\\"),\\n-                Ref(\\\"TableExpressionSegment\\\"),\\n-            ),\\n+            Ref(\\\"FromExpressionSegment\\\"),\\n         ),\\n     )\\n \\n@@ -1119,12 +1134,15 @@ def get_eventual_aliases(self) -> List[Tuple[BaseSegment, AliasInfo]]:\\n         Comes as a list of tuples (table expr, tuple (string, segment, bool)).\\n         \\\"\\\"\\\"\\n         buff = []\\n-        direct_table_children = self.get_children(\\\"table_expression\\\")\\n-        join_clauses = [\\n-            join_clause\\n-            for child in direct_table_children\\n-            for join_clause in child.get_children(\\\"join_clause\\\")\\n-        ]\\n+        direct_table_children = []\\n+        join_clauses = []\\n+\\n+        for from_expression in self.get_children(\\\"from_expression\\\"):\\n+            direct_table_children += from_expression.get_children(\\n+                \\\"from_expression_element\\\"\\n+            )\\n+            join_clauses += from_expression.get_children(\\\"join_clause\\\")\\n+\\n         # Iterate through the potential sources of aliases\\n         for clause in (*direct_table_children, *join_clauses):\\n             ref: AliasInfo = clause.get_eventual_alias()\\n@@ -1133,7 +1151,7 @@ def get_eventual_aliases(self) -> List[Tuple[BaseSegment, AliasInfo]]:\\n             table_expr = (\\n                 clause\\n                 if clause in direct_table_children\\n-                else clause.get_child(\\\"table_expression\\\")\\n+                else clause.get_child(\\\"from_expression_element\\\")\\n             )\\n             if ref:\\n                 buff.append((table_expr, ref))\\n@@ -1359,13 +1377,7 @@ class WhereClauseSegment(BaseSegment):\\n     parse_grammar = Sequence(\\n         \\\"WHERE\\\",\\n         Indent,\\n-        OneOf(\\n-            Bracketed(\\n-                # expression could be in brackets\\n-                Ref(\\\"ExpressionSegment\\\"),\\n-            ),\\n-            Ref(\\\"ExpressionSegment\\\"),\\n-        ),\\n+        OptionallyBracketed(Ref(\\\"ExpressionSegment\\\")),\\n         Dedent,\\n     )\\n \\n@@ -1453,12 +1465,7 @@ class HavingClauseSegment(BaseSegment):\\n     parse_grammar = Sequence(\\n         \\\"HAVING\\\",\\n         Indent,\\n-        OneOf(\\n-            Bracketed(\\n-                Ref(\\\"ExpressionSegment\\\"),\\n-            ),\\n-            Ref(\\\"ExpressionSegment\\\"),\\n-        ),\\n+        OptionallyBracketed(Ref(\\\"ExpressionSegment\\\")),\\n         Dedent,\\n     )\\n \\n\",\"diff --git a/src/sqlfluff/core/dialects/dialect_bigquery.py b/src/sqlfluff/core/dialects/dialect_bigquery.py\\nindex 364ed21688a..36adbe75629 100644\\n--- a/src/sqlfluff/core/dialects/dialect_bigquery.py\\n+++ b/src/sqlfluff/core/dialects/dialect_bigquery.py\\n@@ -23,7 +23,7 @@\\n \\n from sqlfluff.core.dialects.dialect_ansi import (\\n     ansi_dialect,\\n-    SelectTargetElementSegment as AnsiSelectTargetElementSegment,\\n+    SelectClauseElementSegment as AnsiSelectTargetElementSegment,\\n     SelectClauseSegment as AnsiSelectClauseSegment,\\n )\\n \\n@@ -130,7 +130,7 @@ class SelectClauseSegment(AnsiSelectClauseSegment):\\n                 Ref(\\\"StarModifierSegment\\\", optional=True),\\n             ),\\n             Delimited(\\n-                Ref(\\\"SelectTargetElementSegment\\\"),\\n+                Ref(\\\"SelectClauseElementSegment\\\"),\\n                 delimiter=Ref(\\\"CommaSegment\\\"),\\n                 allow_trailing=True,\\n             ),\\n@@ -138,7 +138,7 @@ class SelectClauseSegment(AnsiSelectClauseSegment):\\n     )\\n \\n \\n-class SelectTargetElementSegment(AnsiSelectTargetElementSegment):\\n+class SelectClauseElementSegment(AnsiSelectTargetElementSegment):\\n     \\\"\\\"\\\"BigQuery also supports the special \\\"Struct\\\" construct.\\\"\\\"\\\"\\n \\n     parse_grammar = OneOf(\\n@@ -186,7 +186,7 @@ class SelectTargetElementSegment(AnsiSelectTargetElementSegment):\\n         type=\\\"function_name\\\",\\n         _anti_template=r\\\"STRUCT\\\",\\n     ),\\n-    SelectTargetElementSegment=SelectTargetElementSegment,\\n+    SelectClauseElementSegment=SelectClauseElementSegment,\\n     SelectClauseSegment=SelectClauseSegment,\\n )\\n \\n@@ -272,12 +272,12 @@ class ReplaceClauseSegment(BaseSegment):\\n                 Delimited(\\n                     # Not *really* a select target element. It behaves exactly\\n                     # the same way however.\\n-                    Ref(\\\"SelectTargetElementSegment\\\"),\\n+                    Ref(\\\"SelectClauseElementSegment\\\"),\\n                     delimiter=Ref(\\\"CommaSegment\\\"),\\n                 )\\n             ),\\n             # Single replace not in brackets.\\n-            Ref(\\\"SelectTargetElementSegment\\\"),\\n+            Ref(\\\"SelectClauseElementSegment\\\"),\\n         ),\\n     )\\n \\n\",\"diff --git a/src/sqlfluff/core/dialects/dialect_exasol.py b/src/sqlfluff/core/dialects/dialect_exasol.py\\nindex 71cdc6044f5..2808917b8e6 100644\\n--- a/src/sqlfluff/core/dialects/dialect_exasol.py\\n+++ b/src/sqlfluff/core/dialects/dialect_exasol.py\\n@@ -226,10 +226,10 @@ class SelectStatementSegment(BaseSegment):\\n \\n \\n @exasol_dialect.segment(replace=True)\\n-class MainTableExpressionSegment(BaseSegment):\\n+class TableExpressionSegment(BaseSegment):\\n     \\\"\\\"\\\"The main table expression e.g. within a FROM clause.\\\"\\\"\\\"\\n \\n-    type = \\\"main_table_expression\\\"\\n+    type = \\\"table_expression\\\"\\n     match_grammar = OneOf(\\n         Ref(\\\"BareFunctionSegment\\\"),\\n         Ref(\\\"FunctionSegment\\\"),\\n\",\"diff --git a/src/sqlfluff/core/dialects/dialect_teradata.py b/src/sqlfluff/core/dialects/dialect_teradata.py\\nindex ca0db7e9adb..ba5a213edee 100644\\n--- a/src/sqlfluff/core/dialects/dialect_teradata.py\\n+++ b/src/sqlfluff/core/dialects/dialect_teradata.py\\n@@ -537,7 +537,7 @@ class FromUpdateClauseSegment(BaseSegment):\\n         \\\"FROM\\\",\\n         Delimited(\\n             # Optional old school delimited joins\\n-            Ref(\\\"TableExpressionSegment\\\"),\\n+            Ref(\\\"FromExpressionElementSegment\\\"),\\n             delimiter=Ref(\\\"CommaSegment\\\"),\\n         ),\\n     )\\n\",\"diff --git a/src/sqlfluff/core/rules/analysis/select.py b/src/sqlfluff/core/rules/analysis/select.py\\nindex 30d701305c2..ebbf79373bf 100644\\n--- a/src/sqlfluff/core/rules/analysis/select.py\\n+++ b/src/sqlfluff/core/rules/analysis/select.py\\n@@ -55,7 +55,7 @@ def get_select_statement_info(\\n \\n     # Get all select targets.\\n     select_targets = segment.get_child(\\\"select_clause\\\").get_children(\\n-        \\\"select_target_element\\\"\\n+        \\\"select_clause_element\\\"\\n     )\\n \\n     # Get all column aliases\\n\",\"diff --git a/src/sqlfluff/core/rules/analysis/select_crawler.py b/src/sqlfluff/core/rules/analysis/select_crawler.py\\nindex 004751a03ae..f83a612d56a 100644\\n--- a/src/sqlfluff/core/rules/analysis/select_crawler.py\\n+++ b/src/sqlfluff/core/rules/analysis/select_crawler.py\\n@@ -75,7 +75,7 @@ def get(\\n             # If we reach here, the SELECT may be querying from a value table\\n             # function, e.g. UNNEST(). For our purposes, this is basically the\\n             # same as an external table. Return the \\\"table\\\" part as a string.\\n-            table_expr = segment.get_child(\\\"main_table_expression\\\")\\n+            table_expr = segment.get_child(\\\"table_expression\\\")\\n             if table_expr:\\n                 return table_expr.raw\\n         return buff\\n\",\"diff --git a/src/sqlfluff/core/rules/std/L011.py b/src/sqlfluff/core/rules/std/L011.py\\nindex f84d3cb67ec..43978c2dfb5 100644\\n--- a/src/sqlfluff/core/rules/std/L011.py\\n+++ b/src/sqlfluff/core/rules/std/L011.py\\n@@ -28,7 +28,7 @@ class Rule_L011(BaseRule):\\n \\n     \\\"\\\"\\\"\\n \\n-    _target_elems = (\\\"table_expression\\\",)\\n+    _target_elems = (\\\"from_expression_element\\\",)\\n \\n     def _eval(self, segment, parent_stack, raw_stack, **kwargs):\\n         \\\"\\\"\\\"Implicit aliasing of table/column not allowed. Use explicit `AS` clause.\\n\",\"diff --git a/src/sqlfluff/core/rules/std/L012.py b/src/sqlfluff/core/rules/std/L012.py\\nindex 9dbba1a3593..c7d6d339275 100644\\n--- a/src/sqlfluff/core/rules/std/L012.py\\n+++ b/src/sqlfluff/core/rules/std/L012.py\\n@@ -11,4 +11,4 @@ class Rule_L012(Rule_L011):\\n \\n     \\\"\\\"\\\"\\n \\n-    _target_elems = (\\\"select_target_element\\\",)\\n+    _target_elems = (\\\"select_clause_element\\\",)\\n\",\"diff --git a/src/sqlfluff/core/rules/std/L013.py b/src/sqlfluff/core/rules/std/L013.py\\nindex 021361d7ad9..69e6ed29dcf 100644\\n--- a/src/sqlfluff/core/rules/std/L013.py\\n+++ b/src/sqlfluff/core/rules/std/L013.py\\n@@ -35,13 +35,13 @@ class Rule_L013(BaseRule):\\n     def _eval(self, segment, parent_stack, **kwargs):\\n         \\\"\\\"\\\"Column expression without alias. Use explicit `AS` clause.\\n \\n-        We look for the select_target_element segment, and then evaluate\\n+        We look for the select_clause_element segment, and then evaluate\\n         whether it has an alias segment or not and whether the expression\\n         is complicated enough. `parent_stack` is to assess how many other\\n         elements there are.\\n \\n         \\\"\\\"\\\"\\n-        if segment.is_type(\\\"select_target_element\\\"):\\n+        if segment.is_type(\\\"select_clause_element\\\"):\\n             if not any(e.is_type(\\\"alias_expression\\\") for e in segment.segments):\\n                 types = {e.type for e in segment.segments if e.name != \\\"star\\\"}\\n                 unallowed_types = types - {\\n@@ -58,7 +58,7 @@ def _eval(self, segment, parent_stack, **kwargs):\\n                         # statement. If this is the only one, then we won't\\n                         # report an error.\\n                         num_elements = sum(\\n-                            e.is_type(\\\"select_target_element\\\")\\n+                            e.is_type(\\\"select_clause_element\\\")\\n                             for e in parent_stack[-1].segments\\n                         )\\n                         if num_elements > 1:\\n\",\"diff --git a/src/sqlfluff/core/rules/std/L025.py b/src/sqlfluff/core/rules/std/L025.py\\nindex 1af021b527a..679e5a283ed 100644\\n--- a/src/sqlfluff/core/rules/std/L025.py\\n+++ b/src/sqlfluff/core/rules/std/L025.py\\n@@ -61,7 +61,7 @@ def _lint_references_and_aliases(\\n                 fixes = [LintFix(\\\"delete\\\", alias.alias_expression)]\\n                 found_alias_segment = False\\n                 # Walk back to remove indents/whitespaces\\n-                for segment in reversed(alias.table_expression.segments):\\n+                for segment in reversed(alias.from_expression_element.segments):\\n                     if not found_alias_segment:\\n                         if segment is alias.alias_expression:\\n                             found_alias_segment = True\\n\",\"diff --git a/src/sqlfluff/core/rules/std/L031.py b/src/sqlfluff/core/rules/std/L031.py\\nindex d8e943278f8..b4a71b07126 100644\\n--- a/src/sqlfluff/core/rules/std/L031.py\\n+++ b/src/sqlfluff/core/rules/std/L031.py\\n@@ -58,22 +58,31 @@ def _eval(self, segment, **kwargs):\\n             if not from_clause_segment:\\n                 return None\\n \\n-            table_expression = from_clause_segment.get_child(\\\"table_expression\\\")\\n-            if not table_expression:\\n+            from_expression = from_clause_segment.get_child(\\\"from_expression\\\")\\n+            if from_expression:\\n+                from_expression_element = from_expression.get_child(\\n+                    \\\"from_expression_element\\\"\\n+                )\\n+\\n+            if not from_expression_element:\\n                 return None\\n-            table_expression = table_expression.get_child(\\\"main_table_expression\\\")\\n+            from_expression_element = from_expression_element.get_child(\\n+                \\\"table_expression\\\"\\n+            )\\n \\n             # Find base table\\n             base_table = None\\n-            if table_expression:\\n-                base_table = table_expression.get_child(\\\"object_reference\\\")\\n+            if from_expression_element:\\n+                base_table = from_expression_element.get_child(\\\"object_reference\\\")\\n \\n             from_clause_index = segment.segments.index(from_clause_segment)\\n             from_clause_and_after = segment.segments[from_clause_index:]\\n \\n             for clause in from_clause_and_after:\\n-                for table_expression in clause.recursive_crawl(\\\"table_expression\\\"):\\n-                    table_expression_segments.append(table_expression)\\n+                for from_expression_element in clause.recursive_crawl(\\n+                    \\\"from_expression_element\\\"\\n+                ):\\n+                    table_expression_segments.append(from_expression_element)\\n                 for column_reference in clause.recursive_crawl(\\\"column_reference\\\"):\\n                     column_reference_segments.append(column_reference)\\n \\n@@ -96,11 +105,11 @@ def _lint_aliases_in_join(\\n         violation_buff = []\\n \\n         for table_exp in table_expression_segments:\\n-            table_ref = table_exp.get_child(\\\"main_table_expression\\\").get_child(\\n+            table_ref = table_exp.get_child(\\\"table_expression\\\").get_child(\\n                 \\\"object_reference\\\"\\n             )\\n \\n-            # If the table_expression has no object_references - skip it\\n+            # If the from_expression_element has no object_references - skip it\\n             # An example case is a lateral flatten, where we have a function segment\\n             # instead of a table_reference segment.\\n             if not table_ref:\\n\",\"diff --git a/src/sqlfluff/core/rules/std/L034.py b/src/sqlfluff/core/rules/std/L034.py\\nindex 132aae85c8e..ccda7468993 100644\\n--- a/src/sqlfluff/core/rules/std/L034.py\\n+++ b/src/sqlfluff/core/rules/std/L034.py\\n@@ -62,7 +62,7 @@ def _eval(self, segment, **kwargs):\\n         self.seen_band_elements = [[] for i in select_element_order_preference] + [[]]\\n \\n         if segment.type == \\\"select_clause\\\":\\n-            select_target_elements = segment.get_children(\\\"select_target_element\\\")\\n+            select_target_elements = segment.get_children(\\\"select_clause_element\\\")\\n             if not select_target_elements:\\n                 return None\\n \\n\",\"diff --git a/src/sqlfluff/core/rules/std/L036.py b/src/sqlfluff/core/rules/std/L036.py\\nindex 8b14bc8272b..7e64bafbd2c 100644\\n--- a/src/sqlfluff/core/rules/std/L036.py\\n+++ b/src/sqlfluff/core/rules/std/L036.py\\n@@ -63,7 +63,7 @@ def _get_indexes(segment):\\n         first_whitespace_idx = -1\\n         select_targets = []\\n         for fname_idx, seg in enumerate(segment.segments):\\n-            if seg.is_type(\\\"select_target_element\\\"):\\n+            if seg.is_type(\\\"select_clause_element\\\"):\\n                 select_targets.append(seg)\\n                 if first_select_target_idx == -1:\\n                     first_select_target_idx = fname_idx\\n@@ -112,7 +112,7 @@ def _eval_single_select_target_element(\\n     ):\\n         is_wildcard = False\\n         for segment in select_clause.segments:\\n-            if segment.is_type(\\\"select_target_element\\\"):\\n+            if segment.is_type(\\\"select_clause_element\\\"):\\n                 for sub_segment in segment.segments:\\n                     if sub_segment.is_type(\\\"wildcard_expression\\\"):\\n                         is_wildcard = True\\n\",\"diff --git a/src/sqlfluff/core/rules/std/L042.py b/src/sqlfluff/core/rules/std/L042.py\\nindex 41189b6a671..cd41fbf5119 100644\\n--- a/src/sqlfluff/core/rules/std/L042.py\\n+++ b/src/sqlfluff/core/rules/std/L042.py\\n@@ -45,8 +45,8 @@ class Rule_L042(BaseRule):\\n \\n     _config_mapping = {\\n         \\\"join\\\": [\\\"join_clause\\\"],\\n-        \\\"from\\\": [\\\"from_clause\\\"],\\n-        \\\"both\\\": [\\\"join_clause\\\", \\\"from_clause\\\"],\\n+        \\\"from\\\": [\\\"from_expression\\\"],\\n+        \\\"both\\\": [\\\"join_clause\\\", \\\"from_expression\\\"],\\n     }\\n \\n     def _eval(self, segment, **kwargs):\\n@@ -59,12 +59,14 @@ def _eval(self, segment, **kwargs):\\n         for parent_type in parent_types:\\n             if segment.is_type(parent_type):\\n                 # Get the referenced table segment\\n-                table_expression = segment.get_child(\\\"table_expression\\\")\\n-                if not table_expression:\\n+                from_expression_element = segment.get_child(\\\"from_expression_element\\\")\\n+                if not from_expression_element:\\n                     return None  # There isn't one. We're done.\\n                 # Get the main bit\\n-                table_expression = table_expression.get_child(\\\"main_table_expression\\\")\\n-                if not table_expression:\\n+                from_expression_element = from_expression_element.get_child(\\n+                    \\\"table_expression\\\"\\n+                )\\n+                if not from_expression_element:\\n                     return None  # There isn't one. We're done.\\n \\n                 # If any of the following are found, raise an issue.\\n@@ -75,7 +77,7 @@ def _eval(self, segment, **kwargs):\\n                     \\\"select_statement\\\",\\n                 ]\\n                 for seg_type in problem_children:\\n-                    seg = table_expression.get_child(seg_type)\\n+                    seg = from_expression_element.get_child(seg_type)\\n                     if seg:\\n                         return LintResult(\\n                             anchor=seg,\\n\",\"diff --git a/src/sqlfluff/core/rules/std/L044.py b/src/sqlfluff/core/rules/std/L044.py\\nindex 53bce159422..b504b58111e 100644\\n--- a/src/sqlfluff/core/rules/std/L044.py\\n+++ b/src/sqlfluff/core/rules/std/L044.py\\n@@ -61,7 +61,7 @@ class Rule_L044(BaseRule):\\n \\n     def _handle_alias(self, alias_info, dialect, queries):\\n         select_info_target = SelectCrawler.get(\\n-            alias_info.table_expression, queries, dialect\\n+            alias_info.from_expression_element, queries, dialect\\n         )\\n         if isinstance(select_info_target, str):\\n             # It's an alias to an external table whose\\n\",\"diff --git a/src/sqlfluff/core/rules/std/L045.py b/src/sqlfluff/core/rules/std/L045.py\\nindex de89303e7ad..c7a3a7477cf 100644\\n--- a/src/sqlfluff/core/rules/std/L045.py\\n+++ b/src/sqlfluff/core/rules/std/L045.py\\n@@ -53,8 +53,8 @@ def _visit_sources(\\n         for select_info in select_info_list:\\n             for alias_info in select_info.select_info.table_aliases:\\n                 # Does the query read from a CTE? If so, visit the CTE.\\n-                for target_segment in alias_info.table_expression.get_children(\\n-                    \\\"main_table_expression\\\", \\\"join_clause\\\"\\n+                for target_segment in alias_info.from_expression_element.get_children(\\n+                    \\\"table_expression\\\", \\\"join_clause\\\"\\n                 ):\\n                     target = target_segment.raw\\n                     if target in queries:\\n\"]", "test_patch": "", "hints_text": ""}

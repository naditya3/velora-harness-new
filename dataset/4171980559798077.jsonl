{"instance_id": "4171980559798077", "repo": "stac-utils/pystac", "base_commit": "7f8e7aaf29c9882e717550b219228ccf27add74b", "problem_statement": "Raise exception on attempt to extend object not implementing that extension:\\nCalling, for instance, `pystac.extensions.eo.EOExtension.ext` on an `Item` that does not have the EO schema URI in its `stac_extensions` list will succeed and return an `ItemEOExtension` instance. You can then read and write fields like `eo:cloud_cover` even though the `Item` doesn't actually implement that extension.\\r\\n\\r\\nIt seems like the desired behavior here would be to raise an exception when using `ext` on an object that does not implement that extension for 2 reasons:\\r\\n\\r\\n1. When using PySTAC to read existing STAC Items, this could mask a problem with an invalid object\\r\\n2. This will interfere with the edge case where a user has custom fields with a prefix that overlaps with one of the extensions (maybe because the custom fields predate the extension). In this case, the fields should not be treated as if they are defined by the extension.\\r\\n\\r\\nOriginally raised as part of [this PR comment](https://github.com/stac-utils/stactools/pull/113#discussion_r638974407) in stac-utils/stactools", "FAIL_TO_PASS": ["extensions.test_label.LabelTest.test_extension_type_error.test_extension_type_error"], "PASS_TO_PASS": ["extensions.test_file.MappingObjectTest.test_apply.test_apply", "test_item.CommonMetadataTest.test_common_metadata_start_datetime.test_common_metadata_start_datetime", "extensions.test_scientific.CollectionScientificExtensionTest.test_remove_all_publications_one.test_remove_all_publications_one", "test_stac_io.StacIOTest.test_read_write_catalog.test_read_write_catalog", "test_item_collection.TestItemCollection.test_clone_item_collection.test_clone_item_collection", "test_stac_io.StacIOTest.test_read_write_collection.test_read_write_collection", "test_catalog.CatalogTest.test_map_assets_single.test_map_assets_single", "serialization.test_migrate.MigrateTest.test_migrates_removed_extension.test_migrates_removed_extension", "extensions.test_projection.ProjectionTest.test_to_from_dict.test_to_from_dict", "test_item.CommonMetadataTest.test_asset_license.test_asset_license", "extensions.test_label.LabelTest.test_to_from_dict.test_to_from_dict", "serialization.test_migrate.MigrateTest.test_migrates_renamed_extension.test_migrates_renamed_extension", "test_item_collection.TestItemCollection.test_raise_error_for_invalid_object.test_raise_error_for_invalid_object", "test_catalog.CatalogTest.test_make_all_asset_hrefs_absolute.test_make_all_asset_hrefs_absolute", "test_utils.UtilsTest.test_make_relative_href_windows.test_make_relative_href_windows", "test_catalog.CatalogTest.test_clear_children_sets_parent_and_root_to_None.test_clear_children_sets_parent_and_root_to_None", "extensions.test_projection.ProjectionSummariesTest.test_get_summaries.test_get_summaries", "test_item.ItemTest.test_set_self_href_none_ignores_relative_asset_hrefs.test_set_self_href_none_ignores_relative_asset_hrefs", "extensions.test_file.FileTest.test_repr.test_repr", "extensions.test_eo.EOTest.test_add_to.test_add_to", "extensions.test_version.ItemVersionExtensionTest.test_full_copy.test_full_copy", "test_item.ItemTest.test_make_asset_href_relative_is_noop_on_relative_hrefs.test_make_asset_href_relative_is_noop_on_relative_hrefs", "test_item_collection.TestItemCollection.test_item_collection_get_item_by_index.test_item_collection_get_item_by_index", "test_catalog.CatalogTest.test_generate_subcatalogs_works_for_subcatalogs_with_same_ids.test_generate_subcatalogs_works_for_subcatalogs_with_same_ids", "test_item_collection.TestItemCollection.test_add_other_raises_error.test_add_other_raises_error", "extensions.test_projection.ProjectionTest.test_apply.test_apply", "test_item_collection.TestItemCollection.test_item_collection_extra_fields.test_item_collection_extra_fields", "test_catalog.FullCopyTest.test_full_copy_2.test_full_copy_2", "test_catalog.CatalogTest.test_create_and_read.test_create_and_read", "extensions.test_version.ItemVersionExtensionTest.test_multiple_link_setting.test_multiple_link_setting", "extensions.test_sat.SatTest.test_stac_extensions.test_stac_extensions", "extensions.test_version.ItemVersionExtensionTest.test_rel_types.test_rel_types", "test_item_collection.TestItemCollection.test_from_relative_path.test_from_relative_path", "extensions.test_raster.RasterTest.test_to_from_dict.test_to_from_dict", "test_summaries.SummariesTest.test_summary_empty.test_summary_empty", "test_item.CommonMetadataTest.test_asset_start_datetime.test_asset_start_datetime", "test_utils.UtilsTest.test_geojson_bbox.test_geojson_bbox", "extensions.test_view.ViewSummariestest.test_set_incidence_angle_summaries.test_set_incidence_angle_summaries", "test_layout.LayoutTemplateTest.test_templates_item_start_datetime.test_templates_item_start_datetime", "extensions.test_eo.EOTest.test_summaries.test_summaries", "test_layout.TemplateLayoutStrategyTest.test_produces_fallback_layout_for_item.test_produces_fallback_layout_for_item", "extensions.test_view.ViewSummariestest.test_get_off_nadir_summaries.test_get_off_nadir_summaries", "serialization.test_migrate.MigrateTest.test_migrates_added_extension.test_migrates_added_extension", "extensions.test_view.ViewSummariestest.test_set_off_nadir_summaries.test_set_off_nadir_summaries", "test_link.StaticLinkTest.test_from_dict_round_trip.test_from_dict_round_trip", "test_catalog.CatalogTest.test_get_item_returns_none_if_not_found.test_get_item_returns_none_if_not_found", "extensions.test_view.ViewSummariestest.test_set_azimuth_summaries.test_set_azimuth_summaries", "extensions.test_scientific.CollectionScientificExtensionTest.test_doi.test_doi", "test_layout.CustomLayoutStrategyTest.test_produces_fallback_layout_for_collection.test_produces_fallback_layout_for_collection", "test_catalog.FullCopyTest.test_full_copy_3.test_full_copy_3", "test_stac_io.StacIOTest.test_read_item.test_read_item", "extensions.test_eo.BandsTest.test_band_description_unknown_band.test_band_description_unknown_band", "test_item_collection.TestItemCollection.test_identify_0_9_itemcollection.test_identify_0_9_itemcollection", "test_stac_io.StacIOTest.test_read_item_collection_raises_exception.test_read_item_collection_raises_exception", "test_layout.LayoutTemplateTest.test_defaults.test_defaults", "extensions.test_label.LabelTest.test_from_file_pre_081.test_from_file_pre_081", "test_item.CommonMetadataTest.test_datetimes.test_datetimes", "extensions.test_view.ViewSummariestest.test_get_incidence_angle_summaries.test_get_incidence_angle_summaries", "test_link.StaticLinkTest.test_from_dict_failures.test_from_dict_failures", "serialization.test_identify.IdentifyTest.test_identify.test_identify", "extensions.test_eo.EOTest.test_asset_bands_s2.test_asset_bands_s2", "extensions.test_label.LabelTest.test_merge_label_overviews.test_merge_label_overviews", "test_catalog.CatalogTest.test_map_assets_multi.test_map_assets_multi", "test_item.CommonMetadataTest.test_common_metadata_basics.test_common_metadata_basics", "extensions.test_file.FileTest.test_to_from_dict.test_to_from_dict", "test_layout.LayoutTemplateTest.test_docstring_examples.test_docstring_examples", "extensions.test_version.CollectionVersionExtensionTest.test_full_copy.test_full_copy", "test_catalog.CatalogTest.test_reading_iterating_and_writing_works_as_expected.test_reading_iterating_and_writing_works_as_expected", "extensions.test_eo.EOTest.test_read_pre_09_fields_into_common_metadata.test_read_pre_09_fields_into_common_metadata", "test_item.CommonMetadataTest.test_common_metadata_updated.test_common_metadata_updated", "test_layout.BestPracticesLayoutStrategyTest.test_produces_layout_for_item.test_produces_layout_for_item", "test_utils.UtilsTest.test_is_absolute_href_windows.test_is_absolute_href_windows", "extensions.test_scientific.SummariesScientificTest.test_set_citation_summaries.test_set_citation_summaries", "extensions.test_label.LabelTest.test_merge_label_overviews_empty_counts.test_merge_label_overviews_empty_counts", "test_collection.CollectionTest.test_extra_fields.test_extra_fields", "test_catalog.CatalogTest.test_get_child_returns_none_if_not_found.test_get_child_returns_none_if_not_found", "test_catalog.CatalogTest.test_read_remote.test_read_remote", "test_catalog.CatalogTest.test_map_items.test_map_items", "test_link.LinkTest.test_resolve_stac_object_no_root_and_target_is_item.test_resolve_stac_object_no_root_and_target_is_item", "extensions.test_view.ViewSummariestest.test_get_azimuth_summaries.test_get_azimuth_summaries", "test_utils.UtilsTest.test_is_absolute_href.test_is_absolute_href", "test_catalog.CatalogTest.test_normalize_hrefs_sets_all_hrefs.test_normalize_hrefs_sets_all_hrefs", "test_layout.TemplateLayoutStrategyTest.test_produces_fallback_layout_for_catalog.test_produces_fallback_layout_for_catalog", "test_layout.TemplateLayoutStrategyTest.test_produces_layout_for_item.test_produces_layout_for_item", "test_cache.ResolvedObjectCacheTest.test_get_or_cache_returns_previously_cached_id.test_get_or_cache_returns_previously_cached_id", "test_summaries.SummariesTest.test_summary_custom_fields_file.test_summary_custom_fields_file", "test_summaries.SummariesTest.test_summary_limit.test_summary_limit", "test_item.CommonMetadataTest.test_common_metadata_providers.test_common_metadata_providers", "test_item.ItemTest.test_extra_fields.test_extra_fields", "test_item.ItemTest.test_set_self_href_does_not_break_asset_hrefs.test_set_self_href_does_not_break_asset_hrefs", "extensions.test_version.CollectionVersionExtensionTest.test_validate_all.test_validate_all", "extensions.test_label.LabelTypeTest.test_to_str.test_to_str", "test_collection.CollectionTest.test_schema_summary.test_schema_summary", "test_catalog.CatalogTest.test_collections_cache_correctly.test_collections_cache_correctly", "extensions.test_scientific.CollectionScientificExtensionTest.test_remove_publication_one.test_remove_publication_one", "test_layout.LayoutTemplateTest.test_substitute_with_colon_properties.test_substitute_with_colon_properties", "test_item.CommonMetadataTest.test_common_metadata_created.test_common_metadata_created", "test_catalog.CatalogTest.test_generate_subcatalogs_works_after_adding_more_items.test_generate_subcatalogs_works_after_adding_more_items", "test_item.ItemTest.test_asset_absolute_href.test_asset_absolute_href", "test_catalog.FullCopyTest.test_full_copy_1.test_full_copy_1", "extensions.test_file.FileTest.test_migrates_old_checksum.test_migrates_old_checksum", "test_collection.ExtentTest.test_from_items.test_from_items", "test_utils.UtilsTest.test_make_absolute_href_on_vsitar.test_make_absolute_href_on_vsitar", "test_catalog.CatalogTypeTest.test_determine_type_for_self_contained.test_determine_type_for_self_contained", "test_layout.TemplateLayoutStrategyTest.test_produces_layout_for_catalog_with_filename.test_produces_layout_for_catalog_with_filename", "test_layout.TemplateLayoutStrategyTest.test_produces_layout_for_collection_with_filename.test_produces_layout_for_collection_with_filename", "extensions.test_version.ItemVersionExtensionTest.test_stac_extensions.test_stac_extensions", "test_layout.LayoutTemplateTest.test_throws_for_no_collection.test_throws_for_no_collection", "test_item.CommonMetadataTest.test_asset_platform.test_asset_platform", "test_layout.LayoutTemplateTest.test_templates_item_collection.test_templates_item_collection", "test_item.CommonMetadataTest.test_asset_mission.test_asset_mission", "test_link.LinkTest.test_relative.test_relative", "test_catalog.CatalogTypeTest.test_determine_type_for_relative_published.test_determine_type_for_relative_published", "extensions.test_eo.EOTest.test_reads_asset_bands_in_pre_1_0_version.test_reads_asset_bands_in_pre_1_0_version", "test_utils.UtilsTest.test_make_absolute_href_windows.test_make_absolute_href_windows", "test_catalog.CatalogTest.test_generate_subcatalogs_does_not_change_item_count.test_generate_subcatalogs_does_not_change_item_count", "test_layout.TemplateLayoutStrategyTest.test_produces_layout_for_catalog.test_produces_layout_for_catalog", "extensions.test_eo.BandsTest.test_create.test_create", "extensions.test_version.CollectionVersionExtensionTest.test_setting_none_clears_link.test_setting_none_clears_link", "test_item.ItemTest.test_clone_sets_asset_owner.test_clone_sets_asset_owner", "test_item_collection.TestItemCollection.test_identify_0_8_itemcollection_type.test_identify_0_8_itemcollection_type", "extensions.test_scientific.CollectionScientificExtensionTest.test_remove_publication_reverse.test_remove_publication_reverse", "serialization.test_identify.VersionTest.test_version_ordering.test_version_ordering", "test_item.CommonMetadataTest.test_asset_instruments.test_asset_instruments", "extensions.test_view.ViewSummariestest.test_set_sun_elevation_summaries.test_set_sun_elevation_summaries", "extensions.test_scientific.TestRemoveLinks.test_remove_none_doi.test_remove_none_doi", "serialization.test_identify.IdentifyTest.test_identify_non_stac_type.test_identify_non_stac_type", "test_catalog.CatalogTest.test_map_items_multiple.test_map_items_multiple", "test_catalog.CatalogTest.test_full_copy_and_normalize_works_with_created_stac.test_full_copy_and_normalize_works_with_created_stac", "test_item.ItemTest.test_to_from_dict.test_to_from_dict", "test_catalog.CatalogTest.test_save_uses_previous_catalog_type.test_save_uses_previous_catalog_type", "extensions.test_custom.CustomExtensionTest.test_migrates.test_migrates", "extensions.test_version.CollectionVersionExtensionTest.test_multiple_link_setting.test_multiple_link_setting", "extensions.test_scientific.CollectionScientificExtensionTest.test_publications_one.test_publications_one", "test_catalog.CatalogTest.test_make_all_asset_hrefs_relative.test_make_all_asset_hrefs_relative", "test_version.VersionTest.test_override_stac_version_with_environ.test_override_stac_version_with_environ", "test_layout.CustomLayoutStrategyTest.test_produces_fallback_layout_for_item.test_produces_fallback_layout_for_item", "test_catalog.CatalogTest.test_clone_uses_previous_catalog_type.test_clone_uses_previous_catalog_type", "test_collection.ExtentTest.test_spatial_allows_single_bbox.test_spatial_allows_single_bbox", "extensions.test_sar.SarItemExtTest.test_stac_extensions.test_stac_extensions", "test_item.ItemTest.test_read_eo_item_owns_asset.test_read_eo_item_owns_asset", "extensions.test_version.CollectionVersionExtensionTest.test_successor.test_successor", "test_cache.ResolvedObjectCollectionCacheTest.test_cache.test_cache", "extensions.test_scientific.CollectionScientificExtensionTest.test_stac_extensions.test_stac_extensions", "test_catalog.CatalogTest.test_generate_subcatalogs_can_be_applied_multiple_times.test_generate_subcatalogs_can_be_applied_multiple_times", "extensions.test_label.LabelTest.test_get_sources.test_get_sources", "test_link.LinkTest.test_minimal.test_minimal", "test_catalog.CatalogTest.test_resolve_planet.test_resolve_planet", "test_summaries.SummariesTest.test_summary.test_summary", "extensions.test_scientific.TestPublication.test_get_link_returns_none_if_no_doi.test_get_link_returns_none_if_no_doi", "test_link.StaticLinkTest.test_canonical_collection.test_canonical_collection", "test_summaries.SummariesTest.test_cannot_open_fields_file.test_cannot_open_fields_file", "test_version.VersionTest.test_override_stac_version_with_call.test_override_stac_version_with_call", "extensions.test_version.CollectionVersionExtensionTest.test_add_version.test_add_version", "test_item.CommonMetadataTest.test_asset_providers.test_asset_providers", "test_utils.UtilsTest.test_datetime_to_str.test_datetime_to_str", "extensions.test_version.CollectionVersionExtensionTest.test_stac_extensions.test_stac_extensions", "extensions.test_label.LabelTest.test_read_label_item_owns_asset.test_read_label_item_owns_asset", "test_item_collection.TestItemCollection.test_item_collection_contains.test_item_collection_contains", "extensions.test_version.CollectionVersionExtensionTest.test_add_not_deprecated_version.test_add_not_deprecated_version", "extensions.test_pointcloud.PointcloudTest.test_pointcloud_statistics.test_pointcloud_statistics", "test_collection.CollectionTest.test_collection_with_href_caches_by_href.test_collection_with_href_caches_by_href", "serialization.test_identify.IdentifyTest.test_identify_invalid_with_stac_version.test_identify_invalid_with_stac_version", "test_utils.UtilsTest.test_make_relative_href_url.test_make_relative_href_url", "extensions.test_version.CollectionVersionExtensionTest.test_fail_validate.test_fail_validate", "test_catalog.CatalogTest.test_clear_items_removes_from_cache.test_clear_items_removes_from_cache", "test_summaries.SummariesTest.test_summary_not_empty.test_summary_not_empty", "test_layout.BestPracticesLayoutStrategyTest.test_produces_layout_for_child_catalog.test_produces_layout_for_child_catalog", "extensions.test_view.ViewSummariestest.test_get_sun_azimuth_summaries.test_get_sun_azimuth_summaries", "test_catalog.CatalogTest.test_normalize_href_works_with_label_source_links.test_normalize_href_works_with_label_source_links", "test_collection.CollectionTest.test_supplying_href_in_init_does_not_fail.test_supplying_href_in_init_does_not_fail", "extensions.test_pointcloud.PointcloudTest.test_apply.test_apply", "extensions.test_eo.EOTest.test_extend_invalid_object.test_extend_invalid_object", "extensions.test_view.ViewSummariestest.test_get_sun_elevation_summaries.test_get_sun_elevation_summaries", "test_layout.BestPracticesLayoutStrategyTest.test_produces_layout_for_root_catalog.test_produces_layout_for_root_catalog", "test_layout.CustomLayoutStrategyTest.test_produces_layout_for_collection.test_produces_layout_for_collection", "test_catalog.CatalogTypeTest.test_determine_type_for_unknown.test_determine_type_for_unknown", "test_catalog.FullCopyTest.test_full_copy_4.test_full_copy_4", "test_collection.CollectionTest.test_clone_uses_previous_catalog_type.test_clone_uses_previous_catalog_type", "extensions.test_scientific.CollectionScientificExtensionTest.test_citation.test_citation", "test_catalog.CatalogTest.test_add_child_throws_if_item.test_add_child_throws_if_item", "test_collection.CollectionTest.test_multiple_extents.test_multiple_extents", "extensions.test_sar.SarItemExtTest.test_polarization_must_be_list.test_polarization_must_be_list", "test_utils.UtilsTest.test_make_relative_href.test_make_relative_href", "extensions.test_label.LabelTest.test_merge_label_overviews_error.test_merge_label_overviews_error", "extensions.test_view.ViewTest.test_to_from_dict.test_to_from_dict", "extensions.test_pointcloud.PointcloudTest.test_statistics.test_statistics", "test_layout.CustomLayoutStrategyTest.test_produces_layout_for_catalog.test_produces_layout_for_catalog", "test_catalog.CatalogTest.test_normalize_hrefs_makes_absolute_href.test_normalize_hrefs_makes_absolute_href", "extensions.test_version.ItemVersionExtensionTest.test_setting_none_clears_link.test_setting_none_clears_link", "test_link.StaticLinkTest.test_child.test_child", "test_item.CommonMetadataTest.test_asset_created.test_asset_created", "extensions.test_scientific.CollectionScientificExtensionTest.test_publications.test_publications", "extensions.test_pointcloud.PointcloudTest.test_ext.test_ext", "extensions.test_pointcloud.PointcloudTest.test_pointcloud_schema.test_pointcloud_schema", "serialization.test_identify.VersionTest.test_version_range_ordering.test_version_range_ordering", "test_item_collection.TestItemCollection.test_item_collection_length.test_item_collection_length", "extensions.test_eo.EOTest.test_reads_gsd_in_pre_1_0_version.test_reads_gsd_in_pre_1_0_version", "test_item.CommonMetadataTest.test_asset_updated.test_asset_updated", "test_summaries.SummariesTest.test_summary_wrong_custom_fields_file.test_summary_wrong_custom_fields_file", "extensions.test_scientific.SummariesScientificTest.test_get_citation_summaries.test_get_citation_summaries", "test_layout.LayoutTemplateTest.test_templates_item_datetime.test_templates_item_datetime", "extensions.test_pointcloud.PointcloudTest.test_statistics_accessor_when_no_stats.test_statistics_accessor_when_no_stats", "test_item.ItemTest.test_datetime_ISO8601_format.test_datetime_ISO8601_format", "test_item_collection.TestItemCollection.test_item_collection_iter.test_item_collection_iter", "extensions.test_file.FileTest.test_item_asset_apply.test_item_asset_apply", "test_layout.CustomLayoutStrategyTest.test_produces_layout_for_item.test_produces_layout_for_item", "extensions.test_file.MappingObjectTest.test_create.test_create", "test_layout.TemplateLayoutStrategyTest.test_produces_layout_for_collection.test_produces_layout_for_collection", "test_catalog.CatalogTest.test_make_all_links_relative_or_absolute.test_make_all_links_relative_or_absolute", "extensions.test_pointcloud.PointcloudTest.test_to_from_dict.test_to_from_dict", "serialization.test_migrate.MigrateTest.test_migrate.test_migrate", "extensions.test_version.CollectionVersionExtensionTest.test_latest.test_latest", "extensions.test_view.ViewTest.test_apply.test_apply", "test_collection.CollectionTest.test_update_extents.test_update_extents", "extensions.test_label.LabelRelTypeTest.test_rel_types.test_rel_types", "test_layout.CustomLayoutStrategyTest.test_produces_fallback_layout_for_catalog.test_produces_fallback_layout_for_catalog", "test_catalog.CatalogTest.test_sets_catalog_type.test_sets_catalog_type", "test_item.CommonMetadataTest.test_asset_end_datetime.test_asset_end_datetime", "extensions.test_file.ByteOrderTest.test_to_str.test_to_str", "test_catalog.CatalogTest.test_catalog_with_href_caches_by_href.test_catalog_with_href_caches_by_href", "test_item.CommonMetadataTest.test_common_metadata_end_datetime.test_common_metadata_end_datetime", "test_item.ItemTest.test_get_set_asset_datetime.test_get_set_asset_datetime", "extensions.test_eo.EOTest.test_item_apply.test_item_apply", "extensions.test_timestamps.TimestampsTest.test_to_from_dict.test_to_from_dict", "test_item.CommonMetadataTest.test_asset_gsd.test_asset_gsd", "extensions.test_file.MappingObjectTest.test_set_properties.test_set_properties", "test_catalog.CatalogTest.test_add_item_throws_if_child.test_add_item_throws_if_child", "test_catalog.CatalogTest.test_handles_children_with_same_id.test_handles_children_with_same_id", "test_catalog.CatalogTest.test_walk_iterates_correctly.test_walk_iterates_correctly", "test_item.ItemTest.test_0_9_item_with_no_extensions_does_not_read_collection_data.test_0_9_item_with_no_extensions_does_not_read_collection_data", "extensions.test_scientific.ItemScientificExtensionTest.test_stac_extensions.test_stac_extensions", "extensions.test_view.ViewSummariestest.test_set_sun_azimuth_summaries.test_set_sun_azimuth_summaries", "extensions.test_file.FileTest.test_item_asset_values.test_item_asset_values", "test_layout.TemplateLayoutStrategyTest.test_produces_layout_for_item_without_filename.test_produces_layout_for_item_without_filename", "test_layout.BestPracticesLayoutStrategyTest.test_produces_layout_for_child_collection.test_produces_layout_for_child_collection", "extensions.test_scientific.SummariesScientificTest.test_set_doi_summaries.test_set_doi_summaries", "test_item_collection.TestItemCollection.test_add_item_collections.test_add_item_collections", "test_catalog.CatalogTest.test_extra_fields.test_extra_fields", "test_catalog.CatalogTest.test_clone_generates_correct_links.test_clone_generates_correct_links", "test_collection.CollectionTest.test_save_uses_previous_catalog_type.test_save_uses_previous_catalog_type", "test_link.LinkTest.test_link_does_not_fail_if_href_is_none.test_link_does_not_fail_if_href_is_none", "test_collection.CollectionTest.test_spatial_extent_from_coordinates.test_spatial_extent_from_coordinates", "serialization.test_identify.IdentifyTest.test_identify_non_stac_raises_error.test_identify_non_stac_raises_error", "extensions.test_pointcloud.PointcloudTest.test_asset_extension.test_asset_extension", "test_item_collection.TestItemCollection.test_item_collection_to_dict.test_item_collection_to_dict", "test_link.StaticLinkTest.test_canonical_item.test_canonical_item", "test_item.ItemTest.test_clearing_collection.test_clearing_collection", "test_link.StaticLinkTest.test_collection.test_collection", "test_stac_io.StacIOTest.test_stac_io_issues_warnings.test_stac_io_issues_warnings", "extensions.test_scientific.CollectionScientificExtensionTest.test_remove_all_publications_with_none.test_remove_all_publications_with_none", "extensions.test_sat.SatTest.test_to_from_dict.test_to_from_dict", "test_catalog.CatalogTest.test_generate_subcatalogs_works_for_branched_subcatalogs.test_generate_subcatalogs_works_for_branched_subcatalogs", "test_catalog.CatalogTest.test_clear_children_removes_from_cache.test_clear_children_removes_from_cache", "test_utils.UtilsTest.test_make_absolute_href.test_make_absolute_href", "test_collection.CollectionTest.test_read_eo_items_are_heritable.test_read_eo_items_are_heritable", "extensions.test_timestamps.TimestampsTest.test_apply.test_apply", "test_item_collection.TestItemCollection.test_from_list_of_dicts.test_from_list_of_dicts", "extensions.test_projection.ProjectionSummariesTest.test_set_summaries.test_set_summaries", "test_layout.LayoutTemplateTest.test_nested_properties.test_nested_properties", "test_item.CommonMetadataTest.test_asset_constellation.test_asset_constellation", "extensions.test_version.CollectionVersionExtensionTest.test_version_deprecated.test_version_deprecated", "test_layout.BestPracticesLayoutStrategyTest.test_produces_layout_for_root_collection.test_produces_layout_for_root_collection", "test_cache.ResolvedObjectCollectionCacheTest.test_merge.test_merge", "test_catalog.CatalogTest.test_map_assets_tup.test_map_assets_tup", "test_layout.TemplateLayoutStrategyTest.test_produces_fallback_layout_for_collection.test_produces_fallback_layout_for_collection", "extensions.test_version.CollectionVersionExtensionTest.test_add_deprecated_version.test_add_deprecated_version", "extensions.test_scientific.SummariesScientificTest.test_get_doi_summaries.test_get_doi_summaries", "extensions.test_sat.SatTest.test_from_dict.test_from_dict", "test_catalog.CatalogTest.test_generate_subcatalogs_works_with_custom_properties.test_generate_subcatalogs_works_with_custom_properties", "extensions.test_scientific.CollectionScientificExtensionTest.test_remove_all_publications_with_some.test_remove_all_publications_with_some", "validation.test_schema_uri_map.SchemaUriMapTest.test_gets_schema_uri_for_old_version.test_gets_schema_uri_for_old_version", "extensions.test_scientific.CollectionScientificExtensionTest.test_remove_publication_forward.test_remove_publication_forward", "test_catalog.CatalogTest.test_set_hrefs_manually.test_set_hrefs_manually", "test_catalog.CatalogTypeTest.test_determine_type_for_absolute_published.test_determine_type_for_absolute_published", "test_catalog.CatalogTest.test_map_items_multiple_2.test_map_items_multiple_2", "extensions.test_version.CollectionVersionExtensionTest.test_predecessor.test_predecessor", "extensions.test_eo.EOTest.test_to_from_dict.test_to_from_dict", "serialization.test_migrate.MigrateTest.test_migrates_pre_1_0_0_rc1_stats_summary.test_migrates_pre_1_0_0_rc1_stats_summary"], "language": "python", "test_command": "source /saved/ENV || source /saved/*/ENV && /opt/hostedtoolcache/Python/3.13.7/x64/bin/python3 /app/repo/unittest_loader_no_traceback.py ./tests ;", "test_output_parser": "python/parse_log_unittest", "image_storage_uri": "vmvm-registry.fbinfra.net/repomate_image_activ_python_unittest/stac-utils_pystac:7f8e7aaf29c9882e717550b219228ccf27add74b", "patch": "[\"diff --git a/.coveragerc b/.coveragerc\\nindex 3ca2751a9..9dfac6599 100644\\n--- a/.coveragerc\\n+++ b/.coveragerc\\n@@ -1,5 +1,5 @@\\n [report]\\n-fail_under = 90\\n+fail_under = 91\\n \\n [run]\\n source = pystac\\n\",\"diff --git a/CHANGELOG.md b/CHANGELOG.md\\nindex 1e423a8b7..86bb0ed87 100644\\n--- a/CHANGELOG.md\\n+++ b/CHANGELOG.md\\n@@ -12,6 +12,8 @@\\n   STAC Items ([#430](https://github.com/stac-utils/pystac/pull/430))\\n - Support for Python 3.9 ([#420](https://github.com/stac-utils/pystac/pull/420))\\n - Migration for pre-1.0.0-rc.1 Stats Objects (renamed to Range Objects in 1.0.0-rc.3) ([#447](https://github.com/stac-utils/pystac/pull/447))\\n+- Attempting to extend a `STACObject` that does not contain the extension's schema URI in\\n+  `stac_extensions` raises new `ExtensionNotImplementedError` ([#450](https://github.com/stac-utils/pystac/pull/450))\\n \\n ### Changed\\n \\n@@ -20,6 +22,9 @@\\n   `StacIO.read_text` ([#433](https://github.com/stac-utils/pystac/pull/433))\\n - `FileExtension` updated to work with File Info Extension v2.0.0 ([#442](https://github.com/stac-utils/pystac/pull/442))\\n - `FileExtension` only operates on `pystac.Asset` instances ([#442](https://github.com/stac-utils/pystac/pull/442))\\n+- `*Extension.ext` methods now have an optional `add_if_missing` argument, which will\\n+  add the extension schema URI to the object's `stac_extensions` list if it is not\\n+  present ([#450](https://github.com/stac-utils/pystac/pull/450))\\n \\n ### Fixed\\n \\n@@ -377,4 +382,3 @@ Initial release.\\n [v0.3.2]: <https://github.com/stac-utils/pystac/compare/v0.3.1..v0.3.2>\\n [v0.3.1]: <https://github.com/stac-utils/pystac/compare/v0.3.0..v0.3.1>\\n [v0.3.0]: <https://github.com/stac-utils/pystac/tree/v0.3.0>\\n-\\n\",\"diff --git a/docs/api.rst b/docs/api.rst\\nindex 08ef5fe11..91469842b 100644\\n--- a/docs/api.rst\\n+++ b/docs/api.rst\\n@@ -414,6 +414,43 @@ AssetProjectionExtension\\n    :members:\\n    :show-inheritance:\\n \\n+Raster Extension\\n+----------------\\n+\\n+DataType\\n+~~~~~~~~\\n+\\n+.. autoclass:: pystac.extensions.raster.DataType\\n+   :members:\\n+   :undoc-members:\\n+   :show-inheritance:\\n+\\n+Statistics\\n+~~~~~~~~~~\\n+\\n+.. autoclass:: pystac.extensions.raster.Statistics\\n+   :members:\\n+\\n+Histogram\\n+~~~~~~~~~\\n+\\n+.. autoclass:: pystac.extensions.raster.Histogram\\n+   :members:\\n+\\n+RasterBand\\n+~~~~~~~~~~\\n+\\n+.. autoclass:: pystac.extensions.raster.RasterBand\\n+   :members:\\n+\\n+RasterExtension\\n+~~~~~~~~~~~~~~~\\n+\\n+.. autoclass:: pystac.extensions.raster.RasterExtension\\n+   :members:\\n+   :show-inheritance:\\n+   :inherited-members:\\n+\\n Scientific Extension\\n --------------------\\n \\n\",\"diff --git a/docs/contributing.rst b/docs/contributing.rst\\nindex 66335b810..aa1cba281 100644\\n--- a/docs/contributing.rst\\n+++ b/docs/contributing.rst\\n@@ -62,7 +62,7 @@ example, to format all the Python code, run ``pre-commit run --all-files black``\\n \\n You can also install a Git pre-commit hook which will run the relevant linters and\\n formatters on any staged code when committing. This will be much faster than running on\\n-all files, which is usually[#]_ only required when changing the pre-commit version or\\n+all files, which is usually [#]_ only required when changing the pre-commit version or\\n configuration. Once installed you can bypass this check by adding the ``--no-verify``\\n flag to Git commit commands, as in ``git commit --no-verify``.\\n \\n\",\"diff --git a/pystac/__init__.py b/pystac/__init__.py\\nindex 19732af9b..749fcfb63 100644\\n--- a/pystac/__init__.py\\n+++ b/pystac/__init__.py\\n@@ -7,6 +7,7 @@\\n     STACError,\\n     STACTypeError,\\n     ExtensionAlreadyExistsError,\\n+    ExtensionNotImplemented,\\n     ExtensionTypeError,\\n     RequiredPropertyMissing,\\n     STACValidationError,\\n\",\"diff --git a/pystac/errors.py b/pystac/errors.py\\nindex 488ae781b..a5eae5df4 100644\\n--- a/pystac/errors.py\\n+++ b/pystac/errors.py\\n@@ -35,6 +35,11 @@ class ExtensionAlreadyExistsError(Exception):\\n     pass\\n \\n \\n+class ExtensionNotImplemented(Exception):\\n+    \\\"\\\"\\\"Attempted to extend a STAC object that does not implement the given\\n+    extension.\\\"\\\"\\\"\\n+\\n+\\n class RequiredPropertyMissing(Exception):\\n     \\\"\\\"\\\"This error is raised when a required value was expected\\n     to be there but was missing or None. This will happen, for example,\\n\",\"diff --git a/pystac/extensions/base.py b/pystac/extensions/base.py\\nindex 8f496dcf0..d33707ffa 100644\\n--- a/pystac/extensions/base.py\\n+++ b/pystac/extensions/base.py\\n@@ -1,7 +1,7 @@\\n from abc import ABC, abstractmethod\\n from typing import Generic, Iterable, List, Optional, Dict, Any, Type, TypeVar, Union\\n \\n-from pystac import Collection, RangeSummary, STACObject, Summaries\\n+import pystac\\n \\n \\n class SummariesExtension:\\n@@ -12,16 +12,16 @@ class SummariesExtension:\\n     extension-specific class that inherits from this class and instantiate that. See\\n     :class:`~pystac.extensions.eo.SummariesEOExtension` for an example.\\\"\\\"\\\"\\n \\n-    summaries: Summaries\\n+    summaries: pystac.Summaries\\n     \\\"\\\"\\\"The summaries for the :class:`~pystac.Collection` being extended.\\\"\\\"\\\"\\n \\n-    def __init__(self, collection: Collection) -> None:\\n+    def __init__(self, collection: pystac.Collection) -> None:\\n         self.summaries = collection.summaries\\n \\n     def _set_summary(\\n         self,\\n         prop_key: str,\\n-        v: Optional[Union[List[Any], RangeSummary[Any], Dict[str, Any]]],\\n+        v: Optional[Union[List[Any], pystac.RangeSummary[Any], Dict[str, Any]]],\\n     ) -> None:\\n         if v is None:\\n             self.summaries.remove(prop_key)\\n@@ -77,7 +77,7 @@ def _set_property(\\n             self.properties[prop_name] = v\\n \\n \\n-S = TypeVar(\\\"S\\\", bound=STACObject)\\n+S = TypeVar(\\\"S\\\", bound=pystac.STACObject)\\n \\n \\n class ExtensionManagementMixin(Generic[S], ABC):\\n@@ -124,3 +124,17 @@ def has_extension(cls, obj: S) -> bool:\\n             obj.stac_extensions is not None\\n             and cls.get_schema_uri() in obj.stac_extensions\\n         )\\n+\\n+    @classmethod\\n+    def validate_has_extension(cls, obj: Union[S, pystac.Asset]) -> None:\\n+        \\\"\\\"\\\"Given a :class:`~pystac.STACObject` or :class:`pystac.Asset` instance, checks\\n+        if the object (or its owner in the case of an Asset) has this extension's schema\\n+        URI in it's :attr:`~pystac.STACObject.stac_extensions` list.\\\"\\\"\\\"\\n+        extensible = obj.owner if isinstance(obj, pystac.Asset) else obj\\n+        if (\\n+            extensible is not None\\n+            and cls.get_schema_uri() not in extensible.stac_extensions\\n+        ):\\n+            raise pystac.ExtensionNotImplemented(\\n+                f\\\"Could not find extension schema URI {cls.get_schema_uri()} in object.\\\"\\n+            )\\n\",\"diff --git a/pystac/extensions/datacube.py b/pystac/extensions/datacube.py\\nindex 414400cf9..e43b8de4c 100644\\n--- a/pystac/extensions/datacube.py\\n+++ b/pystac/extensions/datacube.py\\n@@ -337,13 +337,22 @@ def dimensions(self, v: Dict[str, Dimension]) -> None:\\n     def get_schema_uri(cls) -> str:\\n         return SCHEMA_URI\\n \\n-    @staticmethod\\n-    def ext(obj: T) -> \\\"DatacubeExtension[T]\\\":\\n+    @classmethod\\n+    def ext(cls, obj: T, add_if_missing: bool = False) -> \\\"DatacubeExtension[T]\\\":\\n         if isinstance(obj, pystac.Collection):\\n+            if add_if_missing:\\n+                cls.add_to(obj)\\n+            cls.validate_has_extension(obj)\\n             return cast(DatacubeExtension[T], CollectionDatacubeExtension(obj))\\n         if isinstance(obj, pystac.Item):\\n+            if add_if_missing:\\n+                cls.add_to(obj)\\n+            cls.validate_has_extension(obj)\\n             return cast(DatacubeExtension[T], ItemDatacubeExtension(obj))\\n         elif isinstance(obj, pystac.Asset):\\n+            if add_if_missing and obj.owner is not None:\\n+                cls.add_to(obj.owner)\\n+            cls.validate_has_extension(obj)\\n             return cast(DatacubeExtension[T], AssetDatacubeExtension(obj))\\n         else:\\n             raise pystac.ExtensionTypeError(\\n\",\"diff --git a/pystac/extensions/eo.py b/pystac/extensions/eo.py\\nindex d266296b1..576d1c6ba 100644\\n--- a/pystac/extensions/eo.py\\n+++ b/pystac/extensions/eo.py\\n@@ -346,8 +346,8 @@ def cloud_cover(self, v: Optional[float]) -> None:\\n     def get_schema_uri(cls) -> str:\\n         return SCHEMA_URI\\n \\n-    @staticmethod\\n-    def ext(obj: T) -> \\\"EOExtension[T]\\\":\\n+    @classmethod\\n+    def ext(cls, obj: T, add_if_missing: bool = False) -> \\\"EOExtension[T]\\\":\\n         \\\"\\\"\\\"Extends the given STAC Object with properties from the :stac-ext:`Electro-Optical\\n         Extension <eo>`.\\n \\n@@ -359,8 +359,14 @@ def ext(obj: T) -> \\\"EOExtension[T]\\\":\\n             pystac.ExtensionTypeError : If an invalid object type is passed.\\n         \\\"\\\"\\\"\\n         if isinstance(obj, pystac.Item):\\n+            if add_if_missing:\\n+                cls.add_to(obj)\\n+            cls.validate_has_extension(obj)\\n             return cast(EOExtension[T], ItemEOExtension(obj))\\n         elif isinstance(obj, pystac.Asset):\\n+            if add_if_missing and isinstance(obj.owner, pystac.Item):\\n+                cls.add_to(obj.owner)\\n+            cls.validate_has_extension(obj)\\n             return cast(EOExtension[T], AssetEOExtension(obj))\\n         else:\\n             raise pystac.ExtensionTypeError(\\n\",\"diff --git a/pystac/extensions/file.py b/pystac/extensions/file.py\\nindex ebee4f475..deb1df4b0 100644\\n--- a/pystac/extensions/file.py\\n+++ b/pystac/extensions/file.py\\n@@ -193,13 +193,21 @@ def get_schema_uri(cls) -> str:\\n         return SCHEMA_URI\\n \\n     @classmethod\\n-    def ext(cls, obj: pystac.Asset) -> \\\"FileExtension\\\":\\n+    def ext(cls, obj: pystac.Asset, add_if_missing: bool = False) -> \\\"FileExtension\\\":\\n         \\\"\\\"\\\"Extends the given STAC Object with properties from the :stac-ext:`File Info\\n         Extension <file>`.\\n \\n         This extension can be applied to instances of :class:`~pystac.Asset`.\\n         \\\"\\\"\\\"\\n-        return cls(obj)\\n+        if isinstance(obj, pystac.Asset):\\n+            if add_if_missing and isinstance(obj.owner, pystac.Item):\\n+                cls.add_to(obj.owner)\\n+            cls.validate_has_extension(obj)\\n+            return cls(obj)\\n+        else:\\n+            raise pystac.ExtensionTypeError(\\n+                f\\\"File Info extension does not apply to type {type(obj)}\\\"\\n+            )\\n \\n \\n class FileExtensionHooks(ExtensionHooks):\\n\",\"diff --git a/pystac/extensions/item_assets.py b/pystac/extensions/item_assets.py\\nindex 5b362017d..f85451c0f 100644\\n--- a/pystac/extensions/item_assets.py\\n+++ b/pystac/extensions/item_assets.py\\n@@ -117,8 +117,17 @@ def get_schema_uri(cls) -> str:\\n         return SCHEMA_URI\\n \\n     @classmethod\\n-    def ext(cls, collection: pystac.Collection) -> \\\"ItemAssetsExtension\\\":\\n-        return cls(collection)\\n+    def ext(\\n+        cls, obj: pystac.Collection, add_if_missing: bool = False\\n+    ) -> \\\"ItemAssetsExtension\\\":\\n+        if isinstance(obj, pystac.Collection):\\n+            if add_if_missing:\\n+                cls.add_to(obj)\\n+            return cls(obj)\\n+        else:\\n+            raise pystac.ExtensionTypeError(\\n+                f\\\"Item Assets extension does not apply to type {type(obj)}\\\"\\n+            )\\n \\n \\n class ItemAssetsExtensionHooks(ExtensionHooks):\\n\",\"diff --git a/pystac/extensions/label.py b/pystac/extensions/label.py\\nindex 9e3f98431..745d991d7 100644\\n--- a/pystac/extensions/label.py\\n+++ b/pystac/extensions/label.py\\n@@ -639,13 +639,21 @@ def get_schema_uri(cls) -> str:\\n         return SCHEMA_URI\\n \\n     @classmethod\\n-    def ext(cls, obj: pystac.Item) -> \\\"LabelExtension\\\":\\n+    def ext(cls, obj: pystac.Item, add_if_missing: bool = False) -> \\\"LabelExtension\\\":\\n         \\\"\\\"\\\"Extends the given STAC Object with properties from the :stac-ext:`Label\\n         Extension <label>`.\\n \\n         This extension can be applied to instances of :class:`~pystac.Item`.\\n         \\\"\\\"\\\"\\n-        return cls(obj)\\n+        if isinstance(obj, pystac.Item):\\n+            if add_if_missing:\\n+                cls.add_to(obj)\\n+            cls.validate_has_extension(obj)\\n+            return cls(obj)\\n+        else:\\n+            raise pystac.ExtensionTypeError(\\n+                f\\\"Label extension does not apply to type {type(obj)}\\\"\\n+            )\\n \\n \\n class LabelExtensionHooks(ExtensionHooks):\\n\",\"diff --git a/pystac/extensions/pointcloud.py b/pystac/extensions/pointcloud.py\\nindex c3cf863a4..804fed2c2 100644\\n--- a/pystac/extensions/pointcloud.py\\n+++ b/pystac/extensions/pointcloud.py\\n@@ -522,15 +522,21 @@ def statistics(self, v: Optional[List[PointcloudStatistic]]) -> None:\\n     def get_schema_uri(cls) -> str:\\n         return SCHEMA_URI\\n \\n-    @staticmethod\\n-    def ext(obj: T) -> \\\"PointcloudExtension[T]\\\":\\n+    @classmethod\\n+    def ext(cls, obj: T, add_if_missing: bool = False) -> \\\"PointcloudExtension[T]\\\":\\n         if isinstance(obj, pystac.Item):\\n+            if add_if_missing:\\n+                cls.add_to(obj)\\n+            cls.validate_has_extension(obj)\\n             return cast(PointcloudExtension[T], ItemPointcloudExtension(obj))\\n         elif isinstance(obj, pystac.Asset):\\n+            if add_if_missing and isinstance(obj.owner, pystac.Item):\\n+                cls.add_to(obj.owner)\\n+            cls.validate_has_extension(obj)\\n             return cast(PointcloudExtension[T], AssetPointcloudExtension(obj))\\n         else:\\n             raise pystac.ExtensionTypeError(\\n-                f\\\"File extension does not apply to type {type(obj)}\\\"\\n+                f\\\"Pointcloud extension does not apply to type {type(obj)}\\\"\\n             )\\n \\n \\n\",\"diff --git a/pystac/extensions/projection.py b/pystac/extensions/projection.py\\nindex efa121b06..1c68c9fa0 100644\\n--- a/pystac/extensions/projection.py\\n+++ b/pystac/extensions/projection.py\\n@@ -237,8 +237,8 @@ def transform(self, v: Optional[List[float]]) -> None:\\n     def get_schema_uri(cls) -> str:\\n         return SCHEMA_URI\\n \\n-    @staticmethod\\n-    def ext(obj: T) -> \\\"ProjectionExtension[T]\\\":\\n+    @classmethod\\n+    def ext(cls, obj: T, add_if_missing: bool = False) -> \\\"ProjectionExtension[T]\\\":\\n         \\\"\\\"\\\"Extends the given STAC Object with properties from the :stac-ext:`Projection\\n         Extension <projection>`.\\n \\n@@ -250,12 +250,18 @@ def ext(obj: T) -> \\\"ProjectionExtension[T]\\\":\\n             pystac.ExtensionTypeError : If an invalid object type is passed.\\n         \\\"\\\"\\\"\\n         if isinstance(obj, pystac.Item):\\n+            if add_if_missing:\\n+                cls.add_to(obj)\\n+            cls.validate_has_extension(obj)\\n             return cast(ProjectionExtension[T], ItemProjectionExtension(obj))\\n         elif isinstance(obj, pystac.Asset):\\n+            if add_if_missing and isinstance(obj.owner, pystac.Item):\\n+                cls.add_to(obj.owner)\\n+            cls.validate_has_extension(obj)\\n             return cast(ProjectionExtension[T], AssetProjectionExtension(obj))\\n         else:\\n             raise pystac.ExtensionTypeError(\\n-                f\\\"File extension does not apply to type {type(obj)}\\\"\\n+                f\\\"Projection extension does not apply to type {type(obj)}\\\"\\n             )\\n \\n     @staticmethod\\n\",\"diff --git a/pystac/extensions/raster.py b/pystac/extensions/raster.py\\nindex 031940055..551474b17 100644\\n--- a/pystac/extensions/raster.py\\n+++ b/pystac/extensions/raster.py\\n@@ -4,7 +4,7 @@\\n \\\"\\\"\\\"\\n \\n import enum\\n-from typing import Any, Dict, Generic, Iterable, List, Optional, TypeVar, cast\\n+from typing import Any, Dict, Iterable, List, Optional\\n \\n import pystac\\n from pystac.extensions.base import (\\n@@ -14,8 +14,6 @@\\n )\\n from pystac.utils import get_opt, get_required, map_opt\\n \\n-T = TypeVar(\\\"T\\\", pystac.Item, pystac.Asset)\\n-\\n SCHEMA_URI = \\\"https://stac-extensions.github.io/raster/v1.0.0/schema.json\\\"\\n \\n BANDS_PROP = \\\"raster:bands\\\"\\n@@ -625,9 +623,7 @@ def to_dict(self) -> Dict[str, Any]:\\n         return self.properties\\n \\n \\n-class RasterExtension(\\n-    Generic[T], PropertiesExtension, ExtensionManagementMixin[pystac.Item]\\n-):\\n+class RasterExtension(PropertiesExtension, ExtensionManagementMixin[pystac.Item]):\\n     \\\"\\\"\\\"An abstract class that can be used to extend the properties of an\\n     :class:`~pystac.Item` or :class:`~pystac.Asset` with properties from\\n     the :stac-ext:`Raster Extension <raster>`. This class is generic over\\n@@ -639,6 +635,25 @@ class RasterExtension(\\n     :class:`~ItemRasterExtension` to extend an :class:`~pystac.Item`).\\n     \\\"\\\"\\\"\\n \\n+    asset_href: str\\n+    \\\"\\\"\\\"The ``href`` value of the :class:`~pystac.Asset` being extended.\\\"\\\"\\\"\\n+\\n+    properties: Dict[str, Any]\\n+    \\\"\\\"\\\"The :class:`~pystac.Asset` fields, including extension properties.\\\"\\\"\\\"\\n+\\n+    additional_read_properties: Optional[Iterable[Dict[str, Any]]] = None\\n+    \\\"\\\"\\\"If present, this will be a list containing 1 dictionary representing the\\n+    properties of the owning :class:`~pystac.Item`.\\\"\\\"\\\"\\n+\\n+    def __init__(self, asset: pystac.Asset):\\n+        self.asset_href = asset.href\\n+        self.properties = asset.properties\\n+        if asset.owner and isinstance(asset.owner, pystac.Item):\\n+            self.additional_read_properties = [asset.owner.properties]\\n+\\n+    def __repr__(self) -> str:\\n+        return \\\"<AssetRasterExtension Asset href={}>\\\".format(self.asset_href)\\n+\\n     def apply(self, bands: List[RasterBand]) -> None:\\n         \\\"\\\"\\\"Applies raster extension properties to the extended :class:`pystac.Item` or\\n         :class:`pystac.Asset`.\\n@@ -673,10 +688,22 @@ def _get_bands(self) -> Optional[List[RasterBand]]:\\n     def get_schema_uri(cls) -> str:\\n         return SCHEMA_URI\\n \\n-    @staticmethod\\n-    def ext(obj: T) -> \\\"RasterExtension[T]\\\":\\n+    @classmethod\\n+    def ext(cls, obj: pystac.Asset, add_if_missing: bool = False) -> \\\"RasterExtension\\\":\\n+        \\\"\\\"\\\"Extends the given STAC Object with properties from the :stac-ext:`Raster\\n+        Extension <raster>`.\\n+\\n+        This extension can be applied to instances of :class:`~pystac.Asset`.\\n+\\n+        Raises:\\n+\\n+            pystac.ExtensionTypeError : If an invalid object type is passed.\\n+        \\\"\\\"\\\"\\n         if isinstance(obj, pystac.Asset):\\n-            return cast(RasterExtension[T], AssetRasterExtension(obj))\\n+            if add_if_missing and isinstance(obj.owner, pystac.Item):\\n+                cls.add_to(obj.owner)\\n+            cls.validate_has_extension(obj)\\n+            return cls(obj)\\n         else:\\n             raise pystac.ExtensionTypeError(\\n                 f\\\"Raster extension does not apply to type {type(obj)}\\\"\\n@@ -687,35 +714,6 @@ def summaries(obj: pystac.Collection) -> \\\"SummariesRasterExtension\\\":\\n         return SummariesRasterExtension(obj)\\n \\n \\n-class AssetRasterExtension(RasterExtension[pystac.Asset]):\\n-    \\\"\\\"\\\"A concrete implementation of :class:`RasterExtension` on an :class:`~pystac.Asset`\\n-    that extends the Asset fields to include properties defined in the\\n-    :stac-ext:`Raster Extension <raster>`.\\n-\\n-    This class should generally not be instantiated directly. Instead, call\\n-    :meth:`RasterExtension.ext` on an :class:`~pystac.Asset` to extend it.\\n-    \\\"\\\"\\\"\\n-\\n-    asset_href: str\\n-    \\\"\\\"\\\"The ``href`` value of the :class:`~pystac.Asset` being extended.\\\"\\\"\\\"\\n-\\n-    properties: Dict[str, Any]\\n-    \\\"\\\"\\\"The :class:`~pystac.Asset` fields, including extension properties.\\\"\\\"\\\"\\n-\\n-    additional_read_properties: Optional[Iterable[Dict[str, Any]]] = None\\n-    \\\"\\\"\\\"If present, this will be a list containing 1 dictionary representing the\\n-    properties of the owning :class:`~pystac.Item`.\\\"\\\"\\\"\\n-\\n-    def __init__(self, asset: pystac.Asset):\\n-        self.asset_href = asset.href\\n-        self.properties = asset.properties\\n-        if asset.owner and isinstance(asset.owner, pystac.Item):\\n-            self.additional_read_properties = [asset.owner.properties]\\n-\\n-    def __repr__(self) -> str:\\n-        return \\\"<AssetRasterExtension Asset href={}>\\\".format(self.asset_href)\\n-\\n-\\n class SummariesRasterExtension(SummariesExtension):\\n     \\\"\\\"\\\"A concrete implementation of :class:`~SummariesExtension` that extends\\n     the ``summaries`` field of a :class:`~pystac.Collection` to include properties\\n\",\"diff --git a/pystac/extensions/sar.py b/pystac/extensions/sar.py\\nindex 089a567dc..0f07213ea 100644\\n--- a/pystac/extensions/sar.py\\n+++ b/pystac/extensions/sar.py\\n@@ -304,15 +304,21 @@ def observation_direction(self, v: Optional[ObservationDirection]) -> None:\\n     def get_schema_uri(cls) -> str:\\n         return SCHEMA_URI\\n \\n-    @staticmethod\\n-    def ext(obj: T) -> \\\"SarExtension[T]\\\":\\n+    @classmethod\\n+    def ext(cls, obj: T, add_if_missing: bool = False) -> \\\"SarExtension[T]\\\":\\n         if isinstance(obj, pystac.Item):\\n+            if add_if_missing:\\n+                cls.add_to(obj)\\n+            cls.validate_has_extension(obj)\\n             return cast(SarExtension[T], ItemSarExtension(obj))\\n         elif isinstance(obj, pystac.Asset):\\n+            if add_if_missing and isinstance(obj.owner, pystac.Item):\\n+                cls.add_to(obj.owner)\\n+            cls.validate_has_extension(obj)\\n             return cast(SarExtension[T], AssetSarExtension(obj))\\n         else:\\n             raise pystac.ExtensionTypeError(\\n-                f\\\"File extension does not apply to type {type(obj)}\\\"\\n+                f\\\"SAR extension does not apply to type {type(obj)}\\\"\\n             )\\n \\n \\n\",\"diff --git a/pystac/extensions/sat.py b/pystac/extensions/sat.py\\nindex 2f583fdfe..a84cb0b14 100644\\n--- a/pystac/extensions/sat.py\\n+++ b/pystac/extensions/sat.py\\n@@ -95,11 +95,17 @@ def relative_orbit(self, v: Optional[int]) -> None:\\n     def get_schema_uri(cls) -> str:\\n         return SCHEMA_URI\\n \\n-    @staticmethod\\n-    def ext(obj: T) -> \\\"SatExtension[T]\\\":\\n+    @classmethod\\n+    def ext(cls, obj: T, add_if_missing: bool = False) -> \\\"SatExtension[T]\\\":\\n         if isinstance(obj, pystac.Item):\\n+            if add_if_missing:\\n+                cls.add_to(obj)\\n+            cls.validate_has_extension(obj)\\n             return cast(SatExtension[T], ItemSatExtension(obj))\\n         elif isinstance(obj, pystac.Asset):\\n+            if add_if_missing and isinstance(obj.owner, pystac.Item):\\n+                cls.add_to(obj.owner)\\n+            cls.validate_has_extension(obj)\\n             return cast(SatExtension[T], AssetSatExtension(obj))\\n         else:\\n             raise pystac.ExtensionTypeError(\\n\",\"diff --git a/pystac/extensions/scientific.py b/pystac/extensions/scientific.py\\nindex 80d8a4e8a..fff9f3ce1 100644\\n--- a/pystac/extensions/scientific.py\\n+++ b/pystac/extensions/scientific.py\\n@@ -224,8 +224,8 @@ def remove_publication(self, publication: Optional[Publication] = None) -> None:\\n     def get_schema_uri(cls) -> str:\\n         return SCHEMA_URI\\n \\n-    @staticmethod\\n-    def ext(obj: T) -> \\\"ScientificExtension[T]\\\":\\n+    @classmethod\\n+    def ext(cls, obj: T, add_if_missing: bool = False) -> \\\"ScientificExtension[T]\\\":\\n         \\\"\\\"\\\"Extends the given STAC Object with properties from the :stac-ext:`Scientific\\n         Extension <scientific>`.\\n \\n@@ -237,8 +237,14 @@ def ext(obj: T) -> \\\"ScientificExtension[T]\\\":\\n             pystac.ExtensionTypeError : If an invalid object type is passed.\\n         \\\"\\\"\\\"\\n         if isinstance(obj, pystac.Collection):\\n+            if add_if_missing:\\n+                cls.add_to(obj)\\n+            cls.validate_has_extension(obj)\\n             return cast(ScientificExtension[T], CollectionScientificExtension(obj))\\n         if isinstance(obj, pystac.Item):\\n+            if add_if_missing:\\n+                cls.add_to(obj)\\n+            cls.validate_has_extension(obj)\\n             return cast(ScientificExtension[T], ItemScientificExtension(obj))\\n         else:\\n             raise pystac.ExtensionTypeError(\\n\",\"diff --git a/pystac/extensions/timestamps.py b/pystac/extensions/timestamps.py\\nindex 211049900..f4de30851 100644\\n--- a/pystac/extensions/timestamps.py\\n+++ b/pystac/extensions/timestamps.py\\n@@ -116,11 +116,17 @@ def unpublished(self, v: Optional[Datetime]) -> None:\\n     def get_schema_uri(cls) -> str:\\n         return SCHEMA_URI\\n \\n-    @staticmethod\\n-    def ext(obj: T) -> \\\"TimestampsExtension[T]\\\":\\n+    @classmethod\\n+    def ext(cls, obj: T, add_if_missing: bool = False) -> \\\"TimestampsExtension[T]\\\":\\n         if isinstance(obj, pystac.Item):\\n+            if add_if_missing:\\n+                cls.add_to(obj)\\n+            cls.validate_has_extension(obj)\\n             return cast(TimestampsExtension[T], ItemTimestampsExtension(obj))\\n         elif isinstance(obj, pystac.Asset):\\n+            if add_if_missing and isinstance(obj.owner, pystac.Item):\\n+                cls.add_to(obj.owner)\\n+            cls.validate_has_extension(obj)\\n             return cast(TimestampsExtension[T], AssetTimestampsExtension(obj))\\n         else:\\n             raise pystac.ExtensionTypeError(\\n\",\"diff --git a/pystac/extensions/version.py b/pystac/extensions/version.py\\nindex 00436f6b8..ac01dbdc2 100644\\n--- a/pystac/extensions/version.py\\n+++ b/pystac/extensions/version.py\\n@@ -195,8 +195,8 @@ def successor(self, item_or_collection: Optional[T]) -> None:\\n     def get_schema_uri(cls) -> str:\\n         return SCHEMA_URI\\n \\n-    @staticmethod\\n-    def ext(obj: T) -> \\\"VersionExtension[T]\\\":\\n+    @classmethod\\n+    def ext(cls, obj: T, add_if_missing: bool = False) -> \\\"VersionExtension[T]\\\":\\n         \\\"\\\"\\\"Extends the given STAC Object with properties from the :stac-ext:`Versioning\\n         Indicators Extension <version>`.\\n \\n@@ -208,8 +208,14 @@ def ext(obj: T) -> \\\"VersionExtension[T]\\\":\\n             pystac.ExtensionTypeError : If an invalid object type is passed.\\n         \\\"\\\"\\\"\\n         if isinstance(obj, pystac.Collection):\\n+            if add_if_missing:\\n+                cls.add_to(obj)\\n+            cls.validate_has_extension(obj)\\n             return cast(VersionExtension[T], CollectionVersionExtension(obj))\\n         if isinstance(obj, pystac.Item):\\n+            if add_if_missing:\\n+                cls.add_to(obj)\\n+            cls.validate_has_extension(obj)\\n             return cast(VersionExtension[T], ItemVersionExtension(obj))\\n         else:\\n             raise pystac.ExtensionTypeError(\\n\",\"diff --git a/pystac/extensions/view.py b/pystac/extensions/view.py\\nindex 1fd0fa5b4..6438a2cb0 100644\\n--- a/pystac/extensions/view.py\\n+++ b/pystac/extensions/view.py\\n@@ -143,8 +143,8 @@ def sun_elevation(self, v: Optional[float]) -> None:\\n     def get_schema_uri(cls) -> str:\\n         return SCHEMA_URI\\n \\n-    @staticmethod\\n-    def ext(obj: T) -> \\\"ViewExtension[T]\\\":\\n+    @classmethod\\n+    def ext(cls, obj: T, add_if_missing: bool = False) -> \\\"ViewExtension[T]\\\":\\n         \\\"\\\"\\\"Extends the given STAC Object with properties from the :stac-ext:`View\\n         Geometry Extension <scientific>`.\\n \\n@@ -156,8 +156,14 @@ def ext(obj: T) -> \\\"ViewExtension[T]\\\":\\n             pystac.ExtensionTypeError : If an invalid object type is passed.\\n         \\\"\\\"\\\"\\n         if isinstance(obj, pystac.Item):\\n+            if add_if_missing:\\n+                cls.add_to(obj)\\n+            cls.validate_has_extension(obj)\\n             return cast(ViewExtension[T], ItemViewExtension(obj))\\n         elif isinstance(obj, pystac.Asset):\\n+            if add_if_missing and isinstance(obj.owner, pystac.Item):\\n+                cls.add_to(obj.owner)\\n+            cls.validate_has_extension(obj)\\n             return cast(ViewExtension[T], AssetViewExtension(obj))\\n         else:\\n             raise pystac.ExtensionTypeError(\\n\"]", "test_patch": "", "hints_text": ""}

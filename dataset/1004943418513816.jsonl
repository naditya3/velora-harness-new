{"instance_id": "1004943418513816", "repo": "unitaryfund/mitiq", "base_commit": "638e31bad37534075a6085222ffa1e880e118014", "problem_statement": "Create `group_by_strategy` function for Calibrator:\\nAfter running the calibration experiments and seeing the entire list of results, a user might want to know how each `Strategy` performed across all `BenchmarkProblems`\\r\\n\\r\\n```py\\r\\ncal = Calibrator(executor, frontend=\"...\")\\r\\ncal.run()\\r\\ncal.group_by_strategy()\\r\\n>>> new table with one line per strategy\\r\\n```\\r\\n\\r\\nFunction name subject to change.", "FAIL_TO_PASS": ["mitiq/calibration/tests/test_calibration.py::test_Calibrator_log_argument", "mitiq/calibration/tests/test_calibration.py::test_ExtrapolationResults_logging_results_flat", "mitiq/calibration/tests/test_calibration.py::test_ExtrapolationResults_performance_str", "mitiq/calibration/tests/test_calibration.py::test_ExtrapolationResults_logging_results_cartesian"], "PASS_TO_PASS": [], "language": "python", "test_command": "source /saved/ENV || source /saved/*/ENV && pytest --no-header -rA --tb=no -p no:cacheprovider --continue-on-collection-errors", "test_output_parser": "python/parse_log_pytest_v3", "image_storage_uri": "vmvm-registry.fbinfra.net/repomate_image_activ_pytest/unitaryfund_mitiq:638e31bad37534075a6085222ffa1e880e118014", "patch": "[\"diff --git a/mitiq/calibration/calibrator.py b/mitiq/calibration/calibrator.py\\nindex 902807cd6..d707b9cec 100644\\n--- a/mitiq/calibration/calibrator.py\\n+++ b/mitiq/calibration/calibrator.py\\n@@ -4,20 +4,8 @@\\n # LICENSE file in the root directory of this source tree.\\n \\n import warnings\\n-from itertools import product\\n-from typing import (\\n-    Any,\\n-    Callable,\\n-    Dict,\\n-    Iterator,\\n-    List,\\n-    Optional,\\n-    Sequence,\\n-    Set,\\n-    Tuple,\\n-    Union,\\n-    cast,\\n-)\\n+from operator import itemgetter\\n+from typing import Callable, Dict, List, Optional, Sequence, Tuple, Union, cast\\n \\n import cirq\\n import numpy as np\\n@@ -33,7 +21,6 @@\\n )\\n from mitiq.calibration.settings import (\\n     BenchmarkProblem,\\n-    MitigationTechnique,\\n     Settings,\\n     Strategy,\\n     ZNESettings,\\n@@ -96,95 +83,96 @@ def _get_performance(\\n         performance_symbol = \\\"✔\\\" if mitigation_worked else \\\"✘\\\"\\n         return performance_symbol, noisy_error, mitigated_error\\n \\n-    def unique_techniques(self) -> Set[MitigationTechnique]:\\n-        \\\"\\\"\\\"Returns the unique mitigation techniques used across this\\n-        collection of experiment results.\\\"\\\"\\\"\\n-        return set(strategy.technique for strategy in self.strategies)\\n-\\n-    def _technique_results(\\n-        self, technique: MitigationTechnique\\n-    ) -> Iterator[Tuple[BenchmarkProblem, Strategy, str, float, float]]:\\n-        \\\"\\\"\\\"Yields the results from this collection of experiment results,\\n-        limited to a specific technique.\\\"\\\"\\\"\\n-        for strategy, problem in product(self.strategies, self.problems):\\n-            if strategy.technique is technique:\\n-                performance_symbol, nerr, merr = self._get_performance(\\n+    def log_results(self) -> None:\\n+        \\\"\\\"\\\"Prints calibration results in the following form\\n+        ┌────────────────────────────────────────────┬────────────────────────────────┬─────────────────────────┐\\n+        │ benchmark                                  │ strategy                       │ performance             │\\n+        ├────────────────────────────────────────────┼────────────────────────────────┼─────────────────────────┤\\n+        │ Type: rb                                   │ Technique: ZNE                 │ ✔                       │\\n+        │ Ideal distribution: {'00': 1.0}            │ Factory: RichardsonFactory     │ Noisy error: 0.1053     │\\n+        │ Num qubits: 2                              │ Scale factors: [1.0, 2.0, 3.0] │ Mitigated error: 0.0146 │\\n+        │ Circuit depth: 326                         │ Scale method: fold_global      │                         │\\n+        │ Two qubit gate count: 79                   │                                │                         │\\n+        ├────────────────────────────────────────────┼────────────────────────────────┼─────────────────────────┤\\n+        │ Type: rb                                   │ Technique: ZNE                 │ ✔                       │\\n+        │ Ideal distribution: {'00': 1.0}            │ Factory: RichardsonFactory     │ Noisy error: 0.1053     │\\n+        │ Num qubits: 2                              │ Scale factors: [1.0, 3.0, 5.0] │ Mitigated error: 0.0422 │\\n+        │ Circuit depth: 326                         │ Scale method: fold_global      │                         │\\n+        │ Two qubit gate count: 79                   │                                │                         │\\n+        ├────────────────────────────────────────────┼────────────────────────────────┼─────────────────────────┤\\n+        │ Type: ghz                                  │ Technique: ZNE                 │ ✔                       │\\n+        │ Ideal distribution: {'00': 0.5, '11': 0.5} │ Factory: RichardsonFactory     │ Noisy error: 0.0157     │\\n+        │ Num qubits: 2                              │ Scale factors: [1.0, 2.0, 3.0] │ Mitigated error: 0.0018 │\\n+        │ Circuit depth: 2                           │ Scale method: fold_global      │                         │\\n+        │ Two qubit gate count: 1                    │                                │                         │\\n+        ├────────────────────────────────────────────┼────────────────────────────────┼─────────────────────────┤\\n+        │ Type: ghz                                  │ Technique: ZNE                 │ ✔                       │\\n+        │ Ideal distribution: {'00': 0.5, '11': 0.5} │ Factory: RichardsonFactory     │ Noisy error: 0.0157     │\\n+        │ Num qubits: 2                              │ Scale factors: [1.0, 3.0, 5.0] │ Mitigated error: 0.0091 │\\n+        │ Circuit depth: 2                           │ Scale method: fold_global      │                         │\\n+        │ Two qubit gate count: 1                    │                                │                         │\\n+        └────────────────────────────────────────────┴────────────────────────────────┴─────────────────────────┘\\n+        \\\"\\\"\\\"  # noqa: E501\\n+        table: List[List[str | float]] = []\\n+        headers: List[str] = [\\\"benchmark\\\", \\\"strategy\\\", \\\"performance\\\"]\\n+        for problem in self.problems:\\n+            row_group: List[List[str | float]] = []\\n+            for strategy in self.strategies:\\n+                perf, nerr, merr = self._get_performance(\\n                     strategy.id, problem.id\\n                 )\\n-                yield problem, strategy, performance_symbol, nerr, merr\\n-\\n-    def log_technique(self, technique: MitigationTechnique) -> str:\\n-        \\\"\\\"\\\"Creates a table displaying all results of a given mitigation\\n-        technique.\\\"\\\"\\\"\\n-        table: List[List[Union[str, float]]] = []\\n-        for (\\n-            problem,\\n-            strategy,\\n-            performance_symbol,\\n-            noisy_error,\\n-            mitigated_error,\\n-        ) in self._technique_results(technique):\\n-            row: List[Union[str, float]] = [\\n-                performance_symbol,\\n-                problem.type,\\n-                technique.name,\\n-            ]\\n-            summary_dict = strategy.to_pretty_dict()\\n-            if strategy.technique is MitigationTechnique.ZNE:\\n-                row.extend(\\n+                row_group.append(\\n                     [\\n-                        summary_dict[\\\"factory\\\"],\\n-                        summary_dict[\\\"scale_factors\\\"],\\n-                        summary_dict[\\\"scale_method\\\"],\\n+                        str(problem),\\n+                        str(strategy),\\n+                        f\\\"{perf}\\\\nNoisy error: {round(nerr, 4)}\\\\n\\\"\\n+                        f\\\"Mitigated error: {round(merr, 4)}\\\",\\n+                        # this is only for sorting\\n+                        # removed after sorting\\n+                        merr - nerr,\\n                     ]\\n                 )\\n-            elif strategy.technique is MitigationTechnique.PEC:\\n-                row.extend(\\n-                    [\\n-                        summary_dict[\\\"noise_level\\\"],\\n-                        summary_dict[\\\"noise_bias\\\"],\\n-                        summary_dict[\\\"representation_function\\\"],\\n-                    ]\\n+            row_group.sort(key=itemgetter(-1))\\n+            table.extend([r[:-1] for r in row_group])\\n+        return print(tabulate(table, headers, tablefmt=\\\"simple_grid\\\"))\\n+\\n+    def log_results_cartesian(self) -> None:\\n+        \\\"\\\"\\\"Prints calibration results in the following form\\n+        ┌────────────────────────────────┬───────────────────────────────────┬──────────────────────────────────────────────┐\\n+        │ strategy\\\\benchmark             │ Type: rb                          │ Type: ghz                                    │\\n+        │                                │ Ideal distribution: {'00': 1.0}   │ Ideal distribution: {'00': 0.5, '11': 0.5}   │\\n+        │                                │ Num qubits: 2                     │ Num qubits: 2                                │\\n+        │                                │ Circuit depth: 326                │ Circuit depth: 2                             │\\n+        │                                │ Two qubit gate count: 79          │ Two qubit gate count: 1                      │\\n+        │                                │                                   │                                              │\\n+        ├────────────────────────────────┼───────────────────────────────────┼──────────────────────────────────────────────┤\\n+        │ Technique: ZNE                 │ ✔                                 │ ✔                                            │\\n+        │ Factory: RichardsonFactory     │ Noisy error: 0.1053               │ Noisy error: 0.0157                          │\\n+        │ Scale factors: [1.0, 2.0, 3.0] │ Mitigated error: 0.0146           │ Mitigated error: 0.0018                      │\\n+        │ Scale method: fold_global      │                                   │                                              │\\n+        ├────────────────────────────────┼───────────────────────────────────┼──────────────────────────────────────────────┤\\n+        │ Technique: ZNE                 │ ✔                                 │ ✔                                            │\\n+        │ Factory: RichardsonFactory     │ Noisy error: 0.1053               │ Noisy error: 0.0157                          │\\n+        │ Scale factors: [1.0, 3.0, 5.0] │ Mitigated error: 0.0422           │ Mitigated error: 0.0091                      │\\n+        │ Scale method: fold_global      │                                   │                                              │\\n+        └────────────────────────────────┴───────────────────────────────────┴──────────────────────────────────────────────┘\\n+        \\\"\\\"\\\"  # noqa: E501\\n+        table: List[List[str]] = []\\n+        headers: List[str] = [\\\"strategy\\\\\\\\benchmark\\\"]\\n+        for problem in self.problems:\\n+            headers.append(str(problem))\\n+        for strategy in self.strategies:\\n+            row: List[str] = [str(strategy)]\\n+            for problem in self.problems:\\n+                perf, nerr, merr = self._get_performance(\\n+                    strategy.id, problem.id\\n+                )\\n+                row.append(\\n+                    f\\\"{perf}\\\\nNoisy error: {round(nerr, 4)}\\\\n\\\"\\n+                    f\\\"Mitigated error: {round(merr, 4)}\\\",\\n                 )\\n-            row.extend([noisy_error, mitigated_error])\\n             table.append(row)\\n-\\n-        def _sort_best_perf(row: List[Any]) -> float:\\n-            return row[-1] - row[-2]\\n-\\n-        table.sort(key=_sort_best_perf)\\n-\\n-        if technique is MitigationTechnique.ZNE:\\n-            headers = [\\n-                \\\"performance\\\",\\n-                \\\"circuit type\\\",\\n-                \\\"method\\\",\\n-                \\\"extrapolation\\\",\\n-                \\\"scale_factors\\\",\\n-                \\\"scale method\\\",\\n-            ]\\n-        elif technique is MitigationTechnique.PEC:\\n-            headers = [\\n-                \\\"performance\\\",\\n-                \\\"circuit type\\\",\\n-                \\\"method\\\",\\n-                \\\"noise level\\\",\\n-                \\\"noise bias\\\",\\n-                \\\"noise representation\\\",\\n-            ]\\n-\\n-        headers.extend([\\\"noisy error\\\", \\\"mitigated error\\\"])\\n-\\n-        return tabulate(table, headers, tablefmt=\\\"simple_grid\\\")\\n-\\n-    def log_results(self) -> None:\\n-        \\\"\\\"\\\"Log results from entire calibration run. Logging is performed on\\n-        each mitigation technique individually to avoid confusion when many\\n-        techniques are used.\\\"\\\"\\\"\\n-        for mitigation_technique in self.unique_techniques():\\n-            print(f\\\"{mitigation_technique.name} results:\\\")\\n-            print(self.log_technique(mitigation_technique))\\n-            print()\\n+        return print(tabulate(table, headers, tablefmt=\\\"simple_grid\\\"))\\n \\n     def is_missing_data(self) -> bool:\\n         \\\"\\\"\\\"Method to check if there is any missing data that was expected from\\n@@ -308,7 +296,7 @@ def get_cost(self) -> Dict[str, int]:\\n             \\\"ideal_executions\\\": ideal,\\n         }\\n \\n-    def run(self, log: bool = False) -> None:\\n+    def run(self, log: bool = False, log_cartesian: bool = False) -> None:\\n         \\\"\\\"\\\"Runs all the circuits required for calibration.\\\"\\\"\\\"\\n         if not self.results.is_missing_data():\\n             self.results.reset_data()\\n@@ -342,6 +330,9 @@ def run(self, log: bool = False) -> None:\\n         if log:\\n             self.results.log_results()\\n \\n+        if log_cartesian:\\n+            self.results.log_results_cartesian()\\n+\\n     def best_strategy(self) -> Strategy:\\n         \\\"\\\"\\\"Finds the best strategy by using the parameters that had the\\n         smallest error.\\n\",\"diff --git a/mitiq/calibration/settings.py b/mitiq/calibration/settings.py\\nindex 3d3a4b574..dd27a7ba1 100644\\n--- a/mitiq/calibration/settings.py\\n+++ b/mitiq/calibration/settings.py\\n@@ -126,6 +126,13 @@ def to_dict(self) -> Dict[str, Any]:\\n     def __repr__(self) -> str:\\n         return str(self.to_dict())\\n \\n+    def __str__(self) -> str:\\n+        result: str = \\\"\\\"\\n+        for key, value in self.to_dict().items():\\n+            title: str = key.replace(\\\"_\\\", \\\" \\\").capitalize()\\n+            result += f\\\"{title}: {value}\\\\n\\\"\\n+        return result.rstrip()\\n+\\n \\n @dataclass\\n class Strategy:\\n@@ -239,6 +246,13 @@ def to_pretty_dict(self) -> Dict[str, str]:\\n     def __repr__(self) -> str:\\n         return str(self.to_dict())\\n \\n+    def __str__(self) -> str:\\n+        result: str = \\\"\\\"\\n+        for key, value in self.to_pretty_dict().items():\\n+            title: str = key.replace(\\\"_\\\", \\\" \\\").capitalize()\\n+            result += f\\\"{title}: {value}\\\\n\\\"\\n+        return result.rstrip()\\n+\\n     def num_circuits_required(self) -> int:\\n         summary = self.to_dict()\\n         if self.technique is MitigationTechnique.ZNE:\\n\",\"diff --git a/dev_requirements.txt b/dev_requirements.txt\\nindex 1cd0b4523..9bbb1161d 100644\\n--- a/dev_requirements.txt\\n+++ b/dev_requirements.txt\\n@@ -16,6 +16,7 @@ black==22.10\\n mypy==1.0.0\\n isort==5.12.0\\n types-tabulate\\n+mock==5.1.0\\n \\n # Documentation and examples.\\n Sphinx==5.2.3\\n\",\"diff --git a/mitiq/calibration/calibrator.py b/mitiq/calibration/calibrator.py\\nindex d707b9cec..d54968292 100644\\n--- a/mitiq/calibration/calibrator.py\\n+++ b/mitiq/calibration/calibrator.py\\n@@ -4,6 +4,7 @@\\n # LICENSE file in the root directory of this source tree.\\n \\n import warnings\\n+from enum import StrEnum, auto\\n from operator import itemgetter\\n from typing import Callable, Dict, List, Optional, Sequence, Tuple, Union, cast\\n \\n@@ -32,6 +33,11 @@ class MissingResultsError(Exception):\\n     pass\\n \\n \\n+class OutputForm(StrEnum):\\n+    flat = auto()\\n+    cartesian = auto()\\n+\\n+\\n class ExperimentResults:\\n     \\\"\\\"\\\"Class to store calibration experiment data, and provide helper methods\\n     for computing results based on it.\\\"\\\"\\\"\\n@@ -60,73 +66,70 @@ def add_result(\\n         self.noisy[strategy.id, problem.id] = noisy_val\\n         self.ideal[strategy.id, problem.id] = ideal_val\\n \\n-    def _get_performance(\\n+    @staticmethod\\n+    def _performance_str(noisy_error: float, mitigated_error: float):\\n+        \\\"\\\"\\\"Get human readable performance representaion.\\\"\\\"\\\"\\n+        return (\\n+            f\\\"{'✔' if mitigated_error < noisy_error else '✘'}\\\\n\\\"\\n+            f\\\"Noisy error: {round(noisy_error, 4)}\\\\n\\\"\\n+            f\\\"Mitigated error: {round(mitigated_error, 4)}\\\\n\\\"\\n+            f\\\"Improvement factor: {round(noisy_error / mitigated_error, 4)}\\\"\\n+        )\\n+\\n+    def _get_errors(\\n         self, strategy_id: int, problem_id: int\\n     ) -> Tuple[str, float, float]:\\n-        \\\"\\\"\\\"Get performance symbol and errors.\\n+        \\\"\\\"\\\"Get errors for a given strategy/problem combination.\\n \\n         Returns:\\n-            A performance tuple comprising:\\n-            - performance symbol either ✔ or ✘ depending\\n-              on whether mitigation technique works well or not.\\n-              It considered to work well if the mitigated error is less\\n-              than the noisy error.\\n-            - the absolute value of the noisy error\\n-            - the absolute value of the mitigated error\\n+            A tuple comprising:\\n+            - absolute value of the noisy error\\n+            - absolute value of the mitigated error\\n         \\\"\\\"\\\"\\n         mitigated = self.mitigated[strategy_id, problem_id]\\n         noisy = self.noisy[strategy_id, problem_id]\\n         ideal = self.ideal[strategy_id, problem_id]\\n         mitigated_error = abs(ideal - mitigated)\\n         noisy_error = abs(ideal - noisy)\\n-        mitigation_worked = mitigated_error < noisy_error\\n-        performance_symbol = \\\"✔\\\" if mitigation_worked else \\\"✘\\\"\\n-        return performance_symbol, noisy_error, mitigated_error\\n+        return noisy_error, mitigated_error\\n \\n-    def log_results(self) -> None:\\n+    def log_results_flat(self) -> None:\\n         \\\"\\\"\\\"Prints calibration results in the following form\\n-        ┌────────────────────────────────────────────┬────────────────────────────────┬─────────────────────────┐\\n-        │ benchmark                                  │ strategy                       │ performance             │\\n-        ├────────────────────────────────────────────┼────────────────────────────────┼─────────────────────────┤\\n-        │ Type: rb                                   │ Technique: ZNE                 │ ✔                       │\\n-        │ Ideal distribution: {'00': 1.0}            │ Factory: RichardsonFactory     │ Noisy error: 0.1053     │\\n-        │ Num qubits: 2                              │ Scale factors: [1.0, 2.0, 3.0] │ Mitigated error: 0.0146 │\\n-        │ Circuit depth: 326                         │ Scale method: fold_global      │                         │\\n-        │ Two qubit gate count: 79                   │                                │                         │\\n-        ├────────────────────────────────────────────┼────────────────────────────────┼─────────────────────────┤\\n-        │ Type: rb                                   │ Technique: ZNE                 │ ✔                       │\\n-        │ Ideal distribution: {'00': 1.0}            │ Factory: RichardsonFactory     │ Noisy error: 0.1053     │\\n-        │ Num qubits: 2                              │ Scale factors: [1.0, 3.0, 5.0] │ Mitigated error: 0.0422 │\\n-        │ Circuit depth: 326                         │ Scale method: fold_global      │                         │\\n-        │ Two qubit gate count: 79                   │                                │                         │\\n-        ├────────────────────────────────────────────┼────────────────────────────────┼─────────────────────────┤\\n-        │ Type: ghz                                  │ Technique: ZNE                 │ ✔                       │\\n-        │ Ideal distribution: {'00': 0.5, '11': 0.5} │ Factory: RichardsonFactory     │ Noisy error: 0.0157     │\\n-        │ Num qubits: 2                              │ Scale factors: [1.0, 2.0, 3.0] │ Mitigated error: 0.0018 │\\n-        │ Circuit depth: 2                           │ Scale method: fold_global      │                         │\\n-        │ Two qubit gate count: 1                    │                                │                         │\\n-        ├────────────────────────────────────────────┼────────────────────────────────┼─────────────────────────┤\\n-        │ Type: ghz                                  │ Technique: ZNE                 │ ✔                       │\\n-        │ Ideal distribution: {'00': 0.5, '11': 0.5} │ Factory: RichardsonFactory     │ Noisy error: 0.0157     │\\n-        │ Num qubits: 2                              │ Scale factors: [1.0, 3.0, 5.0] │ Mitigated error: 0.0091 │\\n-        │ Circuit depth: 2                           │ Scale method: fold_global      │                         │\\n-        │ Two qubit gate count: 1                    │                                │                         │\\n-        └────────────────────────────────────────────┴────────────────────────────────┴─────────────────────────┘\\n+        ┌──────────────────────────┬──────────────────────────────┬────────────────────────────┐\\n+        │ benchmark                │ strategy                     │ performance                │\\n+        ├──────────────────────────┼──────────────────────────────┼────────────────────────────┤\\n+        │ Type: rb                 │ Technique: ZNE               │ ✔                          │\\n+        │ Num qubits: 2            │ Factory: Richardson          │ Noisy error: 0.101         │\\n+        │ Circuit depth: 323       │ Scale factors: 1.0, 3.0, 5.0 │ Mitigated error: 0.0294    │\\n+        │ Two qubit gate count: 77 │ Scale method: fold_global    │ Improvement factor: 3.4398 │\\n+        ├──────────────────────────┼──────────────────────────────┼────────────────────────────┤\\n+        │ Type: rb                 │ Technique: ZNE               │ ✔                          │\\n+        │ Num qubits: 2            │ Factory: Richardson          │ Noisy error: 0.101         │\\n+        │ Circuit depth: 323       │ Scale factors: 1.0, 2.0, 3.0 │ Mitigated error: 0.0501    │\\n+        │ Two qubit gate count: 77 │ Scale method: fold_global    │ Improvement factor: 2.016  │\\n+        ├──────────────────────────┼──────────────────────────────┼────────────────────────────┤\\n+        │ Type: ghz                │ Technique: ZNE               │ ✔                          │\\n+        │ Num qubits: 2            │ Factory: Richardson          │ Noisy error: 0.0128        │\\n+        │ Circuit depth: 2         │ Scale factors: 1.0, 2.0, 3.0 │ Mitigated error: 0.0082    │\\n+        │ Two qubit gate count: 1  │ Scale method: fold_global    │ Improvement factor: 1.561  │\\n+        ├──────────────────────────┼──────────────────────────────┼────────────────────────────┤\\n+        │ Type: ghz                │ Technique: ZNE               │ ✘                          │\\n+        │ Num qubits: 2            │ Factory: Richardson          │ Noisy error: 0.0128        │\\n+        │ Circuit depth: 2         │ Scale factors: 1.0, 3.0, 5.0 │ Mitigated error: 0.0137    │\\n+        │ Two qubit gate count: 1  │ Scale method: fold_global    │ Improvement factor: 0.9369 │\\n+        └──────────────────────────┴──────────────────────────────┴────────────────────────────┘\\n         \\\"\\\"\\\"  # noqa: E501\\n         table: List[List[str | float]] = []\\n         headers: List[str] = [\\\"benchmark\\\", \\\"strategy\\\", \\\"performance\\\"]\\n         for problem in self.problems:\\n             row_group: List[List[str | float]] = []\\n             for strategy in self.strategies:\\n-                perf, nerr, merr = self._get_performance(\\n-                    strategy.id, problem.id\\n-                )\\n+                nerr, merr = self._get_errors(strategy.id, problem.id)\\n                 row_group.append(\\n                     [\\n                         str(problem),\\n                         str(strategy),\\n-                        f\\\"{perf}\\\\nNoisy error: {round(nerr, 4)}\\\\n\\\"\\n-                        f\\\"Mitigated error: {round(merr, 4)}\\\",\\n+                        self._performance_str(nerr, merr),\\n                         # this is only for sorting\\n                         # removed after sorting\\n                         merr - nerr,\\n@@ -138,24 +141,22 @@ def log_results(self) -> None:\\n \\n     def log_results_cartesian(self) -> None:\\n         \\\"\\\"\\\"Prints calibration results in the following form\\n-        ┌────────────────────────────────┬───────────────────────────────────┬──────────────────────────────────────────────┐\\n-        │ strategy\\\\benchmark             │ Type: rb                          │ Type: ghz                                    │\\n-        │                                │ Ideal distribution: {'00': 1.0}   │ Ideal distribution: {'00': 0.5, '11': 0.5}   │\\n-        │                                │ Num qubits: 2                     │ Num qubits: 2                                │\\n-        │                                │ Circuit depth: 326                │ Circuit depth: 2                             │\\n-        │                                │ Two qubit gate count: 79          │ Two qubit gate count: 1                      │\\n-        │                                │                                   │                                              │\\n-        ├────────────────────────────────┼───────────────────────────────────┼──────────────────────────────────────────────┤\\n-        │ Technique: ZNE                 │ ✔                                 │ ✔                                            │\\n-        │ Factory: RichardsonFactory     │ Noisy error: 0.1053               │ Noisy error: 0.0157                          │\\n-        │ Scale factors: [1.0, 2.0, 3.0] │ Mitigated error: 0.0146           │ Mitigated error: 0.0018                      │\\n-        │ Scale method: fold_global      │                                   │                                              │\\n-        ├────────────────────────────────┼───────────────────────────────────┼──────────────────────────────────────────────┤\\n-        │ Technique: ZNE                 │ ✔                                 │ ✔                                            │\\n-        │ Factory: RichardsonFactory     │ Noisy error: 0.1053               │ Noisy error: 0.0157                          │\\n-        │ Scale factors: [1.0, 3.0, 5.0] │ Mitigated error: 0.0422           │ Mitigated error: 0.0091                      │\\n-        │ Scale method: fold_global      │                                   │                                              │\\n-        └────────────────────────────────┴───────────────────────────────────┴──────────────────────────────────────────────┘\\n+        ┌──────────────────────────────┬────────────────────────────┬────────────────────────────┐\\n+        │ strategy\\\\benchmark           │ Type: rb                   │ Type: ghz                  │\\n+        │                              │ Num qubits: 2              │ Num qubits: 2              │\\n+        │                              │ Circuit depth: 337         │ Circuit depth: 2           │\\n+        │                              │ Two qubit gate count: 80   │ Two qubit gate count: 1    │\\n+        ├──────────────────────────────┼────────────────────────────┼────────────────────────────┤\\n+        │ Technique: ZNE               │ ✔                          │ ✘                          │\\n+        │ Factory: Richardson          │ Noisy error: 0.1128        │ Noisy error: 0.0117        │\\n+        │ Scale factors: 1.0, 2.0, 3.0 │ Mitigated error: 0.0501    │ Mitigated error: 0.0439    │\\n+        │ Scale method: fold_global    │ Improvement factor: 2.2515 │ Improvement factor: 0.2665 │\\n+        ├──────────────────────────────┼────────────────────────────┼────────────────────────────┤\\n+        │ Technique: ZNE               │ ✔                          │ ✘                          │\\n+        │ Factory: Richardson          │ Noisy error: 0.1128        │ Noisy error: 0.0117        │\\n+        │ Scale factors: 1.0, 3.0, 5.0 │ Mitigated error: 0.0408    │ Mitigated error: 0.0171    │\\n+        │ Scale method: fold_global    │ Improvement factor: 2.7672 │ Improvement factor: 0.6852 │\\n+        └──────────────────────────────┴────────────────────────────┴────────────────────────────┘\\n         \\\"\\\"\\\"  # noqa: E501\\n         table: List[List[str]] = []\\n         headers: List[str] = [\\\"strategy\\\\\\\\benchmark\\\"]\\n@@ -164,13 +165,8 @@ def log_results_cartesian(self) -> None:\\n         for strategy in self.strategies:\\n             row: List[str] = [str(strategy)]\\n             for problem in self.problems:\\n-                perf, nerr, merr = self._get_performance(\\n-                    strategy.id, problem.id\\n-                )\\n-                row.append(\\n-                    f\\\"{perf}\\\\nNoisy error: {round(nerr, 4)}\\\\n\\\"\\n-                    f\\\"Mitigated error: {round(merr, 4)}\\\",\\n-                )\\n+                nerr, merr = self._get_errors(strategy.id, problem.id)\\n+                row.append(self._performance_str(nerr, merr))\\n             table.append(row)\\n         return print(tabulate(table, headers, tablefmt=\\\"simple_grid\\\"))\\n \\n@@ -296,7 +292,7 @@ def get_cost(self) -> Dict[str, int]:\\n             \\\"ideal_executions\\\": ideal,\\n         }\\n \\n-    def run(self, log: bool = False, log_cartesian: bool = False) -> None:\\n+    def run(self, log: OutputForm = None) -> None:\\n         \\\"\\\"\\\"Runs all the circuits required for calibration.\\\"\\\"\\\"\\n         if not self.results.is_missing_data():\\n             self.results.reset_data()\\n@@ -327,11 +323,15 @@ def run(self, log: bool = False, log_cartesian: bool = False) -> None:\\n \\n         self.results.ensure_full()\\n \\n-        if log:\\n-            self.results.log_results()\\n-\\n-        if log_cartesian:\\n-            self.results.log_results_cartesian()\\n+        if log is not None:\\n+            if log == OutputForm.flat:\\n+                self.results.log_results_flat()\\n+            elif log == OutputForm.cartesian:\\n+                self.results.log_results_cartesian()\\n+            else:\\n+                raise ValueError(\\n+                    f\\\"log parameter must be one of: {', '.join(OutputForm._member_names_)}\\\"\\n+                )\\n \\n     def best_strategy(self) -> Strategy:\\n         \\\"\\\"\\\"Finds the best strategy by using the parameters that had the\\n\",\"diff --git a/mitiq/calibration/settings.py b/mitiq/calibration/settings.py\\nindex dd27a7ba1..bfea6d1d0 100644\\n--- a/mitiq/calibration/settings.py\\n+++ b/mitiq/calibration/settings.py\\n@@ -127,8 +127,10 @@ def __repr__(self) -> str:\\n         return str(self.to_dict())\\n \\n     def __str__(self) -> str:\\n-        result: str = \\\"\\\"\\n+        result = \\\"\\\"\\n         for key, value in self.to_dict().items():\\n+            if key == \\\"ideal_distribution\\\":\\n+                continue\\n             title: str = key.replace(\\\"_\\\", \\\" \\\").capitalize()\\n             result += f\\\"{title}: {value}\\\\n\\\"\\n         return result.rstrip()\\n@@ -247,7 +249,7 @@ def __repr__(self) -> str:\\n         return str(self.to_dict())\\n \\n     def __str__(self) -> str:\\n-        result: str = \\\"\\\"\\n+        result = \\\"\\\"\\n         for key, value in self.to_pretty_dict().items():\\n             title: str = key.replace(\\\"_\\\", \\\" \\\").capitalize()\\n             result += f\\\"{title}: {value}\\\\n\\\"\\n\",\"diff --git a/mitiq/calibration/calibrator.py b/mitiq/calibration/calibrator.py\\nindex d54968292..5301e331a 100644\\n--- a/mitiq/calibration/calibrator.py\\n+++ b/mitiq/calibration/calibrator.py\\n@@ -4,13 +4,14 @@\\n # LICENSE file in the root directory of this source tree.\\n \\n import warnings\\n-from enum import StrEnum, auto\\n+from enum import auto\\n from operator import itemgetter\\n from typing import Callable, Dict, List, Optional, Sequence, Tuple, Union, cast\\n \\n import cirq\\n import numpy as np\\n import numpy.typing as npt\\n+from strenum import StrEnum\\n from tabulate import tabulate\\n \\n from mitiq import (\\n\",\"diff --git a/requirements.txt b/requirements.txt\\nindex 66da07439..f7c903cfa 100644\\n--- a/requirements.txt\\n+++ b/requirements.txt\\n@@ -2,3 +2,4 @@ numpy>=1.22.0\\n scipy>=1.5.0,<=1.11.3\\n cirq>=1.0.0,<1.3.0\\n tabulate\\n+strenum\\n\",\"diff --git a/mitiq/calibration/calibrator.py b/mitiq/calibration/calibrator.py\\nindex 5301e331a..d60ba8ac8 100644\\n--- a/mitiq/calibration/calibrator.py\\n+++ b/mitiq/calibration/calibrator.py\\n@@ -68,7 +68,7 @@ def add_result(\\n         self.ideal[strategy.id, problem.id] = ideal_val\\n \\n     @staticmethod\\n-    def _performance_str(noisy_error: float, mitigated_error: float):\\n+    def _performance_str(noisy_error: float, mitigated_error: float) -> str:\\n         \\\"\\\"\\\"Get human readable performance representaion.\\\"\\\"\\\"\\n         return (\\n             f\\\"{'✔' if mitigated_error < noisy_error else '✘'}\\\\n\\\"\\n@@ -79,7 +79,7 @@ def _performance_str(noisy_error: float, mitigated_error: float):\\n \\n     def _get_errors(\\n         self, strategy_id: int, problem_id: int\\n-    ) -> Tuple[str, float, float]:\\n+    ) -> Tuple[float, float]:\\n         \\\"\\\"\\\"Get errors for a given strategy/problem combination.\\n \\n         Returns:\\n@@ -293,7 +293,7 @@ def get_cost(self) -> Dict[str, int]:\\n             \\\"ideal_executions\\\": ideal,\\n         }\\n \\n-    def run(self, log: OutputForm = None) -> None:\\n+    def run(self, log: Optional[OutputForm] = None) -> None:\\n         \\\"\\\"\\\"Runs all the circuits required for calibration.\\\"\\\"\\\"\\n         if not self.results.is_missing_data():\\n             self.results.reset_data()\\n@@ -331,7 +331,8 @@ def run(self, log: OutputForm = None) -> None:\\n                 self.results.log_results_cartesian()\\n             else:\\n                 raise ValueError(\\n-                    f\\\"log parameter must be one of: {', '.join(OutputForm._member_names_)}\\\"\\n+                    \\\"log parameter must be one of: \\\"\\n+                    f\\\"{', '.join(OutputForm._member_names_)}\\\"\\n                 )\\n \\n     def best_strategy(self) -> Strategy:\\n\",\"diff --git a/dev_requirements.txt b/dev_requirements.txt\\nindex 9bbb1161d..1cd0b4523 100644\\n--- a/dev_requirements.txt\\n+++ b/dev_requirements.txt\\n@@ -16,7 +16,6 @@ black==22.10\\n mypy==1.0.0\\n isort==5.12.0\\n types-tabulate\\n-mock==5.1.0\\n \\n # Documentation and examples.\\n Sphinx==5.2.3\\n\",\"diff --git a/mitiq/calibration/calibrator.py b/mitiq/calibration/calibrator.py\\nindex d60ba8ac8..25cad5549 100644\\n--- a/mitiq/calibration/calibrator.py\\n+++ b/mitiq/calibration/calibrator.py\\n@@ -4,14 +4,13 @@\\n # LICENSE file in the root directory of this source tree.\\n \\n import warnings\\n-from enum import auto\\n+from enum import auto, Enum\\n from operator import itemgetter\\n from typing import Callable, Dict, List, Optional, Sequence, Tuple, Union, cast\\n \\n import cirq\\n import numpy as np\\n import numpy.typing as npt\\n-from strenum import StrEnum\\n from tabulate import tabulate\\n \\n from mitiq import (\\n@@ -34,7 +33,7 @@ class MissingResultsError(Exception):\\n     pass\\n \\n \\n-class OutputForm(StrEnum):\\n+class OutputForm(str, Enum):\\n     flat = auto()\\n     cartesian = auto()\\n \\n@@ -120,10 +119,10 @@ def log_results_flat(self) -> None:\\n         │ Two qubit gate count: 1  │ Scale method: fold_global    │ Improvement factor: 0.9369 │\\n         └──────────────────────────┴──────────────────────────────┴────────────────────────────┘\\n         \\\"\\\"\\\"  # noqa: E501\\n-        table: List[List[str | float]] = []\\n+        table: List[List[Union[str, float]]] = []\\n         headers: List[str] = [\\\"benchmark\\\", \\\"strategy\\\", \\\"performance\\\"]\\n         for problem in self.problems:\\n-            row_group: List[List[str | float]] = []\\n+            row_group: List[List[Union[str, float]]] = []\\n             for strategy in self.strategies:\\n                 nerr, merr = self._get_errors(strategy.id, problem.id)\\n                 row_group.append(\\n\",\"diff --git a/requirements.txt b/requirements.txt\\nindex f7c903cfa..66da07439 100644\\n--- a/requirements.txt\\n+++ b/requirements.txt\\n@@ -2,4 +2,3 @@ numpy>=1.22.0\\n scipy>=1.5.0,<=1.11.3\\n cirq>=1.0.0,<1.3.0\\n tabulate\\n-strenum\\n\",\"diff --git a/mitiq/calibration/calibrator.py b/mitiq/calibration/calibrator.py\\nindex 25cad5549..6f829c273 100644\\n--- a/mitiq/calibration/calibrator.py\\n+++ b/mitiq/calibration/calibrator.py\\n@@ -4,7 +4,7 @@\\n # LICENSE file in the root directory of this source tree.\\n \\n import warnings\\n-from enum import auto, Enum\\n+from enum import Enum, auto\\n from operator import itemgetter\\n from typing import Callable, Dict, List, Optional, Sequence, Tuple, Union, cast\\n \\n\",\"diff --git a/mitiq/calibration/calibrator.py b/mitiq/calibration/calibrator.py\\nindex 6f829c273..987dd4b16 100644\\n--- a/mitiq/calibration/calibrator.py\\n+++ b/mitiq/calibration/calibrator.py\\n@@ -34,8 +34,8 @@ class MissingResultsError(Exception):\\n \\n \\n class OutputForm(str, Enum):\\n-    flat = auto()\\n-    cartesian = auto()\\n+    flat = \\\"flat\\\"\\n+    cartesian = \\\"cartesian\\\"\\n \\n \\n class ExperimentResults:\\n\",\"diff --git a/mitiq/calibration/calibrator.py b/mitiq/calibration/calibrator.py\\nindex 987dd4b16..10217972c 100644\\n--- a/mitiq/calibration/calibrator.py\\n+++ b/mitiq/calibration/calibrator.py\\n@@ -4,7 +4,7 @@\\n # LICENSE file in the root directory of this source tree.\\n \\n import warnings\\n-from enum import Enum, auto\\n+from enum import Enum\\n from operator import itemgetter\\n from typing import Callable, Dict, List, Optional, Sequence, Tuple, Union, cast\\n \\n\"]", "test_patch": "[\"diff --git a/mitiq/calibration/tests/test_calibration.py b/mitiq/calibration/tests/test_calibration.py\\nindex 3da0b8fc6..7391df23b 100644\\n--- a/mitiq/calibration/tests/test_calibration.py\\n+++ b/mitiq/calibration/tests/test_calibration.py\\n@@ -4,6 +4,7 @@\\n # LICENSE file in the root directory of this source tree.\\n \\n \\\"\\\"\\\"Tests for the Clifford data regression top-level API.\\\"\\\"\\\"\\n+import re\\n from functools import partial\\n \\n import cirq\\n@@ -379,11 +380,42 @@ def test_logging(capfd):\\n     )\\n     cal.run(log=True)\\n     captured = capfd.readouterr()\\n-    assert \\\"ZNE results:\\\" in captured.out\\n-    assert \\\"PEC results:\\\" in captured.out\\n-    assert settings.get_strategy(0).technique.name in captured.out\\n-    assert \\\"noisy error\\\" in captured.out\\n-    assert \\\"mitigated error\\\" in captured.out\\n+    for s in cal.strategies:\\n+        for line in str(s).split():\\n+            assert line in captured.out\\n+    for p in cal.problems:\\n+        for line in str(p).split():\\n+            assert line in captured.out\\n+    mcount = 0\\n+    ncount = 0\\n+    for line in captured.out.split(\\\"\\\\n\\\"):\\n+        if \\\"Mitigated error: \\\" in line:\\n+            mcount += 1\\n+        if \\\"Noisy error: \\\" in line:\\n+            ncount += 1\\n+    assert mcount == (len(cal.strategies) * len(cal.problems))\\n+    assert ncount == (len(cal.strategies) * len(cal.problems))\\n+\\n+\\n+def test_logging_cartesian(capfd):\\n+    cal = Calibrator(\\n+        damping_execute, frontend=\\\"cirq\\\", settings=light_combined_settings\\n+    )\\n+    cal.run(log_cartesian=True)\\n+    captured = capfd.readouterr()\\n+    for s in cal.strategies:\\n+        for line in str(s).split():\\n+            assert line in captured.out\\n+    for p in cal.problems:\\n+        for line in str(p).split():\\n+            assert line in captured.out\\n+    for line in captured.out.split(\\\"\\\\n\\\"):\\n+        if \\\"Mitigated error: \\\" in line:\\n+            assert len(re.findall(\\\"Mitigated error: \\\", line)) == len(\\n+                cal.problems\\n+            )\\n+        if \\\"Noisy error: \\\" in line:\\n+            assert len(re.findall(\\\"Noisy error: \\\", line)) == len(cal.problems)\\n \\n \\n def test_ExperimentResults_reset_data():\\n\",\"diff --git a/mitiq/calibration/tests/test_settings.py b/mitiq/calibration/tests/test_settings.py\\nindex 68622c65e..d28c01428 100644\\n--- a/mitiq/calibration/tests/test_settings.py\\n+++ b/mitiq/calibration/tests/test_settings.py\\n@@ -122,13 +122,73 @@ def test_basic_settings():\\n     assert ghz_problem.two_qubit_gate_count == 1\\n     assert ghz_problem.ideal_distribution == {\\\"00\\\": 0.5, \\\"11\\\": 0.5}\\n \\n+    lines = str(ghz_problem).split(\\\"\\\\n\\\")\\n+    ghz_problem_dict = ghz_problem.to_dict()\\n+    for line in lines:\\n+        [title, value] = line.split(\\\":\\\", 1)\\n+        key = title.lower().replace(\\\" \\\", \\\"_\\\")\\n+        value = value.strip()\\n+        assert key in ghz_problem_dict\\n+        assert value == str(ghz_problem_dict[key])\\n+\\n     strategies = settings.make_strategies()\\n     num_strategies = 4\\n     assert len(strategies) == num_strategies\\n \\n-    strategy_summary = str(strategies[0]).replace(\\\"'\\\", '\\\"')\\n+    strategy_summary = repr(strategies[0]).replace(\\\"'\\\", '\\\"')\\n     assert isinstance(json.loads(strategy_summary), dict)\\n \\n+    lines = str(strategies[0]).split(\\\"\\\\n\\\")\\n+    strategy_dict = strategies[0].to_pretty_dict()\\n+    for line in lines:\\n+        [title, value] = line.split(\\\":\\\")\\n+        key = title.lower().replace(\\\" \\\", \\\"_\\\")\\n+        value = value.strip()\\n+        assert key in strategy_dict\\n+        assert value == str(strategy_dict[key])\\n+\\n+\\n+def test_settings_pretty_dict():\\n+    settings = Settings(\\n+        benchmarks=[\\n+            {\\n+                \\\"circuit_type\\\": \\\"ghz\\\",\\n+                \\\"num_qubits\\\": 2,\\n+                \\\"circuit_depth\\\": 999,\\n+            }\\n+        ],\\n+        strategies=[\\n+            {\\n+                \\\"technique\\\": \\\"zne\\\",\\n+                \\\"scale_noise\\\": fold_global,\\n+                \\\"factory\\\": RichardsonFactory([1.0, 2.0, 3.0]),\\n+            },\\n+            {\\n+                \\\"technique\\\": \\\"pec\\\",\\n+                \\\"representation_function\\\": (\\n+                    represent_operation_with_local_depolarizing_noise\\n+                ),\\n+                \\\"is_qubit_dependent\\\": False,\\n+                \\\"noise_level\\\": 0.001,\\n+                \\\"num_samples\\\": 200,\\n+            },\\n+        ],\\n+    )\\n+    strategies = settings.make_strategies()\\n+    _dict = strategies[0].to_dict()\\n+    pretty_dict = strategies[0].to_pretty_dict()\\n+    if pretty_dict[\\\"technique\\\"] == \\\"ZNE\\\":\\n+        assert pretty_dict[\\\"factory\\\"] == _dict[\\\"factory\\\"][:-7]\\n+        assert (\\n+            pretty_dict[\\\"scale_factors\\\"] == str(_dict[\\\"scale_factors\\\"])[1:-1]\\n+        )\\n+    elif pretty_dict[\\\"technique\\\"] == \\\"PEC\\\":\\n+        assert pretty_dict[\\\"noise_bias\\\"] == _dict.get(\\\"noise_bias\\\", \\\"N/A\\\")\\n+        assert (\\n+            pretty_dict[\\\"representation_function\\\"]\\n+            == _dict[\\\"representation_function\\\"][25:]\\n+        )\\n+\\n \\n def test_make_circuits_qv_circuits():\\n     settings = Settings(\\n\",\"diff --git a/mitiq/calibration/tests/test_calibration.py b/mitiq/calibration/tests/test_calibration.py\\nindex 7391df23b..4b2058090 100644\\n--- a/mitiq/calibration/tests/test_calibration.py\\n+++ b/mitiq/calibration/tests/test_calibration.py\\n@@ -10,6 +10,7 @@\\n import cirq\\n import numpy as np\\n import pytest\\n+from mock import MagicMock, call\\n \\n from mitiq import SUPPORTED_PROGRAM_TYPES, Executor, MeasurementResult\\n from mitiq.benchmarks import generate_rb_circuits\\n@@ -374,48 +375,105 @@ def test_ExtrapolationResults_best_strategy():\\n )\\n \\n \\n-def test_logging(capfd):\\n+def test_ExtrapolationResults_performance_str():\\n+    nerr = 0.9876543\\n+    merr = 0.1234567\\n+    perf_str = ExperimentResults._performance_str(nerr, merr)\\n+    mandatory_lines_count = 0\\n+    for line in perf_str.split(\\\"\\\\n\\\"):\\n+        if \\\"Noisy error: \\\" in line:\\n+            assert line.split(\\\"Noisy error: \\\")[1] == str(round(nerr, 4))\\n+            mandatory_lines_count += 1\\n+        if \\\"Mitigated error: \\\" in line:\\n+            assert line.split(\\\"Mitigated error: \\\")[1] == str(round(merr, 4))\\n+            mandatory_lines_count += 1\\n+        if \\\"Improvement factor: \\\" in line:\\n+            assert line.split(\\\"Improvement factor: \\\")[1] == str(\\n+                round(nerr / merr, 4)\\n+            )\\n+            mandatory_lines_count += 1\\n+    assert mandatory_lines_count == 3\\n+\\n+\\n+def test_Calibrator_log_argument():\\n     cal = Calibrator(\\n-        damping_execute, frontend=\\\"cirq\\\", settings=light_combined_settings\\n+        damping_execute, frontend=\\\"cirq\\\", settings=Settings([], [])\\n     )\\n-    cal.run(log=True)\\n+    cal.results = MagicMock()\\n+    cal.run()\\n+    cal.results.log_results_flat.assert_not_called()\\n+\\n+    cal.run(log=\\\"flat\\\")\\n+    cal.results.log_results_flat.assert_called_once()\\n+\\n+    cal.run(log=\\\"cartesian\\\")\\n+    cal.results.log_results_cartesian.assert_called_once()\\n+\\n+    with pytest.raises(ValueError):\\n+        cal.run(log=\\\"foo\\\")\\n+\\n+\\n+def test_ExtrapolationResults_logging_results_flat(capfd):\\n+    settings = light_zne_settings\\n+    problems = settings.make_problems()\\n+    strategies = settings.make_strategies()\\n+    results = ExperimentResults(strategies, problems)\\n+    perf_str = \\\"performance result\\\"\\n+    results._performance_str = MagicMock(return_value=perf_str)\\n+    for s in strategies:\\n+        for p in problems:\\n+            results.add_result(\\n+                s, p, ideal_val=1.0, noisy_val=0.5, mitigated_val=0.6\\n+            )\\n+    results.log_results_flat()\\n     captured = capfd.readouterr()\\n-    for s in cal.strategies:\\n+    results._performance_str.assert_has_calls(\\n+        [call(0.5, 0.4)] * len(strategies) * len(problems)\\n+    )\\n+    for s in strategies:\\n         for line in str(s).split():\\n             assert line in captured.out\\n-    for p in cal.problems:\\n+    for p in problems:\\n         for line in str(p).split():\\n             assert line in captured.out\\n-    mcount = 0\\n-    ncount = 0\\n+    # Here we make sure that we have len(strategies) * len(problems)\\n+    # performance results lines in the output. One performance result\\n+    # per strategy/problem combination.\\n+    perf_count = 0\\n     for line in captured.out.split(\\\"\\\\n\\\"):\\n-        if \\\"Mitigated error: \\\" in line:\\n-            mcount += 1\\n-        if \\\"Noisy error: \\\" in line:\\n-            ncount += 1\\n-    assert mcount == (len(cal.strategies) * len(cal.problems))\\n-    assert ncount == (len(cal.strategies) * len(cal.problems))\\n-\\n-\\n-def test_logging_cartesian(capfd):\\n-    cal = Calibrator(\\n-        damping_execute, frontend=\\\"cirq\\\", settings=light_combined_settings\\n-    )\\n-    cal.run(log_cartesian=True)\\n+        if perf_str in line:\\n+            perf_count += 1\\n+    assert perf_count == (len(strategies) * len(problems))\\n+\\n+\\n+def test_ExtrapolationResults_logging_results_cartesian(capfd):\\n+    settings = light_zne_settings\\n+    problems = settings.make_problems()\\n+    strategies = settings.make_strategies()\\n+    results = ExperimentResults(strategies, problems)\\n+    perf_str = \\\"performance result\\\"\\n+    results._performance_str = MagicMock(return_value=perf_str)\\n+    for s in strategies:\\n+        for p in problems:\\n+            results.add_result(\\n+                s, p, ideal_val=1.0, noisy_val=0.5, mitigated_val=0.6\\n+            )\\n+    results.log_results_cartesian()\\n     captured = capfd.readouterr()\\n-    for s in cal.strategies:\\n+    results._performance_str.assert_has_calls(\\n+        [call(0.5, 0.4)] * len(strategies) * len(problems)\\n+    )\\n+    for s in strategies:\\n         for line in str(s).split():\\n             assert line in captured.out\\n-    for p in cal.problems:\\n+    for p in problems:\\n         for line in str(p).split():\\n             assert line in captured.out\\n+    # Here we make sure the output contains multiple columns.\\n+    # One column per problem\\n     for line in captured.out.split(\\\"\\\\n\\\"):\\n-        if \\\"Mitigated error: \\\" in line:\\n-            assert len(re.findall(\\\"Mitigated error: \\\", line)) == len(\\n-                cal.problems\\n-            )\\n-        if \\\"Noisy error: \\\" in line:\\n-            assert len(re.findall(\\\"Noisy error: \\\", line)) == len(cal.problems)\\n+        if perf_str in line:\\n+            assert len(re.findall(perf_str, line)) == len(problems)\\n \\n \\n def test_ExperimentResults_reset_data():\\n\",\"diff --git a/mitiq/calibration/tests/test_settings.py b/mitiq/calibration/tests/test_settings.py\\nindex d28c01428..e4eafbc18 100644\\n--- a/mitiq/calibration/tests/test_settings.py\\n+++ b/mitiq/calibration/tests/test_settings.py\\n@@ -73,6 +73,33 @@\\n )\\n \\n \\n+basic_settings = Settings(\\n+    benchmarks=[\\n+        {\\n+            \\\"circuit_type\\\": \\\"ghz\\\",\\n+            \\\"num_qubits\\\": 2,\\n+            \\\"circuit_depth\\\": 999,\\n+        }\\n+    ],\\n+    strategies=[\\n+        {\\n+            \\\"technique\\\": \\\"zne\\\",\\n+            \\\"scale_noise\\\": fold_global,\\n+            \\\"factory\\\": RichardsonFactory([1.0, 2.0, 3.0]),\\n+        },\\n+        {\\n+            \\\"technique\\\": \\\"pec\\\",\\n+            \\\"representation_function\\\": (\\n+                represent_operation_with_local_depolarizing_noise\\n+            ),\\n+            \\\"is_qubit_dependent\\\": False,\\n+            \\\"noise_level\\\": 0.001,\\n+            \\\"num_samples\\\": 200,\\n+        },\\n+    ],\\n+)\\n+\\n+\\n def test_MitigationTechnique():\\n     pec_enum = MitigationTechnique.PEC\\n     assert pec_enum.mitigation_function == execute_with_pec\\n@@ -83,110 +110,78 @@ def test_MitigationTechnique():\\n     assert raw_enum.name == \\\"RAW\\\"\\n \\n \\n-def test_basic_settings():\\n-    settings = Settings(\\n-        benchmarks=[\\n-            {\\n-                \\\"circuit_type\\\": \\\"ghz\\\",\\n-                \\\"num_qubits\\\": 2,\\n-                \\\"circuit_depth\\\": 999,\\n-            }\\n-        ],\\n-        strategies=[\\n-            {\\n-                \\\"technique\\\": \\\"zne\\\",\\n-                \\\"scale_noise\\\": fold_global,\\n-                \\\"factory\\\": RichardsonFactory([1.0, 2.0, 3.0]),\\n-            },\\n-            {\\n-                \\\"technique\\\": \\\"zne\\\",\\n-                \\\"scale_noise\\\": fold_global,\\n-                \\\"factory\\\": RichardsonFactory([1.0, 3.0, 5.0]),\\n-            },\\n-            {\\n-                \\\"technique\\\": \\\"zne\\\",\\n-                \\\"scale_noise\\\": fold_global,\\n-                \\\"factory\\\": LinearFactory([1.0, 2.0, 3.0]),\\n-            },\\n-            {\\n-                \\\"technique\\\": \\\"zne\\\",\\n-                \\\"scale_noise\\\": fold_global,\\n-                \\\"factory\\\": LinearFactory([1.0, 3.0, 5.0]),\\n-            },\\n-        ],\\n-    )\\n-    circuits = settings.make_problems()\\n-    assert len(circuits) == 1\\n-    ghz_problem = circuits[0]\\n+def test_BenchmarkProblem_make_problems():\\n+    settings = basic_settings\\n+    problems = settings.make_problems()\\n+    assert len(problems) == 1\\n+    ghz_problem = problems[0]\\n     assert len(ghz_problem.circuit) == 2\\n     assert ghz_problem.two_qubit_gate_count == 1\\n     assert ghz_problem.ideal_distribution == {\\\"00\\\": 0.5, \\\"11\\\": 0.5}\\n \\n-    lines = str(ghz_problem).split(\\\"\\\\n\\\")\\n-    ghz_problem_dict = ghz_problem.to_dict()\\n+\\n+def test_BenchmarkProblem_repr():\\n+    settings = basic_settings\\n+    problems = settings.make_problems()\\n+    problem_repr = repr(problems[0]).replace(\\\"'\\\", '\\\"')\\n+    assert isinstance(json.loads(problem_repr), dict)\\n+\\n+\\n+def test_BenchmarkProblem_str():\\n+    settings = basic_settings\\n+    circuits = settings.make_problems()\\n+    problem = circuits[0]\\n+    lines = str(problem).split(\\\"\\\\n\\\")\\n+    problem_dict = problem.to_dict()\\n     for line in lines:\\n         [title, value] = line.split(\\\":\\\", 1)\\n         key = title.lower().replace(\\\" \\\", \\\"_\\\")\\n         value = value.strip()\\n-        assert key in ghz_problem_dict\\n-        assert value == str(ghz_problem_dict[key])\\n+        assert key in problem_dict\\n+        assert value == str(problem_dict[key])\\n+    assert \\\"Ideal distribution: \\\" not in str(problem)\\n+\\n \\n+def test_Strategy_repr():\\n+    settings = basic_settings\\n     strategies = settings.make_strategies()\\n-    num_strategies = 4\\n-    assert len(strategies) == num_strategies\\n+    strategy_repr = repr(strategies[0]).replace(\\\"'\\\", '\\\"')\\n+    assert isinstance(json.loads(strategy_repr), dict)\\n \\n-    strategy_summary = repr(strategies[0]).replace(\\\"'\\\", '\\\"')\\n-    assert isinstance(json.loads(strategy_summary), dict)\\n \\n-    lines = str(strategies[0]).split(\\\"\\\\n\\\")\\n-    strategy_dict = strategies[0].to_pretty_dict()\\n-    for line in lines:\\n+def test_Strategy_str():\\n+    settings = basic_settings\\n+    strategies = settings.make_strategies()\\n+\\n+    strategy_str = str(strategies[0])\\n+    strategy_pretty_dict = strategies[0].to_pretty_dict()\\n+    for line in strategy_str.split(\\\"\\\\n\\\"):\\n         [title, value] = line.split(\\\":\\\")\\n         key = title.lower().replace(\\\" \\\", \\\"_\\\")\\n         value = value.strip()\\n-        assert key in strategy_dict\\n-        assert value == str(strategy_dict[key])\\n+        assert key in strategy_pretty_dict\\n+        assert value == str(strategy_pretty_dict[key])\\n \\n \\n-def test_settings_pretty_dict():\\n-    settings = Settings(\\n-        benchmarks=[\\n-            {\\n-                \\\"circuit_type\\\": \\\"ghz\\\",\\n-                \\\"num_qubits\\\": 2,\\n-                \\\"circuit_depth\\\": 999,\\n-            }\\n-        ],\\n-        strategies=[\\n-            {\\n-                \\\"technique\\\": \\\"zne\\\",\\n-                \\\"scale_noise\\\": fold_global,\\n-                \\\"factory\\\": RichardsonFactory([1.0, 2.0, 3.0]),\\n-            },\\n-            {\\n-                \\\"technique\\\": \\\"pec\\\",\\n-                \\\"representation_function\\\": (\\n-                    represent_operation_with_local_depolarizing_noise\\n-                ),\\n-                \\\"is_qubit_dependent\\\": False,\\n-                \\\"noise_level\\\": 0.001,\\n-                \\\"num_samples\\\": 200,\\n-            },\\n-        ],\\n-    )\\n+def test_Strategy_pretty_dict():\\n+    settings = basic_settings\\n     strategies = settings.make_strategies()\\n-    _dict = strategies[0].to_dict()\\n-    pretty_dict = strategies[0].to_pretty_dict()\\n-    if pretty_dict[\\\"technique\\\"] == \\\"ZNE\\\":\\n-        assert pretty_dict[\\\"factory\\\"] == _dict[\\\"factory\\\"][:-7]\\n+\\n+    strategy_dict = strategies[0].to_dict()\\n+    strategy_pretty_dict = strategies[0].to_pretty_dict()\\n+    if strategy_pretty_dict[\\\"technique\\\"] == \\\"ZNE\\\":\\n+        assert strategy_pretty_dict[\\\"factory\\\"] == strategy_dict[\\\"factory\\\"][:-7]\\n         assert (\\n-            pretty_dict[\\\"scale_factors\\\"] == str(_dict[\\\"scale_factors\\\"])[1:-1]\\n+            strategy_pretty_dict[\\\"scale_factors\\\"]\\n+            == str(strategy_dict[\\\"scale_factors\\\"])[1:-1]\\n+        )\\n+    elif strategy_pretty_dict[\\\"technique\\\"] == \\\"PEC\\\":\\n+        assert strategy_pretty_dict[\\\"noise_bias\\\"] == strategy_dict.get(\\n+            \\\"noise_bias\\\", \\\"N/A\\\"\\n         )\\n-    elif pretty_dict[\\\"technique\\\"] == \\\"PEC\\\":\\n-        assert pretty_dict[\\\"noise_bias\\\"] == _dict.get(\\\"noise_bias\\\", \\\"N/A\\\")\\n         assert (\\n-            pretty_dict[\\\"representation_function\\\"]\\n-            == _dict[\\\"representation_function\\\"][25:]\\n+            strategy_pretty_dict[\\\"representation_function\\\"]\\n+            == strategy_dict[\\\"representation_function\\\"][25:]\\n         )\\n \\n \\n\",\"diff --git a/mitiq/calibration/tests/test_calibration.py b/mitiq/calibration/tests/test_calibration.py\\nindex 4b2058090..6b836d976 100644\\n--- a/mitiq/calibration/tests/test_calibration.py\\n+++ b/mitiq/calibration/tests/test_calibration.py\\n@@ -10,7 +10,7 @@\\n import cirq\\n import numpy as np\\n import pytest\\n-from mock import MagicMock, call\\n+from unittest.mock import MagicMock, call\\n \\n from mitiq import SUPPORTED_PROGRAM_TYPES, Executor, MeasurementResult\\n from mitiq.benchmarks import generate_rb_circuits\\n\",\"diff --git a/mitiq/calibration/tests/test_calibration.py b/mitiq/calibration/tests/test_calibration.py\\nindex 6b836d976..bbf3eeede 100644\\n--- a/mitiq/calibration/tests/test_calibration.py\\n+++ b/mitiq/calibration/tests/test_calibration.py\\n@@ -6,11 +6,11 @@\\n \\\"\\\"\\\"Tests for the Clifford data regression top-level API.\\\"\\\"\\\"\\n import re\\n from functools import partial\\n+from unittest.mock import MagicMock, call\\n \\n import cirq\\n import numpy as np\\n import pytest\\n-from unittest.mock import MagicMock, call\\n \\n from mitiq import SUPPORTED_PROGRAM_TYPES, Executor, MeasurementResult\\n from mitiq.benchmarks import generate_rb_circuits\\n\",\"diff --git a/docs/source/examples/calibration-tutorial.md b/docs/source/examples/calibration-tutorial.md\\nindex 113a6a654..f6edf0575 100644\\n--- a/docs/source/examples/calibration-tutorial.md\\n+++ b/docs/source/examples/calibration-tutorial.md\\n@@ -16,14 +16,14 @@ kernelspec:\\n \\n <img src=\\\"../_thumbnails/calibration.png\\\" width=\\\"400\\\">\\n \\n-This tutorial helps answer the question: \\\"What quantum error mitigation technique should I use for my problem?\\\". \\n+This tutorial helps answer the question: \\\"What quantum error mitigation technique should I use for my problem?\\\".\\n The newly introduced `mitiq.calibration` module helps answer that in an optimized way, through `Benchmarks` and `Strategies`.\\n \\n More specifically, this tutorial covers:\\n \\n - Getting started with Mitiq's calibration module with ZNE\\n - Use Qiskit noisy simulator with `FakeJakarta` as backend\\n-- Run calibration with some special settings, `RBSettings`, using the `cal.run(log=True)` option\\n+- Run calibration with some special settings, `RBSettings`, and logging the results\\n \\n ## Getting started with Mitiq\\n \\n@@ -110,12 +110,12 @@ We import from the calibration module the key ingredients to use `mitiq.calibrat\\n \\n Currently `mitiq.calibration` supports ZNE as a technique to calibrate from, tuning different scale factors, extrapolation methods and circuit scaling methods.\\n \\n-Let's run the calibration using an ad-hoc RBSettings and using the `log=True` option in order to print the list of experiments run.\\n+Let's run the calibration using an ad-hoc RBSettings while logging the results for comparison.\\n \\n - benchmarks: Circuit type: \\\"rb\\\"\\n - strategies: use various \\\"zne\\\" strategies, testing various \\\"scale_noise\\\" methods\\n-(such as `mitiq.zne.scaling.folding.fold_global`, `mitiq.zne.scaling.folding.fold_gates_at_random`, and `mitiq.zne.scaling.folding.fold_all`), \\n-and ZNE factories for extrapolation (such as `mitiq.zne.inference.RichardsonFactory` and `mitiq.zne.inference.LinearFactory`)\\n+  (such as `mitiq.zne.scaling.folding.fold_global`, `mitiq.zne.scaling.folding.fold_gates_at_random`, and `mitiq.zne.scaling.folding.fold_all`),\\n+  and ZNE factories for extrapolation (such as `mitiq.zne.inference.RichardsonFactory` and `mitiq.zne.inference.LinearFactory`)\\n \\n ```{code-cell} ipython3\\n RBSettings = Settings(\\n@@ -189,17 +189,17 @@ RBSettings = Settings(\\n             \\\"scale_noise\\\": fold_all,\\n             \\\"factory\\\": LinearFactory([1.0, 3.0, 5.0]),\\n         },\\n-        \\n+\\n     ],\\n )\\n ```\\n \\n ```{code-cell} ipython3\\n cal = Calibrator(execute_calibration, frontend=\\\"qiskit\\\", settings=RBSettings)\\n-cal.run(log=True)\\n+cal.run(log=\\\"flat\\\")\\n ```\\n \\n-As you can see above, several experiments were run, and each one has either a red cross (❌) or a green check (✅) to signal whether the error mitigation experiment obtained an expectation value that is better than the non-mitigated one.\\n+As you can see above, several experiments were run, and each one has either a cross (✘) or a check (✔) to signal whether the error mitigation experiment obtained an expectation value that is better than the non-mitigated one.\\n \\n ```{code-cell} ipython3\\n calibrated_mitigated=execute_with_mitigation(circuit, execute_circuit, calibrator=cal)\"]", "hints_text": ""}

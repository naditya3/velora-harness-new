{"instance_id": "1372289363852683", "repo": "quantumlib/stim", "base_commit": "8162b0c5aa49bffd57284b0c0f2e022e193e9616", "problem_statement": "Add an option to use best-effort (ignore undecomposed errors) when decompose_errors=True is set:\\nFrom @newmanmg", "FAIL_TO_PASS": ["src/stim/circuit/circuit_pybind_test.py::test_shortest_graphlike_error_ignore"], "PASS_TO_PASS": ["src/stim/stabilizers/pauli_string_pybind_test.py::test_init_copy", "src/stim/simulators/tableau_simulator_pybind_test.py::test_gates_present[xcz]", "src/stim/simulators/tableau_simulator_pybind_test.py::test_peek_observable_expectation", "src/stim/stabilizers/pauli_string_pybind_test.py::test_imaginary_phase", "src/stim/circuit/circuit_pybind_test.py::test_backwards_compatibility_vs_safety_append_vs_append_operation", "src/stim/simulators/tableau_simulator_pybind_test.py::test_gates_present[x]", "src/stim/py/compiled_measurement_sampler_pybind_test.py::test_compiled_measurement_sampler_sample", "src/stim/circuit/circuit_gate_target_pybind_test.py::test_init_and_equality", "src/stim/simulators/tableau_simulator_pybind_test.py::test_gates_present[sqrt_y]", "glue/zx/stimzx/_zx_graph_solver_test.py::test_cz", "src/stim/simulators/tableau_simulator_pybind_test.py::test_is_parallel_state_vector", "src/stim/stabilizers/tableau_pybind_test.py::test_identity", "src/stim/simulators/tableau_simulator_pybind_test.py::test_copy", "src/stim/simulators/tableau_simulator_pybind_test.py::test_gates_present[s]", "src/stim/stabilizers/tableau_pybind_test.py::test_append", "src/stim/simulators/tableau_simulator_pybind_test.py::test_gates_present[cy]", "src/stim/circuit/circuit_pybind_test.py::test_circuit_append_operation", "glue/zx/stimzx/_zx_graph_solver_test.py::test_sqrt_x_sqrt_x", "src/stim/dem/detector_error_model_instruction_pybind_test.py::test_equality", "glue/zx/stimzx/_text_diagram_parsing_test.py::test_find_end_of_edge", "src/stim/dem/detector_error_model_pybind_test.py::test_shortest_graphlike_error_trivial", "glue/zx/stimzx/_text_diagram_parsing_test.py::test_text_to_char_map", "src/stim/circuit/circuit_pybind_test.py::test_hash", "src/stim/stabilizers/pauli_string_pybind_test.py::test_inplace_product", "src/stim/simulators/tableau_simulator_pybind_test.py::test_do", "glue/zx/stimzx/_zx_graph_solver_test.py::test_z", "src/stim/dem/detector_error_model_pybind_test.py::test_repr", "src/stim/simulators/tableau_simulator_pybind_test.py::test_canonical_stabilizers", "src/stim/simulators/tableau_simulator_pybind_test.py::test_measure_kickback", "src/stim/simulators/tableau_simulator_pybind_test.py::test_gates_present[xcx]", "src/stim/dem/detector_error_model_instruction_pybind_test.py::test_args_copy", "glue/zx/stimzx/_zx_graph_solver_test.py::test_s_dag", "src/stim/dem/detector_error_model_instruction_pybind_test.py::test_targets_copy", "src/stim/stabilizers/tableau_pybind_test.py::test_inverse_xyz_output", "src/stim/stabilizers/pauli_string_pybind_test.py::test_from_str", "src/stim/dem/detector_error_model_pybind_test.py::test_pickle", "src/stim/dem/detector_error_model_pybind_test.py::test_shortest_graphlike_error_rep_code", "glue/zx/stimzx/_zx_graph_solver_test.py::test_sqrt_z_sqrt_z", "src/stim/simulators/matched_error_pybind_test.py::test_CircuitTargetsInsideInstruction", "src/stim/simulators/tableau_simulator_pybind_test.py::test_paulis", "src/stim/stabilizers/tableau_pybind_test.py::test_pow", "src/stim/circuit/circuit_pybind_test.py::test_append_extended_cases", "src/stim/simulators/tableau_simulator_pybind_test.py::test_gates_present[cz]", "src/stim/simulators/tableau_simulator_pybind_test.py::test_gates_present[iswap]", "src/stim/circuit/circuit_pybind_test.py::test_circuit_add", "src/stim/simulators/tableau_simulator_pybind_test.py::test_post_select_using_measure_kickback", "src/stim/simulators/tableau_simulator_pybind_test.py::test_gates_present[sqrt_x_dag]", "src/stim/dem/detector_error_model_pybind_test.py::test_count_errors", "src/stim/py/compiled_measurement_sampler_pybind_test.py::test_skip_reference_sample", "src/stim/circuit/circuit_repeat_block_test.py::test_repr[value0]", "src/stim/circuit/circuit_instruction_pybind_test.py::test_str", "src/stim/stabilizers/pauli_string_pybind_test.py::test_repr", "src/stim/simulators/matched_error_pybind_test.py::test_DemTargetWithCoords", "src/stim/stabilizers/pauli_string_pybind_test.py::test_copy", "src/stim/circuit/circuit_pybind_test.py::test_circuit_detector_sampling_seeded", "src/stim/simulators/tableau_simulator_pybind_test.py::test_gates_present[ycx]", "src/stim/circuit/circuit_pybind_test.py::test_circuit_flattened_operations", "src/stim/stabilizers/pauli_string_pybind_test.py::test_str", "src/stim/dem/detector_error_model_target_pybind_test.py::test_static_constructors", "src/stim/circuit/circuit_pybind_test.py::test_copy", "src/stim/simulators/tableau_simulator_pybind_test.py::test_measure_kickback_random_branches", "src/stim/stabilizers/tableau_pybind_test.py::test_repr", "glue/zx/stimzx/_external_stabilizer_test.py::test_repr", "src/stim/simulators/tableau_simulator_pybind_test.py::test_basic", "glue/zx/stimzx/_zx_graph_solver_test.py::test_disconnected", "src/stim/stabilizers/tableau_pybind_test.py::test_pickle", "glue/zx/stimzx/_zx_graph_solver_test.py::test_id", "src/stim/circuit/circuit_pybind_test.py::test_slicing", "src/stim/circuit/circuit_pybind_test.py::test_circuit_compile_sampler", "src/stim/simulators/tableau_simulator_pybind_test.py::test_to_state_vector", "src/stim/circuit/circuit_gate_target_pybind_test.py::test_repr[value0]", "src/stim/simulators/tableau_simulator_pybind_test.py::test_set_num_qubits", "src/stim/circuit/circuit_instruction_pybind_test.py::test_repr[value0]", "src/stim/stabilizers/pauli_string_pybind_test.py::test_commutes", "src/stim/stabilizers/tableau_pybind_test.py::test_call", "src/stim/dem/detector_error_model_pybind_test.py::test_shortest_graphlike_error_line", "src/stim/simulators/tableau_simulator_pybind_test.py::test_gates_present[swap]", "src/stim/simulators/tableau_simulator_pybind_test.py::test_gates_present[sqrt_y_dag]", "glue/zx/stimzx/_zx_graph_solver_test.py::test_s", "src/stim/circuit/circuit_instruction_pybind_test.py::test_repr[value1]", "src/stim/stabilizers/pauli_string_pybind_test.py::test_pickle", "glue/zx/stimzx/_zx_graph_solver_test.py::test_sqrt_x_dag", "src/stim/simulators/tableau_simulator_pybind_test.py::test_gates_present[z]", "src/stim/circuit/circuit_instruction_pybind_test.py::test_init_and_equality", "src/stim/circuit/circuit_pybind_test.py::test_append_instructions_and_blocks", "src/stim/stabilizers/tableau_pybind_test.py::test_prepend", "src/stim/circuit/circuit_repeat_block_test.py::test_init_and_equality", "glue/zx/stimzx/_zx_graph_solver_test.py::test_cnot", "src/stim/dem/detector_error_model_target_pybind_test.py::test_str", "src/stim/circuit/circuit_pybind_test.py::test_circuit_init_num_measurements_num_qubits", "src/stim/simulators/matched_error_pybind_test.py::test_CircuitErrorLocationStackFrame", "src/stim/circuit/circuit_pybind_test.py::test_num_detectors", "src/stim/circuit/circuit_pybind_test.py::test_coords", "src/stim/dem/detector_error_model_pybind_test.py::test_approx_equals", "src/stim/circuit/circuit_repeat_block_test.py::test_repr[value1]", "src/stim/dem/detector_error_model_instruction_pybind_test.py::test_str", "src/stim/stabilizers/tableau_pybind_test.py::test_from_conjugated_generators", "src/stim/circuit/circuit_pybind_test.py::test_shortest_graphlike_error", "src/stim/circuit/circuit_pybind_test.py::test_explain_errors", "src/stim/circuit/circuit_pybind_test.py::test_circuit_mul", "src/stim/circuit/circuit_pybind_test.py::test_anti_commuting_mpp_error_message", "src/stim/circuit/circuit_gate_target_pybind_test.py::test_repr[value2]", "src/stim/circuit/circuit_gate_target_pybind_test.py::test_repr[value4]", "src/stim/circuit/circuit_pybind_test.py::test_circuit_repr", "src/stim/simulators/tableau_simulator_pybind_test.py::test_gates_present[xcy]", "src/stim/simulators/tableau_simulator_pybind_test.py::test_gates_present[y]", "glue/zx/stimzx/_text_diagram_parsing_test.py::test_find_nodes", "src/stim/simulators/tableau_simulator_pybind_test.py::test_gates_present[sqrt_x]", "src/stim/dem/detector_error_model_pybind_test.py::test_append", "glue/zx/stimzx/_zx_graph_solver_test.py::test_s_state_distill", "src/stim/stabilizers/tableau_pybind_test.py::test_pauli_output", "src/stim/circuit/circuit_pybind_test.py::test_indexing_operations", "src/stim/circuit/circuit_instruction_pybind_test.py::test_hashable", "src/stim/simulators/tableau_simulator_pybind_test.py::test_gates_present[h_yz]", "src/stim/stabilizers/tableau_pybind_test.py::test_str", "src/stim/dem/detector_error_model_pybind_test.py::test_shortest_graphlike_error_ignore", "src/stim/stabilizers/pauli_string_pybind_test.py::test_equality", "src/stim/stabilizers/pauli_string_pybind_test.py::test_add", "src/stim/simulators/matched_error_pybind_test.py::test_MatchedError", "src/stim/stabilizers/pauli_string_pybind_test.py::test_mul_repeat", "src/stim/dem/detector_error_model_pybind_test.py::test_init_get", "src/stim/dem/detector_error_model_instruction_pybind_test.py::test_type", "src/stim/simulators/tableau_simulator_pybind_test.py::test_access_tableau", "src/stim/stabilizers/tableau_pybind_test.py::test_from_named_gate", "src/stim/dem/detector_error_model_instruction_pybind_test.py::test_repr", "src/stim/circuit/circuit_pybind_test.py::test_circuit_measurement_sampling_seeded", "src/stim/simulators/matched_error_pybind_test.py::test_CircuitErrorLocation", "src/stim/py/compiled_measurement_sampler_pybind_test.py::test_repr", "src/stim/dem/detector_error_model_instruction_pybind_test.py::test_validation", "src/stim/circuit/circuit_pybind_test.py::test_circuit_clear", "src/stim/simulators/tableau_simulator_pybind_test.py::test_gates_present[ycz]", "src/stim/dem/detector_error_model_target_pybind_test.py::test_hashable", "src/stim/circuit/circuit_pybind_test.py::test_reappend_gate_targets", "src/stim/stabilizers/pauli_string_pybind_test.py::test_random", "src/stim/stabilizers/pauli_string_pybind_test.py::test_get_slice", "src/stim/simulators/tableau_simulator_pybind_test.py::test_peek_bloch", "src/stim/circuit/circuit_pybind_test.py::test_circuit_eq", "src/stim/dem/detector_error_model_pybind_test.py::test_coords", "src/stim/stabilizers/pauli_string_pybind_test.py::test_get_set_item", "glue/zx/stimzx/_zx_graph_solver_test.py::test_x", "src/stim/simulators/tableau_simulator_pybind_test.py::test_classical_control_cnot", "src/stim/stabilizers/tableau_pybind_test.py::test_copy", "src/stim/circuit/circuit_pybind_test.py::test_pickle", "src/stim/stabilizers/tableau_pybind_test.py::test_inverse_xyz_output_pauli", "src/stim/simulators/tableau_simulator_pybind_test.py::test_gates_present[h_xy]", "src/stim/circuit/circuit_pybind_test.py::test_num_observables", "src/stim/circuit/circuit_gate_target_pybind_test.py::test_repr[value5]", "src/stim/stabilizers/pauli_string_pybind_test.py::test_product", "src/stim/simulators/tableau_simulator_pybind_test.py::test_gates_present[iswap_dag]", "src/stim/circuit/circuit_pybind_test.py::test_approx_equals", "glue/zx/stimzx/_text_diagram_parsing_test.py::test_find_all_edges", "src/stim/stabilizers/tableau_pybind_test.py::test_xyz_output_pauli", "src/stim/simulators/matched_error_pybind_test.py::test_GateTargetWithCoords", "src/stim/dem/detector_error_model_pybind_test.py::test_equality", "src/stim/dem/detector_error_model_repeat_block_pybind_test.py::test_equality", "src/stim/stabilizers/pauli_string_pybind_test.py::test_div", "src/stim/stabilizers/tableau_pybind_test.py::test_init_equality", "src/stim/dem/detector_error_model_instruction_pybind_test.py::test_hashable", "src/stim/stabilizers/pauli_string_pybind_test.py::test_identity", "src/stim/stabilizers/pauli_string_pybind_test.py::test_mul_different_sizes", "src/stim/stabilizers/tableau_pybind_test.py::test_add", "src/stim/simulators/tableau_simulator_pybind_test.py::test_gates_present[s_dag]", "src/stim/simulators/tableau_simulator_pybind_test.py::test_gates_present[h]", "src/stim/circuit/circuit_pybind_test.py::test_circuit_generation", "src/stim/circuit/circuit_gate_target_pybind_test.py::test_repr[value1]", "src/stim/stabilizers/pauli_string_pybind_test.py::test_get_set_sign", "src/stim/stabilizers/pauli_string_pybind_test.py::test_hash", "src/stim/dem/detector_error_model_target_pybind_test.py::test_repr", "src/stim/stabilizers/tableau_pybind_test.py::test_hash", "src/stim/py/compiled_detector_sampler_pybind_test.py::test_compiled_detector_sampler_sample", "src/stim/dem/detector_error_model_repeat_block_pybind_test.py::test_repr", "src/stim/dem/detector_error_model_target_pybind_test.py::test_equality", "src/stim/simulators/tableau_simulator_pybind_test.py::test_gates_present[ycy]", "src/stim/dem/detector_error_model_target_pybind_test.py::test_properties", "glue/zx/stimzx/_zx_graph_solver_test.py::test_sqrt_x", "src/stim/dem/detector_error_model_repeat_block_pybind_test.py::test_init_vs_properties", "src/stim/circuit/circuit_gate_target_pybind_test.py::test_repr[value3]", "src/stim/py/compiled_measurement_sampler_pybind_test.py::test_sample_write", "src/stim/py/compiled_measurement_sampler_pybind_test.py::test_measurements_vs_resets", "src/stim/circuit/circuit_pybind_test.py::test_circuit_iadd", "src/stim/stabilizers/tableau_pybind_test.py::test_random", "src/stim/stabilizers/tableau_pybind_test.py::test_composition", "src/stim/circuit/circuit_gate_target_pybind_test.py::test_properties", "src/stim/circuit/circuit_pybind_test.py::test_circuit_generation_errors", "src/stim/stabilizers/tableau_pybind_test.py::test_aliasing", "src/stim/circuit/circuit_gate_target_pybind_test.py::test_hashable", "src/stim/stabilizers/tableau_pybind_test.py::test_inverse", "src/stim/simulators/tableau_simulator_pybind_test.py::test_gates_present[cnot]", "src/stim/py/stim_pybind_test.py::test_version", "src/stim/simulators/measurements_to_detection_events_test.py::test_convert_file_without_sweep_bits", "src/stim/circuit/circuit_pybind_test.py::test_circuit_compile_detector_sampler", "src/stim/stabilizers/pauli_string_pybind_test.py::test_commutes_different_lengths", "src/stim/simulators/matched_error_pybind_test.py::test_FlippedMeasurement"], "language": "python", "test_command": "source /saved/ENV || source /saved/*/ENV && pytest --no-header -rA --tb=no -p no:cacheprovider --continue-on-collection-errors", "test_output_parser": "python/parse_log_pytest_v3", "image_storage_uri": "vmvm-registry.fbinfra.net/repomate_image_activ_pytest/quantumlib_stim:8162b0c5aa49bffd57284b0c0f2e022e193e9616", "patch": "[\"diff --git a/.gitignore b/.gitignore\\nindex 7d20bf00..8a155281 100644\\n--- a/.gitignore\\n+++ b/.gitignore\\n@@ -31,3 +31,4 @@ venv/*\\n .venv/*\\n **/LastTest.log\\n *.so\\n+.cmake/*\\n\",\"diff --git a/doc/usage_command_line.md b/doc/usage_command_line.md\\nindex 26b6a3bc..0131195b 100644\\n--- a/doc/usage_command_line.md\\n+++ b/doc/usage_command_line.md\\n@@ -5,8 +5,10 @@\\n - **(mode)** [stim analyze_errors](#analyze_errors)\\n     - [--allow_gauge_detectors](#--allow_gauge_detectors)\\n     - [--approximate_disjoint_errors](#--approximate_disjoint_errors)\\n+    - [--block_decompose_from_introducing_remnant_edges](#--block_decompose_from_introducing_remnant_edges)\\n     - [--decompose_errors](#--decompose_errors)\\n     - [--fold_loops](#--fold_loops)\\n+    - [--ignore_decomposition_failures](#--ignore_decomposition_failures)\\n     - [--in](#--in)\\n     - [--out](#--out)\\n - **(mode)** [stim detect](#detect)\\n@@ -97,8 +99,10 @@ Note: currently, the `ELSE_CORRELATED_ERROR` instruction is not supported by thi\\n Flags used with this mode:\\n - [--allow_gauge_detectors](#--allow_gauge_detectors)\\n - [--approximate_disjoint_errors](#--approximate_disjoint_errors)\\n+- [--block_decompose_from_introducing_remnant_edges](#--block_decompose_from_introducing_remnant_edges)\\n - [--decompose_errors](#--decompose_errors)\\n - [--fold_loops](#--fold_loops)\\n+- [--ignore_decomposition_failures](#--ignore_decomposition_failures)\\n - [--in](#--in)\\n - [--out](#--out)\\n \\n@@ -526,6 +530,20 @@ Flags used with this mode:\\n     When set to 0, the noise operations are not inserted.\\n     \\n     \\n+- <a name=\\\"--block_decomposition_from_introducing_remnant_edges\\\"></a>**`--block_decomposition_from_introducing_remnant_edges`**\\n+    \\n+    Requires that both A B and C D be present elsewhere in the detector error model\\n+    in order to decompose A B C D into A B ^ C D. Normally, only one of A B or C D\\n+    needs to appear to allow this decomposition.\\n+    \\n+    Remnant edges can be a useful feature for ensuring decomposition succeeds, but\\n+    they can also reduce the effective code distance by giving the decoder single\\n+    edges that actually represent multiple errors in the circuit (resulting in the\\n+    decoder making misinformed choices when decoding).\\n+    \\n+    Irrelevant unless --decompose_errors is specified.\\n+    \\n+    \\n - <a name=\\\"--circuit\\\"></a>**`--circuit`**\\n     Specifies the circuit to use when converting measurement data to detector data.\\n     \\n@@ -603,6 +621,17 @@ Flags used with this mode:\\n     between the error analysis finishing in seconds instead of days.\\n     \\n     \\n+- <a name=\\\"--ignore_decomposition_failures\\\"></a>**`--ignore_decomposition_failures`**\\n+    \\n+    When this flag is set, circuit errors that fail to decompose into graphlike\\n+    detector error model errors no longer cause the conversion process to abort.\\n+    Instead, the undecomposed error is inserted into the output. Whatever processes\\n+    the detector error model is then responsible for dealing with the undecomposed\\n+    errors (e.g. a tool may choose to simply ignore them).\\n+    \\n+    Irrelevant unless --decompose_errors is specified.\\n+    \\n+    \\n - <a name=\\\"--in\\\"></a>**`--in`**\\n     Specifies an input file to read from, instead of stdin.\\n     \\n\",\"diff --git a/src/stim/benchmark_util.perf.h b/src/stim/benchmark_util.perf.h\\nindex 7ef5caba..078fb16c 100644\\n--- a/src/stim/benchmark_util.perf.h\\n+++ b/src/stim/benchmark_util.perf.h\\n@@ -63,14 +63,12 @@ struct RegisteredBenchmark {\\n extern RegisteredBenchmark *running_benchmark;\\n extern std::vector<RegisteredBenchmark> all_registered_benchmarks;\\n \\n-#define BENCHMARK(name)                                                          \\\\\\n-    void BENCH_##name##_METHOD();                                                \\\\\\n-    struct BENCH_STARTUP_TYPE_##name {                                           \\\\\\n-        BENCH_STARTUP_TYPE_##name() {                                            \\\\\\n-            all_registered_benchmarks.push_back({#name, BENCH_##name##_METHOD}); \\\\\\n-        }                                                                        \\\\\\n-    };                                                                           \\\\\\n-    static BENCH_STARTUP_TYPE_##name BENCH_STARTUP_INSTANCE_##name;              \\\\\\n+#define BENCHMARK(name)                                                                                      \\\\\\n+    void BENCH_##name##_METHOD();                                                                            \\\\\\n+    struct BENCH_STARTUP_TYPE_##name {                                                                       \\\\\\n+        BENCH_STARTUP_TYPE_##name() { all_registered_benchmarks.push_back({#name, BENCH_##name##_METHOD}); } \\\\\\n+    };                                                                                                       \\\\\\n+    static BENCH_STARTUP_TYPE_##name BENCH_STARTUP_INSTANCE_##name;                                          \\\\\\n     void BENCH_##name##_METHOD()\\n \\n // HACK: Templating the body function type makes inlining significantly more likely.\\n\",\"diff --git a/src/stim/dem/detector_error_model.cc b/src/stim/dem/detector_error_model.cc\\nindex 25796cbf..a32d53ea 100644\\n--- a/src/stim/dem/detector_error_model.cc\\n+++ b/src/stim/dem/detector_error_model.cc\\n@@ -822,7 +822,13 @@ bool get_detector_coordinates_helper(\\n             // TODO: Finish in time proportional to len(instructions) + len(desired) instead of len(execution).\\n             for (uint64_t k = 0; k < reps; k++) {\\n                 if (get_detector_coordinates_helper(\\n-                    block, included_detector_indices, iter_desired_detector_index, coord_shift, detector_offset, out, false)) {\\n+                        block,\\n+                        included_detector_indices,\\n+                        iter_desired_detector_index,\\n+                        coord_shift,\\n+                        detector_offset,\\n+                        out,\\n+                        false)) {\\n                     return true;\\n                 }\\n             }\\n\",\"diff --git a/src/stim/help.cc b/src/stim/help.cc\\nindex c4484f2b..2eb06564 100644\\n--- a/src/stim/help.cc\\n+++ b/src/stim/help.cc\\n@@ -404,6 +404,8 @@ Note: currently, the `ELSE_CORRELATED_ERROR` instruction is not supported by thi\\n         {\\n             \\\"--allow_gauge_detectors\\\",\\n             \\\"--approximate_disjoint_errors\\\",\\n+            \\\"--block_decompose_from_introducing_remnant_edges\\\",\\n+            \\\"--ignore_decomposition_failures\\\",\\n             \\\"--decompose_errors\\\",\\n             \\\"--fold_loops\\\",\\n             \\\"--out\\\",\\n@@ -411,6 +413,28 @@ Note: currently, the `ELSE_CORRELATED_ERROR` instruction is not supported by thi\\n         },\\n     };\\n \\n+    flags[\\\"--ignore_decomposition_failures\\\"] = R\\\"PARAGRAPH(\\n+When this flag is set, circuit errors that fail to decompose into graphlike\\n+detector error model errors no longer cause the conversion process to abort.\\n+Instead, the undecomposed error is inserted into the output. Whatever processes\\n+the detector error model is then responsible for dealing with the undecomposed\\n+errors (e.g. a tool may choose to simply ignore them).\\n+\\n+Irrelevant unless --decompose_errors is specified.\\n+)PARAGRAPH\\\";\\n+    flags[\\\"--block_decomposition_from_introducing_remnant_edges\\\"] = R\\\"PARAGRAPH(\\n+Requires that both A B and C D be present elsewhere in the detector error model\\n+in order to decompose A B C D into A B ^ C D. Normally, only one of A B or C D\\n+needs to appear to allow this decomposition.\\n+\\n+Remnant edges can be a useful feature for ensuring decomposition succeeds, but\\n+they can also reduce the effective code distance by giving the decoder single\\n+edges that actually represent multiple errors in the circuit (resulting in the\\n+decoder making misinformed choices when decoding).\\n+\\n+Irrelevant unless --decompose_errors is specified.\\n+)PARAGRAPH\\\";\\n+\\n     flags[\\\"--fold_loops\\\"] = R\\\"PARAGRAPH(\\n Allows the output error model to contain `repeat` blocks.\\n \\n\",\"diff --git a/src/stim/main_namespaced.cc b/src/stim/main_namespaced.cc\\nindex 42a0378c..82cf5fc8 100644\\n--- a/src/stim/main_namespaced.cc\\n+++ b/src/stim/main_namespaced.cc\\n@@ -208,10 +208,12 @@ int main_mode_analyze_errors(int argc, const char **argv) {\\n         {\\n             \\\"--allow_gauge_detectors\\\",\\n             \\\"--approximate_disjoint_errors\\\",\\n+            \\\"--block_decompose_from_introducing_remnant_edges\\\",\\n             \\\"--decompose_errors\\\",\\n             \\\"--fold_loops\\\",\\n-            \\\"--out\\\",\\n+            \\\"--ignore_decomposition_failures\\\",\\n             \\\"--in\\\",\\n+            \\\"--out\\\",\\n         },\\n         {\\\"--analyze_errors\\\", \\\"--detector_hypergraph\\\"},\\n         \\\"analyze_errors\\\",\\n@@ -220,6 +222,9 @@ int main_mode_analyze_errors(int argc, const char **argv) {\\n     bool decompose_errors = find_bool_argument(\\\"--decompose_errors\\\", argc, argv);\\n     bool fold_loops = find_bool_argument(\\\"--fold_loops\\\", argc, argv);\\n     bool allow_gauge_detectors = find_bool_argument(\\\"--allow_gauge_detectors\\\", argc, argv);\\n+    bool ignore_decomposition_failures = find_bool_argument(\\\"--ignore_decomposition_failures\\\", argc, argv);\\n+    bool block_decompose_from_introducing_remnant_edges =\\n+        find_bool_argument(\\\"--block_decompose_from_introducing_remnant_edges\\\", argc, argv);\\n \\n     const char *approximate_disjoint_errors_arg = find_argument(\\\"--approximate_disjoint_errors\\\", argc, argv);\\n     float approximate_disjoint_errors_threshold = 0;\\n@@ -238,7 +243,13 @@ int main_mode_analyze_errors(int argc, const char **argv) {\\n         fclose(in);\\n     }\\n     out << ErrorAnalyzer::circuit_to_detector_error_model(\\n-               circuit, decompose_errors, fold_loops, allow_gauge_detectors, approximate_disjoint_errors_threshold)\\n+               circuit,\\n+               decompose_errors,\\n+               fold_loops,\\n+               allow_gauge_detectors,\\n+               approximate_disjoint_errors_threshold,\\n+               ignore_decomposition_failures,\\n+               block_decompose_from_introducing_remnant_edges)\\n         << \\\"\\\\n\\\";\\n     return EXIT_SUCCESS;\\n }\\n\",\"diff --git a/src/stim/mem/simd_bits_range_ref.h b/src/stim/mem/simd_bits_range_ref.h\\nindex 17c5990a..a60c691d 100644\\n--- a/src/stim/mem/simd_bits_range_ref.h\\n+++ b/src/stim/mem/simd_bits_range_ref.h\\n@@ -17,10 +17,10 @@\\n #ifndef _STIM_MEM_SIMD_BITS_RANGE_REF_H\\n #define _STIM_MEM_SIMD_BITS_RANGE_REF_H\\n \\n+#include <array>\\n #include <iostream>\\n #include <random>\\n #include <vector>\\n-#include <array>\\n \\n #include \\\"stim/mem/bit_ref.h\\\"\\n #include \\\"stim/mem/simd_compat.h\\\"\\n\",\"diff --git a/src/stim/py/base.pybind.h b/src/stim/py/base.pybind.h\\nindex 88f2dc92..28671f24 100644\\n--- a/src/stim/py/base.pybind.h\\n+++ b/src/stim/py/base.pybind.h\\n@@ -48,6 +48,6 @@ pybind11::tuple tuple_tree(const std::vector<T> &val, size_t offset = 0) {\\n     return pybind11::make_tuple(val[offset], tuple_tree(val, offset + 1));\\n }\\n \\n-}\\n+}  // namespace stim_pybind\\n \\n #endif\\n\",\"diff --git a/src/stim/py/compiled_detector_sampler.pybind.cc b/src/stim/py/compiled_detector_sampler.pybind.cc\\nindex 79293e23..8e37ec70 100644\\n--- a/src/stim/py/compiled_detector_sampler.pybind.cc\\n+++ b/src/stim/py/compiled_detector_sampler.pybind.cc\\n@@ -92,15 +92,14 @@ std::string CompiledDetectorSampler::repr() const {\\n     return result.str();\\n }\\n \\n-CompiledDetectorSampler stim_pybind::py_init_compiled_detector_sampler(const Circuit &circuit, const pybind11::object &seed) {\\n+CompiledDetectorSampler stim_pybind::py_init_compiled_detector_sampler(\\n+    const Circuit &circuit, const pybind11::object &seed) {\\n     return CompiledDetectorSampler(circuit, make_py_seeded_rng(seed));\\n }\\n \\n pybind11::class_<CompiledDetectorSampler> stim_pybind::pybind_compiled_detector_sampler_class(pybind11::module &m) {\\n     return pybind11::class_<CompiledDetectorSampler>(\\n-        m,\\n-        \\\"CompiledDetectorSampler\\\",\\n-        \\\"An analyzed stabilizer circuit whose detection events can be sampled quickly.\\\");\\n+        m, \\\"CompiledDetectorSampler\\\", \\\"An analyzed stabilizer circuit whose detection events can be sampled quickly.\\\");\\n }\\n \\n void stim_pybind::pybind_compiled_detector_sampler_methods(pybind11::class_<CompiledDetectorSampler> &c) {\\n\",\"diff --git a/src/stim/py/compiled_detector_sampler.pybind.h b/src/stim/py/compiled_detector_sampler.pybind.h\\nindex 83d748e9..2badf496 100644\\n--- a/src/stim/py/compiled_detector_sampler.pybind.h\\n+++ b/src/stim/py/compiled_detector_sampler.pybind.h\\n@@ -47,6 +47,6 @@ pybind11::class_<CompiledDetectorSampler> pybind_compiled_detector_sampler_class\\n void pybind_compiled_detector_sampler_methods(pybind11::class_<CompiledDetectorSampler> &c);\\n CompiledDetectorSampler py_init_compiled_detector_sampler(const stim::Circuit &circuit, const pybind11::object &seed);\\n \\n-}\\n+}  // namespace stim_pybind\\n \\n #endif\\n\",\"diff --git a/src/stim/py/compiled_measurement_sampler.pybind.cc b/src/stim/py/compiled_measurement_sampler.pybind.cc\\nindex 3de9fd64..43fdfbd4 100644\\n--- a/src/stim/py/compiled_measurement_sampler.pybind.cc\\n+++ b/src/stim/py/compiled_measurement_sampler.pybind.cc\\n@@ -89,9 +89,7 @@ std::string CompiledMeasurementSampler::repr() const {\\n \\n pybind11::class_<CompiledMeasurementSampler> pybind_compiled_measurement_sampler_class(pybind11::module &m) {\\n     return pybind11::class_<CompiledMeasurementSampler>(\\n-        m,\\n-        \\\"CompiledMeasurementSampler\\\",\\n-        \\\"An analyzed stabilizer circuit whose measurements can be sampled quickly.\\\");\\n+        m, \\\"CompiledMeasurementSampler\\\", \\\"An analyzed stabilizer circuit whose measurements can be sampled quickly.\\\");\\n }\\n \\n CompiledMeasurementSampler py_init_compiled_sampler(\\n\",\"diff --git a/src/stim/py/march.pybind.cc b/src/stim/py/march.pybind.cc\\nindex 8e5f527f..762b86e4 100644\\n--- a/src/stim/py/march.pybind.cc\\n+++ b/src/stim/py/march.pybind.cc\\n@@ -1,7 +1,7 @@\\n-#include <pybind11/pybind11.h>\\n-\\n #include \\\"stim/py/march.pybind.h\\\"\\n \\n+#include <pybind11/pybind11.h>\\n+\\n #ifdef _WIN32\\n //  Windows\\n #include <intrin.h>\\n\",\"diff --git a/src/stim/simulators/error_analyzer.cc b/src/stim/simulators/error_analyzer.cc\\nindex 66cbcf6f..6bb6a308 100644\\n--- a/src/stim/simulators/error_analyzer.cc\\n+++ b/src/stim/simulators/error_analyzer.cc\\n@@ -581,7 +581,9 @@ ErrorAnalyzer::ErrorAnalyzer(\\n     bool decompose_errors,\\n     bool fold_loops,\\n     bool allow_gauge_detectors,\\n-    double approximate_disjoint_errors_threshold)\\n+    double approximate_disjoint_errors_threshold,\\n+    bool ignore_decomposition_failures,\\n+    bool block_decomposition_from_introducing_remnant_edges)\\n     : total_detectors(num_detectors),\\n       used_detectors(0),\\n       xs(num_qubits),\\n@@ -591,7 +593,9 @@ ErrorAnalyzer::ErrorAnalyzer(\\n       accumulate_errors(true),\\n       fold_loops(fold_loops),\\n       allow_gauge_detectors(allow_gauge_detectors),\\n-      approximate_disjoint_errors_threshold(approximate_disjoint_errors_threshold) {\\n+      approximate_disjoint_errors_threshold(approximate_disjoint_errors_threshold),\\n+      ignore_decomposition_failures(ignore_decomposition_failures),\\n+      block_decomposition_from_introducing_remnant_edges(block_decomposition_from_introducing_remnant_edges) {\\n }\\n \\n void ErrorAnalyzer::run_circuit(const Circuit &circuit) {\\n@@ -860,14 +864,18 @@ DetectorErrorModel ErrorAnalyzer::circuit_to_detector_error_model(\\n     bool decompose_errors,\\n     bool fold_loops,\\n     bool allow_gauge_detectors,\\n-    double approximate_disjoint_errors_threshold) {\\n+    double approximate_disjoint_errors_threshold,\\n+    bool ignore_decomposition_failures,\\n+    bool block_decomposition_from_introducing_remnant_edges) {\\n     ErrorAnalyzer analyzer(\\n         circuit.count_detectors(),\\n         circuit.count_qubits(),\\n         decompose_errors,\\n         fold_loops,\\n         allow_gauge_detectors,\\n-        approximate_disjoint_errors_threshold);\\n+        approximate_disjoint_errors_threshold,\\n+        ignore_decomposition_failures,\\n+        block_decomposition_from_introducing_remnant_edges);\\n     analyzer.current_circuit_being_analyzed = &circuit;\\n     analyzer.run_circuit(circuit);\\n     analyzer.post_check_initialization();\\n@@ -964,7 +972,9 @@ void ErrorAnalyzer::run_loop(const Circuit &loop, uint64_t iterations) {\\n         false,\\n         true,\\n         allow_gauge_detectors,\\n-        approximate_disjoint_errors_threshold);\\n+        approximate_disjoint_errors_threshold,\\n+        false,\\n+        false);\\n     hare.xs = xs;\\n     hare.zs = zs;\\n     hare.ticks_seen = ticks_seen;\\n@@ -1205,7 +1215,7 @@ bool ErrorAnalyzer::has_unflushed_ungraphlike_errors() const {\\n     return false;\\n }\\n \\n-void ErrorAnalyzer::decompose_and_append_component_to_tail(\\n+bool ErrorAnalyzer::decompose_and_append_component_to_tail(\\n     ConstPointerRange<DemTarget> component,\\n     const std::map<FixedCapVector<DemTarget, 2>, ConstPointerRange<DemTarget>> &known_symptoms) {\\n     std::vector<bool> done(component.size(), false);\\n@@ -1221,7 +1231,7 @@ void ErrorAnalyzer::decompose_and_append_component_to_tail(\\n     if (num_component_detectors <= 2) {\\n         mono_buf.append_tail(component);\\n         mono_buf.append_tail(DemTarget::separator());\\n-        return;\\n+        return true;\\n     }\\n \\n     SparseXorVec<DemTarget> sparse;\\n@@ -1259,17 +1269,101 @@ void ErrorAnalyzer::decompose_and_append_component_to_tail(\\n         missed += !done[k];\\n     }\\n \\n-    if (missed > 2) {\\n-        throw std::invalid_argument(\\n-            \\\"Failed to decompose errors into graphlike components with at most two symptoms.\\\\n\\\"\\n-            \\\"The error component that failed to decompose is '\\\" +\\n-            comma_sep_workaround(component) + \\\"'.\\\");\\n+    if (missed <= 2) {\\n+        if (!sparse.empty()) {\\n+            mono_buf.append_tail({sparse.begin(), sparse.end()});\\n+            mono_buf.append_tail(DemTarget::separator());\\n+        }\\n+        return true;\\n     }\\n \\n-    if (!sparse.empty()) {\\n-        mono_buf.append_tail({sparse.begin(), sparse.end()});\\n-        mono_buf.append_tail(DemTarget::separator());\\n+    mono_buf.discard_tail();\\n+    return false;\\n+}\\n+\\n+std::pair<uint64_t, uint64_t> obs_mask_of_targets(ConstPointerRange<DemTarget> targets) {\\n+    uint64_t obs_mask = 0;\\n+    uint64_t used_mask = 0;\\n+    for (size_t k = 0; k < targets.size(); k++) {\\n+        const auto &t = targets[k];\\n+        if (t.is_observable_id()) {\\n+            if (t.val() >= 64) {\\n+                throw std::invalid_argument(\\\"Not implemented: decomposing errors observable ids larger than 63.\\\");\\n+            }\\n+            obs_mask |= uint64_t{1} << t.val();\\n+            used_mask |= uint64_t{1} << k;\\n+        }\\n     }\\n+    return {obs_mask, used_mask};\\n+}\\n+\\n+bool brute_force_decomp_helper(\\n+    size_t start,\\n+    uint64_t used_term_mask,\\n+    uint64_t remaining_obs_mask,\\n+    ConstPointerRange<DemTarget> problem,\\n+    const std::map<FixedCapVector<DemTarget, 2>, ConstPointerRange<DemTarget>> &known_symptoms,\\n+    std::vector<ConstPointerRange<DemTarget>> &out_result) {\\n+    while (true) {\\n+        if (start >= problem.size()) {\\n+            return remaining_obs_mask == 0;\\n+        }\\n+        if (((used_term_mask >> start) & 1) == 0) {\\n+            break;\\n+        }\\n+        start++;\\n+    }\\n+    used_term_mask |= 1 << start;\\n+\\n+    FixedCapVector<DemTarget, 2> key;\\n+    key.push_back(problem[start]);\\n+    for (size_t k = start + 1; k <= problem.size(); k++) {\\n+        if (k < problem.size()) {\\n+            if ((used_term_mask >> k) & 1) {\\n+                continue;\\n+            }\\n+            key.push_back(problem[k]);\\n+            used_term_mask ^= 1 << k;\\n+        }\\n+        auto match = known_symptoms.find(key);\\n+        if (match != known_symptoms.end()) {\\n+            uint64_t obs_change = obs_mask_of_targets(match->second).first;\\n+            if (brute_force_decomp_helper(\\n+                    start + 1, used_term_mask, remaining_obs_mask ^ obs_change, problem, known_symptoms, out_result)) {\\n+                out_result.push_back(match->second);\\n+                return true;\\n+            }\\n+        }\\n+        if (k < problem.size()) {\\n+            key.pop_back();\\n+            used_term_mask ^= 1 << k;\\n+        }\\n+    }\\n+\\n+    return false;\\n+}\\n+\\n+bool stim::brute_force_decomposition_into_known_graphlike_errors(\\n+    ConstPointerRange<DemTarget> problem,\\n+    const std::map<FixedCapVector<DemTarget, 2>, ConstPointerRange<DemTarget>> &known_graphlike_errors,\\n+    MonotonicBuffer<DemTarget> &output) {\\n+    if (problem.size() >= 64) {\\n+        throw std::invalid_argument(\\\"Not implemented: decomposing errors with more than 64 terms.\\\");\\n+    }\\n+\\n+    std::vector<ConstPointerRange<DemTarget>> out;\\n+    out.reserve(problem.size());\\n+    auto prob_masks = obs_mask_of_targets(problem);\\n+\\n+    bool result =\\n+        brute_force_decomp_helper(0, prob_masks.second, prob_masks.first, problem, known_graphlike_errors, out);\\n+    if (result) {\\n+        for (auto r = out.crbegin(); r != out.crend(); r++) {\\n+            output.append_tail(*r);\\n+            output.append_tail(DemTarget::separator());\\n+        }\\n+    }\\n+    return result;\\n }\\n \\n void ErrorAnalyzer::do_global_error_decomposition_pass() {\\n@@ -1317,7 +1411,37 @@ void ErrorAnalyzer::do_global_error_decomposition_pass() {\\n         size_t start = 0;\\n         for (size_t k = 0; k <= targets.size(); k++) {\\n             if (k == targets.size() || targets[k].is_separator()) {\\n-                decompose_and_append_component_to_tail({&targets[start], &targets[k]}, known_symptoms);\\n+                ConstPointerRange<DemTarget> problem{&targets[start], &targets[k]};\\n+                if (brute_force_decomposition_into_known_graphlike_errors(problem, known_symptoms, mono_buf)) {\\n+                    // Solved using only existing edges.\\n+                } else if (\\n+                    !block_decomposition_from_introducing_remnant_edges &&\\n+                    // We are now *really* desperate.\\n+                    // We need to start considering decomposing into errors that\\n+                    // don't exist, as long as they can be formed by xoring\\n+                    // together errors that do exist. This might impact the\\n+                    // graphlike code distance.\\n+                    decompose_and_append_component_to_tail({&targets[start], &targets[k]}, known_symptoms)) {\\n+                    // Solved using a remnant edge.\\n+                } else if (ignore_decomposition_failures) {\\n+                    mono_buf.append_tail(problem);\\n+                    mono_buf.append_tail(DemTarget::separator());\\n+                } else {\\n+                    std::stringstream ss;\\n+                    ss << \\\"Failed to decompose errors into graphlike components with at most two symptoms.\\\\n\\\";\\n+                    ss << \\\"The error component that failed to decompose is '\\\" << comma_sep_workaround(problem)\\n+                       << \\\"'.\\\\n\\\";\\n+                    ss << \\\"\\\\n\\\";\\n+                    ss << \\\"In Python, you can ignore this error by passing `ignore_decomposition_failures=True` to \\\"\\n+                          \\\"`stim.Circuit.detector_error_model(...)`.\\\\n\\\";\\n+                    ss << \\\"From the command line, you can ignore this error by passing the flag \\\"\\n+                          \\\"`--ignore_decomposition_failures` to `stim analyze_errors`.\\\";\\n+                    if (block_decomposition_from_introducing_remnant_edges) {\\n+                        ss << \\\"\\\\n\\\\nNote: `block_decomposition_from_introducing_remnant_edges` is ON.\\\\n\\\";\\n+                        ss << \\\"Turning it off may prevent this error.\\\\n\\\";\\n+                    }\\n+                    throw std::invalid_argument(ss.str());\\n+                }\\n                 start = k + 1;\\n             }\\n         }\\n@@ -1331,8 +1455,9 @@ void ErrorAnalyzer::do_global_error_decomposition_pass() {\\n     }\\n \\n     for (const auto &rewrite : rewrites) {\\n-        add_error(error_class_probabilities[rewrite.first], rewrite.second);\\n+        double p = error_class_probabilities[rewrite.first];\\n         error_class_probabilities.erase(rewrite.first);\\n+        add_error(p, rewrite.second);\\n     }\\n }\\n \\n\",\"diff --git a/src/stim/simulators/error_analyzer.h b/src/stim/simulators/error_analyzer.h\\nindex 2cf4a6d1..ebf527d0 100644\\n--- a/src/stim/simulators/error_analyzer.h\\n+++ b/src/stim/simulators/error_analyzer.h\\n@@ -99,6 +99,21 @@ struct ErrorAnalyzer {\\n     /// before they can be approximated as being independent. Any larger probabilities cause failure.\\n     double approximate_disjoint_errors_threshold;\\n \\n+    /// When true, errors that fail to decompose are inserted into the output\\n+    /// undecomposed instead of raising an exception that terminates the\\n+    /// conversion from circuit to detector error model.\\n+    ///\\n+    /// Only relevant when decompose_errors=True.\\n+    bool ignore_decomposition_failures;\\n+\\n+    /// When true, decomposition is permitted to split A B C D into A B ^ C D\\n+    /// when only one of A B or C D exists elsewhere, instead of requiring both\\n+    /// to exist. This can reduce the code distance of the decoding graph, but\\n+    /// is sometimes necessary.\\n+    ///\\n+    /// Only relevant when decompose_errors=True.\\n+    bool block_decomposition_from_introducing_remnant_edges;\\n+\\n     /// A buffer containing the growing output error model as the circuit is traversed.\\n     /// The buffer is in reverse order because the circuit is traversed back to front.\\n     /// Certain events during period solving of loops can cause the error probabilities\\n@@ -120,7 +135,9 @@ struct ErrorAnalyzer {\\n         bool decompose_errors,\\n         bool fold_loops,\\n         bool allow_gauge_detectors,\\n-        double approximate_disjoint_errors_threshold);\\n+        double approximate_disjoint_errors_threshold,\\n+        bool ignore_decomposition_failures,\\n+        bool block_decomposition_from_introducing_remnant_edges);\\n \\n     /// Returns the detector error model of the given circuit.\\n     ///\\n@@ -132,6 +149,11 @@ struct ErrorAnalyzer {\\n     ///         of failing.\\n     ///     approximate_disjoint_errors_threshold: When larger than 0, allows disjoint errors like PAULI_CHANNEL_2 to\\n     ///         be present in the circuit, as long as their probabilities are not larger than this.\\n+    ///     ignore_decomposition_failures: Determines whether errors that that fail to decompose are inserted into the\\n+    ///         output, or cause the conversion to fail and raise an exception.\\n+    ///     block_decomposition_from_introducing_remnant_edges: When true, it is not permitted to decompose A B C D\\n+    ///         into A B ^ C D unless both A B and C D appear elsewhere in the error model. When false, only one has\\n+    ///         to appear elsewhere.\\n     ///\\n     /// Returns:\\n     ///     The detector error model.\\n@@ -140,7 +162,9 @@ struct ErrorAnalyzer {\\n         bool decompose_errors,\\n         bool fold_loops,\\n         bool allow_gauge_detectors,\\n-        double approximate_disjoint_errors_threshold);\\n+        double approximate_disjoint_errors_threshold,\\n+        bool ignore_decomposition_failures,\\n+        bool block_decomposition_from_introducing_remnant_edges);\\n \\n     /// Copying is unsafe because `error_class_probabilities` has overlapping pointers to `monobuf`'s internals.\\n     ErrorAnalyzer(const ErrorAnalyzer &analyzer) = delete;\\n@@ -306,7 +330,7 @@ struct ErrorAnalyzer {\\n     /// Handles global decomposition of errors.\\n     /// When an error has more than two symptoms, this method attempts to find other known errors that can be used as\\n     /// components of this error, so that it is decomposed into graphlike components.\\n-    void decompose_and_append_component_to_tail(\\n+    bool decompose_and_append_component_to_tail(\\n         ConstPointerRange<DemTarget> component,\\n         const std::map<FixedCapVector<DemTarget, 2>, ConstPointerRange<DemTarget>> &known_symptoms);\\n \\n@@ -324,6 +348,11 @@ struct ErrorAnalyzer {\\n /// For example, error(0.1) D0 D1 ^ D2 D3 L55 is graphlike but error(0.1) D0 D1 ^ D2 D3 D55 is not.\\n bool is_graphlike(const ConstPointerRange<DemTarget> &components);\\n \\n+bool brute_force_decomposition_into_known_graphlike_errors(\\n+    ConstPointerRange<DemTarget> problem,\\n+    const std::map<FixedCapVector<DemTarget, 2>, ConstPointerRange<DemTarget>> &known_graphlike_errors,\\n+    MonotonicBuffer<DemTarget> &output);\\n+\\n }  // namespace stim\\n \\n #endif\\n\",\"diff --git a/src/stim/simulators/error_matcher.cc b/src/stim/simulators/error_matcher.cc\\nindex f4557984..44c12872 100644\\n--- a/src/stim/simulators/error_matcher.cc\\n+++ b/src/stim/simulators/error_matcher.cc\\n@@ -23,7 +23,7 @@ using namespace stim;\\n \\n ErrorMatcher::ErrorMatcher(\\n     const Circuit &circuit, const DetectorErrorModel *init_filter, bool reduce_to_one_representative_error)\\n-    : error_analyzer(circuit.count_detectors(), circuit.count_qubits(), false, false, true, 1),\\n+    : error_analyzer(circuit.count_detectors(), circuit.count_qubits(), false, false, true, 1, false, false),\\n       cur_loc(),\\n       output_map(),\\n       allow_adding_new_dem_errors_to_output_map(init_filter == nullptr),\\n\",\"diff --git a/src/stim/simulators/tableau_simulator.pybind.cc b/src/stim/simulators/tableau_simulator.pybind.cc\\nindex 6fc95b72..70f0d338 100644\\n--- a/src/stim/simulators/tableau_simulator.pybind.cc\\n+++ b/src/stim/simulators/tableau_simulator.pybind.cc\\n@@ -22,7 +22,8 @@\\n using namespace stim;\\n using namespace stim_pybind;\\n \\n-PyTableauSimulator::PyTableauSimulator(std::shared_ptr<std::mt19937_64> rng) : TableauSimulator(*rng), rng_reference(rng) {\\n+PyTableauSimulator::PyTableauSimulator(std::shared_ptr<std::mt19937_64> rng)\\n+    : TableauSimulator(*rng), rng_reference(rng) {\\n }\\n \\n struct TempViewableData {\\n\",\"diff --git a/src/stim/simulators/vector_simulator.cc b/src/stim/simulators/vector_simulator.cc\\nindex 7e5461b2..5485faf2 100644\\n--- a/src/stim/simulators/vector_simulator.cc\\n+++ b/src/stim/simulators/vector_simulator.cc\\n@@ -107,7 +107,8 @@ void VectorSimulator::apply(const PauliStringRef &gate, size_t qubit_offset) {\\n     }\\n }\\n \\n-VectorSimulator VectorSimulator::from_stabilizers(const std::vector<PauliStringRef> &stabilizers, std::mt19937_64 &rng) {\\n+VectorSimulator VectorSimulator::from_stabilizers(\\n+    const std::vector<PauliStringRef> &stabilizers, std::mt19937_64 &rng) {\\n     size_t num_qubits = stabilizers.empty() ? 0 : stabilizers[0].num_qubits;\\n     VectorSimulator result(num_qubits);\\n \\n\",\"diff --git a/src/stim/simulators/error_analyzer.perf.cc b/src/stim/simulators/error_analyzer.perf.cc\\nindex 79ab7bad..11370928 100644\\n--- a/src/stim/simulators/error_analyzer.perf.cc\\n+++ b/src/stim/simulators/error_analyzer.perf.cc\\n@@ -26,7 +26,7 @@ BENCHMARK(ErrorAnalyzer_surface_code_rotated_memory_z_d11_r100) {\\n     params.after_clifford_depolarization = 0.001;\\n     auto circuit = generate_surface_code_circuit(params).circuit;\\n     benchmark_go([&]() {\\n-        ErrorAnalyzer analyzer(circuit.count_detectors(), circuit.count_qubits(), false, false, false, 0.0);\\n+        ErrorAnalyzer analyzer(circuit.count_detectors(), circuit.count_qubits(), false, false, false, 0.0, false, true);\\n         analyzer.run_circuit(circuit);\\n     }).goal_millis(320);\\n }\\n@@ -38,7 +38,7 @@ BENCHMARK(ErrorAnalyzer_surface_code_rotated_memory_z_d11_r100_find_reducible_er\\n     params.after_clifford_depolarization = 0.001;\\n     auto circuit = generate_surface_code_circuit(params).circuit;\\n     benchmark_go([&]() {\\n-        ErrorAnalyzer analyzer(circuit.count_detectors(), circuit.count_qubits(), true, false, false, 0.0);\\n+        ErrorAnalyzer analyzer(circuit.count_detectors(), circuit.count_qubits(), true, false, false, 0.0, false, true);\\n         analyzer.run_circuit(circuit);\\n     }).goal_millis(450);\\n }\\n@@ -50,7 +50,7 @@ BENCHMARK(ErrorAnalyzer_surface_code_rotated_memory_z_d11_r100000000_find_loops)\\n     params.after_clifford_depolarization = 0.001;\\n     auto circuit = generate_surface_code_circuit(params).circuit;\\n     benchmark_go([&]() {\\n-        ErrorAnalyzer analyzer(circuit.count_detectors(), circuit.count_qubits(), false, true, false, 0.0);\\n+        ErrorAnalyzer analyzer(circuit.count_detectors(), circuit.count_qubits(), false, true, false, 0.0, false, true);\\n         analyzer.run_circuit(circuit);\\n     }).goal_millis(15);\\n }\\n\",\"diff --git a/src/stim/simulators/min_distance.perf.cc b/src/stim/simulators/min_distance.perf.cc\\nindex 91e32ea2..d56128bb 100644\\n--- a/src/stim/simulators/min_distance.perf.cc\\n+++ b/src/stim/simulators/min_distance.perf.cc\\n@@ -27,7 +27,7 @@ BENCHMARK(find_graphlike_logical_error_surface_code_d25) {\\n     params.after_reset_flip_probability = 0.001;\\n     params.before_round_data_depolarization = 0.001;\\n     auto circuit = generate_surface_code_circuit(params).circuit;\\n-    auto model = ErrorAnalyzer::circuit_to_detector_error_model(circuit, true, true, false, false);\\n+    auto model = ErrorAnalyzer::circuit_to_detector_error_model(circuit, true, true, false, 0.0, false, true);\\n \\n     size_t total = 0;\\n     benchmark_go([&]() {\\n\"]", "test_patch": "", "hints_text": ""}
